/*!
*  filename: ej1.chart.all.js
*  version : 6.7.11
*  Copyright Syncfusion Inc. 2001 - 2023. All rights reserved.
*  Use of this code is subject to the terms of our license.
*  A copy of the current license can be obtained at any time by e-mailing
*  licensing@syncfusion.com. Any infringement will be prosecuted under
*  applicable laws. 
*/

BoldBIDashboard.EjCanvasRender = function (element) {
    this.svgObj = document.createElement('canvas');
    this._rootId = bbdesigner$(element).attr("id");
    this.svgObj.setAttribute('id', this._rootId + '_canvas');
    this.ctx = this.svgObj.getContext("2d");
    
};
(function (bbdesigner$) {
    BoldBIDashboard.EjCanvasRender.prototype = {

        drawPath: function (options, element, canvasTranslate) {

            var path = options.d;
            var dataSplit = path.split(" ");
            var borderWidth = options["stroke-width"];
            if (!options.lgndCtx) {
                var canvasCtx = this.ctx;
                this.ctx = element != undefined ? element : this.ctx;
                this.ctx.save();
                this.ctx.beginPath();
                if (canvasTranslate) this.ctx.translate(canvasTranslate[0], canvasTranslate[1]);
                this.ctx.globalAlpha = options.opacity ? options.opacity : options["fill-opacity"];
                var flag = true;
                this.ctx.lineWidth = borderWidth;
				var dashArray = options["stroke-dasharray"] ? options["stroke-dasharray"].split(",") : false;
                if (dashArray) this.ctx.setLineDash(dashArray);
                this.ctx.strokeStyle = options.stroke;
                for (var i = 0; i < dataSplit.length; i = i + 3) {
                    var x1 = parseFloat(dataSplit[i + 1]);
                    var y1 = parseFloat(dataSplit[i + 2]);
                    switch (dataSplit[i]) {
                        case "M":
                            if (!options.innerR && !options.cx)
                                this.ctx.moveTo(x1, y1);
                            break;
                        case "L":
                            if (!options.innerR)
                                this.ctx.lineTo(x1, y1);
                            break;
                        case "C":
                            this.ctx.bezierCurveTo(x1, y1, parseFloat(dataSplit[i + 3]), parseFloat(dataSplit[i + 4]), parseFloat(dataSplit[i + 5]), parseFloat(dataSplit[i + 6]));
                            i = i + 4;
                            break;
                        case "A":
                            if (!options.innerR) {
							    if (options.cx) {
                                    this.ctx.arc(options.cx, options.cy, options.radius, 0, 2 * Math.PI, options.counterClockWise);
                               }
								else{
                                    this.ctx.moveTo(options.x, options.y);
                                    this.ctx.arc(options.x, options.y, options.radius, options.start, options.end, options.counterClockWise);
                                    this.ctx.lineTo(options.x, options.y);
								}
                            }
                            else if (flag) {
                                this.ctx.arc(options.x, options.y, options.radius, options.start, options.end, options.counterClockWise);
                                this.ctx.arc(options.x, options.y, options.innerR, options.end, options.start, !options.counterClockWise);
                                flag = false; 
                            }
                            i = i + 5;
                            break;
					    case "z":
                            this.ctx.closePath();
                            break;
                    }
                }
                if (options.fill != "none" && options.fill != undefined) {
                    this.ctx.fillStyle = options.fill;
                    this.ctx.fill();
                }
                if (borderWidth > 0)
                    this.ctx.stroke();
                this.ctx.restore();
                this.ctx = canvasCtx;
            } else {
                var legendCtx = this.lgndCtx;
                this.lgndCtx = element != undefined ? element : this.lgndCtx;
                this.lgndCtx.save();
                this.lgndCtx.beginPath();
                if (canvasTranslate) this.lgndCtx.translate(canvasTranslate[0], canvasTranslate[1]);
                this.lgndCtx.globalAlpha = options.opacity ? options.opacity : options["fill-opacity"];

                this.lgndCtx.lineWidth = options["stroke-width"];
                this.lgndCtx.strokeStyle = options.stroke;
                for (var i = 0; i < dataSplit.length; i = i + 3) {
                    var x1 = parseFloat(dataSplit[i + 1]);
                    var y1 = parseFloat(dataSplit[i + 2]);
                    switch (dataSplit[i]) {
                        case "M":
                            this.lgndCtx.moveTo(x1, y1);
                            break;
                        case "L":
                            this.lgndCtx.lineTo(x1, y1);
                            break;
                        case "C":
                            this.lgndCtx.bezierCurveTo(x1, y1, parseFloat(dataSplit[i + 3]), parseFloat(dataSplit[i + 4]), parseFloat(dataSplit[i + 5]), parseFloat(dataSplit[i + 6]));
                            i = i + 4;
                            break;
                        case "A":
                            this.lgndCtx.arc(parseFloat(dataSplit[i - 5]), parseFloat(dataSplit[i - 4]), x1, 0, 2 * Math.PI, false);
                            i = i + 5;
                            break;
							case "a":
                            this.lgndCtx.beginPath();
                            var centerX = parseFloat(dataSplit[i - 2]) + x1;
                            var centerY = dataSplit[i - 1];
                            this.lgndCtx.arc(centerX, centerY, x1, 0, 2 * Math.PI, false);
                            i = i + 5;
                            break;
                        case "Z":
                            this.lgndCtx.fillStyle = options.fill;
                            this.lgndCtx.fill();
                            i = i - 2;
                            break;
					    case "Q":
                            this.lgndCtx.quadraticCurveTo(x1, y1, parseFloat(dataSplit[i + 3]), parseFloat(dataSplit[i + 4]));
                            i = i + 2;
                            break;
                    }
                }
                if (options.fill != "none" && options.fill != undefined) {
                    this.lgndCtx.fillStyle = options.fill;
                    this.lgndCtx.fill();
                }
                this.lgndCtx.stroke();
                this.lgndCtx.restore();
                this.lgndCtx = legendCtx;
            }
        },
        
       
        drawRect: function (options, element) {
            var canvasCtx = this.ctx, cornerRadius = options.rx;
            this.ctx = element ? (element.canvas ? element : this.ctx ) : this.ctx;
            this.ctx.save();
            this.ctx.beginPath();
            this.ctx.globalAlpha = options.opacity;
            this.ctx.lineWidth = options["stroke-width"];
            dashArray = options["stroke-dasharray"] ? options["stroke-dasharray"].split(",") : false;
            if (dashArray) this.ctx.setLineDash(dashArray);
            this.ctx.strokeStyle = options.stroke;
            this.ctx.rect(options.x, options.y, options.width, options.height);
            if (cornerRadius != null && cornerRadius >= 0) {
                this.drawCornerRadius(options);
            }
            else {
                if (options.fill == "none") options.fill = "transparent";
                this.ctx.fillStyle = options.fill;
                this.ctx.fillRect(options.x, options.y, options.width, options.height);
                this.ctx.stroke();
             }
            if(options.id.indexOf("Series") >= 0)
            this.ctx.clip();
	        this.ctx.restore();
            this.ctx = canvasCtx;
        },

        drawCornerRadius: function (options) {
            var cornerRadius = options.rx, x = options.x, y = options.y, width = options.width, height = options.height;
            if (options.fill == "none") options.fill = "transparent";
            this.ctx.fillStyle = options.fill;
            if (width < 2 * cornerRadius) cornerRadius = width / 2;
            if (height < 2 * cornerRadius) cornerRadius = height / 2;
            this.ctx.beginPath();
            this.ctx.moveTo(x + width - cornerRadius, y);
            this.ctx.arcTo(x + width, y, x + width, y + height, cornerRadius);
            this.ctx.arcTo(x + width, y + height, x, y + height, cornerRadius);
            this.ctx.arcTo(x, y + height, x, y, cornerRadius);
            this.ctx.arcTo(x, y, x + width, y, cornerRadius);
            this.ctx.closePath();
            this.ctx.fill();
            this.ctx.stroke();
        },

        createGradientElement: function (name, colors, model, position) {
            var colorName;
            var ctx = this.ctx;
            if (Object.prototype.toString.call(colors) == '[object Array]') {
                if(!model.legend.enableMultiRange && model.legend.mode == "range")
                {
                    if (position == "right" || position == "left")
                        var my_gradient = ctx.createLinearGradient(0, 0, 0, this.svgObj.height);
                    else if (position == "top" || position == "bottom")
                        var my_gradient = ctx.createLinearGradient(0, 0, this.svgObj.width, 0);
                }
                else
                    var my_gradient = ctx.createLinearGradient(0, 0, 0, this.svgObj.height);
                var temp = 0;
                for (var i = 0; i <= colors.length - 1 ; i++) {
                    if (!model.legend.enableMultiRange) {
                        temp = temp + (1 / 10);
                        if (i == 0) {
                            my_gradient.addColorStop(0, colors[i]);
                            my_gradient.addColorStop(temp, colors[i]);
                        } else if (i == colors.length - 1) {
                            my_gradient.addColorStop(temp - (1 / 10), colors[i]);
                            my_gradient.addColorStop(temp, colors[i]);
                        } else {
                            my_gradient.addColorStop(temp - (1 / 10), colors[i]);
                            my_gradient.addColorStop(temp, colors[i + 1]);
                        }
                    }
                    else {
                        var color = colors[i].color;
                        var colorStop = (colors[i].colorStop).slice(0, -1);
                        colorStop = parseInt(colorStop) / 100;
                        my_gradient.addColorStop(colorStop, color);
                    }
                    
                }
                colorName = my_gradient;
            }
            else {
                colorName = colors;
            }
            return colorName;
        },
        drawLine: function (options) {
            this.ctx.save();
            this.ctx.beginPath();
			this.ctx.lineWidth = options["stroke-width"];
            this.ctx.strokeStyle = options.stroke;
            this.ctx.moveTo(options.x1, options.y1);
            this.ctx.lineTo(options.x2, options.y2);
            this.ctx.stroke();
            this.ctx.restore();
        },
        drawText: function (options, label) {
            if (!BoldBIDashboard.util.isNullOrUndefined(options["font-weight"]) && options["font-weight"].toLowerCase() == "regular")
                options["font-weight"] = "normal";
            var font = (options["font-style"].toLowerCase() + " " + options["font-weight"] + " " + options["font-size"] + " " + options["font-family"]);
            // text-anchor
            var anchor = options["text-anchor"];
            var opacity = options["opacity"] !== undefined ? options["opacity"] : 1;
            if (anchor == "middle")
                anchor = "center";
            if (!options.lgndCtx) {
                this.ctx.save();
                this.ctx.fillStyle = options.fill;                
                this.ctx.font = font;                
                this.ctx.textAlign = anchor;
                this.ctx.globalAlpha = opacity;
                if (options.baseline)
                    this.ctx.textBaseline = options.baseline;
                // dominant-baseline
                //if (options["dominant-baseline"] == "middle")
                    //this.ctx.textBaseline = "center";
                if (!options.labelRotation) {
                    this.ctx.fillText(label, options.x, options.y);
                } else {
                    var txtlngth = 0;
                    if (options.labelRotation == 90 && options.id.indexOf("XLabel") != -1)
                        txtlngth = this.ctx.measureText(label).width;
                    
                    this.ctx.translate(options.x + (txtlngth/2), options.y);
                    this.ctx.rotate(options.labelRotation * Math.PI / 180);
                    this.ctx.fillText(label, 0, 0);
                }
                this.ctx.restore();
            } else {
                this.lgndCtx.save();
                this.lgndCtx.fillStyle = options.fill;
                this.lgndCtx.font = font;
                this.lgndCtx.textAlign = anchor;
                this.lgndCtx.globalAlpha = opacity;
                // dominant-baseline
                if (options["dominant-baseline"] == "middle")
                    this.lgndCtx.textBaseline = "center";
                if (!options.labelRotation) {
                    this.lgndCtx.fillText(label, options.x, options.y);
                } else {
                    this.lgndCtx.translate(options.x, options.y);
                    this.lgndCtx.rotate(options.labelRotation * Math.PI / 180);
                    this.lgndCtx.fillText(label, 0, 0);
                }
                this.lgndCtx.restore();
            }
        },
        drawZoomRect: function(options, chartObj) {

            var chartPos = { left: this.svgObj.offsetLeft, top: this.svgObj.offsetTop };
            var zoomRect = bbdesigner$("<div id=" + options.id + "></div>");
            var areaBounds = chartObj.model.m_AreaBounds;
			
			// for drawing zoom area within the chartArea
            if (options.x < areaBounds.X || options.x + chartPos.left + options.width > chartPos.left + bbdesigner$(this.svgObj).width() - 20) {
                width = this.prevWidth;
                x = this.prevX;
            } else {
                width = this.prevWidth = options.width;
                x = this.prevX = options.x + chartPos.left;
            }
            
            if (options.y < areaBounds.Y || options.y + chartPos.top + options.height > chartPos.top + areaBounds.Y + areaBounds.Height) {
                height = this.prevHeight;
                y = this.prevY;
            } else {
                height = this.prevHeight = options.height;
                y = this.prevY = options.y + chartPos.top;
            }
            
            bbdesigner$(zoomRect).css({
                    "width": width,
                    "height": height,
                    "top": y,
                    "left": x,
                    "background-color": options.fill,
                    "border-style": "solid",
                    "position": "absolute",
                    "border-color": options.stroke,
                    "border-width": options["stroke-width"]
                });
                document.getElementById(this._rootId).appendChild(zoomRect[0]);
        },
        zoomButton: function (options, currentItem) {
            if (currentItem == "zoom")
                var currentItemId = "_Zoom";
            else if (currentItem == "zoomIn")
                currentItemId = "_ZoomIn";
            else
                currentItemId = "_ZoomOut";

            var chartPos = { left: this.svgObj.offsetLeft, top: this.svgObj.offsetTop };
            if (bbdesigner$("#" + options.zoomId).length <= 0) {
                var zoomButton = bbdesigner$("<div id=" + this.svgObj.id + currentItemId +'Btn' + "></div>");
                bbdesigner$(zoomButton).css({
                    "width": options.width,
                    "height": options.height,
                    "top": options.top + chartPos.top,
                    "left": options.left + chartPos.left,
                    "background-color": options.fill,
                    "border-style": "solid",
                    "position": "absolute",
                    "border-radius": "0.4em",
                    "border-color": options.fill,
                    "box-sizing": "content-box"
                });                
                var svgLink = "http://www.w3.org/2000/svg";
                var svgShape = document.createElementNS(svgLink, "svg");
                svgShape.setAttribute('id', options.zoomId);
                svgShape.setAttribute('width', 25);
                svgShape.setAttribute('height', 25);
               
                if (currentItem == "zoom") {
                    var direction = "M26.101,22.893l-6.605-6.174c1.414-2.781,0.897-6.267-1.496-8.504c-2.901-2.711-7.448-2.56-10.161,0.341    c-2.712,2.9-2.56,7.45,0.341,10.163c2.426,2.266,6,2.523,8.694,0.853l6.579,6.151L26.101,22.893z M10.186,16.571    c-1.715-1.604-1.805-4.293-0.203-6.009c1.605-1.715,4.295-1.805,6.009-0.201c1.715,1.603,1.805,4.293,0.202,6.007    C14.59,18.084,11.901,18.175,10.186,16.571";
                    var transform = "translate(-3,-3)";
                } else if (currentItem == "zoomIn") {
                    direction = "M9.0983096,4.2999878L9.0983096,9.3999634 3.9983783,9.3999634 3.9983783,12.699951 9.0983096,12.699951 9.0983096,17.799988 12.398249,17.799988 12.398249,12.699951 17.49818,12.699951 17.49818,9.5 12.398249,9.5 12.398249,4.2999878z M10.998276,0C14.298215,0 17.49818,1.3999634 19.69813,4.1999512 22.79809,8.0999756 22.79809,13.5 19.998144,17.399963L28.597992,28.299988 23.898081,32 15.398205,21.199951C10.898271,23.099976 5.5983606,21.899963 2.3983956,17.899963 -1.4015366,13.099976 -0.60156059,6.0999756 4.1983567,2.3999634 6.1983276,0.79998779 8.5983163,0 10.998276,0z";
                    transform = "translate(4,4) scale(0.6)";
                } else {
                    direction = "M3.9983433,9.5L3.9983433,12.799988 17.598165,12.799988 17.598165,9.5z M10.998234,0C14.298169,0 17.498131,1.3999634 19.698108,4.1999512 22.798034,8.0999756 22.798034,13.5 19.998092,17.399963L28.597994,28.299988 23.898054,32 15.398188,21.199951C10.898259,23.099976 5.5983546,21.899963 2.398393,17.899963 -1.4015351,13.099976 -0.60155994,6.0999756 4.1983522,2.3999634 6.1983207,0.79998779 8.5983074,0 10.998234,0z";
                    transform = "translate(4,4) scale(0.6)";
                }

                var attrOptions = {
                    'id': currentItemId + 'Path',
                    'fill': '#FFFFFF',
                    'transform': transform,
                    'd': direction
                };

                var path = document.createElementNS(svgLink, "path");
                bbdesigner$(path).attr(attrOptions).appendTo(svgShape);
                zoomButton[0].appendChild(svgShape);
                document.getElementById(this._rootId).appendChild(zoomButton[0]);
            } else {
                var zoomButton = document.getElementById(this.svgObj.id + currentItemId + 'Btn');
                bbdesigner$(zoomButton).css({
                    "top": options.top + chartPos.top,
                    "left": options.left + chartPos.left - 20
                });
            }
        },
        panButton: function (options) {
            var chartPos = { left: this.svgObj.offsetLeft, top: this.svgObj.offsetTop };
            if (bbdesigner$("#" + options.panId).length <= 0) {
                var panButton = bbdesigner$("<div id=" + this.svgObj.id + '_PanBtn' + "></div>");
                bbdesigner$(panButton).css({
                    "width": options.width,
                    "height": options.height,
                    "top": options.top + chartPos.top,
                    "left": options.left + chartPos.left,
                    "background-color": options.fill,
                    "border-style": "solid",
                    "position": "absolute",
                    "border-radius": "0.4em",
                    "border-color": options.fill,
                    "box-sizing": "content-box"
                });                
                var svgLink = "http://www.w3.org/2000/svg";
                var svgShape = document.createElementNS(svgLink, "svg");
                svgShape.setAttribute('id', options.panId);
                svgShape.setAttribute('width', 25);
                svgShape.setAttribute('height', 25);

                var attrOptions = {
                    'id': 'panPath',
                    'fill': '#FFFFFF',
                    'transform': 'translate(-3,-3)'
                };
                attrOptions.points = "26.105,16 21.053,12.211 21.053,14.737 17.263,14.737 17.263,10.947 19.834,10.947 16.044,5.895 12.255,10.947 14.737,10.947 14.737,14.737 10.947,14.737 10.947,12.211 5.895,16 10.947,19.789 10.947,17.263 14.737,17.263 14.737,21.053 12.255,21.053 16.044,26.105 19.834,21.053 17.263,21.053 17.263,17.263 21.053,17.263 21.053,19.789";

                var path = document.createElementNS(svgLink, "polygon");
                bbdesigner$(path).attr(attrOptions).appendTo(svgShape);
                panButton[0].appendChild(svgShape);
                document.getElementById(this._rootId).appendChild(panButton[0]);     
            } else {
                var panButton = document.getElementById(this.svgObj.id + '_PanBtn');
                bbdesigner$(panButton).css({
                    "top": options.top + chartPos.top,
                    "left": options.left + chartPos.left - 10
                });
            }
        },
        resetZoom: function (options) {
            var chartPos = { left: this.svgObj.offsetLeft, top: this.svgObj.offsetTop };
            if (bbdesigner$("#" + options.resetZoomId).length <= 0) {
                var resetZoom = bbdesigner$("<div id=" + this.svgObj.id + '_ResetZoom' + "></div>");
                bbdesigner$(resetZoom).css({
                    "width": options.width,
                    "height": options.height,
                    "top": options.top + chartPos.top,
                    "left": options.left + chartPos.left,
                    "background-color": options.fill,
                    "border-style": "solid",
                    "border-radius": "0.4em",
                    "position": "absolute",
                    "border-color": options.fill,
                    "box-sizing":"content-box"
                });                
                var svgLink = "http://www.w3.org/2000/svg";
                var svgShape = document.createElementNS(svgLink, "svg");
                svgShape.setAttribute('id', options.resetZoomId);
                svgShape.setAttribute('width', 25);
                svgShape.setAttribute('height', 25);

                var points1 = {
                    'id': 'p1',
                    'fill': '#FFFFFF',
                    'transform': 'translate(-3,-3)'
                };
                points1.points = "11.895,18.398 8.061,22.23 5.796,19.967 5.796,26.283 12.112,26.283 9.848,24.018 13.682,20.186";

                var path1 = document.createElementNS(svgLink, "polygon");
                bbdesigner$(path1).attr(points1).appendTo(svgShape);

                var points2 = {
                    'id': 'p2',
                    'fill': '#FFFFFF',
                    'transform': 'translate(-3,-3)'
                };
                points2.points = "19.691,6.072 21.955,8.337 18.121,12.172 19.908,13.959 23.742,10.123 26.007,12.389 26.007,6.072";

                var path2 = document.createElementNS(svgLink, "polygon");
                bbdesigner$(path2).attr(points2).appendTo(svgShape);

                var points3 = {
                    'id': 'p3',
                    'fill': '#FFFFFF',
                    'transform': 'translate(-3,-3)'
                };
                points3.points = "11.895,13.958 13.682,12.172 9.848,8.337 12.112,6.072 5.796,6.072 5.796,12.389 8.061,10.123";

                var path3 = document.createElementNS(svgLink, "polygon");
                bbdesigner$(path3).attr(points3).appendTo(svgShape);

                var points4 = {
                    'id': 'p4',
                    'fill': '#FFFFFF',
                    'transform': 'translate(-3,-3)'
                };
                points4.points = "19.908,18.396 18.121,20.186 21.955,24.018 19.691,26.283 26.007,26.283 26.007,19.967 23.741,22.23";

                var path4 = document.createElementNS(svgLink, "polygon");
                bbdesigner$(path4).attr(points4).appendTo(svgShape);

                resetZoom[0].appendChild(svgShape);
                document.getElementById(this._rootId).appendChild(resetZoom[0]);
            } else {
                var resetZoom = document.getElementById(this.svgObj.id + '_ResetZoom');
                bbdesigner$(resetZoom).css({
                    "top": options.top + chartPos.top,
                    "left": options.left + chartPos.left
                });
            }
        },
        drawCrosshairLine: function (options, evt) {
            var line = bbdesigner$("<div id=" + options.id + " style='position: absolute; z-index: 13000;'></div>");
            bbdesigner$(line).css({
                "width": options.width,
                "height": options.height,
                "left": options.left,
                "top": options.top,
                "border-style": "solid",
                "opacity": 0.5,
                "visibility": "visible",
                "border-color": options.stroke,
                "border-width": options["stroke-width"],
                "z-index": 100
            });
            document.getElementById(this._rootId).appendChild(line[0]);
        },
        drawCrosshairlabel: function (rectOptions, textOptions, text) {
            var chartPos = { left: this.svgObj.offsetLeft, top: this.svgObj.offsetTop };
            if (bbdesigner$("#" + rectOptions.id).length > 0) {
                var label = document.getElementById(rectOptions.id);                
                bbdesigner$(label).css({
                    "width": rectOptions.width - 5,
                    "height": rectOptions.height - 5,
                    "left": textOptions.x + chartPos.left - 5,
                    "top": textOptions.y + chartPos.top - 15,
                    "visibility": "visible",
                    "display": rectOptions.display
                });
                document.getElementById(rectOptions.id).textContent = text;
            } else {
                var label = bbdesigner$("<div id=" + rectOptions.id + " style='position: absolute; z-index: 13000;'></div>");
                bbdesigner$(label).css({
                    "color": textOptions.fill,
                    "font-family": textOptions["font-family"],
                    "font-size": textOptions["font-size"],
                    "font-weight": textOptions["font-weight"],
                    "font-style": textOptions["font-style"],
                    "background-color": rectOptions.fill,
                    "border-style": "solid",
                    "border-color": rectOptions.stroke,
                    "border-width": rectOptions["stroke-width"],
                    "opacity": rectOptions["fill-opacity"],
                    "text-align" : "center"
                });
                
                document.getElementById(this._rootId).appendChild(label[0]);
            }
        },
        draw_tooltip: function (textOptions, text, padding, toolpoly, font) {
            var chartCanvas = document.getElementById(this._rootId + "_canvas"), chartPos = { left: chartCanvas.offsetLeft, top: chartCanvas.offsetTop }, strokewidth = toolpoly["stroke-width"].split("px");
            if (!bbdesigner$("#secondCanvas").length) {
                var secCanvas = document.createElement('canvas');
                bbdesigner$(document).find("#container").append(secCanvas);
                bbdesigner$(secCanvas).attr({
                    'id': 'secondCanvas',
                    'width': chartCanvas.width,
                    'height': chartCanvas.height,
                    'top': chartPos.top,
                    'left': chartPos.left,
                });
                bbdesigner$(secCanvas).css({
                    'width': chartCanvas.width,
                    'height': chartCanvas.height,
                    'top': chartPos.top,
                    'left': chartPos.left,
                    'position': "absolute",
                });
            }
            else {
                var secCanvas = document.getElementById("secondCanvas");
            }
            var drw = secCanvas.getContext('2d');
            drw.lineWidth = strokewidth[0];
            drw.beginPath();
            var polylinePoints = toolpoly.points.split(" ");
            for (var i = 0; i < polylinePoints.length - 1; i+=2) {
                var x = polylinePoints[i], y = polylinePoints[i + 1];
                if (i == 0) {
                    drw.moveTo(x, y);
                }
                else {
                    drw.lineTo(x, y);
                }
            }
            drw.closePath();
            drw.fillStyle = toolpoly.fill;
            drw.fill();
            drw.strokeStyle = toolpoly.stroke;
            drw.stroke();
            drw.fillStyle = textOptions.fill;
            var fontsize = font.size.toString().replace(/px/i, "");
            drw.font = fontsize + "px" + " " + font.fontFamily;
            if (typeof text == "object") {
                var len = text.length;
                for (var i = 0; i < len; i++) {
                    drw.fillText(text[i], textOptions.x, textOptions.y + (Number(fontsize) + padding) * i);
                }
            }
            else {
                drw.fillText(text.toString().replace(/\s{2,}/g, ' '), textOptions.x, textOptions.y);
            }

        },
        drawTrackToolTip: function (rectOptions, textOptions, text, padding) {
            var chartPos = { left: this.svgObj.offsetLeft, top: this.svgObj.offsetTop };
            if (bbdesigner$("#" + rectOptions.id).length > 0) {
                var label = document.getElementById(rectOptions.id);               
                bbdesigner$(label).css({
                    "left": rectOptions.x + chartPos.left,
                    "top": rectOptions.y + chartPos.top,
                    "visibility": "visible",
                    "border-box": "content-box",
					"background-color": rectOptions.fill,
					"color": textOptions.fill, 
					"border-color": rectOptions.stroke,
					"border-width": rectOptions["stroke-width"]
                });
                 if (bbdesigner$.type(text) == "array") {
                    var j = 0;
                    var arrayText = "";
                    for (var i = 0; i < text.length; i++) {
                        arrayText = arrayText + text[i] + '</br>';
                    }
                    bbdesigner$("#" + rectOptions.id).html(arrayText);
                } else
                    bbdesigner$("#" + rectOptions.id).html(text);
            } else {
                var label = bbdesigner$("<div id=" + rectOptions.id + " style='position: absolute; z-index: 13000;'></div>");
                bbdesigner$(label).css({
                    "color": textOptions.fill,
                    "font-family": textOptions["font-family"],
                    "font-size": textOptions["font-size"],
                    "font-weight": textOptions["font-weight"],
                    "font-style": textOptions["font-style"],
                    "width": rectOptions.width,
                    "height": rectOptions.height - padding - 2 * rectOptions["stroke-width"],
                    "background-color": rectOptions.fill,
                    "border-style": "solid",
                    "text-align": "center",
                    "padding" : "0px",
                    "padding-top": (padding/2) + 'px',
                    "padding-bottom": (padding/2) + 'px',
                    "border-color": rectOptions.stroke,
                    "border-width": rectOptions["stroke-width"],
                    "opacity": rectOptions["fill-opacity"]
                });
                document.getElementById(this._rootId).appendChild(label[0]);
            }
        },
        trackSymbol: function (options, evt, symbolName, trackSymbol, chartObj) {
		var chartAreaRect = chartObj.model.m_AreaBounds;
        if (evt.startX >= chartAreaRect.X && evt.startX <= chartAreaRect.X + chartAreaRect.Width && evt.startY >= chartAreaRect.Y && evt.startY <= chartAreaRect.Y + chartAreaRect.Height) {
            var seriesIndex = options.SeriesIndex;
            var pointIndex = options.PointIndex;
            if (chartObj.model.series[seriesIndex].type.toLowerCase() == "bubble") {
                var point = chartObj.model.series[seriesIndex].points[pointIndex];
                var width = (point.radius * 2)+15;//exploding the bubble
                var height = width;
                options.Style.BorderColor = options.Style.Color;
            }
            
            if (chartObj.model.series[seriesIndex].type.toLowerCase() == "scatter" && BoldBIDashboard.util.isNullOrUndefined(trackSymbol)) {
                var circleOptions = {
                    "cx": evt.startX -2,
                    "cy": evt.startY -2,
                    "r": options.ShapeSize.width/2,
                    "fill" : options.Style.Color,
                    "opacity": options.Style.Opacity,
                    "stroke" : options.Style.BorderColor
                };
                this.drawCircle(circleOptions, null);
            }
            
        else {
                if (bbdesigner$("#" + "canvas_trackSymbol").length > 0)
                    var parentDiv = bbdesigner$("#" + "canvas_trackSymbol");
                else
                    parentDiv = bbdesigner$("<div id=" + "canvas_trackSymbol" + "></div>");

                var chartPos = { left:Math.round(bbdesigner$(this.svgObj).offset().left), top:Math.round(bbdesigner$(this.svgObj).offset().top) };                
               
                var symbol = bbdesigner$("<div id=" + options.ID + "></div>");
                var left = (evt.startX + chartPos.left - options.ShapeSize.width);
                var top = (evt.startY + chartPos.top - options.ShapeSize.height);
                
                    bbdesigner$(symbol).css({
                       
                        "left":  left ,
                        "top": top,
                        "box-sizing": 'content-box',
                        "position": "absolute",
                        "visibility": "visible",                        
                        "opacity": options.Style.Opacity,
                        "z-index" : 200
                    });
                    var style = options.ShapeSize;
                    options.symbol = symbol;
                    var shapeAttr = {};
                    switch (symbolName.toLowerCase()) {
                        case "circle":
                            bbdesigner$(symbol).css({
                                "width": options.ShapeSize.width + 'px',
                                "height": options.ShapeSize.height + 'px',
                                "left": (left + options.ShapeSize.width / 2 - options.Style.BorderWidth) + 'px',
                                "top": (top + options.ShapeSize.height / 2 - options.Style.BorderWidth) + 'px',
                                "border-style": "solid",
                                "background-color": options.Style.Color,
                                "border-color": options.Style.BorderColor,
                                "border-width": options.Style.BorderWidth,
                                "border-radius": "100%"
                            });
                            break;
                        case "rectangle":
                            bbdesigner$(symbol).css({
                                "width": options.ShapeSize.width,
                                "height": options.ShapeSize.height,
                                "left": left + options.ShapeSize.width / 2 - options.Style.BorderWidth / 2,
                                "top": top + options.Style.BorderWidth / 2,
                                "border-style": "solid",
                                "background-color": options.Style.Color,
                                "border-color": options.Style.BorderColor,
                                "border-width": options.Style.BorderWidth
                            });
                            break;
                        case "diamond":

                            var direction  = "M" + " " + (evt.startX + (-style.width / 2)) + " " + (evt.startY) + " " 
                                             + "L" + " " + (evt.startX) + " " + (evt.startY + (-options.ShapeSize.height / 2)) + " "
                                             + "L" + " " + (evt.startX + (options.ShapeSize.width / 2)) + " " + (evt.startY) + " "
                                             + "L" + " " + (evt.startX) + " " + (evt.startY + ( options.ShapeSize.height/2)) + " " 
                                             + "L" + " " + (evt.startX + (-options.ShapeSize.width / 2)) + " " + (evt.startY) + "z";
                            shapeAttr.direction = direction;
                            this.drawSvgShape(options, shapeAttr);
                          
                            break;
                        case "triangle":
                                                     
                            var direction = "M" + " " + (evt.startX + (-style.width / 2)) + " " + (evt.startY + (style.height / 2)) + " " + "L" + " " + (evt.startX) + " " + (evt.startY + (-style.height / 2))
                                + " " + "L" + " " + (evt.startX + (style.width / 2)) + " " + (evt.startY + (style.height / 2)) + " " + "L" + " " + (evt.startX + (-style.width / 2)) + " " + (evt.startY + (style.height / 2)) + "z";
                            shapeAttr.direction = direction;
                            this.drawSvgShape(options, shapeAttr);
                           
                            break;
                        case "invertedtriangle":
                                                     
                            var direction = "M" + " " + (evt.startX + (-style.width / 2)) + " " + (evt.startY + (style.height / 2)) + " " + "L" + " " + (evt.startX) + " " +
                                (evt.startY + (-style.height / 2)) + " " + "L" + " " + (evt.startX + (style.width / 2)) + " " + (evt.startY + (style.height / 2)) + " " + "L" + " " +
                                (evt.startX + (-style.width / 2)) + " " + (evt.startY + (style.height / 2)) + "z";
                            var x = evt.startX;
                            var y = evt.startY;
                            var rotate = 'rotate(180,' + x + ',' + y + ')';

                            shapeAttr.direction = direction;
                            shapeAttr.rotate = rotate;
                            this.drawSvgShape(options, shapeAttr);
                            
                            break;
                       
                        case "cross":
                           
                            var direction = "M" + " " + (evt.startX + (-style.width / 2)) + " " + (evt.startY) + " " + "L" + " " + (evt.startX + (style.width / 2))
                                + " " + (evt.startY) + " " + "M" + " " + (evt.startX) + " " + (evt.startY + (style.height / 2)) + " " + "L" + " " + (evt.startX) + " " +
                                (evt.startY + (-style.height / 2)) + "z";

                            shapeAttr.direction = direction;
                            this.drawSvgShape(options, shapeAttr);

                            break;
                        case "star":
                           
                            var direction = "M" + " " + (evt.startX + (style.width / 3)) + " " + (evt.startY + (-style.height / 2)) + " " + "L" + " " + (evt.startX + (-style.width / 2)) + " " +
                                (evt.startY + (style.height / 6)) + " " + "L" + " " + (evt.startX + (style.width / 2)) + " " + (evt.startY + (style.height / 6)) + " " + "L" + " " + (evt.startX + (-style.width / 3)) + " " +
                                (evt.startY + (-style.height / 2)) + " " + "L" + " " + (evt.startX) + " " + (evt.startY + (style.height / 2)) + " " + "L" + " " + (evt.startX + (style.width / 3)) + " " + (evt.startY + (-style.height / 2)) + "z";

                            shapeAttr.direction = direction;
                            this.drawSvgShape(options, shapeAttr);

                            break;
                        case "hexagon":
                           
                            var direction = "M" + " " + (evt.startX + (-style.width / 2)) + " " + (evt.startY) + " " + "L" + " " + (evt.startX + (-style.width / 4)) + " " +
                                (evt.startY + (-style.height / 2)) + " " + "L" + " " + (evt.startX + (style.width / 4)) + " " + (evt.startY + (-style.height / 2)) + " " + "L" + " " +
                                (evt.startX + (style.width / 2)) + " " + (evt.startY) + " " + "L" + " " + (evt.startX + (style.width / 4)) + " " + (evt.startY + (style.height / 2)) + " " + "L" + " " +
                                (evt.startX + (-style.width / 4)) + " " + (evt.startY + (style.height / 2)) + " " + "L" + " " + (evt.startX + (-style.width / 2)) + " " + (evt.startY) + "z";

                            shapeAttr.direction = direction;
                            this.drawSvgShape(options, shapeAttr);

                            break;
                        case "wedge":
                           
                            var direction = "M" + " " + (evt.startX -style.width) + " " + (evt.startY) + " " + "L" + " " + (evt.startX + style.width) + " " +
                                (evt.startY + (-style.height / 2)) + " " + "L" + " " + (evt.startX + (3 * (style.width / 4))) + " " + (evt.startY) + " " + "L" + " " +
                                (evt.startX + (style.width)) + " " + (evt.startY + (style.height / 2)) + " " + "L" + " " + (evt.startX - style.width) + " " + (evt.startY) + "z";

                            shapeAttr.direction = direction;
                            this.drawSvgShape(options, shapeAttr);

                            break;
                        case "trapezoid":
                                                       
                            var direction = "M" + " " + (evt.startX + (-style.width / 2)) + " " + (evt.startY) + " " + "L" + " " + (evt.startX + (-style.width / 2)) + " " +
                                (evt.startY + (-style.height / 4)) + " " + "L" + " " + (evt.startX + (-style.width / 2) + (style.width)) + " " + (evt.startY + (-style.height / 2)) + " " + "L" + " " +
                                (evt.startX + (-style.width / 2) + (style.width)) + " " + (evt.startY + (style.height / 2)) + " " + "L" + " " + (evt.startX + (-style.width / 2)) + " " + (evt.startY + (style.height / 4)) +
                                " " + "L" + " " + (evt.startX + (-style.width / 2)) + " " + (evt.startY) + "z";

                            shapeAttr.direction = direction;
                            this.drawSvgShape(options, shapeAttr);

                            break;
                        case "uparrow":
                           
                            var direction = "M" + " " + ((evt.startX - (style.width / 2) + (style.width / 4))) + " " + (evt.startY - (style.height / 2) + (style.height)) + " " + "L" + " " + ((evt.startX - (style.width / 2) + (style.width / 4))) + " " + (evt.startY - (style.height / 2) + (style.height / 2)) + " " + "L" + " " + ((evt.startX - (style.width / 2))) + " " + (evt.startY - (style.height / 2) + (style.height / 2)) + " " + "L" + " " + ((evt.startX)) + " " + (evt.startY - (style.height / 2)) + " " + "L" + " " + ((evt.startX + (style.width / 2))) + " " + (evt.startY - (style.height / 2) + (style.height / 2)) + " " + "L" + " " + ((evt.startX + (style.width / 2) - (style.width / 4))) + " " + (evt.startY - (style.height / 2) + (style.height / 2)) + " " + "L" + " " + ((evt.startX + (style.width / 2) - (style.width / 4))) + " " + (evt.startY - (style.height / 2) + (style.height)) + " " + "L" + " " + ((evt.startX - (style.width / 2) + (style.width / 4))) + " " + (evt.startY - (style.height / 2) + (style.height)) + "z";
                            shapeAttr.direction = direction;
                            this.drawSvgShape(options, shapeAttr);

                            break;
                        case "downarrow":
                           
                            var direction = "M" + " " + ((evt.startX - (style.width / 2) + (style.width / 4))) + " " + (evt.startY - (style.height / 2)) + " " + "L" + " " + ((evt.startX + (style.width / 2) - (style.width / 4))) + " " + (evt.startY - (style.height / 2)) + " " + "L" + " " + ((evt.startX + (style.width / 2) - (style.width / 4))) + " " + (evt.startY - (style.height / 2) + (style.height / 2)) + " " + "L" + " " + ((evt.startX + (style.width / 2))) + " " + (evt.startY - (style.height / 2) + (style.height / 2)) + " " + "L" + " " + ((evt.startX)) + " " + (evt.startY - (style.height / 2) + (style.height)) + " " + "L" + " " + ((evt.startX - (style.width / 2))) + " " + (evt.startY - (style.height / 2) + (style.height / 2)) + " " + "L" + " " + ((evt.startX - (style.width / 2) + (style.width / 4))) + " " + (evt.startY - (style.height / 2) + (style.height / 2)) + " " + "L" + " " + ((evt.startX - (style.width / 2) + (style.width / 4))) + " " + (evt.startY - (style.height / 2)) + "z";
                            shapeAttr.direction = direction;
                            this.drawSvgShape(options, shapeAttr);

                            break;
                        case "leftarrow":
                           
                            var direction = "M" + " " + ((evt.startX - (style.width / 2)) + style.width) + " " + (evt.startY + (style.height / 4)) + " " + "L" + " " + ((evt.startX - (style.width / 2)) + style.width) + " " + (evt.startY + (-style.height / 4)) + " " + "L" + " " +
                                ((evt.startX - (style.width / 2)) + (style.width / 2)) + " " + (evt.startY + (-style.height / 4)) + " " + "L" + " " + ((evt.startX - (style.width / 2)) + (style.width / 2)) + " " + (evt.startY + (-style.height / 2)) + " " + "L" + " " + ((evt.startX -
                                (style.width / 2))) + " " + (evt.startY) + " " + "L" + " " + ((evt.startX - (style.width / 2)) + (style.width / 2)) + " " + (evt.startY + (style.height / 2)) + " " + "L" + " " + ((evt.startX - (style.width / 2)) + (style.width / 2)) + " " +
                                (evt.startY + (style.height / 4)) + " " + "L" + " " + ((evt.startX - (style.width / 2)) + style.width) + " " + (evt.startY + (style.height / 4)) + "z";

                            shapeAttr.direction = direction;
                            this.drawSvgShape(options, shapeAttr);

                            break;
                        case "rightarrow":

                            var direction = "M" + " " + ((evt.startX - (style.width / 2))) + " " + (evt.startY + (style.height / 4)) + " " + "L" + " " + ((evt.startX - (style.width / 2))) + " " + (evt.startY + (-style.height / 4)) + " " + "L" + " " + ((evt.startX - (style.width / 2)) + (style.width / 2)) + " " + (evt.startY + (-style.height / 4)) + " " + "L" + " " + ((evt.startX - (style.width / 2)) + (style.width / 2)) + " " + (evt.startY + (-style.height / 2)) + " " + "L" + " " + ((evt.startX - (style.width / 2)) + style.width) + " " + (evt.startY) + " " + "L" + " " + ((evt.startX - (style.width / 2)) + (style.width / 2)) + " " + (evt.startY + (style.height / 2)) + " " + "L" + " " + ((evt.startX - (style.width / 2)) + (style.width / 2)) + " " + (evt.startY + (style.height / 4)) + " " + "L" + " " + ((evt.startX - (style.width / 2))) + " " + (evt.startY + (style.height / 4)) + "z";
                            shapeAttr.direction = direction;
                            this.drawSvgShape(options, shapeAttr);

                            break;
                        case "pentagon":
                           
                            var eq = 72;
                            var radius = Math.sqrt(style.height * style.height + style.width * style.width) / 2;
                            var sb = BoldBIDashboard.EjSvgRender.utils._getStringBuilder();
                            for (var i = 0; i <= 5; i++) {
                                var deg = i * eq;
                                var rad = (Math.PI / 180) * deg;
                                var x1 = radius * Math.cos(rad);
                                var y1 = radius * Math.sin(rad);
                                if (i == 0)
                                    sb.append("M" + " " + (evt.startX + x1) + " " + (evt.startY + y1) + " ");
                                else
                                    sb.append("L" + " " + (evt.startX + x1) + " " + (evt.startY + y1) + " ");
                            }
                            sb.append("z");
                            var direction = sb.toString();
                            shapeAttr.direction = direction;
                            this.drawSvgShape(options, shapeAttr);

                            break;
                        case "ellipse":
                            bbdesigner$(symbol).css({
                                "width": options.ShapeSize.width,
                                "height": options.ShapeSize.height / 2,
                                "border-style": "solid",
                                "left": left + options.ShapeSize.height / 2 - options.Style.BorderWidth / 2,
                                "top": (evt.startY + chartPos.top - options.ShapeSize.height + 4),
                                "background-color": options.Style.Color,
                                "border-color": options.Style.BorderColor,
                                "border-width": options.Style.BorderWidth,
                                "-moz-border-radius": "50%",
                                "-webkit-border-radius": "50%",
                                "border-radius": "50%",
                                "border-box": "content-box"
                            });
                            break;
                        case "horizline":
                            bbdesigner$(symbol).css({
                                "width": options.ShapeSize.width,
                                "height": 0,
                                "border-style": "solid",
                                "left": left + options.ShapeSize.width / 2,
                                "top": (evt.startY + chartPos.top - 1),
                                "border-color": options.Style.BorderColor,
                                "border-width": '2px',
                                "border-box": "content-box"
                            });
                            break;
                        case "vertline":
                            bbdesigner$(symbol).css({
                                "width": 0,
                                "height": options.ShapeSize.height,
                                "border-style": "solid",
                                "left": (evt.startX + chartPos.left - 1),
                                "top": top + options.ShapeSize.height / 2 - 2,
                                "border-color": options.Style.BorderColor,
                                "border-width": '2px',
                                "border-box": "content-box"
                            });
                            break;
                        default:
                            bbdesigner$(symbol).css({
                                "width": options.ShapeSize.width,
                                "height": options.ShapeSize.height,
                                "border-style": "solid",
                                "background-color": options.Style.Color,
                                "border-color": options.Style.BorderColor,
                                "border-width": options.Style.BorderWidth,
                                "border-radius": "50px"
                            });
                            break;
                    }
                    parentDiv[0].appendChild(symbol[0]);
                document.getElementById(this._rootId).appendChild(parentDiv[0]);
            }
		  }
        },
        //draw SVG Marker shape on mouse over the points
        drawSvgShape: function (options, attr) {
            var chartCanvas = document.getElementById(this._rootId + "_canvas"),offset = bbdesigner$(chartCanvas).offset(),
                chartPos = { left:Math.round(offset.left) , top: Math.round(offset.top) },
                svgLink = "http://www.w3.org/2000/svg",
                svgShape = document.createElementNS(svgLink, "svg");
            svgShape.setAttribute('id', 'mySVG');
            svgShape.setAttribute('width', bbdesigner$(chartCanvas).width());
            svgShape.setAttribute('height', bbdesigner$(chartCanvas).height());
            bbdesigner$(options.symbol).css({
                "left":  chartPos.left + 'px',
                "top": chartPos.top + 'px'
            });
            var attrOptions = {
                'id': 'svgPath',
                'fill-opacity': options.Style.Opacity,
                'stroke-width': options.Style.BorderWidth,
                'fill': options.Style.Color,
                'transform' : attr.rotate,
                'stroke': options.Style.BorderColor
            };
            attrOptions.d = attr.direction;

            var path = document.createElementNS(svgLink, "path");
            bbdesigner$(path).attr(attrOptions).appendTo(svgShape);
            options.symbol[0].appendChild(svgShape);
        },
        drawCircle: function (options, element) {
            if (!options.lgndCtx) {
                var canvasCtx = this.ctx, dashArray;
                this.ctx = element != undefined ? element : this.ctx;
                this.ctx.save();
                this.ctx.beginPath();
                this.ctx.arc(options.cx, options.cy, options.r, 0, 2 * Math.PI);
                this.ctx.fillStyle = options.fill;
                this.ctx.globalAlpha = options.opacity;
                this.ctx.fill();
                this.ctx.lineWidth = options["stroke-width"];
                dashArray = options["stroke-dasharray"] ? options["stroke-dasharray"].split(",") : false;
                if (dashArray) this.ctx.setLineDash(dashArray);
                this.ctx.strokeStyle = options.stroke;
                this.ctx.stroke();
                this.ctx.restore();
                this.ctx = canvasCtx;
            } else {
                var legendCtx = this.lgndCtx;
                this.lgndCtx = element != undefined ? element : this.lgndCtx;
                this.lgndCtx.save();
                this.lgndCtx.beginPath();
                this.lgndCtx.arc(options.cx, options.cy, options.r, 0, 2 * Math.PI);
                this.lgndCtx.fillStyle = options.fill;
                this.lgndCtx.globalAlpha = options.opacity;
                this.lgndCtx.fill();
                this.lgndCtx.lineWidth = options["stroke-width"];
                this.lgndCtx.strokeStyle = options.stroke;
                this.lgndCtx.stroke();
                this.lgndCtx.restore();
                this.lgndCtx = legendCtx;
            }
        },    
        
        drawPolyline: function (options, element) {
            
            this.ctx.save();
            this.ctx.beginPath();
            var points = options.points.split(" ");
            for (var i = 0; i < points.length - 1; i++) {
                var point = points[i].split(",");
                var x = point[0];
                var y = point[1];
                if (i == 0) 
                    this.ctx.moveTo(x,y);
                 else
                    this.ctx.lineTo(x,y);
            }
            this.ctx.lineWidth = options["stroke-width"];
			 this.ctx.strokeStyle = options.stroke;
            this.ctx.stroke();
            this.ctx.restore();            
        },
        drawPolygon: function (options, element) {
           
        },
        setFillAttribute: function (element, options) {
           
        },
        setStrokeAttribute: function (element, options) {
            
        },
        changePathValue: function (options) {
            
        },


        drawArc: function (w, h, options) {
            var x = 0, y = 0;
  
        },
        changeVMLStyle: function(bbdesigner$element, options) {
           
        },
        applyVMLStyle: function (bbdesigner$element, options) {

        },
       
        drawEllipse: function (options, element) {
            var canvasCtx = this.ctx;
            this.ctx = element != undefined ? element : this.ctx;
            var circumference = Math.max(options.rx, options.ry);
            var scaleX = options.rx / circumference;
            var scaleY = options.ry / circumference;
            if (!options.lgndCtx) {
                this.ctx.save();
                this.ctx.beginPath();
                this.ctx.translate(options.cx, options.cy);
                this.ctx.save();
                this.ctx.scale(scaleX, scaleY);
                this.ctx.arc(0, 0, circumference, 0, 2 * Math.PI, false);
                this.ctx.fillStyle = options.fill;
                this.ctx.fill();
                this.ctx.restore();
                this.ctx.lineWidth = options["stroke-width"];
                this.ctx.strokeStyle = options.stroke;
                this.ctx.stroke();
                this.ctx.restore();
                this.ctx = canvasCtx;
            } else {
                this.lgndCtx.save();
                this.lgndCtx.beginPath();
                this.lgndCtx.translate(options.rx, options.ry);
                this.lgndCtx.scale(scaleX, scaleY);
                this.lgndCtx.arc(options.cx - options.rx, options.cy * 2 - options.rx, options.rx, 0, 2 * Math.PI, false);
                this.lgndCtx.fillStyle = options.fill;
                this.lgndCtx.fill();
                this.lgndCtx.restore();
                this.lgndCtx.lineWidth = options["stroke-width"];
                this.lgndCtx.strokeStyle = options.stroke;
                this.lgndCtx.stroke();
                this.lgndCtx.restore();
            }
        },
      
        _getAttrVal: function (ele, val, option) {
            var value = bbdesigner$(ele).attr(val);
            if (value != null)
                return value;
            else
                return option;
        },
        _setAttr: function (element, attribute) {
          
        },
       
        setSpanAttr: function (options, label, element) {
           
        },
       
        //text element attributes values are replaced 
        _textAttrReplace: function (options, label, font, bbdesigner$Ele) {
           
        },

        drawImage: function (options, element) {
             this.ctx.save();
             var imageObj = new Image();
             imageObj.src = options.href;
             this.ctx.drawImage(imageObj, options.x, options.y, options.width, options.height);
             this.ctx.restore();
        },

        createDefs: function () {

        },

        createGroup: function (options) {
           
        },

        createText: function (options, label) {
            var text = document.createElement("div");
            var diff= 1.1; // difference between svg and div element rotated text height
            bbdesigner$(text).css({
                "transform": options.rotateAngle,
                "font-family": parseFloat(options["font-family"]),
                "font-size": parseFloat(options["font-size"]) * diff,
                "position": "absolute"}); 
            if (!BoldBIDashboard.util.isNullOrUndefined(label))
                text.textContent = label;
            return text;
        },


        //Draw clip path for each series to avoid series overlap in multiple axes zooming
        drawAxesBoundsClipPath: function (gSeriesGroupEle, options, invertedAxis) {
            var clipOptions = options;
           
        },

        getAttrVal: function (ele, val, option) {
       
        },

        hexFromRGB: function (color) {
          
        },

        createDelegate: function (context, handler) {
           
        },

        drawClipPath: function (options, element) {
            
        },

        drawCircularClipPath: function (options, element) {

        },

        append: function (childEle, parentEle) {
            bbdesigner$(childEle).appendTo(parentEle);
			},
			
		createLegendCanvas: function (element) {            
            this.legendsvgObj = document.createElement('canvas');
            this._rootId = bbdesigner$(element).attr("id");
            this.legendsvgObj.setAttribute('id', "legend_" + this._rootId + '_canvas');
            this.lgndCtx = this.legendsvgObj.getContext("2d");
            return this.legendsvgObj;
        }
		
    };
})(bbdesigner$);


;

BoldBIDashboard.Ej3DRender = function () {

   
};

(function (bbdesigner$) {
    
    BoldBIDashboard.Ej3DRender.Polygons = [];

    
    BoldBIDashboard.Ej3DRender.prototype = {
        matrix3D: function () {
            
        },

        vector3D: function () {
             
        },
       
        BSPTreeBuilder: function () {

        },

        Graphics3D: function () {

        },

        polygon3D: function () {

        }
    }

    var Ej3DRender = new BoldBIDashboard.Ej3DRender();
    
    Ej3DRender.vector3D.prototype = {
        //Members
        x: "",
        y: "",
        z: "",
        Epsilon:0.00001,
        //all coordinates indicate 0
        //  empty: new Vector3D(0, 0, 0),

        //isValid: !isNaN(this.x) && !isNaN(this.y) && !isNaN(this.z),
        isValid: function (point) {
            return !isNaN(point.x) && !isNaN(point.y) && !isNaN(point.z)
        },
        //Constructor
        vector3D: function (points, vz) {
            this.x = points.x;
            this.y = points.y;
            this.z = vz;
        },

        vector3D: function (vx, vy, vz) {
            this.x = vx;
            this.y = vy;
            this.z = vz;
            return {x:vx, y:vy, z:vz}
        },

        //operations
        vector3DMinus: function (v1, v2) {
            return this.vector3D(v1.x - v2.x, v1.y - v2.y, v1.z - v2.z);
        },

        vector3DPlus: function (v1, v2) {
            return this.vector3D(v1.x + v2.x, v1.y + v2.y, v1.z + v2.z);
        },

        vector3DMultiply: function (v1, v2) {
            var _x = v1.y * v2.z - v2.y * v1.z;
            var _y = v1.z * v2.x - v2.z * v1.x;
            var _z = v1.x * v2.y - v2.x * v1.y;

            return this.vector3D(_x, _y, _z);
        },

        vector3dAND: function (v1, v2) {
            return (v1.x * v2.x + v1.y * v2.y + v1.z * v2.z);
        },

        vector3DStarMultiply: function (v1, val) {
            var _x = v1.x * val;
            var _y = v1.y * val;
            var _z = v1.z * val;

            return this.vector3D(_x, _y, _z);
        },

        //Methods
        getLength: function (vector) {
            var sqt = this.vector3dAND(vector, vector);
            return Math.sqrt(sqt);
        },

       

        normalize: function () {
            var l = this.getLength();
            x /= l;
            y /= l;
            z /= l;
        },
        getNormal:function(v1, v2, v3)
        {
            var v4 = this.vector3DMinus(v1, v2);
            var v5 = this.vector3DMinus(v3, v2);
            var n = this.vector3DMultiply(v4, v5);
            var l = this.getLength(n);

           if (l < this.Epsilon)
           {
              l = 0;
            }
           return { x: n.x/ l, y: n.y / l, z: n.z / l }
        }
    }

   Ej3DRender.matrix3D.prototype = {
       //Memebr
        MATRIX_SIZE: 4,
       //Constructor
        matrix3D: function (size) {
            var mData = [];
           for (var i = 0; i < size; i++) {
               mData[i] = this.createArray(size);
           }
           return mData;
        },

       //method
        isAffine: function (mData) {

            return (mData[0][3] == 0) && (mData[1][3] == 0)
                    && (mData[2][3] == 0) && (mData[3][3] == 1);
        },
       createArray: function (initialSize) {
           var a = [];
           for (index = 0; index < initialSize; ++index) {
               a[index] = 0;
           }
           return a;
       },

       getIdentity: function () {

           var mData=this.matrix3D(this.MATRIX_SIZE);

           for (var i = 0; i < this.MATRIX_SIZE; i++) {
               mData[i][i] = 1.0;
           }
          
           return mData;
       },

      getInvertal:function(matrix)
      {
         var m = this.getIdentity();

         for (var i = 0; i < this.MATRIX_SIZE; i++)
         {
           for (var j = 0; j < this.MATRIX_SIZE; j++)
           {
               m[i][j] = this.getMinor(matrix, i, j);
            }
         }

         m = this.transposed(m);
         m = this.getMatrixMultiple((1 / this.getDeterminant(matrix)) , m);

      return m;
      },
      getMatrixMultiple: function (factor, matrix) {
          for (var i = 0; i < matrix.length; i++) {
              for (var j = 0; j < matrix[i].length; j++) {
                  matrix[i][j] = matrix[i][j] * factor;
              }
          }
          return matrix;
      },
      getMatrixVectorMutiple:function(m1, point)
      {
            var x = m1[0][0] * point.x + m1[1][0] * point.y + m1[2][0] * point.z + m1[3][0];
            var y = m1[0][1] * point.x + m1[1][1] * point.y + m1[2][1] * point.z + m1[3][1];
            var z = m1[0][2] * point.x + m1[1][2] * point.y + m1[2][2] * point.z + m1[3][2];

      if (!this.isAffine(m1))
      {
         var c = 1 / (m1[0][3] * point.x + m1[1][3] * point.y + m1[2][3] * point.z + m1[3][3]);
         x *= c;
         y *= c;
         z *= c;
      }

       return {x:x, y:y, z:z};
      },
      getMatrixVectorAnd:function(m1, v1)
      {
            var x = m1[0][0] * v1.x + m1[1][0] * v1.y + m1[2][0] * v1.z;
            var y = m1[0][1] * v1.x + m1[1][1] * v1.y + m1[2][1] * v1.z;
            var z = m1[0][2] * v1.x + m1[1][2] * v1.y + m1[2][2] * v1.z;

            return Ej3DRender.vector3D.prototype.vector3D(x, y, z);
         },
      getMatrixAdd:function(m1, m2) 
      {
          var m = this.matrix3D(4);

       for (var i = 0; i < 4; i++)
        {
          for (var j = 0; j < 4; j++)
          {
             m[i][j] = m1[i][j] + m2[i][j];
          }
        }

       return m;
     },
      getMatrixMultiplication:function(m1, m2)
      {
          var res = this.getIdentity();

         for (var i = 0; i < this.MATRIX_SIZE; i++)
         {
             for (var j = 0; j < this.MATRIX_SIZE; j++)
             {
             var v = 0;

             for (var k = 0; k < this.MATRIX_SIZE; k++)
             {
                 v += m1[k][j] * m2[i][k];
                 var t = v;
             }

             res[i][j] = v;
          }
       }

       return res;
      },
      getMatrixEqual:function(m1,m2)
       {
            var res = true;

           for (var i = 0; i < m1.length; i++)
          {
              for (var j = 0; j < m1.length; j++)
              {
                 if (m1[i][j] != m2[i][j])
                 {
                     res = false;
                 }
             }
         }

      return res;
      },
      getMatrixNotEqual:function(m1, m2)
      {
            var res = true; 

         for (var i = 0; i < m1.length; i++)
        {
             for (var j = 0; j < m1.length; j++)
          {
             if (m1[i][j] != m2[i][j])
             {
                res = false;
             }
          }
       }

        return !res;
    },


      getMinor:function(dd, columnIndex, rowIndex)
      {
          return (((columnIndex + rowIndex) % 2 == 0) ? 1 : -1) * this.getDeterminant(this.getMMtr(dd, columnIndex, rowIndex));

      },

     getMMtr:function(dd, columnIndex, rowIndex)
     {
        var count = dd.length - 1;
        var d = this.createArray(count);

        for (var i = 0; i < count; i++)
        {
            var m = (i >= columnIndex) ? i + 1 : i;
            d[i] = this.createArray(count);

            for (var j = 0; j < count; j++)
            {
                var n = (j >= rowIndex) ? j + 1 : j;

                d[i][j] = dd[m][n];
            }
        }
         return d;
     },
    getDeterminant:function(dd)
    {
        var count = dd.length;
        var res = 0;

        if (count < 2)
        {
            res = dd[0][0];
        }
        else
        {
            var k = 1;

            for (var i = 0; i < count; i++)
            {
                var dm = this.getMMtr(dd, i, 0);

                res += k * dd[i][0] * this.getDeterminant(dm);
                k = (k > 0) ? -1 : 1;
            }
        }

        return res;
    },


       transform: function (x, y, z) {
           var res = this.getIdentity();

           res[3][0] = x;
           res[3][1] = y;
           res[3][2] = z;

           return res;
       },


       turn: function (angle) {
           var res = this.getIdentity();

           res[0][0] = Math.cos(angle);
           res[2][0] = -Math.sin(angle);
           res[0][2] = Math.sin(angle);
           res[2][2] = Math.cos(angle);

           return res;
       },

       tilt: function (angle) {
           var res = this.getIdentity();
          
           res[1][1] = Math.cos(angle);
           res[2][1] = Math.sin(angle);
           res[1][2] = -(Math.sin(angle));
           res[2][2] = Math.cos(angle);
          
           return res;          
       },
       transposed:function(matrix3D)
       {
           var m = this.getIdentity();

           for (var i = 0; i < this.MATRIX_SIZE; i++)
            {
                for (var j = 0; j < this.MATRIX_SIZE; j++)
                {
                    m[i][j] = matrix3D[j][i];
                }
           }
          return m;
       },
      shear:function(xy, xz, yx, yz, zx, zy)
        {
          var res = this.getIdentity();

           res[1, 0] = xy;
           res[2, 0] = xz;
           res[0, 1] = yx;
           res[2, 1] = yz;
           res[0, 2] = zx;
           res[1, 2] = zy;

           return res;
        }


   }
   Ej3DRender.Graphics3D.prototype = {
      addVisual:function(polygon)
         {
          if ((polygon == null) || (polygonobj.test(polygon)))
            {
                return -1;
            }
         polygon.Graphics3D = this;
         return bsptreeobj.add(polygon);
      },

       getVisualCount:function()
           {
           return BoldBIDashboard.Ej3DRender.Polygons.length();
       },
       remove:function(polygon)
        {
           BoldBIDashboard.Ej3DRender.Polygons.Remove(polygon);
       },
 
     clearVisual:function()
       {
         BoldBIDashboard.Ej3DRender.Polygons=null;
       },

      getVisual:function()
          {
                return BoldBIDashboard.Ej3DRender.Polygons;
         },
      prepareView:function(perspectiveAngle, depth, rotation, tilt, size, sender)
      {
          if (arguments.length==0) {
              bsptreeobj.build();
          }
          else {
              if (BoldBIDashboard.Ej3DRender.transform == null)
                  BoldBIDashboard.Ej3DRender.transform = BoldBIDashboard.EjSvgRender.chartTransform3D.transform3D(size);
              else
                  BoldBIDashboard.Ej3DRender.transform.mViewport = size;
              if(!BoldBIDashboard.Ej3DRender.tree)
                  BoldBIDashboard.Ej3DRender.tree=[];
              BoldBIDashboard.Ej3DRender.transform.Rotation = rotation;
              BoldBIDashboard.Ej3DRender.transform.Tilt = tilt;
              BoldBIDashboard.Ej3DRender.transform.Depth = depth;
              BoldBIDashboard.Ej3DRender.transform.PerspectiveAngle = perspectiveAngle;
              BoldBIDashboard.EjSvgRender.chartTransform3D.transform(BoldBIDashboard.Ej3DRender.transform);
              BoldBIDashboard.Ej3DRender.tree[sender._id] = bsptreeobj.build();
             
          } 
      },
      view: function (panel, sender, rotation, tilt, size, perspectiveAngle, depth)
      {
          var MaxValue = 32767;
          if (arguments.length == 2) {
              if (panel == null) return;
              var eye = vector.vector3D(0, 0, MaxValue);
              this.drawBspNode3D(BoldBIDashboard.Ej3DRender.tree[sender._id], eye, panel, sender);
          }
          else {
              if (panel == null) return;
            
              if (BoldBIDashboard.Ej3DRender.transform == null)
                  BoldBIDashboard.Ej3DRender.transform = BoldBIDashboard.EjSvgRender.chartTransform3D.transform3D(size);
              else
                  BoldBIDashboard.Ej3DRender.transform.mViewport = size;
              BoldBIDashboard.Ej3DRender.transform.Rotation = rotation;
              BoldBIDashboard.Ej3DRender.transform.Tilt = tilt;
              BoldBIDashboard.Ej3DRender.transform.Depth = depth;
              BoldBIDashboard.Ej3DRender.transform.PerspectiveAngle = perspectiveAngle;
              BoldBIDashboard.EjSvgRender.chartTransform3D.transform(BoldBIDashboard.Ej3DRender.transform);
              var eye = vector.vector3D(0, 0, MaxValue);
              this.drawBspNode3D(BoldBIDashboard.Ej3DRender.tree[sender._id], eye, panel, sender);
          }
      },

      draw3DElement: function (tr, sender) {
          if (tr.Plane.element){
              if (tr.Plane.element.tag == "text" || tr.Plane.element.tag == "dataLabel")
                  polygonobj.drawText(tr.Plane, sender);
              else if (tr.Plane.element.tag == "polyline")
                  polygonobj.drawPolyLine(tr.Plane, sender);
              else if(tr.Plane.element.tag == "template")
                  polygonobj.drawTemplate(tr.Plane, sender);
              else
                  polygonobj.drawLine(tr.Plane, sender);
            }
              
          else
            polygonobj.draw(tr.Plane, sender);          
      },

    drawBspNode3D:function(tr, eye, panel, sender)
    {
        if (tr == null || BoldBIDashboard.Ej3DRender.transform == null) return;
     while (true)
     {
         var r = vector.vector3dAND(polygonobj.getNormal(BoldBIDashboard.EjSvgRender.chartTransform3D.result(BoldBIDashboard.Ej3DRender.transform), tr.Plane.VectorPoints), eye);
        if (r > tr.Plane.D)
        {
            if (tr.Front != null)
            {
                this.drawBspNode3D(tr.Front, eye, panel, sender);
            }

            this.draw3DElement(tr, sender);

            if (tr.Back != null)
            {
                tr = tr.Back;
                continue;
            }
        }
        else
        {
            if (tr.Back != null)
            {
                this.drawBspNode3D(tr.Back, eye, panel, sender);
            }

            this.draw3DElement(tr, sender);

            if (tr.Front != null)
            {
                tr = tr.Front;
                continue;
            }
        }
        break;
    }

    }

 }


   Ej3DRender.BSPTreeBuilder.prototype = {
       //Members
       EPSILON: 0.0005,
       Polygon:[],
       
       //Methods
       add:function(poly)
       {
           BoldBIDashboard.Ej3DRender.Polygons.push(poly);
           return BoldBIDashboard.Ej3DRender.Polygons.length - 1;
       },

       remove:function(index)
       {
           BoldBIDashboard.Ej3DRender.Polygons.splice(index,1);
       },

       clear:function()
       {
           BoldBIDashboard.Ej3DRender.Polygons=[];
       },

       count:function()
       {
           return BoldBIDashboard.Ej3DRender.Polygons.length;
       },

       getNext:function(i, count)
        {
            if (i >= count)
            {
             return i - count;
            }
            if (i < 0)
              {
                  return i + count;
              }

             return i;
       },
       getNodeCount:function(el)
        {
            return (el == null) ? 0 : 1 + this.getNodeCount(el.Back) + this.getNodeCount(el.Front);
        },
       vector3DIndexClassification:function(point, ind, res){
           return{
                 index:ind,
                 result: res,
                 vector:point,

                isCuttingBackPoint:false,
                cuttingBackPairIndex:null,
                alreadyCuttedBack:false,

                isCuttingFrontPoint:false,
                cuttingFrontPairIndex:null,
                alreadyCuttedFront:false
         }
       },
       classifyPoint: function(pt, pln)
         {
            var res = "OnPlane";
            var sv = -pln.D - Ej3DRender.vector3D.prototype.vector3dAND(pt , pln.normal);

           if (sv > this.EPSILON)
            {
              res ="OnBack";
            }
          else if (sv < -this.EPSILON)
            {
              res = "OnFront";
            }

            return res;
        },
      
     classifyPolygon:function(pln, plg)
        {
            var res = "Unknown";
            var points = plg.Points;

           if (points == null)
               return res;
               var onBack = 0;
               var onFront = 0;
               var onPlane = 0;
               var normal = pln.normal;// root node normailized value perpendicular direction
               var d = pln.D; // constant of the plan or depth

          for (var i = 0, len = points.length; i < len; i++)
           {
              var r = -d - Ej3DRender.vector3D.prototype.vector3dAND(points[i], normal); // Comparision of Plane point depth with the other nodes
 
              if (r > this.EPSILON)
                {
                  onBack++;
                }
              else if (r < -this.EPSILON)
                {
                   onFront++;
                }
             else
               {
                  onPlane++;
               }

             if ((onBack > 0) && (onFront > 0))
               {
                 break;
               }
          }
         if (onPlane == points.length)
            {
               res = "OnPlane";
            }
          else if (onFront + onPlane == points.length)
           {
              res = "ToRight";
           }
          else if (onBack + onPlane == points.length)
           {
             res = "ToLeft";
           }
          else
          {
                res = "Unknown";
          }
      return res;
     },
   splitPolygon:function(poly, part)
     {
            var backP = [];
            var frontP = [];

    // this code looks for points which lie on the part plane and divide polygon into two parts
    if (poly.Points != null)
    {
        var polyPoints = [];
        var backPartPoints = [];
        var frontPartPoints = [];

        var outpts;
        var inpts;

        var count = poly.Points.length;
        for (var i = 0; i < count;i++)
        {
            var ptB = poly.Points[i];
            var ptC = poly.Points[this.getNext(i + 1, count)];
            var sideB = this.classifyPoint(ptB, part);
            var sideC = this.classifyPoint(ptC, part);

            var vwiwcB = this.vector3DIndexClassification(ptB, polyPoints.length, sideB);
            polyPoints.push(vwiwcB);

            if ((sideB != sideC) && (sideB != "OnPlane") &&
                (sideC !="OnPlane"))
            {
                var v = vector.vector3DMinus(ptB, ptC);
                var dir = vector.vector3DMinus(vector.vector3DStarMultiply(part.normal, (-part.D)), ptC);

                var sv = vector.vector3dAND(dir, part.normal);
                var sect = sv / vector.vector3dAND(part.normal, v);
                var ptP = vector.vector3DPlus(ptC, vector.vector3DStarMultiply(v, sect));
                var vwiwc = this.vector3DIndexClassification(ptP, polyPoints.length, "OnPlane");

                polyPoints.push(vwiwc);
                backPartPoints.push(vwiwc);
                frontPartPoints.push(vwiwc);
            }
            else
                if (sideB == "OnPlane")
                {
                    var ptA = poly.Points[this.getNext(i - 1, count)];
                    var sideA = this.classifyPoint(ptA, part);
                    if ((sideA == sideC)) continue;
                    if ((sideA != "OnPlane") && (sideC != "OnPlane"))
                    {
                        backPartPoints.push(vwiwcB);
                        frontPartPoints.push(vwiwcB);
                    }
                    else
                        if (sideA =="OnPlane")
                        {
                            switch (sideC)
                            {
                                case "OnBack":
                                    backPartPoints.push(vwiwcB);
                                    break;
                                case "OnFront":
                                    frontPartPoints.push(vwiwcB);
                                    break;
                            }
                        }
                        else
                            if (sideC =="OnPlane")
                            {
                                switch (sideA)
                                {
                                    case "OnBack":
                                        backPartPoints.push(vwiwcB);
                                        break;
                                    case "OnFront":
                                        frontPartPoints.push(vwiwcB);
                                        break;
                                }
                            }
                }
        }

        if ((frontPartPoints.length != 0) || (backPartPoints.length != 0))
        {
            for (var i = 0; i < backPartPoints.length - 1; i += 2)
            {
                var vwiwc1 = backPartPoints[i];
                var vwiwc2 = backPartPoints[i + 1];
                vwiwc1.CuttingBackPoint = true;
                vwiwc2.CuttingBackPoint = true;
                vwiwc1.CuttingBackPairIndex = vwiwc2.index;
                vwiwc2.CuttingBackPairIndex = vwiwc1.index;
            }
            for (var i = 0; i < frontPartPoints.length - 1; i += 2)
            {
                var vwiwc1 = frontPartPoints[i];
                var vwiwc2 = frontPartPoints[i + 1];
                vwiwc1.CuttingFrontPoint = true;
                vwiwc2.CuttingFrontPoint = true;
                vwiwc1.CuttingFrontPairIndex = vwiwc2.index;
                vwiwc2.CuttingFrontPairIndex = vwiwc1.index;
            }


            for (var i = 0; i < backPartPoints.length - 1; i++)
            {
                var vwiwc1 = backPartPoints[i];
                if (vwiwc1.alreadyCuttedBack) continue;
                var outpts=this.cutOutBackPolygon(polyPoints, vwiwc1);

                if (outpts.length > 2) {
                    var polygon1 = polygonobj.polygon3D(outpts, poly);
                    backP.push(bbdesigner$.extend({}, polygon1));
                }
            }

            for (var i = 0; i < frontPartPoints.length - 1; i++)
            {
                var vwiwc2 = frontPartPoints[i];
                if (vwiwc2.alreadyCuttedFront) continue;
                inpts=this.cutOutFrontPolygon(polyPoints, vwiwc2);
                if (inpts.length > 2) {
                    var polygon2 = polygonobj.polygon3D(inpts, poly);
                    frontP.push(bbdesigner$.extend({}, polygon2));
                }
            }
        } 
    }
     else
     {
        backP.push(poly);
        frontP.push(poly); 
     }

    return{BackP:backP, FrontP:frontP}
   },
  cutOutFrontPolygon:function(polyPoints, vwiwc)
   {
      points = [];

    var curVW = vwiwc;

    while (true)
    {
        curVW.alreadyCuttedFront = true;
        points.push(curVW.vector);

        var curVWPair = polyPoints[curVW.CuttingFrontPairIndex];

        if (curVW.CuttingFrontPoint)
        {
            if (!curVWPair.alreadyCuttedFront)
            {
                curVW = curVWPair;
            }
            else
            {
                var curVWPrev = polyPoints[this.getNext(curVW.index - 1, polyPoints.length)];
                var curVWNext = polyPoints[this.getNext(curVW.index + 1, polyPoints.length)];

                if ((curVWPrev.result =="OnFront") && !curVWPrev.alreadyCuttedFront)
                {
                    curVW = curVWPrev;
                }
                else
                    if ((curVWNext.result == "OnFront") && !curVWNext.alreadyCuttedFront)
                    {
                        curVW = curVWNext;
                    }
                    else
                    {
                        return points;
                    }
            }
        }
        else
        {
            var curPrev = polyPoints[this.getNext(curVW.index - 1, polyPoints.length)];
            var curNext = polyPoints[this.getNext(curVW.index + 1, polyPoints.length)];

            if ((curPrev.result != "OnBack") && !curPrev.alreadyCuttedFront)
            {
                curVW = curPrev;
            }
            else
                if ((curNext.result != "OnBack") && !curNext.alreadyCuttedFront)
                {
                    curVW = curNext;
                }
                else
                {
                    return points;
                }
        }
    }
    return points;
 },

   cutOutBackPolygon:function(polyPoints, vwiwc)
   {
       var points = [];
       var curVW = vwiwc;

    while (true)
    {
        curVW.alreadyCuttedBack = true;
        points.push(curVW.vector);

        var curVWPair = polyPoints[curVW.CuttingBackPairIndex];

        if (curVW.CuttingBackPoint)
        {
            if (!curVWPair.alreadyCuttedBack)
            {
                curVW = curVWPair;
            }
            else
            {
                var curVWPrev = polyPoints[this.getNext(curVW.index - 1, polyPoints.length)];
                var curVWNext = polyPoints[this.getNext(curVW.index + 1, polyPoints.length)];

                if ((curVWPrev.result == "OnBack") && !curVWPrev.alreadyCuttedBack)
                {
                    curVW = curVWPrev;
                }
                else
                    if ((curVWNext.result == "OnBack") && !curVWNext.alreadyCuttedBack)
                    {
                        curVW = curVWNext;
                    }
                    else
                    {
                        return points;
                    }
            }
        }
        else
        {
            var curVWPrev = polyPoints[this.getNext(curVW.index - 1, polyPoints.length)];
            var curVWNext = polyPoints[this.getNext(curVW.index + 1, polyPoints.length)];

            if ((curVWPrev.result != "OnFront") && !curVWPrev.alreadyCuttedBack)
            {
                curVW = curVWPrev;
            }
            else
                if ((curVWNext.result != "OnFront") && !curVWNext.alreadyCuttedBack)
                {
                    curVW = curVWNext;
                }
                else
                {
                    return points;
                }
        }
    }
     return points
  },
     build:function()
       {
           if(!arguments[0]){
             return (this.build(BoldBIDashboard.Ej3DRender.Polygons));               
           }
           else{
               var arlist=arguments[0];
               if (arlist.length < 1) return null;
               var bspNode = {Back:null, Front:null, Plane:null}
               var plane = arlist[0];
               bspNode.Plane = plane;
               var arleft = [];
               var arright = [];

               for (var i = 1, len = arlist.length; i < len; i++)
               {
                   var pln = arlist[i];

                   if (pln == plane) continue;
                   var r = this.classifyPolygon(plane, pln);

                   switch (r)
                   {
                       case "OnPlane":
                       case "ToRight":
                           arright.push(pln);
                           break;

                       case "ToLeft":
                           arleft.push(pln);
                           break;

                       case "Unknown":
                           //if (pln is Line3D || pln is UIElement3D)
                           if(pln.element && (pln.element.tag == "line" || pln.element.tag == "text"))
                           {
                               arleft.push(pln);
                           }
                         else
                         {
                            
                               var result = this.splitPolygon(pln, plane);                              
                               for (var k = 0; k < result.BackP.length; k++) {
                                   result.BackP[k].Name = result.BackP[k].Name + "back";
                                   arleft.push(result.BackP[k]);
                               }
                               for (var j = 0; j < result.FrontP.length; j++) {
                                   result.FrontP[j].Name = result.FrontP[j].Name + "front";
                                   arright.push(result.FrontP[j]);
                               }
                        }
                   break;
               }
           }

           if (arleft.length > 0)
           {
               bspNode.Back = this.build(arleft);
           }

           if (arright.length > 0)
           {
               bspNode.Front = this.build(arright);
           }

           return bspNode;
         }
    }

   }

   Ej3DRender.polygon3D.prototype = {
       // Member    
       epsilon: 0.00001,
       normal: { x: 0, y: 0, z: 0 },
       a: (this.normal) ? this.normal.x : 0,
       b: (this.normal) ? this.normal.y : 0,
       c: (this.normal) ? this.normal.z : 0,
       vector: new (new BoldBIDashboard.Ej3DRender()).vector3D(),

       // Constructor
       polygon3D: function (points, tag, index, stroke, strokeThickness, opacity, fill, name) {

           if (arguments.length == 3) {
               this.calcNormal(arguments[0], arguments[1], arguments[2])
           }
           else if (arguments.length == 2) {
               points = arguments[0];
               this.calcNormal(points[0], points[1], points[2]);
               this.vectorPoints = points;
               this.calcNormal(this.vectorPoints);
               var polygon = arguments[1];
               polygon.Normal = this.normal;
               polygon.normal = this.normal;
               polygon.Points = points;
               polygon.VectorPoints = this.vectorPoints;
               polygon.IsSplitted = true;
               polygon.d = this.d;
               polygon.D = this.d;
               return polygon;
                
           }
           else {
               this.calcNormal(points[0], points[1], points[2]);
               this.vectorPoints = points;
               this.calcNormal(this.vectorPoints);
               var element = { Tag: 'path', Parent: arguments[arguments.length - 1] }
               var polygon= {
                   Normal: this.normal,
                   normal: this.normal,
                   Points: points,
                   VectorPoints: this.vectorPoints,
                   Index: index,
                   Tag: tag,
                   Name: (name) ? name : null,
                   StrokeThickness: strokeThickness,
                   Opacity:opacity,
                   Fill: fill,
                   d: this.d,
                   D: this.d
               }
               if (arguments.length != 1) 
                   polygon.Element = element;

               return polygon;
               
           }
       },

       //Methods
       createLine: function (line, x1, y1, x2, y2, depth) {
           var strokeThickness = line.width;
           var vectorColl = [];
           vectorColl[0] = vector.vector3D(x1, y1, depth);
           vectorColl[1] = vector.vector3D(x1 + strokeThickness, y2 + strokeThickness, depth);
           vectorColl[2] = vector.vector3D(x2, y2, depth);
           return this.line3D(line, vectorColl);
       },
       createPolyline: function (points, element) {
           if (points.length == 2) {
               var prePoint = points[1];
               points.push(vector.vector3D(prePoint.x, prePoint.y, prePoint.z));
           }
            return this.polyLine3D(element, points);
       },
       polyLine3D: function (element, points) {
           var plane = this.polygon3D(points);
           plane.element = element;
           return plane;
       },

       line3D:function(element, points)
       {
           var plane = this.polygon3D(points);
           plane.element = element;
           return plane;
       },
      text3D:function(element,points)
      {
          var plane = this.polygon3D(points);
          plane.element = element;
          return plane;
      },

       createBox: function (v1, v2, tag, index, graphics3D, stroke, fill, strokeThickness, opacity, inverse, name, parent) {
           var res = [];

           var p1 = new Array(vector.vector3D(v1.x, v1.y, v1.z),
                vector.vector3D(v2.x, v1.y, v1.z),
                vector.vector3D(v2.x, v2.y, v1.z),
                vector.vector3D(v1.x, v2.y, v1.z))

           var p2 = new Array(
               vector.vector3D(v1.x, v1.y, v2.z),
               vector.vector3D(v2.x, v1.y, v2.z),
               vector.vector3D(v2.x, v2.y, v2.z),
               vector.vector3D(v1.x, v2.y, v2.z)
            )

           var p3 = new Array(

               vector.vector3D(v1.x, v1.y, v2.z),
               vector.vector3D(v2.x, v1.y, v2.z),
               vector.vector3D(v2.x, v1.y, v1.z),
               vector.vector3D(v1.x, v1.y, v1.z)
          )

           var p4 = new Array(
               vector.vector3D(v1.x, v2.y, v2.z),
               vector.vector3D(v2.x, v2.y, v2.z),
               vector.vector3D(v2.x, v2.y, v1.z),
               vector.vector3D(v1.x, v2.y, v1.z)
           )

           var p5 = new Array(
               vector.vector3D(v1.x, v1.y, v1.z),
               vector.vector3D(v1.x, v1.y, v2.z),
               vector.vector3D(v1.x, v2.y, v2.z),
               vector.vector3D(v1.x, v2.y, v1.z)
           )

           var p6 = new Array(
               vector.vector3D(v2.x, v1.y, v1.z),
               vector.vector3D(v2.x, v1.y, v2.z),
               vector.vector3D(v2.x, v2.y, v2.z),
               vector.vector3D(v2.x, v2.y, v1.z)
           )
           if (arguments[10]) {

               res[0] = this.polygon3D(p1, tag, index, stroke, strokeThickness, opacity, fill, "_0_"+ name, parent);
               res[1] = this.polygon3D(p2, tag, index, stroke, strokeThickness, opacity, fill, "_1_" + name, parent);
               res[2] = this.polygon3D(p3, tag, index, stroke, strokeThickness, opacity, fill, "_2_" + name, parent);
               res[3] = this.polygon3D(p4, tag, index, stroke, strokeThickness, opacity, fill, "_3_" + name, parent);
               res[4] = this.polygon3D(p5, tag, index, stroke, strokeThickness, opacity, fill, "_4_" + name, parent);
               res[5] = this.polygon3D(p6, tag, index, stroke, strokeThickness, opacity, fill, "_5_" + name, parent);
           }
           else {
               var parent= arguments[arguments.length-1];
               res[0] = this.polygon3D(p1, tag, index, stroke, strokeThickness, opacity, fill, "_0_" + index, parent);
               res[1] = this.polygon3D(p2, tag, index, stroke, strokeThickness, opacity, fill, "_1_" + index, parent);
               res[2] = this.polygon3D(p3, tag, index, stroke, strokeThickness, opacity, fill, "_2_" + index, parent);
               res[3] = this.polygon3D(p4, tag, index, stroke, strokeThickness, opacity, fill, "_3_" + index, parent);
               res[4] = this.polygon3D(p5, tag, index, stroke, strokeThickness, opacity, fill, "_4_" + index, parent);
               res[5] = this.polygon3D(p6, tag, index, stroke, strokeThickness, opacity, fill, "_5_" + index, parent);
           }

           if (inverse) {
               graphics.addVisual(res[0]);
               graphics.addVisual(res[1]);
               graphics.addVisual(res[2]);
               graphics.addVisual(res[3]);
               graphics.addVisual(res[4]);
               graphics.addVisual(res[5]);
           }
           else {
               graphics.addVisual(res[5]);
               graphics.addVisual(res[4]);
               graphics.addVisual(res[0]);
               graphics.addVisual(res[1]);
               graphics.addVisual(res[2]);
               graphics.addVisual(res[3]);
              
           }
           return res;
       },

       updateBox: function (plan, v1, v2, sender) {
           if (plan.Length < 6) return;

           this.update(new Array(vector.vector3D(v1.x, v1.y, v1.z),
                                        vector.vector3D(v2.x, v1.y, v1.z),
                                        vector.vector3D(v2.x, v2.y, v1.z),
                                        vector.vector3D(v1.x, v2.y, v1.z)), plan[0], sender);

           this.update(new Array(vector.vector3D(v1.x, v1.y, v2.z),
                                       vector.vector3D(v2.x, v1.y, v2.z),
                                       vector.vector3D(v2.x, v2.y, v2.z),
                                       vector.vector3D(v1.x, v2.y, v2.z)), plan[1], sender);

           this.update(new Array(vector.vector3D(v1.x, v1.y, v2.z),
                                       vector.vector3D(v2.x, v1.y, v2.z),
                                       vector.vector3D(v2.x, v1.y, v1.z),
                                       vector.vector3D(v1.x, v1.y, v1.z)), plan[2], sender);

           this.update(new Array(vector.vector3D(v1.x, v2.y, v2.z),
                                       vector.vector3D(v2.x, v2.y, v2.z),
                                       vector.vector3D(v2.x, v2.y, v1.z),
                                       vector.vector3D(v1.x, v2.y, v1.z)), plan[3], sender);

           this.update(new Array(vector.vector3D(v1.x, v1.y, v1.z),
                                       vector.vector3D(v1.x, v1.y, v2.z),
                                       vector.vector3D(v1.x, v2.y, v2.z),
                                       vector.vector3D(v1.x, v2.y, v1.z)), plan[4], sender);

           this.update(new Array(vector.vector3D(v2.x, v1.y, v1.z),
                                       vector.vector3D(v2.x, v1.y, v2.z),
                                       vector.vector3D(v2.x, v2.y, v2.z),
                                       vector.vector3D(v2.x, v2.y, v1.z)), plan[5], sender);
       },


       calcNormal: function () {
           if (arguments.length >= 3) {
               // Relative information of the points
               var v1 = arguments[0];
               var v2 = arguments[1];
               var v3 = arguments[2];
               var v4 = vector.vector3DMinus(v1, v2);
               var v5 = vector.vector3DMinus(v3, v2);
               var n = vector.vector3DMultiply(v4, v5);

               var l = vector.getLength(n);//Get length of the vector

               if (l < this.epsilon) {
                   l = 1;
               }

               this.normal= vector.vector3D(n.x / l, n.y / l, n.z / l); //Calculate normalization of the vector
               this.d = -(this.normal.x * v1.x + this.normal.y * v1.y + this.normal.z * v1.z);// Normalized values * 1st coordinates Coordinates - Depth of the plan

               if (arguments[3]) {
                   arguments[3].normal = this.normal;
                   arguments.d = this.d;
               }
           }
           else {
               var Points = arguments[0];
               this.calcNormal(Points[0], Points[1], Points[2], arguments[1]);

               for (var i = 3; (i < Points.length) && (this.test()) ; i++) {
                   this.calcNormal(Points[i], Points[0], Points[i / 2]);
               }
           }
       },

       test: function () {
           return !vector.isValid(this.normal);
       },

       transform: function (matrix, plan) {
           if (plan.Points != null) {
               for (var i = 0; i < plan.Points.length; i++) {

                   plan.VectorPoints[i] = plan.Points[i] = matrixobj.getMatrixVectorMutiple(matrix, plan.Points[i]);
               }

               this.calcNormal(plan.VectorPoints, plan);
           }
           else {
               var v = matrix * (plan.normal * -plan.d);
               plan.normal = matrixobj.getMatrixVectorAnd(matrix, plan.normal);
               vector.normalize(normal);
               plan.d = -(plan.normal & v);
           }
       },

       getPoint: function (x, y, normal, d) {
           if (typeof x == double) {
               var z = -(normal.x * x + normal.y * y + d) / normal.z;

               return vector.vector3D(x, y, z);
           }
           else {
               var position = x;
               var ray = y;
               var dir = vector.vector3DMinus(vector.vector3DStarMultiply(normal, (-d)), position);

               var sv = vector.vector3dAND(dir, normal);
               var sect = sv / vector.vector3dAND(normal, ray);

               return vector.vector3DPlus(position, (vector.vector3DStarMultiply(ray * sect)));
           }
       },

       getNormal: function (transform, VectorPoints) {
           var norm;

           if (VectorPoints != null) {
               norm = vector.getNormal(matrixobj.getMatrixVectorMutiple(transform, VectorPoints[0]),
                  matrixobj.getMatrixVectorMutiple(transform, VectorPoints[1]), matrixobj.getMatrixVectorMutiple(transform, VectorPoints[2]))


               for (var i = 3; (i < VectorPoints.length) && !vector.isValid(norm) && VectorPoints[i / 2]; i++) {
                   var v1 = matrixobj.getMatrixVectorMutiple(transform, VectorPoints[i]);
                   var v2 = matrixobj.getMatrixVectorMutiple(transform, VectorPoints[0]);
                   var v3 = matrixobj.getMatrixVectorMutiple(transform, VectorPoints[i / 2]);

                   norm = vector.getNormal(v1, v2, v3);
               }
           }
           else {
               norm = matrixobj.getMatrixVectorAnd(transform, normal);
               vector.normalize();
           }

           return norm;

       },

     createTextElement:function(position,  element, xLen, yLen)
      {
        
       var vectorColl = [];
       var x = position.x;
       var y = position.y;
 
       var desiredWidth = element.Width;
       var desiredHeight = element.Height;

          vectorColl[0] = this.vector.vector3D(x, y, position.z);
          vectorColl[1] = this.vector.vector3D(x + desiredWidth, y + desiredHeight + yLen, position.z);
          vectorColl[2] = this.vector.vector3D(x + desiredWidth + xLen, y + desiredHeight + yLen, position.z);
         return this.text3D(element, vectorColl);
     },

     redraw: function () { },

     drawPolyLine: function (panel, sender) {
         var transform = BoldBIDashboard.Ej3DRender.transform;
         var pathDirection = BoldBIDashboard.EjSvgRender.utils._getStringBuilder();
         var StartPoint = BoldBIDashboard.EjSvgRender.chartTransform3D.toScreen(panel.VectorPoints[0], transform);
         pathDirection.append("M" + " " + (StartPoint.x) + " " + (StartPoint.y) + " ");
         for(var i=0; i< panel.VectorPoints.length; i++)
         {
            lineSegment = BoldBIDashboard.EjSvgRender.chartTransform3D.toScreen(panel.VectorPoints[i], transform);
            pathDirection.append("L" + " " + (lineSegment.x) + " " + (lineSegment.y) + " ");
                     
         }        
          
         direction = pathDirection.toString();

        
         var optionsLine = {
             'id': panel.element.id,
             'stroke-dasharray': panel.element.dashArray,
             'stroke-width': panel.element.width,
             'stroke': panel.element.stroke,
             'd': direction
         };
         optionsLine.id = (optionsLine.id).replace(/[^a-zA-Z0-9]/g, "");
         sender.svgRenderer.drawPath(optionsLine, panel.element.child);
     },

       drawLine: function (panel, sender) {
           
           var transform = BoldBIDashboard.Ej3DRender.transform;
           if (transform == null) return;
           var actual3DPosition1 = BoldBIDashboard.EjSvgRender.chartTransform3D.toScreen(panel.VectorPoints[0], transform);
           var actual3DPosition2 = BoldBIDashboard.EjSvgRender.chartTransform3D.toScreen(panel.VectorPoints[2], transform);

           var optionsLine = {
               'id': panel.element.id,
               x1: actual3DPosition1.x ,
               y1: actual3DPosition1.y,
               x2: actual3DPosition2.x,
               y2:actual3DPosition2.y,
               'stroke-dasharray': panel.element.dashArray,
               'stroke-width': panel.element.width,
               'stroke': panel.element.stroke,
               'opacity': panel.element.opacity
           };
           optionsLine.id = (optionsLine.id).replace(/[^a-zA-Z0-9]/g, "");
           sender.svgRenderer.drawLine(optionsLine, panel.element.child);
 

       },
       drawTemplate: function (panel, sender) {
           var element = panel.element;
           var transform = BoldBIDashboard.Ej3DRender.transform;
           if (transform == null) return;
           var actual3DPosition = BoldBIDashboard.EjSvgRender.chartTransform3D.toScreen(panel.VectorPoints[0], transform);
           BoldBIDashboard.EjSeriesRender.prototype.drawLabelTemplate(element.Label.series, element.Label.series.points[element.Label.pointIndex], element.Label.pointIndex, { X: actual3DPosition.x, Y: actual3DPosition.y }, sender)
       },
       drawText: function (panel, sender) {
           
           var element = panel.element;
           var transform =BoldBIDashboard.Ej3DRender.transform;
           if (transform == null) return;
           var actual3DPosition = BoldBIDashboard.EjSvgRender.chartTransform3D.toScreen(panel.VectorPoints[0], transform);
           var x = actual3DPosition.x;
           var y = actual3DPosition.y;
 
           if (element.tag == "text") {
               var options = {
                   'id': element.id,
                   'x': x,
                   'y': y,
                   'fill': element.font.color,
                   'font-size': element.font.size,
                   'font-family': element.font.fontFamily,
                   'font-style': element.font.fontStyle,
                   'font-weight': element.font.fontWeight,
                   'opacity': element.font.opacity,
                   'text-anchor': element.TextAnchor,            
                   "cursor":"default",
                   'transform': element.Angle ? 'rotate(' + element.Angle + ',' + (x) + ',' + y + ')' : null
               };           
              
               sender.svgRenderer.drawText(options, panel.element.Label.Text, panel.element.child, panel.element.Label);			 
           }
           else {
               var series = element.series;           
 
               var labelFormat = (series.yAxis && series.yAxis.labelFormat) ? series.yAxis.labelFormat : "";
               var pointText = (element.point.text) ? element.point.text : element.point.y + labelFormat.substring(labelFormat.indexOf('}') + 1);
               var textOffset = BoldBIDashboard.EjSvgRender.utils._measureText(pointText, null, series.marker.dataLabel.font);
               var margin = series.marker.dataLabel.margin;
               var width = textOffset.width + margin.left + margin.right;
               var height = textOffset.height + margin.top + margin.bottom;
               var location = { X: actual3DPosition.x, Y: actual3DPosition.y };

                  
                      if (series.marker.dataLabel.shape)
                          var elementShape = series.marker.dataLabel.shape;
                      else if (series.marker.dataLabel.shape)
                          elementShape = marker.dataLabel.shape;
                      else
                          elementShape = "None";

                      bbdesigner$.each(sender.model.symbolShape, function (name) {
                          if (elementShape.toLowerCase() == name.toLowerCase())
                              symbolName = name;
                      });

                   var xXalue = location.X - (margin.left) / 2 + (margin.right) / 2;
                   var yValue = location.Y - (margin.top) / 2 - (height / margin.top) + (margin.bottom) / 2;

                   var seriesIndex = bbdesigner$.inArray(series, sender.model.series);
                   BoldBIDashboard.EjSeriesRender.prototype.dataLabelSymbol(seriesIndex, series, element.pointIndex, xXalue, yValue, width, height, symbolName, sender);
            
           }

       },

       draw: function (panel,sender) {            
           if (panel.VectorPoints == null || panel.VectorPoints.length <= 0) return;
           var transform = BoldBIDashboard.Ej3DRender.transform;
           var pathDirection = BoldBIDashboard.EjSvgRender.utils._getStringBuilder();
           var color = panel.Fill;
		   var format = sender.svgRenderer.checkColorFormat(color);
		   if (!format)
		      color=sender.colorNameToHex(color);
           var figure={Segments:null, StartPoint:null};
           if (transform != null)
           {
               figure.StartPoint = BoldBIDashboard.EjSvgRender.chartTransform3D.toScreen(panel.VectorPoints[0], transform);
               pathDirection.append("M" + " " + (figure.StartPoint.x) + " " + (figure.StartPoint.y) + " ");
               for(var i=0; i< panel.VectorPoints.length; i++)
                {
                       lineSegment = BoldBIDashboard.EjSvgRender.chartTransform3D.toScreen(panel.VectorPoints[i], transform);
                       pathDirection.append("L" + " " + (lineSegment.x) + " " + (lineSegment.y) + " ");
                     
                }
           }
          
           direction = pathDirection.toString();
          
            var name = "Light";
            var lightCoefZ =(2 * (Math.abs(vector.vector3dAND(panel.normal, vector.vector3D(0, 0, 1))) - 1));
            var lightCoefY =(2 * (Math.abs(vector.vector3dAND(panel.normal, vector.vector3D(0, 1, 0))) - 1));
            var lightCoefX =(2 * (Math.abs(vector.vector3dAND(panel.normal, vector.vector3D(1, 0, 0))) - 1));
           if (lightCoefZ == lightCoefX)
           {               
              name = "ZLight";
              color = this.applyZLight(color, sender);  
           }
          else if (((lightCoefY == lightCoefZ) || (lightCoefZ != 0 && lightCoefY < lightCoefZ)))
          {
              name = "XLight";
              color= this.applyXLight(color, sender);
           }
          else if (lightCoefZ < 0)
          {
              name = "ZLight";
              color = this.applyZLight(color, sender);
          }
          else
          {
              name = "Light";
              color = color;
          }
          if (sender.model.AreaType == "none")
               panel.StrokeThickness = 0;
           var optionsMinorGrid = {
               'id': sender.svgObject.id +"_"+ panel.Name,
               'name':name, 
               'fill': color,
               'stroke': panel.Stroke,
               'stroke-width': panel.StrokeThickness,
               'opacity': panel.Opacity,
               'd': direction
           };
           sender.svgRenderer.drawPath(optionsMinorGrid, panel.Element.Parent);

       },

       applyXLight: function (color, sender)
       { 
           var RGB = sender.svgRenderer.hexToRGB(color);
           RGB.R = (parseInt)(RGB.R * 0.7);
           RGB.G = (parseInt)(RGB.G * 0.7);
           RGB.B = (parseInt)(RGB.B * 0.7);
           return sender.svgRenderer.hexFromRGB(RGB);
       },

       applyZLight:function(color, sender)
         {
           var RGB = sender.svgRenderer.hexToRGB(color);
           RGB.R = (parseInt)(RGB.R * 0.9);
           RGB.G = (parseInt)(RGB.G * 0.9);
           RGB.B = (parseInt)(RGB.B * 0.9);
           return sender.svgRenderer.hexFromRGB(RGB);
        },

       update: function (updatedVectors, panel, sender) {
           if (panel.VectorPoints == null || panel.VectorPoints.length <= 0) return;
           panel.VectorPoints = updatedVectors;
           var transform = BoldBIDashboard.Ej3DRender.transform;
           var pathDirection = BoldBIDashboard.EjSvgRender.utils._getStringBuilder();
           var color = panel.Fill;
           var figure = { Segments: null, StartPoint: null };
           if (transform != null) {
               figure.StartPoint = BoldBIDashboard.EjSvgRender.chartTransform3D.toScreen(panel.VectorPoints[0], transform);
               pathDirection.append("M" + " " + (figure.StartPoint.x) + " " + (figure.StartPoint.y) + " ");
               for (var i = 0; i < panel.VectorPoints.length; i++) {
                   lineSegment = BoldBIDashboard.EjSvgRender.chartTransform3D.toScreen(panel.VectorPoints[i], transform);
                   pathDirection.append("L" + " " + (lineSegment.x) + " " + (lineSegment.y) + " ");

               }
           }

           direction = pathDirection.toString();    

           if (bbdesigner$(sender.chartObj.chart3D).find("#" + sender.chartObj.svgObject.id + "_" + panel.Name).length > 0) {
               var element = bbdesigner$(sender.chartObj.chart3D).find("#" + sender.chartObj.svgObject.id + "_" + panel.Name)[0];
               sender.chartObj.svgRenderer._setAttr(bbdesigner$(element), { 'd': direction });
              
           }
         
       }


   }
   var Ej3DRender = new BoldBIDashboard.Ej3DRender();
   var vector = new Ej3DRender.vector3D();
   var matrixobj = new Ej3DRender.matrix3D();
   var bsptreeobj = new Ej3DRender.BSPTreeBuilder();
   var polygonobj = new Ej3DRender.polygon3D();
   var graphics = new Ej3DRender.Graphics3D();

  
})(bbdesigner$);
;
BoldBIDashboard.Ej3DAxisRenderer = function () {
};

BoldBIDashboard.Ej3DSeriesRender = function () {
};


BoldBIDashboard.Ej3DChart = function () {
};

BoldBIDashboard.series3DTypes = {};

(function (bbdesigner$) {

    BoldBIDashboard.Ej3DAxisRenderer.prototype = {

        _drawAxes: function (index, axis, params) {
            if (axis.majorGridLines.visible)
                this._drawGridLines3D(axis, params);
            if (axis.visible && axis.majorTickLines.visible)
                this._renderTicks3D(axis, axis.majorTickLines.size, axis.majorTickLines.width, params);

            if (axis.visible) {
                this._drawAxisLabel(axis, params);
                this._drawAxisTitle(axis);
            }
        },

        _drawAxisTitle: function (axis) {
           if(axis.title.visible)
           {
               var opposedPosition = axis._opposed;
            if (axis.orientation.toLowerCase() == "horizontal") {
                var xtitleLocation = (this.model.elementSpacing) + axis._LableMaxWidth.height;
                var titlesize = (BoldBIDashboard.EjSvgRender.utils._measureText(axis.title.text, (axis.width), axis.title.font).height / 2);
                var commonEventArgs = bbdesigner$.extend({}, BoldBIDashboard.EjSvgRender.commonChartEventArgs);
                commonEventArgs.data = { Text: axis.title.text, location: { x: (axis.width) / 2, y: (xtitleLocation + titlesize + axis.majorTickLines.size + axis.axisLine.width + this.model.wallSize) }, axes: axis };
                this._trigger("axesTitleRendering", commonEventArgs);

                var x1 = commonEventArgs.data.location.x + axis.x;
                var y1 = (opposedPosition) ? (axis.y - commonEventArgs.data.location.y) : (commonEventArgs.data.location.y + axis.y);

                element = { Width: titlesize.width, Height: titlesize.height, Label: commonEventArgs.data, TextAnchor: 'middle', tag: 'text', font: axis.title.font, id: this.svgObject.id + "axisTitle", child: this.chart3D };

                this.graphics.addVisual(this.polygon.createTextElement(this.vector.vector3D(x1, y1, 0), element, 10, 10));
            }
            else {
                var titleSize = BoldBIDashboard.EjSvgRender.utils._measureText(axis.title.text, (axis.height), axis.title.font);
                var x1 = (opposedPosition) ? axis.x + ((3 * this.model.elementSpacing) + axis._LableMaxWidth.width + axis.majorTickLines.size + axis.axisLine.width) : axis.x - ((3 * this.model.elementSpacing) + axis._LableMaxWidth.width + axis.majorTickLines.size + axis.axisLine.width + this.model.wallSize);

                var commonEventArgs = bbdesigner$.extend({}, BoldBIDashboard.EjSvgRender.commonChartEventArgs);
                commonEventArgs.data = { Text: axis.title.text, location: { x: titleSize.width / 2, y: 0 }, axes: axis };
                this._trigger("axesTitleRendering", commonEventArgs);

                var y1 = commonEventArgs.data.location.y + (axis.y + axis.height) + (((axis.height) / 2) * -1);

                var labelRotation = (opposedPosition) ? 90 : -90;

                element = { Width: titleSize.width, Height: titleSize.height, Angle: -90 , Label: commonEventArgs.data, TextAnchor: 'middle', tag: 'text', font: axis.title.font, id: this.svgObject.id + '_YAxisTitle', child: this.chart3D };

                this.graphics.addVisual(this.polygon.createTextElement(this.vector.vector3D(x1, y1, 0), element, 10, 10));
            }
           }
        },

        _drawAxisLabel: function (axis, params) {
            var labelsCount = axis.visibleLabels.length,
				areaBounds = this.model.m_AreaBounds,
                opposedPosition = axis._opposed,
				validCross = params.axes[axis.name]._validCross,
				y = validCross ? axis.y : areaBounds.Y + (!opposedPosition && areaBounds.Height),
				x = validCross ? axis.x : areaBounds.X + (opposedPosition && areaBounds.Width);
           
            for (var i = 0; i < labelsCount; i++) {
				if (!BoldBIDashboard.util.isNullOrUndefined(axis.visibleLabels[i].Text)) {
                var x1 = 0, y1 = 0, x2 = 0, y2 = 0;
                var textAnchor;
                
                var textSize = BoldBIDashboard.EjSvgRender.utils._measureText(axis.visibleLabels[i].Text, this.model.m_AreaBounds.Width, axis.font);
				var value = (axis.visibleLabels[i].Value - axis.visibleRange.min) / (axis.visibleRange.delta);
                value = (axis.isInversed) ? 1 - value : value;
                value = isNaN(value) ? 0 : value;

                if (axis.orientation.toLowerCase() == "horizontal") {
                    x2 = x1 = (Math.round(axis.width * value)) + this.model.m_AreaBounds.X + ((axis.plotOffset));
                    y1 = (opposedPosition) ? (y - this.model.wallSize - (axis.majorTickLines.size) - (this.model.elementSpacing/2)) : y + this.model.wallSize + (axis.majorTickLines.size) + this.model.elementSpacing;
                    textAnchor="middle"
                }
                else {
                    y1 = y2 = Math.round(axis.plotOffset + axis.y + (textSize.height / 4) + (axis.height * (1 - value)));
                    x1 = (opposedPosition) ? (x + this.model.wallSize + axis.majorTickLines.size + this.model.elementSpacing / 2) : (x - this.model.wallSize - axis.majorTickLines.size - this.model.elementSpacing / 2);
                    textAnchor = (opposedPosition) ?"start" : "end"
                }
 
             
                element = { Width: textSize.width, Height: textSize.height, Label: axis.visibleLabels[i], TextAnchor: textAnchor, tag: 'text', font: axis.font, id: this.svgObject.id + '_' + axis.name + '_' + axis.orientation+ '_' + i, child: this.chart3D };

                this.graphics.addVisual(this.polygon.createTextElement(this.vector.vector3D(x1, y1, 0), element, 10, 10));
				}
            }

        },

        _renderTicks3D: function (axis, size, width, params) {
            var labelsCount = axis.visibleLabels.length,
             parent,
             gEle,
             m_AreaBounds = this.model.m_AreaBounds,
			 y = axis.y;

            for (var i = 0; i < labelsCount; i++)
            {
                var x1 = 0, x2 = 0, y1=0, y2=0;
            
       
                var value = (axis.visibleLabels[i].Value - axis.visibleRange.min) / (axis.visibleRange.delta);
                value = (axis.isInversed) ? 1 - value : value;
                value = isNaN(value) ? 0 : value;
            
                if (axis.orientation.toLowerCase() == "horizontal")
                {
                    x2 = x1 = (Math.round(axis.width * value)) + m_AreaBounds.X + ((axis.plotOffset));
                }
                else
                {
                    y1 = y2 = Math.round(axis.plotOffset + ((axis.height) * (1 - value))+axis.y);
                }

                var position = this._calculatePosition3D(axis, axis.tickLinesPosition, size, width, x1, y1, x2, y2, params);


                var line = { width: axis.majorTickLines.width, stroke: axis.majorTickLines.color, child: this.chart3D,  tag: 'line' };

                line.id = this.svgObject.id + axis.name + "_majorTickLines_" + i;

                this.graphics.addVisual(this.polygon.createLine(line, position.X1, position.Y1, position.X2, position.Y2, 0));

                if (axis.minorGridLines.visible && axis.minorTicksPerInterval > 0 && i < labelsCount - 1) {
                    minorTicks = axis.visibleRange.interval / (axis.minorTicksPerInterval + 1);
                    for (var k = 0; k < axis.minorTicksPerInterval; k++) {
                        value = BoldBIDashboard.EjSvgRender.utils._valueToCoefficient(axis, axis.visibleLabels[i].Value + (minorTicks * (k + 1)));

                        value = isNaN(value) ? 0 : value;

                        if (axis.orientation.toLowerCase() == "horizontal") {
                            x1 = x2 = Math.round(axis.plotOffset + (m_AreaBounds.Width * value) + m_AreaBounds.X);
                        }
                        else {
                            y1 = y2 = Math.round(axis.plotOffset + ((m_AreaBounds.Height) * (1 - value))) + axis.y;
                        }

                        var position = this._calculatePosition3D(axis, axis.tickLinesPosition, size, width, x1, y1, x2, y2, params);


                        var line = { width: axis.minorTickLines.width, stroke: axis.minorTickLines.color, child: this.chart3D, tag: 'line' };

                        line.id = this.svgObject.id + axis.name + "_minorTickLines_" + i + k;

                        this.graphics.addVisual(this.polygon.createLine(line, position.X1, position.Y1, position.X2, position.Y2, 0));
                    }
                }
            }
        },

        _calculatePosition3D: function (axis, ticksPosition, tickSize, width, x1, y1, x2, y2, params) {
            var orientation = axis.orientation;
            var isOpposed = axis._opposed,
				ticksPosition = "outside",
				areaBounds = this.model.m_AreaBounds,
				validCross = params.axes[axis.name]._validCross,
				y = validCross ? axis.y : areaBounds.Y + (!isOpposed && areaBounds.Height),
				x = validCross ? axis.x : areaBounds.X + (isOpposed && areaBounds.Width);
            if (axis.orientation.toLowerCase() == "horizontal") {
                switch (ticksPosition) {
                    case "inside":
                        y1 = isOpposed ? width : 0;
                        y2 = isOpposed ? y1 + tickSize : tickSize;
                        break;
                    case "outside":
                        y1 = 0;
                        y2 = isOpposed ? tickSize : y1 + tickSize;
                        break;
                }                
                var screenPositionTop = ((isOpposed) ? y - this.model.wallSize - (tickSize) : y + this.model.wallSize - (tickSize / 2));
                var screenPositionLeft = axis.x;
                y1 += screenPositionTop;
                y2 += screenPositionTop;

                x1 = x2 = x1;
            }
            else {
                switch (ticksPosition) {
                    case "inside":
                        x1 = 0;
                        x2 = isOpposed ? tickSize : x1 + tickSize;
                        break;
                    case "outside":
                        x1 = 0;
                        x2 = isOpposed ? x1 + tickSize : tickSize;
                        break;
                }
                var screenPositionLeft = (isOpposed) ? x + this.model.wallSize  : (x - this.model.wallSize - tickSize);
                var screenPositionTop = this.model.m_AreaBounds.Y;
                x1 += screenPositionLeft;
                x2 += screenPositionLeft;

                y1 = y2 = y1;
            }
            return { X1: x1, Y1: y1, X2: x2, Y2: y2 };
        },

    

        _drawGridLines3D:function(axis, params)
        {          
            if (axis == null)
                return;
        
            var labelsCount = axis.visibleLabels.length,
                minorTicks, opposedPosition = axis._opposed,
                orientation = axis.orientation, validCross = params.axes[axis.name]._validCross,
                x1, x2, y1, y2;
            if (orientation.toLowerCase() == "horizontal")
            {
                 
                var i;
                for (i = 0; i < labelsCount; i++)
                {                
                    var value = BoldBIDashboard.EjSvgRender.utils._valueToCoefficient(axis, axis.visibleLabels[i].Value);
                    value = isNaN(value) ? 0 : value;
					 x2 = x1 = (Math.round(axis.width * value)) + this.model.m_AreaBounds.X+axis.plotOffset;
                    y1 = this.model.m_AreaBounds.Y;
                    y2 = this.model.m_AreaBounds.Y + this.model.m_AreaBounds.Height;
              
                
                    var depth = this.model.depth > 2 ? this.model.depth - 2 : 1;
                    var bottom = validCross ? axis.y : this.model.m_AreaBounds.Y + (!opposedPosition && this.model.m_AreaBounds.Height);

                    var line = { opacity: axis.majorGridLines.opacity, width: axis.majorGridLines.width, stroke: axis.majorGridLines.color, child: this.chart3D,  tag: 'line' };
                    line.id = this.svgObject.id + axis.name + "_gridlines_" + i;
                    this.graphics.addVisual(this.polygon.createLine(line, x1, y1, x2, y2, depth));
                    var parallelLine = bbdesigner$.extend({}, line);
                    parallelLine.id = this.svgObject.id + axis.name + "_parallelGridlines_" + i;
                  
                    var line3D =   this.polygon.createLine(parallelLine, x2, 0, x2, -depth, bottom);
                    //To fold the gridline alone the wall(bottom)
                    this.polygon.transform(this.matrixobj.tilt((parseFloat)(Math.PI / 2)), line3D);
                        
                    this.graphics.addVisual(line3D);
                    
                    if (axis.minorGridLines.visible && axis.minorTicksPerInterval > 0 && i<labelsCount-1) {
                        minorTicks = axis.visibleRange.interval / (axis.minorTicksPerInterval + 1);
                        for (var k = 0; k < axis.minorTicksPerInterval; k++) {
                            value = BoldBIDashboard.EjSvgRender.utils._valueToCoefficient(axis, axis.visibleLabels[i].Value + (minorTicks * (k+1)));
                            value = isNaN(value) ? 0 : value;
                            x2 = x1 = (Math.round(this.model.m_AreaBounds.Width * value) + this.model.m_AreaBounds.X);
                            y1 = this.model.m_AreaBounds.Y;
                            y2 = this.model.m_AreaBounds.Y + this.model.m_AreaBounds.Height;

                            var line = { opacity: axis.minorGridLines.opacity, width: axis.minorGridLines.width, stroke: axis.minorGridLines.color, child: this.chart3D, tag: 'line' };
                            line.id = this.svgObject.id + axis.name + "_minorgridlines_" + i + k;
                            this.graphics.addVisual(this.polygon.createLine(line, x1, y1, x2, y2, depth));
                            var parallelLine = bbdesigner$.extend({}, line);
                            parallelLine.id = this.svgObject.id + axis.name + "_parallelMinorGridlines_" + i + k;

                            var line3D = this.polygon.createLine(parallelLine, x2, 0, x2, -depth, bottom);
                            //To fold the gridline alone the wall(bottom)
                            this.polygon.transform(this.matrixobj.tilt((parseFloat)(Math.PI / 2)), line3D);

                            this.graphics.addVisual(line3D);
                        }
                    }
                
                    index++;
                }
            }
            else
            {
                var i;
       
              
                for (i = 0; i < labelsCount; i++)
                {
                    //if (i < linesCount)
                    //{
                    var line;
					var value = (axis.visibleLabels[i].Value - axis.visibleRange.min) / (axis.visibleRange.delta); 
                    value = (axis.isInversed) ? 1 - value : value;
                    value = isNaN(value) ? 0 : value;
                    x1 = this.model.m_AreaBounds.X;
                    y1 = Math.round((axis.height) * (1 - value)) + 0.5;
                    y1 += axis.y;
                    x2 = x1 + this.model.m_AreaBounds.Width;
                    y2 = y1;

                    var depth = this.model.depth > 2 ? this.model.depth - 2 : 1;

                    var line = { opacity: axis.majorGridLines.opacity, width: axis.majorGridLines.width, stroke: axis.majorGridLines.color, axisName: axis.name, child: this.chart3D, tag: 'line' };
                 
                    line.id = this.svgObject.id + axis.name + "_gridlines_" + i;

                    this.graphics.addVisual(this.polygon.createLine(line, x1, y1, x2, y2, depth));

                    var depthD = validCross ? axis.x : this.model.m_AreaBounds.X + (opposedPosition && this.model.m_AreaBounds.Width + 1);

                    var sideLine = bbdesigner$.extend({}, line);
                    sideLine.id = this.svgObject.id + axis.name + "_parallelGridlines_" + i;
              
                    var line3D = this.polygon.createLine(sideLine, -depth, y2, 0, y2, depthD);
                    //To fold the gridline alone the wall(right of vertical)
                    this.polygon.transform(this.matrixobj.turn((parseFloat)(-Math.PI / 2)), line3D);
                    this.graphics.addVisual(line3D);

                    if (axis.minorGridLines.visible && axis.minorTicksPerInterval > 0 && i < labelsCount - 1) {
                        minorTicks = axis.visibleRange.interval / (axis.minorTicksPerInterval + 1);
                        for (var k = 0; k < axis.minorTicksPerInterval; k++) {
                            var value = BoldBIDashboard.EjSvgRender.utils._valueToCoefficient(axis, axis.visibleLabels[i].Value + (minorTicks * (k + 1)));
                            value = isNaN(value) ? 0 : value;
                            x1 = this.model.m_AreaBounds.X;
                            y1 = Math.round((axis.height) * (1 - value)) + 0.5;
                            y1 += axis.y;
                            x2 = x1 + this.model.m_AreaBounds.Width;
                            y2 = y1;
                            var line = { opacity: axis.minorGridLines.opacity, width: axis.minorGridLines.width, stroke: axis.minorGridLines.color, axisName: axis.name, child: this.chart3D, tag: 'line' };

                            line.id = this.svgObject.id + axis.name + "_minorgridlines_" + i + k;

                            this.graphics.addVisual(this.polygon.createLine(line, x1, y1, x2, y2, depth));                          

                            var sideLine = bbdesigner$.extend({}, line);
                            sideLine.id = this.svgObject.id + axis.name + "_parallelMinorGridlines_" + i + k;

                            var line3D = this.polygon.createLine(sideLine, -depth, y2, 0, y2, depthD);
                            //To fold the gridline alone the wall(right of vertical)
                            this.polygon.transform(this.matrixobj.turn((parseFloat)(-Math.PI / 2)), line3D);
                            this.graphics.addVisual(line3D);
                        }
                    }

                    ////}
                    index++;
                }

            }
        }

    },

    

    BoldBIDashboard.Ej3DSeriesRender.prototype={
        _getSegmentDepth:function(series)
        {
            var actualDepth = this.chartObj.model.depth;
            var start, end;

            if (this.chartObj.model._sideBySideSeriesPlacement)
            {
                var space = actualDepth / 4;
                start = space;
                end = space * 3;
            }
            else
            {
                var index = series.position-1;
                var count = series.all;
                var space = actualDepth / ((count * 2) + count + 1);
                start = space + (space * index * 3);
                end = start + space * 2;
            }
            return {Start:start, End:end, Delta:end-start};
        },

        createSegment: function (center, start, end, height, r, i, y, insideRadius, pointindex) {
         
            return {
                StartValue : start,
                EndValue : end,
                depth : height,
                radius : r,      
                index : i,
                YData : y,
                Center : center,
                inSideRadius : insideRadius,
                ActualEndValue : end,
                ActualStartValue: start,
                pointIndex: pointindex
            }

            return segment;

        },

        calculateSize:function(sender, series){
            var legend = sender.chartObj.model.legend;
   
            var legXSpace = 0;
            var legYSpace = 0;
            if (legend.visible && legend.position.toLowerCase() != "custom") {
                if (legend.position.toLowerCase() == "right" || legend.position.toLowerCase() == "left")
                    legXSpace = ((legend.position.toLowerCase() == "right") ? sender.chartObj.model.margin.right : sender.chartObj.model.margin.left) + sender.chartObj.model.LegendViewerBounds.Width;
                else
                    legYSpace = ((legend.position.toLowerCase() == "top") ? sender.chartObj.model.margin.top : sender.chartObj.model.margin.bottom) + sender.chartObj.model.LegendViewerBounds.Height;

            }

            var yOffset = ((sender.chartObj.model.title.text) ? sender.chartObj.model._titleLocation.Y : 0) + legYSpace;

            series.actualWidth = bbdesigner$(sender.chartObj.svgObject).width() - legXSpace;
            series.actualHeight = bbdesigner$(sender.chartObj.svgObject).height() - yOffset;
			 var centerx = series.actualWidth * 0.5 + ((legend.position.toLowerCase() === "left") ? legXSpace : 0);
            var centery = series.actualHeight * 0.5 + ((legend.position.toLowerCase() === "top") ? yOffset : ((this.chartObj.model.title.text) ? (this.chartObj.model._titleLocation.Y) : 0));
            return { centerX: centerx, centerY: centery };
        },

        createPoints: function (series, sender) {
            series.segments = [];
            var size = this.calculateSize(sender, series),
                all = 0,
                visiblepoints = this._calculateVisiblePoints(series).visiblePoints,
                count = series._visiblePoints.length;
            for (j = 0; j < count; j++)
                all += visiblepoints[j].YValues[0];
            var coef = 360 / all,
                seriesIndex = bbdesigner$.inArray(series, sender.chartObj.model._visibleSeries),
                seriesLength = this.chartObj.model._visibleSeries.length,
                InsideRadius = sender.chartObj.model.innerRadius[seriesIndex],
                YValues = sender.chartObj._getYValues(series._visiblePoints),
                pieHeight = sender.chartObj.model.depth, center,
                arcStartAngle = 0, arcEndAngle = 0,
                current = 0, pointindex, val, rect, offset, segment,
                segindex = 0,
                radius = sender.chartObj.model.circularRadius[seriesIndex];

            for (var i = 0; i < count; i++) {
                if (series._visiblePoints[i].visible || series._visiblePoints[i].gapMode) {
                    pointindex = bbdesigner$.inArray(series._visiblePoints[i], series._visiblePoints);
                val = Math.abs(YValues[i]);
                arcEndAngle = Math.abs(val) * ((Math.PI * 2) / all);
                rect = {};
                rect.x = 0;
                rect.y = 0;

                if (val != 0) {
                    if (series.explodeIndex == series._visiblePoints[i].actualIndex || series.explodeAll) {
                        offset = {X:0, Y:0};
                        offset.X = Math.cos(2 * Math.PI * (current + val / 2) / all),
                        offset.Y = Math.sin(2 * Math.PI * (current + val / 2) / all);
                        rect.x = 0.01 * radius * offset.X * series.explodeOffset;
                        rect.y = 0.01 * radius * offset.Y * series.explodeOffset;
                    }

                    center = sender.chartObj.vector.vector3D(rect.x +  size.centerX, rect.y + size.centerY, 0);
                    {
                            segment = this.createSegment(center, (parseFloat)(coef * current), (parseFloat)(coef * val), pieHeight, radius, i, val, InsideRadius, pointindex, series);
                            if (series._visiblePoints[i].gapMode)
                                segment.visible = false;
                            else
                                segment.visible = true;
                            series.segments.push(segment);
                    }
                }

                if (series.marker.dataLabel.visible)
                    this._addPieDataLabel(segindex, YValues[i], arcStartAngle, arcStartAngle + arcEndAngle, i, radius, this._isChartRotated(sender) ? sender.chartObj.model.depth + 5 : 0, center, series._visiblePoints[i]);

                segindex++;
                arcStartAngle += arcEndAngle;
                current += val;

                }
            }
            return series.segments;
        },

        _addPieDataLabel: function (x, y, startAngle, endAngle, i, radius, startDepth, center, point) {
            var angle = (startAngle + endAngle) / 2;
            point.symbolLocation = { x: 0, y: 0, radius: 0, angle: 0, StartDepth: 0 };
            point.symbolLocation.x = x;
            point.symbolLocation.y = y;
            point.symbolLocation.radius = radius;
            point.symbolLocation.angle = angle;
            point.symbolLocation.center = center;
            point.startDepth = startDepth;
        },

        _isChartRotated:function(sender)
           {
            var actualTiltView = Math.abs(sender.chartObj.model.tilt % 360);
            var actualRotateView = Math.abs(sender.chartObj.model.rotattion % 360);
            if ((actualTiltView > 90 && actualTiltView < 270) ^ (actualRotateView > 90 && actualRotateView < 270))
              {
                return true;
              }
                  return false;
          },

        createSector: function (seg, sender, style, seriesIndex) {
            var count = (parseInt)(Math.ceil(seg.ActualEndValue / 6));
            var DtoR = Math.PI / 180;
            var inc = 0;
            var Points = [];
            var depth = sender.chartObj.model.depth;
            if (count < 1) return null;
            var res = [];
            var f = seg.ActualEndValue / count;

            var oPts = [];
            var iPts = [];

            for (var i = 0; i < count + 1; i++) {
                var ox = (parseFloat)(seg.Center.x + seg.radius * Math.cos((seg.ActualStartValue + i * f) * DtoR));
                var oy = (parseFloat)(seg.Center.y + seg.radius * Math.sin((seg.ActualStartValue + i * f) * DtoR));

                oPts[i] = { X: ox, Y: oy };

                var ix = (parseFloat)(seg.Center.x + seg.inSideRadius * Math.cos((seg.ActualStartValue + i * f) * DtoR));
                var iy = (parseFloat)(seg.Center.y + seg.inSideRadius * Math.sin((seg.ActualStartValue + i * f) * DtoR));

                iPts[i] = { X: ix, Y: iy };
                Points.push({ X: ox, Y: oy });
            }

            var oPlgs = [];

            for (var i = 0; i < count; i++) {
                vts = new Array(sender.chartObj.vector.vector3D(oPts[i].X, oPts[i].Y, 0),
                       sender.chartObj.vector.vector3D(oPts[i].X, oPts[i].Y, depth),
                       sender.chartObj.vector.vector3D(oPts[i + 1].X, oPts[i + 1].Y, depth),
                       sender.chartObj.vector.vector3D(oPts[i + 1].X, oPts[i + 1].Y, 0))


                oPlgs[i] = sender.chartObj.polygon.polygon3D(vts, this, seg.index, style.borderColor, style.borderWidth, style.opacity, style.interior, inc.toString()  + "_Region" + "_Series_" + seriesIndex + "_Point_" + seg.index, sender.chartObj.chart3D);
                inc++;
            }

            res[1] = oPlgs;

            if (seg.inSideRadius > 0) {
                var iPlgs = [];

                for (var i = 0; i < count; i++) {
                    vts = new Array(sender.chartObj.vector.vector3D(iPts[i].X, iPts[i].Y, 0),
                      sender.chartObj.vector.vector3D(iPts[i].X, iPts[i].Y, depth),
                      sender.chartObj.vector.vector3D(iPts[i + 1].X, iPts[i + 1].Y, depth),
                      sender.chartObj.vector.vector3D(iPts[i + 1].X, iPts[i + 1].Y, 0))


                    iPlgs[i] = sender.chartObj.polygon.polygon3D(vts, this, seg.index, style.borderColor, style.borderWidth, style.opacity, style.interior, inc.toString() + "_Region" + "_Series_" + seriesIndex + "_Point_" + seg.index, sender.chartObj.chart3D);
                    inc++;
                }

                res[3] = iPlgs;
            }

            var tVtxs = [];
            var bVtxs = [];

            for (var i = 0; i < count + 1; i++) {
                tVtxs.push(sender.chartObj.vector.vector3D(oPts[i].X, oPts[i].Y, 0));
                bVtxs.push(sender.chartObj.vector.vector3D(oPts[i].X, oPts[i].Y, depth));
            }

            if (seg.inSideRadius > 0) {
                for (var i = count; i > -1; i--) {
                    tVtxs.push(sender.chartObj.vector.vector3D(iPts[i].X, iPts[i].Y, 0));
                    bVtxs.push(sender.chartObj.vector.vector3D(iPts[i].X, iPts[i].Y, depth));
                }
            }
            else {
                tVtxs.push(seg.Center);
                bVtxs.push(sender.chartObj.vector.vector3D(seg.Center.x, seg.Center.y, depth));
            }
            res[0] = [];
            res[0].push(sender.chartObj.polygon.polygon3D(tVtxs, this, seg.index, style.borderColor, style.borderWidth, style.opacity, style.interior, inc.toString() + "_Region" + "_Series_" + seriesIndex + "_Point_" + seg.index, sender.chartObj.chart3D));
            inc++;
            res[0].push(sender.chartObj.polygon.polygon3D(bVtxs, this, seg.index, style.borderColor, style.borderWidth, style.opacity, style.interior, inc.toString() + "_Region" + "_Series_" + seriesIndex + "_Point_" + seg.index, sender.chartObj.chart3D));
            inc++;



            if (seg.inSideRadius > 0) {
                var rvts = new Array(

                      sender.chartObj.vector.vector3D(oPts[0].X, oPts[0].Y, 0),
                      sender.chartObj.vector.vector3D(oPts[0].X, oPts[0].Y, depth),
                      sender.chartObj.vector.vector3D(iPts[0].X, iPts[0].Y, depth),
                      sender.chartObj.vector.vector3D(iPts[0].X, iPts[0].Y, 0)
                 )

                var lvts = new Array
                 (
                     sender.chartObj.vector.vector3D(oPts[count].X, oPts[count].Y, 0),
                     sender.chartObj.vector.vector3D(oPts[count].X, oPts[count].Y, depth),
                     sender.chartObj.vector.vector3D(iPts[count].X, iPts[count].Y, depth),
                     sender.chartObj.vector.vector3D(iPts[count].X, iPts[count].Y, 0)
                 )
                res[2] = [];

                res[2].push(sender.chartObj.polygon.polygon3D(rvts, this, seg.index, style.borderColor, style.borderWidth, style.opacity, style.interior, inc.toString() + "_Region" + "_Series_" + seriesIndex + "_Point_" + seg.index, sender.chartObj.chart3D));
                inc++;
                res[2].push(sender.chartObj.polygon.polygon3D(lvts, this, seg.index, style.borderColor, style.borderWidth, style.opacity, style.interior, inc.toString() + "_Region" + "_Series_" + seriesIndex + "_Point_" + seg.index, sender.chartObj.chart3D));
                inc++;             

            }
            else {
                var rvts = new Array(
                     sender.chartObj.vector.vector3D(oPts[0].X, oPts[0].Y, 0),
                     sender.chartObj.vector.vector3D(oPts[0].X, oPts[0].Y, depth),
                     sender.chartObj.vector.vector3D(seg.Center.x, seg.Center.y, depth),
                     sender.chartObj.vector.vector3D(seg.Center.x, seg.Center.y, 0)
                )

                var lvts = new Array(
                     sender.chartObj.vector.vector3D(oPts[count].X, oPts[count].Y, 0),
                     sender.chartObj.vector.vector3D(oPts[count].X, oPts[count].Y, depth),
                     sender.chartObj.vector.vector3D(seg.Center.x, seg.Center.y, depth),
                     sender.chartObj.vector.vector3D(seg.Center.x, seg.Center.y, 0)
                )
                res[2] = [];
                res[2].push(sender.chartObj.polygon.polygon3D(rvts, this, seg.index, style.borderColor, style.borderWidth, style.opacity, style.interior, inc.toString() + "_Region" + "_Series_" + seriesIndex + "_Point_" + seg.index, sender.chartObj.chart3D));
                inc++;
                res[2].push(sender.chartObj.polygon.polygon3D(lvts, this, seg.index, style.borderColor, style.borderWidth, style.opacity, style.interior, inc.toString() + "_Region" + "_Series_" + seriesIndex + "_Point_" + seg.index, sender.chartObj.chart3D));
                inc++;


            }


            return res;
        },

        createPolygons: function (series, sender, returnPoly) {
            var segments, poligons = [], seg, style,
                pointindex, segmentsLength, plgs,
                seriesIndex = bbdesigner$.inArray(series, sender.chartObj.model._visibleSeries);
            if (!series.segments || !returnPoly)
                segments = this.createPoints(series, sender);
            else
                segments = series.segments;
            segmentsLength = segments.length;
            for (var i = 0; i < segmentsLength; i++) {
                seg = segments[i];
                if (seg.visible) {
                    pointindex = segments[i].pointIndex;
                    style = sender.chartObj.setStyle(sender, series, seriesIndex, pointindex);
                    if (typeof (sender.chartObj.model.pointColors[pointindex]) == "object")
                        style.interior = sender.chartObj.model.pointColors[pointindex][0].color;
                    plgs = this.createSector(seg, sender, style, seriesIndex);
                    if (plgs != null)
                        for (var ai = 0; ai < plgs.length; ai++) {
                            if (!poligons[ai])
                                poligons[ai] = [];
                            if (plgs[ai] != null) {
                                for (var pi = 0; pi < plgs[ai].length; pi++) {
                                    poligons[ai].push(plgs[ai][pi]);

                                }
                            }
                        }
                    }


            }
            if (returnPoly) {
                return poligons;               
            }

            for (var ai = 0; ai < poligons.length; ai++) {
                for (var k = 0; k < poligons[ai].length; k++) {
                    sender.chartObj.graphics.addVisual(poligons[ai][k]);
                }
            }
        },

        draw3DDataLabel: function (series, pointIndex, point, sender) {

            var connectorHeight = series.marker.dataLabel.connectorLine.height;
            var tag;
            if (this.chartObj.model.AreaType == "none") {
                location = { x: 0, y: 0 };
                var pointText = (point.text) ? point.text : point.y;
                var seriesIndex = bbdesigner$.inArray(series, this.chartObj.model.series);
                var commonEventArgs = bbdesigner$.extend({}, BoldBIDashboard.EjSvgRender.commonChartEventArgs);
                commonEventArgs.data = { text: pointText, location: { x: pointX, y: pointY }, series: series, pointIndex: pointIndex ,seriesIndex:seriesIndex};
                this.chartObj._trigger("displayTextRendering", commonEventArgs);
                commonEventArgs.data.Text = commonEventArgs.data.text;
                var size = BoldBIDashboard.EjSvgRender.utils._measureText(pointText, null, series.marker.dataLabel.font);

                if (series.type.toLowerCase() == "doughnut"  || series.type.toLowerCase() == "pie")
                {
                   
                    var width = Math.min(series.actualWidth, series.actualHeight) / 2;
                    var center = point.symbolLocation.center;

                    var dradius = point.symbolLocation.radius * series._coefficient;
                    if (BoldBIDashboard.util.isNullOrUndefined(connectorHeight))
                         connectorHeight = BoldBIDashboard.EjSvgRender.utils._measureText(commonEventArgs.data.text, null, series.marker.dataLabel.font).height;
                    if (series != null &&series.labelPosition != "inside")
                        radius = point.symbolLocation.radius +  connectorHeight;
                    else if (series != null )
                        radius = dradius + (point.symbolLocation.radius-dradius) / 2;
                    pointX=location.X = center.x + radius * Math.cos(point.symbolLocation.angle);
                    pointY=location.Y = center.y + radius * Math.sin(point.symbolLocation.angle);
                }
            }
            else {
                var labelFormat = series.yAxis.labelFormat ? series.yAxis.labelFormat : "";
                var seriesIndex = bbdesigner$.inArray(series, this.chartObj.model.series);
                var pointText = (point.text) ? point.text : point.y + labelFormat.substring(labelFormat.indexOf('}') + 1);
                var pointHeight = 0;
                var commonEventArgs = bbdesigner$.extend({}, BoldBIDashboard.EjSvgRender.commonChartEventArgs);
                commonEventArgs.data = { text: pointText, location: { x: pointX, y: pointY }, series: series, pointIndex: pointIndex };
                this.chartObj._trigger("displayTextRendering", commonEventArgs);
                commonEventArgs.data.Text = commonEventArgs.data.text;
                var size = BoldBIDashboard.EjSvgRender.utils._measureText(pointText, null, series.marker.dataLabel.font);

                var location = BoldBIDashboard.EjSvgRender.utils.Transform3DToVisible(series, point.symbolLocation.x, point.symbolLocation.y, this.chartObj);
                var connectorHeight = (series.marker.dataLabel.connectorLine.height) ? series.marker.dataLabel.connectorLine.height : 0;
                var angle = (6.28 * (1 - (90 / 360.0)));
                var pointY = location.Y;
                var pointX = location.X;
                if (!this.chartObj.model.requireInvertedAxes) {
                    if (point.y > 0)
                        pointY = location.Y + (Math.sin((angle)) * connectorHeight);
                    else
                        pointY = location.Y + (Math.sin((-angle)) * connectorHeight);
                }
                else {
                    if (point.x > 0)
                        pointX = location.X - (Math.sin((angle)) * connectorHeight);
                    else
                        pointX = location.X + (Math.sin((angle)) * connectorHeight);
                      pointHeight = - size.height / 3;
                }
            }

         
          
            var depthInfo = this._getSegmentDepth(series);

            

            if (series.marker.dataLabel.shape.toLowerCase() != "none" && !point.marker.dataLabel.template && commonEventArgs.data.Text != '') {
              
                var element = { tag: 'dataLabel', series: series, point: point, pointIndex: pointIndex, id: this.chartObj.svgObject.id + seriesIndex + '_DataLabel' + pointIndex, child: this.chartObj.chart3D };

                this.chartObj.graphics.addVisual(this.chartObj.polygon.createTextElement(this.chartObj.vector.vector3D(pointX, pointY, (point.symbolLocation.z) ? point.symbolLocation.z : 0), element, 0, -size.height));
            }

            tag = (!point.marker.dataLabel.template) ? "text" : "template";
             
            var element = { Width: size.width, Height: size.height, Label: commonEventArgs.data, TextAnchor: "middle", tag: tag, font: series.marker.dataLabel.font, Angle: series.marker.dataLabel.angle, id: this.chartObj.svgObject.id + '_SeriesText' + pointIndex + seriesIndex, child: this.chartObj.chart3D };
           

            if (this.chartObj.model.AreaType != "none") {
                if (series.marker.dataLabel.connectorLine.height && series.marker.dataLabel.connectorLine.height > 0) {
                    var drawPoints = [];
                    drawPoints.push({ x: location.X, y: location.Y + pointHeight, z: point.symbolLocation.z });

                    drawPoints.push({ x: pointX, y: pointY + pointHeight, z: point.symbolLocation.z });
                    this.drawLineSegment(drawPoints, pointIndex, series);
                }
                this.chartObj.graphics.addVisual(this.chartObj.polygon.createTextElement(this.chartObj.vector.vector3D(pointX, pointY, point.symbolLocation.z), element, 0, -size.height));
            }
            else {
                  if (series.labelPosition.toLowerCase() != "inside")
                    this.updateConnectorLine(point, pointIndex, series, location, connectorHeight)
                var finalSize = { x: series.actualWidth, y: series.actualHeight };
                this.chartObj.graphics.addVisual(this.chartObj.polygon.createTextElement(this.chartObj.vector.vector3D(location.X, location.Y, -1), element, 0, -size.height));
            }        
        },
        updateConnectorLine: function (point, pointIndex, series, location, connectorHeight) {
            var drawPoints = [];
            var symbolLocation = point.symbolLocation;
            var x = symbolLocation.center.x + Math.cos(symbolLocation.angle) * symbolLocation.radius;
            var y = symbolLocation.center.y + Math.sin(symbolLocation.angle) * symbolLocation.radius;
            drawPoints.push({ x: x, y: y });
            var labelRadiusFromOrigin = symbolLocation.radius + connectorHeight;
            x = symbolLocation.center.x + (Math.cos((symbolLocation.angle)) * (labelRadiusFromOrigin));
            y = symbolLocation.center.y + (Math.sin((symbolLocation.angle)) * (labelRadiusFromOrigin));
           
            drawPoints.push({ x: x, y: y });
            //var hipen = height / 5;
            //x += (x > symbolLocation.center.x) ? hipen : -hipen;
            //drawPoints.push({ x: x, y: y });
            if (series.marker.dataLabel.connectorLine.type =="bezier")
                drawPoints = this.getBezierApproximation(drawPoints, 256, series);
            this.drawLineSegment(drawPoints, pointIndex, series)
        },
        /// <returns></returns>
        getBezierApproximation: function (controlPoints, outputSegmentCount, series)
        {
            var points = [];
             for (var i = 0; i <= outputSegmentCount; i++)
             {
               var t =i / outputSegmentCount;
               points.push(this.GetBezierPoint(t, controlPoints, 0, controlPoints.length, series));
             }
            return points;
         },
        drawLineSegment: function (drawpoints, pointIndex, series) {
            var vectorPoints = [];
            for (var i = 0; i < drawpoints.length; i++) {
                vectorPoints.push(this.chartObj.vector.vector3D(drawpoints[i].x, drawpoints[i].y, drawpoints[i].z ? drawpoints[i].z:0));
            }
            var seriesIndex=bbdesigner$.inArray(series, this.chartObj.model._visibleSeries);
            var color = (this.chartObj.model.AreaType=="none") ? this.chartObj.model.pointColors[pointIndex] : this.chartObj.model.seriesColors[seriesIndex];
            var stroke = (series.marker.dataLabel.connectorLine.stroke)?series.marker.dataLabel.connectorLine.stroke:color;
            var line = { width: series.marker.dataLabel.connectorLine.width, stroke: stroke, child: this.chartObj.chart3D, tag: 'polyline', id:this.chartObj.svgObject.id + "_" + seriesIndex + "_" + pointIndex };
          
            this.chartObj.graphics.addVisual(this.chartObj.polygon.createPolyline(vectorPoints, line));
        }

    },

     BoldBIDashboard.ejCircularSeries = {

         draw: function (series, sender, type) {
             var MARGINS_RATIO = 0.03;
             
             seriesLength = sender.chartObj.model._visibleSeries.length,
             seriesIndex = bbdesigner$.inArray(series, sender.chartObj.model._visibleSeries);
             sender._calculateVisiblePoints(series);
              sender.calculateSize(sender, series);
             
             if (type == "pie") {
                 series._size = series.pieCoefficient;
                 series._coefficient = seriesIndex == 0 ? 0 : series._size ;
             }
             else {
                 series._size = series.doughnutSize;
                 series._coefficient =  series.doughnutCoefficient;
             }
            if (sender.chartObj.model.circularRadius.length > 1) {
                 for (i = seriesIndex; i < sender.chartObj.model.circularRadius.length; i++) {
                     if (!BoldBIDashboard.util.isNullOrUndefined(sender.chartObj.model.circularRadius[i])) {
                         sender.chartObj.model.circularRadius[seriesIndex] = sender.chartObj.model.circularRadius[i] * series._size;
                         break;
                     }
                 }
             }
             else
                 sender.chartObj.model.circularRadius[seriesIndex] = (((1 - MARGINS_RATIO) * Math.min(series.actualWidth / 2, series.actualHeight / 2)) * series._size);
             sender.chartObj.model.innerRadius[seriesIndex] = series._coefficient * sender.chartObj.model.circularRadius[seriesIndex];
             sender.createPolygons(series, sender);
         },
         doAnimation: function (series, sender) {
             var seriesRendering = this;
             series.count = 0;
             bbdesigner$.each(series.segments, function (pointIndex, point) {

                 var radius = point.radius;
                 var insideRadius = point.inSideRadius;

                 series.animate = true;
                 bbdesigner$(sender.chartObj.element).each(function () { point.radius = 0, point.inSideRadius=0 }).animate(
                     { Radius: radius, InsideRadius: insideRadius },

                     {
                         duration: 1000, queue: false, step: function (now, fx) {


                             if (fx.prop.toString() === "Radius") {
                                 point.radius = now;
                             }
                             else {
                                 point.inSideRadius = now;
                             }


                             var poligons = sender.createPolygons(series, sender, true);

                             for (var ai = 0; ai < poligons.length; ai++) {
                                 for (var k = 0; k < poligons[ai].length; k++) {                                     
                                     sender.chartObj.polygon.update(poligons[ai][k].VectorPoints, poligons[ai][k], sender)
                                 }
                             }
                            
                         },
                         complete: function () {
                             sender.chartObj.model.AnimationComplete = true;
                             var commonEventArgs = bbdesigner$.extend({}, BoldBIDashboard.EjSvgRender.commonChartEventArgs);
                             commonEventArgs.data = { series: series };
                             sender.chartObj._trigger("animationComplete", commonEventArgs);

                         }
                     });
             });
         }
     },

      BoldBIDashboard.series3DTypes.doughnut = BoldBIDashboard.ejCircularSeries;
      BoldBIDashboard.series3DTypes.pie = BoldBIDashboard.ejCircularSeries;

    

    BoldBIDashboard.ej3DStackingColumn = {

        draw: function (series, sender, type, params) {
            var visiblePoints = sender._isVisiblePoints(series);
            this.createSegments(series, sender, params);
            for (var i = 0; i < visiblePoints.length; i++) {
                if (visiblePoints[i].visible) {
                    series._visiblePoints[i].plans = null;
                    BoldBIDashboard.ej3DColumnSeries.update(series, series._visiblePoints[i], i, sender)
                }
            }
        },

        createSegments: function (series, sender, params) {
            var xValues = sender.chartObj._getXValues(series._visiblePoints);
          
            var median;
            if (xValues == null) return;
            
            var sbsInfo = sender.getSideBySideInfo(series, params);
            var depthInfo = sender._getSegmentDepth(series);           
            median = sbsInfo.Delta / 2;
            var visiblePoints = sender._isVisiblePoints(series);
            for (var i = 0; i < visiblePoints.length; i++) {

                var x1 = xValues[i] + sbsInfo.Start;
                var x2 = xValues[i] + sbsInfo.End;
                var y2 = series.stackedValue.StartValues[i];
                var y1 = series.stackedValue.EndValues[i];

                BoldBIDashboard.ej3DColumnSeries._setData(x1, y1, x2, y2, depthInfo.Start, depthInfo.End, sender, visiblePoints[i]);

                if (!series.marker.dataLabel.visible) continue;
                visiblePoints[i].symbolLocation = { x: 0, y: 0, z: 0 };
                switch (series.marker.dataLabel.textPosition) {
                    case "top":
                        visiblePoints[i].symbolLocation.x = x1 + median;
                        visiblePoints[i].symbolLocation.y = y1;
                        visiblePoints[i].symbolLocation.z = depthInfo.Start + (depthInfo.Delta / 2);
                        break;
                    case "bottom":
                        visiblePoints[i].symbolLocation.x = x1 + median;
                        visiblePoints[i].symbolLocation.y = y2;
                        visiblePoints[i].symbolLocation.z = depthInfo.Start + (depthInfo.End - depthInfo.Start) / 2;
                        break;
                    default:
                        visiblePoints[i].symbolLocation.x = x1 + median;
                        visiblePoints[i].symbolLocation.y = y1 + (y2 - y1) / 2;
                        visiblePoints[i].symbolLocation.z = depthInfo.Start;
                        break;
                }

            }

        },

        doAnimation: function (series, sender) {            

                var seriesRender = this;

                bbdesigner$.each(series._visiblePoints, function (pointIndex, point) {

                    var topValue = point.Top;
                    var bottomValue = point.Bottom;

                    bbdesigner$(point).each(function () { point.Top = 0, point.Bottom = 0}).animate(
                    { Top: topValue, Bottom: bottomValue },

                    {
                        duration: 1200, queue: false, step: function (now, fx) {

                            if (fx.prop.toString() === "Top") {
                                point.Top = now;
                            }
                            if (fx.prop.toString() === "Bottom") {
                                point.Bottom = now;
                            }

                            BoldBIDashboard.ej3DColumnSeries.update(series, point, pointIndex, sender);

                        },
                        
                         complete: function () {                  
                       
                                sender.chartObj.model.AnimationComplete = true;
                                var commonEventArgs = bbdesigner$.extend({}, BoldBIDashboard.EjSvgRender.commonChartEventArgs);
                                commonEventArgs.data = { series: series };
                                sender.chartObj._trigger("animationComplete", commonEventArgs);
                  
                            }

                    });

                });

           }

        
        
    },

    BoldBIDashboard.series3DTypes.stackingcolumn = BoldBIDashboard.ej3DStackingColumn;

    BoldBIDashboard.series3DTypes.stackingbar = BoldBIDashboard.ej3DStackingColumn;
     
	BoldBIDashboard.series3DTypes.stackingbar100 = BoldBIDashboard.ej3DStackingColumn;
	 
	BoldBIDashboard.series3DTypes.stackingcolumn100 = BoldBIDashboard.ej3DStackingColumn;
   
    BoldBIDashboard.ej3DColumnSeries = {
        draw: function (series, sender, type, params) {
            var visiblePoints = sender._isVisiblePoints(series);
            this.createSegments(series, sender, params);
            for (var i = 0; i < visiblePoints.length; i++) {
                if (visiblePoints[i].visible) {
                    series._visiblePoints[i].plans = null;
                    this.update(series, series._visiblePoints[i], i, sender);
                }
            }
        },

        update: function (series, point, pointIndex, sender) {
            var plans;
            var valueType = series.xAxis._valueType.toLowerCase();
            var seriesIndex = bbdesigner$.inArray(series, sender.chartObj.model._visibleSeries);    
            var xBase = (valueType == "logarithmic") ? null : 1;
            var xIsLogarithmic = (valueType == "logarithmic") ? true :false;
            var left = xIsLogarithmic ? Math.log(point.Left, xBase) : point.Left;
            var right = xIsLogarithmic ? Math.log(point.Right, xBase) : point.Right;
            var bottom = series.yAxis.visibleRange.min;
            var top = series.yAxis.visibleRange.max;
            var xStart = series.xAxis.visibleRange.min;
            var xEnd = series.xAxis.visibleRange.max;
            if ((!(left >= xStart) || !(left <= xEnd)) && (!(right >= xStart) || !(right <= xEnd))) return;
           
            var topValue;
            if(point.Top<0)
                topValue = point.Top > bottom ? point.Top : bottom;
            else
                topValue = (series.yAxis.valueType && series.yAxis.valueType.toLowerCase() == "logarithmic") ?  point.Top : point.Top < top ? point.Top : top;
            var tlpoint = BoldBIDashboard.EjSvgRender.utils.Transform3DToVisible(series, point.Left > xStart ? point.Left : xStart, topValue, sender.chartObj);
            var rbpoint = BoldBIDashboard.EjSvgRender.utils.Transform3DToVisible(series, xEnd > point.Right ? point.Right : xEnd, bottom > point.Bottom ? bottom : point.Bottom, sender.chartObj);
            
            var tlfVector = sender.chartObj.vector.vector3D(Math.min(tlpoint.X, rbpoint.X), Math.min(tlpoint.Y, rbpoint.Y), point.StartDepth);
            var brbVector = sender.chartObj.vector.vector3D(Math.max(tlpoint.X, rbpoint.X), Math.max(tlpoint.Y, rbpoint.Y), point.EndDepth);
           
            var styleOptions = sender.chartObj.setStyle(sender, series, seriesIndex, pointIndex);
            if (styleOptions.interior.indexOf("url") >= 0)
                styleOptions.interior = sender.chartObj.model.seriesColors[seriesIndex][0].color;
            var name = "Region" + "_Series_" + seriesIndex + "_Point_" + pointIndex

            if (!point.plans)
                point.plans = sender.chartObj.polygon.createBox(tlfVector, brbVector, this, pointIndex, null,
                    styleOptions.borderColor, styleOptions.interior, styleOptions.borderWidth, styleOptions.opacity, sender.chartObj.model.requireInvertedAxes, name, sender.chartObj.chart3D);
            else
                sender.chartObj.polygon.updateBox(point.plans, tlfVector, brbVector, sender);
        },

        _setData:function()
        {  
            var values=arguments;
            point = arguments[arguments.length - 1];
            sender = arguments[arguments.length - 2];
        
            point.Left = values[0];
            point.Bottom = values[3];
            point.Top = values[1];
            point.Right = values[2];
            point.StartDepth = values[4];
            point.EndDepth = values[5];
            point.XRange = sender.getDoubleRange(point.Left, point.Right);
            if (!isNaN(point.Top) && !isNaN(point.Bottom))
                point.YRange = sender.getDoubleRange(point.Top, point.Bottom);
        },

        createSegments:function(series, sender, params)
        {
            var xValues = sender.chartObj._getXValues(series._visiblePoints),
                YValues = sender.chartObj._getYValues(series._visiblePoints);            
            if (xValues == null) return;
      
            var sbsInfo = sender.getSideBySideInfo(series, params),
                depthInfo = sender._getSegmentDepth(series);
                crossValue = sender.chartObj._getXCrossValue(series, series.xAxis, params),
                median = sbsInfo.Delta / 2,
            visiblePoints = series._visiblePoints;
            for (var i = 0; i < visiblePoints.length; i++)
            {                 
                var x1 = xValues[i] + sbsInfo.Start,
                    x2 = xValues[i] + sbsInfo.End,
                    y1 = YValues[i],
                    y2 = crossValue;
                
                this._setData(x1, y1, x2, y2, depthInfo.Start, depthInfo.End, sender, visiblePoints[i]);

                XData = xValues[i];
                YData = YValues[i];
                //Item = ActualData[i];
              
                if (!series.marker.dataLabel.visible) continue;
                visiblePoints[i].symbolLocation = {x:0, y:0, z:0};
                switch (series.marker.dataLabel.textPosition) {
                    case "top":
                        visiblePoints[i].symbolLocation.x = x1 + median;
                        visiblePoints[i].symbolLocation.y = y1;
                        visiblePoints[i].symbolLocation.z = depthInfo.Start + (depthInfo.Delta / 2);
                        break;
                    case "bottom":
                        visiblePoints[i].symbolLocation.x = x1 + median;
                        visiblePoints[i].symbolLocation.y = y2;
                        visiblePoints[i].symbolLocation.z = depthInfo.Start + (depthInfo.End - depthInfo.Start) / 2;
                        break;
                    default:
                        visiblePoints[i].symbolLocation.x = x1 + median;
                        visiblePoints[i].symbolLocation.y = Math.abs(y2 - y1) / 2;
                        visiblePoints[i].symbolLocation.z = depthInfo.Start;
                        break;
                }
        
            }

    
        },

        doAnimation: function (series, sender) {

            var seriesRender = this;

            bbdesigner$.each(series._visiblePoints, function (pointIndex, point) {

                var topValue = point.Top;
                bbdesigner$(point).each(function () { point.Top = 0 }).animate(
                { Top: topValue },

                {
                    duration: 1200, queue: false, step: function (now, fx) {

                        if (fx.prop.toString() === "Top") {
                            point.Top = now;
                        }                      

                        seriesRender.update(series, point, pointIndex, sender);

                    },
                    
                     complete: function () {                        
                            sender.chartObj.model.AnimationComplete = true;
                            var commonEventArgs = bbdesigner$.extend({}, BoldBIDashboard.EjSvgRender.commonChartEventArgs);
                            commonEventArgs.data = { series: series };
                            sender.chartObj._trigger("animationComplete", commonEventArgs);
                  
                        }

                });

            })

        }
     
    }

    BoldBIDashboard.series3DTypes.column = BoldBIDashboard.ej3DColumnSeries;

    //bar series
    BoldBIDashboard.series3DTypes.bar = BoldBIDashboard.ej3DColumnSeries;

    BoldBIDashboard.Ej3DChart.prototype = {
        renderSeries: function (sender, series, params) {            

            var series;
            BoldBIDashboard.Ej3DSeriesRender.prototype.chartObj = sender;
         
            bbdesigner$.extend(BoldBIDashboard.Ej3DSeriesRender.prototype, BoldBIDashboard.EjSeriesRender.prototype);
            
            var seriesRendering = new BoldBIDashboard.Ej3DSeriesRender();
            var commonEventArgs = bbdesigner$.extend({}, BoldBIDashboard.EjSvgRender.commonChartEventArgs);
            commonEventArgs.data = {"series":series};
            seriesRendering.chartObj._trigger("seriesRendering", commonEventArgs);
                var type = series.type.toLowerCase();
                var options = BoldBIDashboard.series3DTypes[type];                
                if (BoldBIDashboard.util.isNullOrUndefined(options)) return;
                options.draw(series, seriesRendering,type, params);
                if (series.marker.dataLabel.visible) {
                    bbdesigner$.each(series._visiblePoints, function (pointIndex, point) {
                        point.marker = bbdesigner$.extend(true, {}, series.marker, point.marker);
                       if (point.visible && (BoldBIDashboard.util.isNullOrUndefined(point.marker) || (point.marker.dataLabel && point.marker.dataLabel.visible)))
                            seriesRendering.draw3DDataLabel(series, pointIndex, point, sender);
                    });
                }


               
 
        },
        update3DWall: function (sender, params) {
            if (sender.model.AreaType == "cartesianaxes") {
                bbdesigner$.extend(BoldBIDashboard.Ej3DRender.prototype, this);
                this.updateBackWall(sender);                
                for (var i = 0; i < sender.model._axes.length; i++) {
                    var axis = sender.model._axes[i],
                        opposedPosition = axis._opposed;
                    if (axis.orientation.toLowerCase() == "vertical") {
                        if (!opposedPosition)
                            this.updateLeftWall(sender, axis, params);
                        else
                            this.updateRightWall(sender, axis, params);
                    }
                    else {
                        if (!opposedPosition)
                            this.updateBottomWall(sender, axis, params);
                        else
                            this.updateTopWall(sender, axis, params);
                    }
                }
            }                  
        },

      updateTopWall:function(sender, axis, params)
        {
        
            var offset = 0;
            var  areaBounds= sender.model.m_AreaBounds, y = params.axes[axis.name]._validCross ? axis.y : areaBounds.Y;			
            if (sender.model.wallSize < y)
                offset = y - sender.model.wallSize;
           else
                offset = -(sender.model.wallSize - y);
            var tlfVector = sender.vector.vector3D(areaBounds.X + areaBounds.Width, -sender.model.depth, y - 0.1);
            var brbVector = sender.vector.vector3D(areaBounds.X, - 0.1, offset);
            topSideWallPlans = sender.polygon.createBox(tlfVector, brbVector, this, 0, "Graphics3D", "#e2e1e1", "#e2e1e1", 0, 0.15, false, "TopWallBrush", sender.chart3D);
  
          for (var i = 0; i < topSideWallPlans.length; i++)
              sender.polygon.transform(sender.matrixobj.tilt((parseFloat)(Math.PI / 2)), topSideWallPlans[i]);
    
                  
    },

       updateRightWall:function(sender, axis, params)
        {
		   var x = params.axes[axis.name]._validCross ? axis.x : sender.model.m_AreaBounds.X+sender.model.m_AreaBounds.Width;
           var rightRect = { left: -(sender.model.depth), top: sender.model.m_AreaBounds.Y, bottom: sender.model.m_AreaBounds.Height+sender.model.m_AreaBounds.Y, right: 0 };
           var tlfVector = sender.vector.vector3D(rightRect.left, rightRect.top, x + 1.5);
           var brbVector = sender.vector.vector3D(rightRect.right, rightRect.bottom, x + sender.model.wallSize);
           rightSideWallPlans = sender.polygon.createBox(tlfVector, brbVector, sender, 0, "Graphics3D", "#e2e1e1", "#e2e1e1", 0, 0.15, false, "RightWallBrush", sender.chart3D);
           for (var i = 0; i < rightSideWallPlans.length; i++)
             sender.polygon.transform(sender.matrixobj.turn((parseFloat)(-Math.PI / 2)), rightSideWallPlans[i]);           
        },
        updateBackWall: function (sender) {
            var areaBounds = sender.model.m_AreaBounds;           
            var tlfVector = sender.vector.vector3D(areaBounds.X, areaBounds.Y, sender.model.depth == 0 ? 1.5 : sender.model.depth + sender.model.wallSize);
            var brbVector = sender.vector.vector3D((areaBounds.X + areaBounds.Width), areaBounds.Y + areaBounds.Height, sender.model.depth == 0 ? 1.5 : sender.model.depth);

            sender.polygon.createBox(tlfVector, brbVector, sender, 0, "Graphics3D", "#e2e1e1", "#e2e1e1", 0, 0.15, false, "BackWallBrush", sender.chart3D);
        },
        updateLeftWall: function (sender, axis, params) {
            var leftRect = { left: -(sender.model.depth), top: sender.model.m_AreaBounds.Y, bottom: sender.model.m_AreaBounds.Height+sender.model.m_AreaBounds.Y, right: 0 },
				offset = params.axes[axis.name]._validCross ? axis.x : sender.model.m_AreaBounds.X;
            var tlfVector = sender.vector.vector3D(leftRect.left, leftRect.top, offset - 0.1);
            var brbVector = sender.vector.vector3D(leftRect.right, leftRect.bottom, offset - sender.model.wallSize);

            leftSideWallPlans = sender.polygon.createBox(tlfVector, brbVector, this, 0, "Graphics3D", "#e2e1e1", "#e2e1e1", 0, 0.15, false, "LeftWallBrush", sender.chart3D);
            for (var i = 0; i < leftSideWallPlans.length; i++)
                sender.polygon.transform(sender.matrixobj.turn((parseFloat)(-Math.PI / 2)), leftSideWallPlans[i]);
        },
        updateBottomWall: function (sender, axis, params) {
            var areaBounds = sender.model.m_AreaBounds;
			var y = params.axes[axis.name]._validCross ? axis.y : areaBounds.Y + areaBounds.Height;
            var tlfVector = sender.vector.vector3D((areaBounds.X + areaBounds.Width), -(sender.model.depth), sender.model.wallSize + y);
            var brbVector = sender.vector.vector3D(areaBounds.X, -0.1, y + 1);

            bottomSideWallPlans = sender.polygon.createBox(brbVector, tlfVector, this, 0, "Graphics3D", "#D3D3D3", "#D3D3D3", 0, 0.15, false, "BottomWallBrush", sender.chart3D);
            for (var i = 0; i < bottomSideWallPlans.length; i++)
                sender.polygon.transform(sender.matrixobj.tilt((parseFloat)(Math.PI / 2)), bottomSideWallPlans[i]);
        }
    }

})(bbdesigner$)
;
BoldBIDashboard.EjSvgRender = function (element) {

    this.svgLink = "http://www.w3.org/2000/svg";
    this.svgObj = document.createElementNS(this.svgLink, "svg");
    this._rootId = bbdesigner$(element).attr("id");
    var id = this._rootId + '_svg';   
    if (bbdesigner$(document).find("#" + id).length > 0){       
        var count=0
        do {
            count++;
        } while (bbdesigner$(document).find("#" + this._rootId + '_svg' + count).length > 0);
        id = this._rootId + '_svg' + count;
    }    
    this.svgObj.setAttribute('id', id);

};
(function (bbdesigner$) {
BoldBIDashboard.EjSvgRender.prototype = {
    drawPath: function (options, element) {
        if (bbdesigner$("#" + options.id).length > 0) { 
            bbdesigner$("#" + options.id).attr(options);
        }
        else {
            var path = document.createElementNS(this.svgLink, "path");
            bbdesigner$(path).attr(options).appendTo(element);
        }

    },
    createLegendSvg:function(element)
    {
        this.svgLink = "http://www.w3.org/2000/svg";
        this.legendsvgObj = document.createElementNS(this.svgLink, "svg");
        this._rootId = bbdesigner$(element).attr("id");
        this.legendsvgObj.setAttribute('id', "legend_" + this._rootId + '_svg');
        return this.legendsvgObj;
    },
    drawPolyline: function (options, element) {
        if (bbdesigner$("#" + options.id).length > 0) {
            bbdesigner$("#" + options.id).attr(options);
        }
        else {
            var polyline = document.createElementNS(this.svgLink, "polyline");
            bbdesigner$(polyline).attr(options).appendTo(element);
        }

    },

    drawLine: function (options, element) {
        if (bbdesigner$("#" + options.id).length > 0) {
            bbdesigner$("#" + options.id).attr(options);
        }
        else {
            var path = document.createElementNS(this.svgLink, "line");
            bbdesigner$(path).attr(options);
            bbdesigner$(path).appendTo(element);
        }
    },
    drawPolygon: function (options, element) {
        if (bbdesigner$("#" + options.id).length > 0) {
            bbdesigner$("#" + options.id).attr(options);
        }
        else {
            var polygon = document.createElementNS(this.svgLink, "polygon");
            bbdesigner$(polygon).attr(options);
            bbdesigner$(polygon).appendTo(element);
        }
    },
    drawCircle: function (options, element) {
        if (bbdesigner$("#" + options.id).length > 0) {
            bbdesigner$("#" + options.id).attr(options);
        }
        else {
            var circle = document.createElementNS(this.svgLink, "circle");
            bbdesigner$(circle).attr(options).appendTo(element);
        }
    },
    drawEllipse: function (options, element) {
        if (bbdesigner$("#" + options.id).length > 0) {
            bbdesigner$("#" + options.id).attr(options);
        }
        else {
            var ellipse = document.createElementNS(this.svgLink, "ellipse");
            bbdesigner$(ellipse).attr(options).appendTo(element);
        }
    },
    
    drawRect: function (options, element) {
            if (bbdesigner$("#" + options.id).length > 0) {
                bbdesigner$("#" + options.id).attr(options);
            }
            else {
                var rect = document.createElementNS(this.svgLink, "rect");
                bbdesigner$(rect).attr(options).appendTo(element);
            }    
    },

    createGradientElement: function (name, colors, x1, y1, x2, y2, element, model) {
        var colorName;
        if (Object.prototype.toString.call(colors) == '[object Array]') {
            var options = {
                'id': this.svgObj.id + '_' + name + 'Gradient',
                'x1': x1 + '%',
                'y1': y1 + '%',
                'x2': x2 + '%',
                'y2': y2 + '%'
            };
            var cName = '#' + this.svgObj.id + '_' + name + 'Gradient';
                this.drawGradient(options, colors, element, model);
            colorName = 'url(#' + this.svgObj.id + '_' + name + 'Gradient)';
        }
        else {
            colorName = colors;
        }
        return colorName;
    },

    drawGradient: function (options, gradientEle, element, model) {

        var defs = this.createDefs();
        var linerGradient = document.createElementNS(this.svgLink, "linearGradient");
	
        bbdesigner$(linerGradient).attr(options);
        var offsetValue = 0;

        for (var i = 0; i < gradientEle.length; i++) {
            offsetValue = offsetValue + (100 / gradientEle.length);
            var stop = document.createElementNS(this.svgLink, "stop");
            var legendMode = model.legend.mode.toLowerCase();
            if (legendMode == "range" || legendMode == "point") {
                    bbdesigner$(stop).attr({
                        'offset': offsetValue + '%',
                        'stop-color': typeof gradientEle[i] == "object" ? gradientEle[i][0] : gradientEle[i],
                        'stop-opacity': 1
                    });
            }
            else {
                bbdesigner$(stop).attr({
                    'offset': gradientEle[i].colorStop,
                    'stop-color': gradientEle[i].color,
                    'stop-opacity': 1
                });
            }
            bbdesigner$(stop).appendTo(linerGradient);
        }

        bbdesigner$(linerGradient).appendTo(defs);
        bbdesigner$(defs).appendTo(element);
    },

    drawText: function (options, label, groupEle,font) {
        
        if (bbdesigner$("#" + options.id).length > 0) 
            this._textAttrReplace(options, label,font);           
       else{
            var text = document.createElementNS(this.svgLink, "text");
            var bbdesigner$text = bbdesigner$(text);


            if (bbdesigner$.type(label) == "array") {
                var j = 0;
                bbdesigner$text.attr(options);
                for (var i = 0; i < label.length; i++) {
                    var textspan = document.createElementNS(this.svgLink, "tspan");
                    textspan.textContent = label[i];
                    bbdesigner$(textspan).attr({ "x": options.x, "dy": j });
                    bbdesigner$(textspan).appendTo(text);
                    var bounds = BoldBIDashboard.EjSvgRender.utils._measureText(label[i],null,font);
                    j = bounds.height+2;
                }
            } else {
                text.textContent = label;
				/** To avoid override style of parent element (JS-63724) */
                text.style.fontFamily = options['font-family'];
                text.style.fontSize = options['font-size'];
                text.style.fontStyle = options['font-style'];
                text.style.fontWeight = options['font-weight'];
                text.style.color = options['fill'];
                bbdesigner$text.attr(options);
            }
            bbdesigner$text.appendTo(groupEle);

 
        }
    },
    //text element attributes values are replaced 
    _textAttrReplace: function (options, label, font) {
        bbdesigner$("#" + options.id).attr(options);

        if (bbdesigner$.type(label) == "array") {
            var elements = bbdesigner$("#" + options.id).children("tspan");
            var j = 0;
            if (elements.length > 0 && elements.length == label.length) {
                for (var i = 0; i < elements.length; i++) {
                    var element = elements[i];
                    bbdesigner$(element).attr({ "x": options.x, "dy": j });
                    element.textContent = label[i];
                    var bounds = BoldBIDashboard.EjSvgRender.utils._measureText(label[i], null, font);
                    j = bounds.height + 2;
                }
            }
            else {
                bbdesigner$("#" + options.id).remove();
                this.drawText(options, label, this.gTransToolEle,font);

            }
        } else {
            bbdesigner$("#" + options.id).text(label);
        }

    },

    drawImage: function (options, element) {

        var img = document.createElementNS(this.svgLink, 'image');
        img.setAttributeNS(null, 'height', options.height);
        img.setAttributeNS(null, 'width', options.width);
        img.setAttributeNS('http://www.w3.org/1999/xlink', 'href', options.href);
        img.setAttributeNS(null, 'x', options.x);
        img.setAttributeNS(null, 'y', options.y);
        img.setAttributeNS(null, 'id', options.id);
        img.setAttributeNS(null, 'visibility', options.visibility);
        if (!BoldBIDashboard.util.isNullOrUndefined(options.clippath) || !BoldBIDashboard.util.isNullOrUndefined(options.preserveAspectRatio)) {
            img.setAttributeNS(null, 'clip-path', options.clippath);
            img.setAttributeNS(null, "preserveAspectRatio", options.preserveAspectRatio);
        }
        bbdesigner$(img).appendTo(element);

    },

    createDefs: function () {
        var defs = document.createElementNS(this.svgLink, "defs");
        return defs;
    },

    createClipPath: function (options) {
        var clipPath = document.createElementNS(this.svgLink, "clipPath");
        bbdesigner$(clipPath).attr(options);
        return clipPath;
    },
    createForeignObject: function (options) {
        var object = document.createElementNS(this.svgLink, "foreignObject");
        bbdesigner$(object).attr(options);
        return object;
    },
    createGroup: function (options) {
        var group = document.createElementNS(this.svgLink, "g");
        bbdesigner$(group).attr(options);
        return group;
    },
    createPattern: function (options,element) {
        var pattern = document.createElementNS(this.svgLink, element);
        for (var name in options) {
            if (options.hasOwnProperty(name)) {
                pattern.setAttribute(name, options[name]);
            }
        }
        return pattern;
    },
    createText: function (options, label) {
        var text = document.createElementNS(this.svgLink, "text");
        bbdesigner$(text).attr(options);
        if (!BoldBIDashboard.util.isNullOrUndefined(label))
            text.textContent = label;
        return text;
    },

    createPath: function (options) {
        var path = document.createElementNS(this.svgLink, "path");
        bbdesigner$(path).attr(options);
        return path;
    },

    createCircle: function (options) {
        var circle = document.createElementNS(this.svgLink, "circle");
        bbdesigner$(circle).attr(options);
        return circle;
    },

    createLine: function (options) {
        var line = document.createElementNS(this.svgLink, "line");
        bbdesigner$(line).attr(options);
        return line;
    },

   
    _getAttrVal: function (ele, val, option) {
        var value = bbdesigner$(ele).attr(val);
        if (value != null)
            return value;
        else
            return option;
    },
 
    
    hexFromRGB: function (color) {
        var r = color.R;
        var g = color.G;
        var b = color.B;
        var hex = [r.toString(16), g.toString(16), b.toString(16)];
        bbdesigner$.each(hex, function (nr, val) { if (val.length === 1) { hex[nr] = "0" + val; } });
        return "#" + (hex.join("").toUpperCase());
    },
    
	 checkColorFormat: function (color)
	  {
        return /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.test(color);
      },

    hexToRGB:function(hex) {
    var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    return result ? {
        R: parseInt(result[1], 16),
        G: parseInt(result[2], 16),
        B: parseInt(result[3], 16)
    } : null;
  },


    createDelegate: function (context, handler) {
        return function (e) {
            handler.apply(context, [e, this]);
        };
    },

    drawClipPath: function (options, element) {

        var defs = this.createDefs();
        var clipPath = this.createClipPath({ 'id': options.id });
        this.drawRect(options, clipPath);

        this.append(clipPath, defs);

        this.append(defs, element);

    },

    drawCircularClipPath: function (options, element) {
        var defs = this.createDefs();
        var clipPath = this.createClipPath({ 'id': options.id });
        this.drawCircle(options, clipPath);
        this.append(clipPath, defs);
        this.append(defs, element);
    },
   
   append: function (childEle, parentEle) {
        bbdesigner$(childEle).appendTo(parentEle);
   },
   _setAttr: function (element, attribute) {
       bbdesigner$(element).attr(attribute);
   }
};

BoldBIDashboard.EjSvgRender.commonChartEventArgs = {
    cancel: false,
    data: null
};
BoldBIDashboard.EjSvgRender.utils = {

   

    _decimalPlaces: function (num) {
        var match = ('' + num).match(/(?:\.(\d+))?(?:[eE]([+-]?\d+))?$/);
        if (!match) { return 0; }
        return Math.max(
       0,
        // Number of digits right of decimal point.
       (match[1] ? match[1].length : 0)
        // Adjust for scientific notation.
       - (match[2] ? +match[2] : 0));
    },
    _getLabelContent: function (pos, axis) {
        switch (axis._categoryValueType) {
            case 'number':
                var customFormat = (BoldBIDashboard.util.isNullOrUndefined(axis.labelFormat)) ? null : axis.labelFormat.match('{value}');
                return (BoldBIDashboard.util.isNullOrUndefined(axis.labelFormat)) ? axis.labels[Math.floor(pos)] : (customFormat != null) ? axis.labelFormat.replace('{value}', axis.labels[Math.floor(pos)]) : (BoldBIDashboard.format(axis.labels[Math.floor(pos)], axis.labelFormat));
            case 'date':
                return (BoldBIDashboard.format(new Date(axis.labels[Math.floor(pos)]), ((BoldBIDashboard.util.isNullOrUndefined(axis.labelFormat)) ? "dd/MM/yyyy" : axis.labelFormat)));
            case 'string':
                return axis.labels[Math.floor(pos)];
            default:
                return "";
        }
    },
    
    //Calculation for label size in template
    _getSeriesTemplateSize: function (point, pointIndex, series, isLeft, sender) {
        var point;
        var pointIndex;
        var areaType = sender.model.AreaType;
         
        var chartContainer = sender._id;
        var seriesIndex = bbdesigner$.inArray(series, sender.model._visibleSeries);

            if (bbdesigner$('#template_group_' + chartContainer).length != 0)
                var templateContainer = bbdesigner$('#template_group_' + chartContainer);
            else
                templateContainer = bbdesigner$("<div></div>").attr('id', "template_group_" + chartContainer);

            templateContainer.css('position', 'relative').css('z-index', 1000);
            var cloneNode = bbdesigner$("#" + series.marker.dataLabel.template).clone();
            bbdesigner$(cloneNode).attr("id", series.marker.dataLabel.template + '_' + seriesIndex + '_' + pointIndex + '_' + chartContainer);
            var bbdesigner$cloneNode = bbdesigner$(cloneNode);
            bbdesigner$cloneNode.css("position", "absolute");
           
            point.count = 1;
            var data = { series: series, point: point };
            bbdesigner$cloneNode.html(bbdesigner$cloneNode.html().parseTemplate(data));

            var display = (areaType == "cartesianaxes" || !series.enableAnimation || (series.type.toLowerCase() == "pyramid" || series.type.toLowerCase() == "funnel")) ? "block" : "none";
            bbdesigner$cloneNode.css("display", display).appendTo(bbdesigner$(templateContainer));
            bbdesigner$(templateContainer).appendTo('#' + chartContainer);
            point.size = { height: bbdesigner$cloneNode.height(), width: bbdesigner$cloneNode.width() };
         
            if (isLeft) {
                if (BoldBIDashboard.util.isNullOrUndefined(series.LeftLabelMaxHeight) || series.LeftLabelMaxHeight < point.size.height) {
                    series.LeftLabelMaxHeight = point.size.height;
                }
                if (BoldBIDashboard.util.isNullOrUndefined(series.LeftLabelMaxWidth) || series.LeftLabelMaxWidth < point.size.width) {
                    series.LeftLabelMaxWidth = point.size.width;
                }
            }
            else {
                if (BoldBIDashboard.util.isNullOrUndefined(series.RightLabelMaxHeight) || series.RightLabelMaxHeight < point.size.height) {
                    series.RightLabelMaxHeight = point.size.height;
                }
                if (BoldBIDashboard.util.isNullOrUndefined(series.RightLabelMaxWidth) || series.RightLabelMaxWidth < point.size.width) {
                    series.RightLabelMaxWidth = point.size.width;
                }
            }
        
    },
    getMinPointsDelta: function (axis, chartObj, start) {
        var chart = chartObj;
        var m_minPointsDelta = Number.MAX_VALUE;
        bbdesigner$.each(chart.model._visibleSeries, function (index, series) {
            if (series.visibility.toLowerCase() == 'visible' && axis.name == series._xAxisName) {
                var xValues = BoldBIDashboard.DataManager(series.points, BoldBIDashboard.Query().sortBy("xValue")).executeLocal();
                if (xValues.length == 1) {
					start = (axis.valueType === 'DateTime' && series.minX === series.maxX) ? (series.minX - 2592000000) : series.minX;
                    var minValue = BoldBIDashboard.util.isNullOrUndefined(start) ? series.xAxis.visibleRange.min : start;
                    var delta = xValues[0].xValue - minValue;
                    if (delta != 0)
                        m_minPointsDelta = Math.min(m_minPointsDelta, delta);
                }
                else {
                    bbdesigner$.each(xValues, function (pointIndex, point) {
                        if (pointIndex > 0 && point.xValue) {
                            var deltaValue = point.xValue - xValues[pointIndex - 1].xValue;
                            if (deltaValue != 0) {
                                m_minPointsDelta = Math.min(m_minPointsDelta, deltaValue);
                            }
                        }
                    });
                }
            }
        });

        if (m_minPointsDelta == Number.MAX_VALUE) {
            m_minPointsDelta = 1;
        }
        return m_minPointsDelta;
    },
    //Calculation for label size
    _getSeriesMaxLabel: function (series) {
        var maxTxtDim = { width: 0, height: 0 };
        var width = bbdesigner$(this.svgObject).width();
        var labels=[];
        if (series.labels.length > 0) {
            for (var j = 0; j < series.labels.length; j++) {
                var dim = this._measureText(series.visibleLabels[j], width, series.marker.dataLabel.font);
                if (maxTxtDim.width < dim.width) {
                    maxTxtDim.width = dim.width;
                }
                if (maxTxtDim.height < dim.height) {
                    maxTxtDim.height = dim.height;
                }
            }
            series.LabelMaxHeight = maxTxtDim.height;
            series.LabelMaxWidth = maxTxtDim.width;
        }
        else {
            labels.push(series.rightsidePoints);
            labels.push(series.leftsidePoints);

            for (var k = 0; k < labels.length; k++) {
                for (var j = 0; j < labels[k].length; j++) {
                    var text = (labels[k][j].text) ? labels[k][j].text : labels[k][j].y;
                    var dim = this._measureText(text, width, series.marker.dataLabel.font);
                    if (maxTxtDim.width < dim.width) {
                        maxTxtDim.width = dim.width;
                    }
                    if (maxTxtDim.height < dim.height) {
                        maxTxtDim.height = dim.height;
                    }
                }
                if (k == 0) {
                    series.RightLabelMaxHeight = maxTxtDim.height;
                    series.RightLabelMaxWidth = maxTxtDim.width;
                }
                else {
                    series.LeftLabelMaxHeight = maxTxtDim.height;
                    series.LeftLabelMaxWidth = maxTxtDim.width;
                }
             }
        }
       

    },
    _getMaxLabelWidth: function (axis, sender) {
        this.chartObj = sender;
        var maxTxtDim = { width: 0, height: 0, maxHeight:0, maxWidth:0 };
        var rotateLabel = '';
        var currentRow = 1;
        var vmlrendering = sender.svgRenderer.vmlNamespace;
        var range = axis.visibleRange;
        var intersectAction = axis.labelIntersectAction ? axis.labelIntersectAction.toLowerCase() : "";
        var labelPlacement = axis.labelPlacement;
        var opposedPosition = axis.opposedPosition;
        var orientation = axis.orientation.toLowerCase();
        var isHorizontal = sender.model.requireInvertedAxes ? (orientation == 'vertical') : orientation == 'horizontal';
        var roundingPlaces = axis.roundingPlaces;
        var labelRotation = axis.labelRotation;
        var orientation = axis.orientation;
        var maxHeight = 0;
        var prevLabels = [];
        var visibleLabels = axis.visibleLabels;
        var visibleLabelsLength =visibleLabels.length;
		var adaptiveRendering = sender.model.adaptiveRendering;
        if (axis.visible) {
                for (var j = 0; j < visibleLabelsLength ; j++) {
                    axis.visibleLabels[j].y = 0;
                    var dim = this._measureText(axis.visibleLabels[j].Text, bbdesigner$(this.svgObject).width(), axis.font, axis.labelRotation);
                    if (maxTxtDim.width < dim.width) {
                        maxTxtDim.width = dim.width;
                        rotateLabel = axis.visibleLabels[j].Text;
                    }
                    if (maxTxtDim.height < dim.height)
                        maxTxtDim.height = dim.height;
                }
			
			if (axis.enableTrim || intersectAction == "trim"){   // for enable trim
			  var derivedGap = axis.enableTrim || intersectAction == "trim" ? axis.maximumLabelWidth : axis.length / axis.visibleLabels.length;
			  maxTxtDim.width = maxTxtDim.width > derivedGap ? derivedGap : maxTxtDim.width;
			}
			
            // initialize rows to 1
            maxTxtDim.rows = 1;
            maxTxtDim.maxWidth = maxTxtDim.width;
            maxTxtDim.maxHeight = maxTxtDim.height;
        
            if (!vmlrendering && (labelRotation ||intersectAction)) {
                var intersectRotation = 0;
                if (intersectAction == 'rotate45')
                    intersectRotation = 45;
                else if (intersectAction == 'rotate90')
                    intersectRotation = 90;
                labelRotation = labelRotation!=null || orientation== "vertical" ? labelRotation : intersectRotation;
                axis.rotationValue = labelRotation;
                if (labelRotation) {                
                    rotateLabel = (!BoldBIDashboard.isNullOrUndefined(rotateLabel)) ? rotateLabel : '';
					labeltextWidth = this._measureText(rotateLabel, bbdesigner$(this.svgObject).width(), axis.font, axis.labelRotation);
					if ((axis.enableTrim || adaptiveRendering || intersectAction == "trim") && labeltextWidth.width > derivedGap && rotateLabel != "") { // to find trimmed text
					  var t, textWidth, text = rotateLabel;
                      for (t = 1; t < text.toString().length; t++) {
                        text = text.toString().substring(0, t) + '... ';
                        textWidth = this._measureText(text, bbdesigner$(sender.svgObject).width(), axis.font);
                        if (textWidth.width >= derivedGap) {
                            text = text.toString().substring(0, t - 1) + '... ';
                            rotateLabel = text;
                            break;
                         }
                      }
                    }
					
                    maxSize = this.rotatedLabel(axis, sender, labelRotation, rotateLabel);
                    if (axis.labelIntersectAction && axis.labelIntersectAction.toLowerCase() == 'multiplerows')
                        maxHeight = maxTxtDim.height + maxSize.height;
                    maxTxtDim.height = maxSize.height;
					maxTxtDim.width = maxSize.width;
                }
            }

                if (axis.labelIntersectAction) {
                    if (intersectAction == 'wrap' || intersectAction == 'wrapbyword') {
                        // pointX calculation to find the gap between the ticks
                        labelPlacement = (!(labelPlacement)) ? BoldBIDashboard.datavisualization.Chart.LabelPlacement.BetweenTicks : labelPlacement;
                        var ticksbwtLabel = ((axis.labels.length > 1) && (labelPlacement.toLowerCase() == "betweenticks")) ? -0.5 : 0;
                        var tempInterval = ((axis.labels.length > 1) && (ticksbwtLabel < 0)) ? (visibleLabelsLength == 1 ? visibleLabels[0].Value : visibleLabels[1].Value) + ticksbwtLabel : (visibleLabelsLength == 1 ? visibleLabels[0].Value : visibleLabels[1].Value);
                        tempInterval = (!(roundingPlaces)) ? parseFloat(tempInterval.toFixed((BoldBIDashboard.EjSvgRender.utils._decimalPlaces(range.interval) == 0 ?
                            1 : BoldBIDashboard.EjSvgRender.utils._decimalPlaces(range.interval)))) : parseFloat(tempInterval.toFixed(roundingPlaces));
                        var pointX = Math.ceil(((tempInterval - range.min) / (range.max - range.min)) * (axis.length));
                        var row = Math.round(maxTxtDim.width / pointX);
                        maxTxtDim.rows = labelRotation ? row - currentRow : row + currentRow;
                        if (maxTxtDim.rows < 0)
                            maxTxtDim.rows = 0;
                        maxTxtDim.height = (maxTxtDim.height + (row) * maxTxtDim.height);
                    }
                    else if (intersectAction == 'multiplerows') {
                        var spaceValue = sender._getLegendSpace();
                        var chartBorderWidth = sender.model.border.width;
                      
                        var verticalaxis = sender.model._axes[1];
                        var realWidth = bbdesigner$(sender.svgObject).width() - sender.model.margin.left - sender.model.margin.right;
                        var axisTitleHeight = (axis.title.text == "" || !(axis.visible)) ? 0 : (this._measureText(axis.title.text, realWidth, axis.title.font).height + (2 * sender.model.elementSpacing));
                        var vAxesWidth = sender.model.elementSpacing + axisTitleHeight + axis.majorTickLines.size + axis.axisLine.width;
                        var yLabels = sender._getYValues(sender.model._visibleSeries[0].points);
                        var largest = Math.max.apply(Math, yLabels);
                        var vaxis = sender.model._axes[1];
                        var dim = this._measureText(largest, bbdesigner$(this.svgObject).width(), vaxis.font, vaxis.labelRotation);
 
                        var rightSpacing = spaceValue.rightLegendWidth + vAxesWidth + dim.width + sender.model.margin.right + sender.model.margin.left + (2 * chartBorderWidth);
                        var boundsWidth = bbdesigner$(sender.svgObject).width() - (rightSpacing);
                        if (isHorizontal) {
                            var addedMaxHeight = 0;
                            //loop to get current label
                            for (j = 0; j < visibleLabels.length; j++) {
                                //declaration
                                var currentLabel = visibleLabels[j];
                                var flag = false;
                                maxHeight = Math.max(maxHeight, addedMaxHeight)
                                addedMaxHeight = currentLabel.y = maxTxtDim.height;
                                var text = this._measureText(currentLabel.Text, bbdesigner$(this.svgObject).width(), axis.font);
                                var textWidth = text.width;
                                var textHeight = text.height;
                                var currentPoint = Math.abs(Math.floor(((currentLabel.Value - range.min) / (range.delta)) * (boundsWidth)));
                                // loop to get previous labels                         
                                for (var k = 0; k < prevLabels.length && !flag; k++) {
                                    for (var l = 0; prevLabels[k] && l < prevLabels[k].length; l++) {
                                        var prevLabel = prevLabels[k][l];
                                        var prevPoint = Math.abs(Math.floor(((prevLabel.Value - range.min) / (range.delta)) * (boundsWidth)));
                                        var preTextWidth = this._measureText(prevLabel.Text, bbdesigner$(this.svgObject).width(), axis.font).width;
                                        var value = prevPoint + preTextWidth / 2;
                                        if (value > currentPoint - textWidth / 2 && !BoldBIDashboard.util.isNullOrUndefined(currentLabel.y)) {
                                            addedMaxHeight = currentLabel.y + textHeight;
                                            currentLabel.y += textHeight;
                                            if (k + 1 == prevLabels.length)
                                            flag = true;
                                        }
                                        else {
                                            if (l + 1 == prevLabels[k].length) {
                                                flag = true;
                                                break;
                                            }
                                        }
                                    }
                                  
                                 }
                                currentLabel.y = addedMaxHeight;
                                row = (addedMaxHeight / textHeight) - 1;
                                if( prevLabels[row]==undefined)
                                prevLabels[row] = [];
                                prevLabels[row].push(currentLabel);
                               
                            }
                            maxHeight = (prevLabels.length * textHeight);
                         //   maxHeight = opposedPosition ? maxHeight + textHeight : maxHeight;
                            maxTxtDim.height = maxTxtDim.height > maxHeight ? maxTxtDim.height : maxHeight;
                            //calculating rows
                            if (opposedPosition)
                                maxTxtDim.rows = Math.round((maxHeight + textHeight) / textHeight);
                            else
                                maxTxtDim.rows = Math.round(maxHeight / textHeight);
                            maxTxtDim.rows = labelRotation ? maxTxtDim.rows - 1 : maxTxtDim.rows ;
                            if (maxTxtDim.rows < 1) maxTxtDim.rows = 1;
                        }
                        if (!isHorizontal) {
                            var addedMaxWidth = 0;
                            //loop to get current label
                            for (j = 0; j < axis.visibleLabels.length; j++) {
                                currentLabel = axis.visibleLabels[j];
                                text = this._measureText(currentLabel.Text, bbdesigner$(this.svgObject).width(), axis.font);
                                textWidth = text.width;
                                textHeight = text.height;
                                currentPoint = Math.abs(Math.floor(((currentLabel.Value - axis.visibleRange.min) / (axis.visibleRange.delta)) * (axis.length)));
                                for (i = 0; i < j; i++) {
                                    // loop to get previous labels
                                    prevLabel = axis.visibleLabels[i];
                                    prevPoint = Math.abs(Math.floor(((prevLabel.Value - axis.visibleRange.min) / (axis.visibleRange.delta)) * (axis.length)));
                                    var prevTextHeight = this._measureText(prevLabel.Text, bbdesigner$(this.svgObject).width(), axis.font).height;
                                    value = prevPoint + prevTextHeight / 2;
                                    if (value > currentPoint - textHeight / 2 && axis.visibleLabels[i].y == currentLabel.y) {
                                        addedMaxWidth = currentLabel.y + textWidth;
                                        currentLabel.y = addedMaxWidth;
                                    }
                                }
                               var maxheight = addedMaxWidth;
                            }
                            // label width + multiple rows width + gap between the rows
                            maxTxtDim.width = maxTxtDim.width + maxheight +5;
                        }
                    }
               }
        }
		if(!BoldBIDashboard.util.isNullOrUndefined(axis.maximumBoundsWidth) && axis.maximumBoundsWidth > maxTxtDim.width)
		   maxTxtDim.maxWidth = maxTxtDim.width = axis.maximumBoundsWidth;
        return maxTxtDim;
    },
	
        rotatedLabel: function (axis, sender, value, rotatedLabel) {
            // to get height of rotated labels
            var rotatedOptions = {
                'font-size': axis.font.size,
                'transform': 'rotate(' + value + ',0,0)',
                'font-family': axis.font.fontFamily,
                'font-style': axis.font.fontStyle,
                'rotateAngle' : 'rotate('+ value +'deg)',
                'text-anchor': 'middle'
            };
            var text = sender.svgRenderer.createText(rotatedOptions, rotatedLabel);
            var height = Math.ceil((this._measureBounds(text, sender).height));
			var width = Math.ceil((this._measureBounds(text, sender).width));
            return {height: height, width: width};
        },
		
    _getTransform: function (xAxis, yAxis, invertedAxis) {
        var x , y , width, height;
        if (invertedAxis) {
            x = yAxis.x;
            y = xAxis.y;
            width = yAxis.width;
            height = xAxis.height;
        } else {
            {
                x = xAxis.x;
                y = yAxis.y;
                width = xAxis.width;
                height = yAxis.height;
            }
        }
        return { x: x, y: y, width: width, height: height };
    },
	browserInfo: function () {
        var browser = {}, clientInfo = [],
        browserClients = {
            webkit: /(chrome)[ \/]([\w.]+)/i, safari: /(webkit)[ \/]([\w.]+)/i, msie: /(msie) ([\w.]+)/i,
            opera: /(opera)(?:.*version|)[ \/]([\w.]+)/i, mozilla: /(mozilla)(?:.*? rv:([\w.]+)|)/i
        };
        for (var client in browserClients) {
            if (browserClients.hasOwnProperty(client)) {
                clientInfo = navigator.userAgent.match(browserClients[client]);
                if (clientInfo) {
                    browser.name = clientInfo[1].toLowerCase();
                    browser.version = clientInfo[2];
                    if (!!navigator.userAgent.match(/Trident\/7\./)) {
                        browser.name = "msie";
                    }
                    break;
                }
            }
        }
        browser.isMSPointerEnabled = (browser.name == 'msie') && browser.version > 9 && window.navigator.msPointerEnabled;
        browser.pointerEnabled = window.navigator.pointerEnabled;
        return browser;
    },
    _measureText: function (text, maxwidth, font, chartContainerID, overLapLegend) {
        var element = bbdesigner$(document).find("#measureTex");
		bbdesigner$("#measureTex").css('display', 'block'); // fixed for scroll issue in sample browser
        if (element.length==0) {
            var textObj = document.createElement('text');
            bbdesigner$(textObj).attr({ 'id': 'measureTex' });
             document.body.appendChild(textObj);			
            // fix for bootstrap default line-height property (Start) (JS-63856)
            //if (chartContainerID) {
            //   var chartContainer = document.getElementById(chartContainerID);
            //    chartContainer.style.lineHeight = 'normal';
            //    chartContainer.appendChild(textObj);
           // } else {
           //     document.body.appendChild(textObj);
           // }
            // fix for bootstrap default line-height property (End)
        }
        else
        {
            var textObj = element[0];
        }
       
        var style = null, size = null, family = null, weight = null;
        if (typeof (text) == "string" && ( text.indexOf("<") > -1 || text.indexOf(">") > -1)) {
                var textArray = text.split(" ");
                for (var i = 0; i < textArray.length; i++) {
                    if (textArray[i].indexOf("<br/>") == -1)
                       textArray[i]=textArray[i].replace(/[<>]/g, '&');                
                     }
                    text=textArray.join(' ');           
         }
        textObj.innerHTML = text;
		
        textObj.style.backgroundColor = 'white';
        textObj.style.position = 'absolute';
        textObj.style.top = -100;
        textObj.style.left = 0;
        textObj.style.visibility = 'hidden';
        textObj.style.whiteSpace = 'nowrap';
        if (font != null) {
            textObj.style.fontSize = (font.size > 0) ? (font.size + "px") : font.size? font.size : size ;
            if (textObj.style.fontStyle) 
     			textObj.style.fontStyle = (font.fontStyle)? font.fontStyle : style;
            // textObj.style.fontFamily = font.fontFamily;
            if(window.navigator.userAgent.indexOf('MSIE 8.0')==-1)
                textObj.style.fontWeight = font.fontWeight ? font.fontWeight : weight;
        }
        if (maxwidth)
            textObj.style.maxwidth = maxwidth + "px";

        var width = 0; var height = 0;
        if (font != undefined && font != null && font.fontFamily != null) {
            for (i = 0; i < font.fontFamily.split(',').length; i++) {
                textObj.style.fontFamily = font.fontFamily.split(',')[i];
                width = width > textObj.offsetWidth ? width : textObj.offsetWidth;
                height = height > textObj.offsetHeight ? height : textObj.offsetHeight;
            }
        }
        textObj.offsetWidth = width;
        textObj.offsetHeight = height;
        if (!overLapLegend) {
            var bounds = { width: width, height: height };
        } else {
            var bounds = { width: textObj.offsetWidth, height: textObj.offsetHeight };
        }
        bbdesigner$("#measureTex").css('display', 'none'); // fixed for scroll issue in sample browser
        return bounds;
    },
	getCumulativePercentage: function (data, property) {
         var sumValue = 0;
         var currentValue = 0;
         var cumulative =  bbdesigner$.extend(true, [], data);;
         for  (var t = 0; t < data.length; t++) {
              sumValue += data[t][property];
         }  
         for  (var i = 0; i < cumulative.length; i++) {
             cumulative[i][property] = ((currentValue += cumulative[i][property]) / sumValue) * 100;
         }   
         return cumulative; 
    }, 
    //to trim legend text
    _trimText: function (legendtext, maxwidth, font) {
        var textWidth, text,textLength;
        text = legendtext.toString();
        textLength=text.length;
        for (var t = 1; t < textLength; t++) {
            text = legendtext.substring(0, t) + '...';
            textWidth = BoldBIDashboard.EjSvgRender.utils._measureText(text, null, font).width;
            if (textWidth >= maxwidth) {
                text = text.substring(0, t - 1) + '... ';
                return text;
            }
        }
        return legendtext;
    },
    _measureBounds: function (element, sender) {
        if (sender.model.enableCanvasRendering) 
             bbdesigner$(document.body).append(element);
         else {
            sender.svgRenderer.append(element, sender.svgObject);
            sender.svgRenderer.append(sender.svgObject, sender.element);
        }
        var box = element.getBoundingClientRect();
        var bounds = { left: box.left, right: box.right, top: box.top, bottom: box.bottom, width: (box.right - box.left), height: (box.bottom - box.top) };
        bbdesigner$(element).remove();
        return bounds;
    },
    //Draw clip path for each series to avoid series overlap in multiple axes zooming
    _drawAxesBoundsClipPath: function (gSeriesGroupEle, options, sender) {
        var clipOptions;
        var element = bbdesigner$(gSeriesGroupEle);
        var trans = this._getTransform(options.xAxis, options.yAxis, sender.model.requireInvertedAxes);
        var width = (sender.model.AreaType == "polaraxes") ? bbdesigner$(sender.svgObject).width() : trans.width;
        var height = (sender.model.AreaType == "polaraxes") ? bbdesigner$(sender.svgObject).height() : trans.height;

        var hPlotOffset = sender.model.requireInvertedAxes ? options.yAxis.plotOffset : options.xAxis.plotOffset;
        var vPlotOffset = sender.model.requireInvertedAxes ? options.xAxis.plotOffset : options.yAxis.plotOffset;
        if (sender.model.AreaType == 'polaraxes') {
            clipOptions = {
                'id': gSeriesGroupEle ? gSeriesGroupEle.id + '_ClipRect' : '',
                'cx': sender.model.centerX,
                'cy': sender.model.centerY,
                'r': sender.model.Radius,
                'fill': 'white',
                'stroke-width': 1,
                'stroke': 'transparent'
            };
            sender.svgRenderer.drawCircularClipPath(clipOptions, gSeriesGroupEle);
        }
        else {
            clipOptions = {
                'id': gSeriesGroupEle ? gSeriesGroupEle.id + '_ClipRect' : '',
                'x': (0 - hPlotOffset),
                'y': (0 - vPlotOffset),
                'width': (width + 2 * hPlotOffset),
                'height': (height + 2 * vPlotOffset),
                'fill': 'white',
                'stroke-width': 1,
                'stroke': 'transparent'
            };
            sender.svgRenderer.drawClipPath(clipOptions, gSeriesGroupEle);
        }
                
        element.attr('clip-path', 'url(#' + clipOptions.id + ')');

    },
    _getStringBuilder: function () {

        var data = [];
        var counter = 0;

        return {
            // adds string s to the stringbuilder

            append: function (s) {
                data[counter++] = s;
                return this;
            },

            // removes j elements starting at i, or 1 if j is omitted

            remove: function (i, j) {
                data.splice(i, j || 1);
                return this;
            },

            // inserts string s at i

            insert: function (i, s) {
                data.splice(i, 0, s);
                return this;
            },

            // builds the string

            toString: function (s) { return data.join(s || ""); }
        };


    },
    _addRegion: function (chart, bounds, series, point, pointIndex) {
	    var type = series.type;
        var seriesIndex = bbdesigner$.inArray(series, chart.model._visibleSeries);
        if (seriesIndex >= 0) {
	        var regionItem = { SeriesIndex: seriesIndex, Region: { PointIndex: pointIndex, Bounds: bounds }, type: type };
	        chart.model.chartRegions.push(regionItem);
	    }
    },

    AddRegion: function (chart, bounds, isStripLine) {
       
        if (isStripLine) {
            var regionItem = { isStripLine: isStripLine, Region: { Bounds: bounds } };
            chart.model.chartRegions.push(regionItem);
        }
    },


    _getSvgXY: function (x, y, series, sender) {
        var svgX, svgY;
        if (!(sender.model.requireInvertedAxes)) {
              svgX = x + series.xAxis.x;
              svgY = y + series.yAxis.y;
        } else {
              svgX = x + series.yAxis.x;
              svgY = y + series.xAxis.y;
        }
        return { X: svgX, Y: svgY };
    },
    _getPoint: function (point, series) {
	  
        var x = point.xValue, low;
        var y = point.YValues[0];
		point.location = {};
		
		if (series._hiloTypes) {
            low = point.YValues[1];
            low = (series.yAxis._valueType == "logarithmic") ? BoldBIDashboard.EjSvgRender.utils._logBase((low == 0 ? 1 : low), series.xAxis.logBase) : low;
            low = this._getPointXY(low, series.yAxis.visibleRange, series.yAxis.isInversed);
            point.location.low = (series._isTransposed ? low : (1 - low)) * (series._isTransposed ? series.yAxis.width : series.yAxis.height);
        }
        var xvalue = (series.xAxis._valueType == "logarithmic") ? BoldBIDashboard.EjSvgRender.utils._logBase((x == 0 ? 1 : x), series.xAxis.logBase) : x;
        var yvalue = (series.yAxis._valueType == "logarithmic") ? BoldBIDashboard.EjSvgRender.utils._logBase((y == 0 ? 1 : y), series.xAxis.logBase) : y;
        if (series._isTransposed)
		 {
            xvalue = (1 - this._getPointXY(xvalue, series.xAxis.visibleRange, series.xAxis.isInversed)) * (series.xAxis.height);
            yvalue = this._getPointXY(yvalue, series.yAxis.visibleRange, series.yAxis.isInversed) * (series.yAxis.width);
            point.location.X = yvalue;
			point.location.Y = xvalue;
            return point.location;
        }
        else
        {
            xvalue =  this._getPointXY(xvalue, series.xAxis.visibleRange, series.xAxis.isInversed) * (series.xAxis.width);
            yvalue = (1-this._getPointXY(yvalue, series.yAxis.visibleRange, series.yAxis.isInversed)) * (series.yAxis.height);
            point.location.X = xvalue;
			point.location.Y = yvalue;
            return point.location;
        }
    },
    _getPointXY: function (value, Range, isInversed) {
         
        var result = 0;
        result = (value - Range.min) / (Range.delta);
		result = isNaN(result) ? 0 : result;
        return (isInversed) ? (1 - result) : result;   
        
    },
    
    _dateTimeLabelFormat: function (intervalType) {
        var format = 'd';
        if (intervalType.toLowerCase() == 'years')
            format = 'MMM, yyyy';
        else if (intervalType.toLowerCase() == 'months')
            format = 'dd, MMM';
        else if (intervalType.toLowerCase() == 'days')
            format = 'MM/dd/yyyy';
        else if (intervalType.toLowerCase() == 'hours')
            format = 'dd, hh:mm';
        else if (intervalType.toLowerCase() == 'seconds' || intervalType.toLowerCase() == 'minutes')
            format = 'hh:mm:ss';
        else if (intervalType.toLowerCase() == 'milliseconds')
            format = 'hh:mm:ss:tt';
        return format;
    },
    _getFontString: function (fontObj) {
        if (fontObj == null)
            fontObj = {};
        if (!fontObj.FontFamily)
            fontObj.FontFamily = "Arial";
        if (!fontObj.FontStyle)
            fontObj.FontStyle = "Normal";
        if (!fontObj.Size)
            fontObj.Size = "12px";

        return fontObj.FontStyle + " " + fontObj.Size + " " + fontObj.FontFamily;
    },

    _valueToVector: function (axis, value) {
        return this._coefficientToVector(this._valueToPolarCoefficient(axis, value));
    },

    TransformToVisible: function (currentseries, x, y, sender) {
        x = (currentseries.xAxis._valueType == "logarithmic") && x > 0 ? Math.log(x, currentseries.xAxis.logBase) : x;
        y = (currentseries.xAxis._valueType == "logarithmic") && y > 0 ? Math.log(y, currentseries.yAxis.logBase) : y;
        var radius = sender.model.Radius * this._valueToCoefficient(currentseries.yAxis, y);
        //var radius = this.chartObj.model.Radius * BoldBIDashboard.EjSvgRender.utils._valueToPolarCoefficient(currentseries.yAxis, y);
        var point = this._valueToVector(currentseries.xAxis, x);
        return { X: sender.model.centerX + radius * point.X, Y: sender.model.centerY + radius * point.Y };
    },

    Transform3DToVisible:function(currentseries, x, y, sender)
    {
      if (currentseries.xAxis != null && currentseries.yAxis != null)
       {
          var valueType = currentseries.xAxis._valueType.toLowerCase();
          var xIsLogarithmic = (valueType == "logarithmic") ? true :false;
          x = x = xIsLogarithmic && x > 0 ? math.log(x, xlogarithmicBase) : x;
          y = y;

       if (sender.model.requireInvertedAxes)
        {
           var left = sender.model.m_AreaBounds.X;
           var top = sender.model.m_AreaBounds.Y;
            var pointX = left + currentseries.yAxis.width * BoldBIDashboard.EjSvgRender.utils._valueToCoefficient(currentseries.yAxis, y, sender);
            var pointY = top + currentseries.xAxis.height * (1 - BoldBIDashboard.EjSvgRender.utils._valueToCoefficient(currentseries.xAxis, x, sender))
           return { X: pointX, Y: pointY }          
        }
        else
        {
            var left = currentseries.xAxis.x;
            var top = currentseries.yAxis.y;
            var x = left + Math.round(currentseries.xAxis.width * BoldBIDashboard.EjSvgRender.utils._valueToCoefficient(currentseries.xAxis, x, sender));
            var y= top + Math.round(currentseries.yAxis.height * (1 - BoldBIDashboard.EjSvgRender.utils._valueToCoefficient(currentseries.yAxis,y, sender)));
            return {X:x, Y:y}
        }
    }
                
    return new Point(0, 0);
  },

    _valueToPolarCoefficient:function(axis, value)
         {
          var start = axis.visibleRange.min;
          var delta;
          var length;
          if (axis._valueType != "category") {
              delta = (axis.visibleRange.max - axis.visibleRange.interval) - axis.visibleRange.min;
              length = axis.visibleLabels.length - 1;
          }
          else {
              delta = axis.visibleRange.delta;
              length = axis.visibleLabels.length;
          }

            result = (value - start) / delta;
            result *= 1 - 1 / (length);
            result = isNaN(result)? 0 : result;

            return axis.isInversed ?  result : 1 - result;
        },

    _coefficientToVector: function (coefficient)
       {
            var angle = Math.PI * (1.5 - 2 * coefficient);

            return  {X:Math.cos(angle), Y: Math.sin(angle)};
      },


    _valueToCoefficient: function (axis, value, sender) {
        if (sender && sender.model.AreaType=='polaraxes') {
            var yvalue = value;
        }
        else
        var yvalue = (axis._valueType && axis._valueType.toLowerCase() == "logarithmic") ?
          BoldBIDashboard.EjSvgRender.utils._logBase((value == 0 ? 1 : value), axis.logBase) : value;

        yvalue = (yvalue - axis.visibleRange.min) / (axis.visibleRange.delta);
        
        return (axis.isInversed) ? 1 - yvalue : yvalue;
    },
    _getBoundingClientRect: function (element, sender,series,invertedAxes) {
        var box = element.getBoundingClientRect();
        var position = bbdesigner$("#" + (sender.svgObject.id))[0].getBoundingClientRect();
        var xSeries, ySeries;
        if (invertedAxes) {
            xSeries = this._getTransform(series.xAxis, series.yAxis, true).x;
            ySeries = this._getTransform(series.xAxis, series.yAxis, true).y;
        } else {
            xSeries = this._getTransform(series.xAxis, series.yAxis, false).x;
            ySeries = this._getTransform(series.xAxis, series.yAxis, false).y;
        }
        var x = box.left - (xSeries + position.left);
        var y = box.top - (ySeries + position.top);
        return { x: x, y: y, width: (box.right - box.left), height: (box.bottom - box.top) };
    },
    _minMax: function (value, min, max) {
        return value > max ? max : (value < min ? min : value);
    },
    _inside: function (value, range) {
        if (value === "")
            return false;
        return (value <= range.max) && (value >= range.min);
    },
    _logBase: function (val, base) {
        return Math.log(val) / Math.log(base);
    },
    _correctRect: function (x1, y1, x2, y2) {
        return { X: Math.min(x1, x2), Y: Math.min(y1, y2), Width: Math.abs(x2 - x1), Height: Math.abs(y2 - y1) };
    },
    _getValuebyPoint: function (x, y, series) {

        var xSize = (this.chartObj.model.requireInvertedAxes) ? series.xAxis.height : series.xAxis.width;
        var ySize = (this.chartObj.model.requireInvertedAxes) ? series.yAxis.width : series.yAxis.height;
      
        var xValue = (series.xAxis.isInversed) ? (1 - (x / xSize)) : (x / xSize);
        var yValue = (series.yAxis.isInversed) ? (1 - (y / ySize)) : (y / ySize);

        xValue = xValue * (series.xAxis.visibleRange.delta) + series.xAxis.visibleRange.min;

        yValue = yValue * (series.yAxis.visibleRange.delta) + series.yAxis.visibleRange.min;

        xValue = (series.xAxis._valueType == "logarithmic") ? Math.pow(series.xAxis.logBase, xValue) : xValue;

        yValue = (series.yAxis._valueType == "logarithmic") ? Math.pow(series.yAxis.logBase, yValue) : yValue;

        return { PointX: xValue, PointY: yValue };

    }
   
};
BoldBIDashboard.EjSvgRender.chartTransform3D = {
      ToRadial: Math.PI / 180,

      transform3D: function (size) {
          if (!this.vector){
          this.vector=new (new BoldBIDashboard.Ej3DRender()).vector3D();
          this.matrixobj = new (new BoldBIDashboard.Ej3DRender()).matrix3D();
          this.bsptreeobj = new (new BoldBIDashboard.Ej3DRender()).BSPTreeBuilder();
          this.polygon = new (new BoldBIDashboard.Ej3DRender()).polygon3D();
          }
        return {
            mViewport: size,
            Rotation: 0,
            Tilt: 0,
            Depth: 0,
            PerspectiveAngle: 0,
            needUpdate:true,
            centeredMatrix: this.matrixobj.getIdentity(),
            Perspective: this.matrixobj.getIdentity(),
            resultMatrix: this.matrixobj.getIdentity(),
            viewMatrix: this.matrixobj.getIdentity(),
            Depth: 0           
          };
     },

    transform: function (trans) {
        this.setCenter(this.vector.vector3D(trans.mViewport.Width / 2, trans.mViewport.Height / 2, trans.Depth / 2), trans);
        this.setViewMatrix(this.matrixobj.transform(0, 0, trans.Depth), trans)
        this.setViewMatrix(this.matrixobj.getMatrixMultiplication(trans.viewMatrix, this.matrixobj.turn(-this.ToRadial * trans.Rotation)), trans);
        this.setViewMatrix(this.matrixobj.getMatrixMultiplication(trans.viewMatrix, this.matrixobj.tilt(-this.ToRadial * trans.Tilt)), trans);
        this.updatePerspective(trans.PerspectiveAngle, trans);
        trans.needUpdate = true;
        
    },

   updatePerspective:function(angle, trans)
    {
       var width = (((trans.mViewport.Width + trans.mViewport.Height) * Math.tan(this.degreeToRadianConverter((180 - Math.abs(angle % 181)) / 2.0))) + (trans.Depth * 2) / 2);
       trans.Perspective[0][0] = width;
       trans.Perspective[1][1] = width;
       trans.Perspective[2][3] = 1;
       trans.Perspective[3][3] = width;
     
   },

   degreeToRadianConverter:function(degree)
   {
           return degree * Math.PI / 180;
   },
   toScreen:function(vector3D, trans)
      {
       vector3D = this.matrixobj.getMatrixVectorMutiple(this.result(trans), vector3D);
       return { x: vector3D.x, y: vector3D.y };
   },

   setViewMatrix: function (value, trans) {
       if (trans.viewMatrix == value) return;
       trans.viewMatrix = value;
       trans.needUpdate = true;
      
   },

   setCenteredMatrix: function (value, trans) {
       if (trans.viewMatrix == value) return;
       trans.centeredMatrix = value;
       trans.needUpdate = true;
       
   },

   result:function(trans) 
     {
       if (!trans.needUpdate) return trans.resultMatrix;
       trans.resultMatrix = this.matrixobj.getMatrixMultiplication(this.matrixobj.getInvertal(trans.centeredMatrix),
                       trans.Perspective);
       trans.resultMatrix = this.matrixobj.getMatrixMultiplication(trans.resultMatrix, trans.viewMatrix);
       trans.resultMatrix = this.matrixobj.getMatrixMultiplication(trans.resultMatrix, trans.centeredMatrix);
       trans.needUpdate = false;

       return trans.resultMatrix;
    },


   setCenter:function(center, trans)
    {
        trans.centeredMatrix = this.matrixobj.transform(-center.x, -center.y, -center.z);
        trans.needUpdate = true;
   },
   toPlane:function(point, plane, trans)
     {
     var vec1 = this.vector.vector3D(point.x, point.y, 0);
     var vec2 = this.vector.vector3DPlus(vec1, vector.vector3D(0, 0, 1));

     vec1 = this.vector.vector3DMultiply(trans.centeredMatrix , vec1);
     vec2 = this.vector.vector3DMultiply(trans.centeredMatrix , vec2);

     vec1 = this.vector.vector3DMultiply(this.matrixobj.getInvertal(trans.Perspective) , vec1);
     vec2 =  this.vector.vector3DMultiply(this.matrixobj.getInvertal(trans.Perspective) , vec2);

     vec1 = this.polygon.getPoint(vec1, this.vector.vector3DMinus(vec2 - vec1));

     vec1 = this.vector.vector3DMultiply(this.matrixobj.getInvertal(trans.viewMatrix), vec1);
     vec1 =  this.vector.vector3DMultiply(this.matrixobj.getInvertal(trans.centeredMatrix), vec1);

     return vec1;
    }

};
BoldBIDashboard.EjSvgRender.chartSymbol =
{
    _drawSeriesType: function (location, symbolStyle, sender) {
        var seriesType = sender.model.series[symbolStyle.SeriesIndex].type.toLowerCase();
        var trendlinetype = sender.legendItem.drawType;
        seriesType = BoldBIDashboard.util.isNullOrUndefined(trendlinetype) ? seriesType : trendlinetype;
        switch (seriesType) {
            case BoldBIDashboard.datavisualization.Chart.Type.Line: {
                var line;
                if(BoldBIDashboard.util.isNullOrUndefined(trendlinetype))
                     line = this._drawLine(location, symbolStyle, sender, sender.gLegendItemEle);
                else
                    line = this._drawStraightLine(location, symbolStyle, sender, sender.gLegendItemEle);
                return line;
            }
                
            case BoldBIDashboard.datavisualization.Chart.Type.StepLine:
                return this._drawStepLine(location, symbolStyle, sender, sender.gLegendItemEle);
                 
            case BoldBIDashboard.datavisualization.Chart.Type.StackingArea:
            case BoldBIDashboard.datavisualization.Chart.Type.StackingArea100:
            case BoldBIDashboard.datavisualization.Chart.Type.Area:
            case BoldBIDashboard.datavisualization.Chart.Type.RangeArea:
                return this._drawArea(location, symbolStyle, sender, sender.gLegendItemEle);
                 
            case BoldBIDashboard.datavisualization.Chart.Type.StepArea:
                return this._drawStepArea(location, symbolStyle, sender, sender.gLegendItemEle);
                 
            case BoldBIDashboard.datavisualization.Chart.Type.Bar:
            case BoldBIDashboard.datavisualization.Chart.Type.StackingBar100:
            case BoldBIDashboard.datavisualization.Chart.Type.StackingBar:
                return this._drawBar(location, symbolStyle, sender, sender.gLegendItemEle);
                
            case BoldBIDashboard.datavisualization.Chart.Type.Pie:
                return this._drawPie(location, symbolStyle, sender, sender.gLegendItemEle);
                
            case BoldBIDashboard.datavisualization.Chart.Type.Doughnut:
                return this._drawDoughnut(location, symbolStyle, sender, sender.gLegendItemEle);

            case BoldBIDashboard.datavisualization.Chart.Type.Hilo:
                return this._drawHilo(location, symbolStyle, sender, sender.gLegendItemEle);

            case BoldBIDashboard.datavisualization.Chart.Type.HiloOpenClose:
                return this._drawHiloOpenClose(location, symbolStyle, sender, sender.gLegendItemEle);

            case BoldBIDashboard.datavisualization.Chart.Type.Candle:
                return this._drawCandle(location, symbolStyle, sender, sender.gLegendItemEle);

            case BoldBIDashboard.datavisualization.Chart.Type.Pyramid:
                return this._drawPyramid(location, symbolStyle, sender, sender.gLegendItemEle);

            case BoldBIDashboard.datavisualization.Chart.Type.Funnel:
                return this._drawFunnel(location, symbolStyle, sender, sender.gLegendItemEle);

            case BoldBIDashboard.datavisualization.Chart.Type.Spline:
                return this._drawSpline(location, symbolStyle, sender, sender.gLegendItemEle);

            case BoldBIDashboard.datavisualization.Chart.Type.SplineArea:
                return this._drawSplineArea(location, symbolStyle, sender, sender.gLegendItemEle);

            case BoldBIDashboard.datavisualization.Chart.Type.RangeColumn:
                return this._drawRangeColumn(location, symbolStyle, sender, sender.gLegendItemEle);

            case BoldBIDashboard.datavisualization.Chart.Type.Bubble:
            case BoldBIDashboard.datavisualization.Chart.Type.Scatter:
                return this._drawCircle(location, symbolStyle, sender, sender.gLegendItemEle);

            case BoldBIDashboard.datavisualization.Chart.Type.Column:
            case BoldBIDashboard.datavisualization.Chart.Type.StackingColumn:
            case BoldBIDashboard.datavisualization.Chart.Type.StackingColumn100:
			case BoldBIDashboard.datavisualization.Chart.Type.Waterfall:
                return this._drawColumn(location, symbolStyle, sender, sender.gLegendItemEle);
                
            default:
                return this._drawRectangle(location, symbolStyle, sender, sender.gLegendItemEle);
                 
        }

    },

    _drawCircle: function (location, symbolStyle, sender, element) {
        var svgRender = sender.svgRenderer, svgObj = sender.svgObject, style = symbolStyle.ShapeSize,
        radius = Math.sqrt(style.height * style.height + style.width * style.width) / 2,
        symbolstyleStyle=symbolStyle.Style;
     		
        var options = {
            'id': symbolStyle.ID,
            'cx': location.startX,
            'cy': location.startY,
            'r': radius,
            'fill': symbolstyleStyle.Color,
            'stroke-width': symbolstyleStyle.BorderWidth,
            'stroke': symbolstyleStyle.BorderColor,
            'opacity': symbolstyleStyle.Opacity,
            'visibility': symbolstyleStyle.Visibility,
            'lgndCtx': symbolStyle.context
        };

        svgRender.drawCircle(options, element);

        return (location.startX - radius);
    },

    _drawLeftArrow: function (location, symbolStyle, sender, element) {
        var svgRender = sender.svgRenderer;
        var svgObj = sender.svgObject;
        var style = symbolStyle.ShapeSize;
        var path;
        path = "M" + " " + ((location.startX - (style.width / 2)) + style.width) + " " + (location.startY + (style.height / 4)) + " " + "L" + " " + ((location.startX - (style.width / 2)) + style.width) + " " + (location.startY + (-style.height / 4)) + " " + "L" + " " + ((location.startX - (style.width / 2)) + (style.width / 2)) + " " + (location.startY + (-style.height / 4)) + " " + "L" + " " + ((location.startX - (style.width / 2)) + (style.width / 2)) + " " + (location.startY + (-style.height / 2)) + " " + "L" + " " + ((location.startX - (style.width / 2))) + " " + (location.startY) + " " + "L" + " " + ((location.startX - (style.width / 2)) + (style.width / 2)) + " " + (location.startY + (style.height / 2)) + " " + "L" + " " + ((location.startX - (style.width / 2)) + (style.width / 2)) + " " + (location.startY + (style.height / 4)) + " " + "L" + " " + ((location.startX - (style.width / 2)) + style.width) + " " + (location.startY + (style.height / 4)) + " z";
        var options = {
            'id': symbolStyle.ID,
            'fill': symbolStyle.Style.Color,
            'stroke-width': symbolStyle.Style.BorderWidth,
            'stroke': symbolStyle.Style.BorderColor,
            'opacity': symbolStyle.Style.Opacity,
            'visibility':symbolStyle.Style.Visibility,
            'lgndCtx': symbolStyle.context,
            'd': path
        };

        svgRender.drawPath(options, element);

    },


    _drawRightArrow: function (location, symbolStyle, sender, element) {
        var svgRender = sender.svgRenderer;
        var svgObj = sender.svgObject;
        var style = symbolStyle.ShapeSize;
        var path;
        path = "M" + " " + ((location.startX - (style.width / 2))) + " " + (location.startY + (style.height / 4)) + " " + "L" + " " + ((location.startX - (style.width / 2))) + " " + (location.startY + (-style.height / 4)) + " " + "L" + " " + ((location.startX - (style.width / 2)) + (style.width / 2)) + " " + (location.startY + (-style.height / 4)) + " " + "L" + " " + ((location.startX - (style.width / 2)) + (style.width / 2)) + " " + (location.startY + (-style.height / 2)) + " " + "L" + " " + ((location.startX - (style.width / 2)) + style.width) + " " + (location.startY) + " " + "L" + " " + ((location.startX - (style.width / 2)) + (style.width / 2)) + " " + (location.startY + (style.height / 2)) + " " + "L" + " " + ((location.startX - (style.width / 2)) + (style.width / 2)) + " " + (location.startY + (style.height / 4)) + " " + "L" + " " + ((location.startX - (style.width / 2))) + " " + (location.startY + (style.height / 4)) + " z";       
        var options = {
            'id': symbolStyle.ID,
            'fill': symbolStyle.Style.Color,
            'stroke-width': symbolStyle.Style.BorderWidth,
            'stroke': symbolStyle.Style.BorderColor,
            'opacity': symbolStyle.Style.Opacity,
            'visibility':symbolStyle.Style.Visibility,
            'lgndCtx': symbolStyle.context,
            'd': path
        };


        svgRender.drawPath(options, element);


    },


    _drawUpArrow: function (location, symbolStyle, sender, element) {
        var svgRender = sender.svgRenderer;
        var svgObj = sender.svgObject;
        var style = symbolStyle.ShapeSize;
        var path;
        path = "M" + " " + ((location.startX - (style.width / 2) + (style.width / 4))) + " " + (location.startY - (style.height / 2) + (style.height)) + " " + "L" + " " + ((location.startX - (style.width / 2) + (style.width / 4))) + " " + (location.startY - (style.height / 2) + (style.height / 2)) + " " + "L" + " " + ((location.startX - (style.width / 2))) + " " + (location.startY - (style.height / 2) + (style.height / 2)) + " " + "L" + " " + ((location.startX)) + " " + (location.startY - (style.height / 2)) + " " + "L" + " " + ((location.startX + (style.width / 2))) + " " + (location.startY - (style.height / 2) + (style.height / 2)) + " " + "L" + " " + ((location.startX + (style.width / 2) - (style.width / 4))) + " " + (location.startY - (style.height / 2) + (style.height / 2)) + " " + "L" + " " + ((location.startX + (style.width / 2) - (style.width / 4))) + " " + (location.startY - (style.height / 2) + (style.height)) + " " + "L" + " " + ((location.startX - (style.width / 2) + (style.width / 4))) + " " + (location.startY - (style.height / 2) + (style.height)) + " z";
        var options = {
            'id': symbolStyle.ID,
            'fill': symbolStyle.Style.Color,
            'stroke-width': symbolStyle.Style.BorderWidth,
            'stroke': symbolStyle.Style.BorderColor,
            'opacity': symbolStyle.Style.Opacity,
            'visibility': symbolStyle.Style.Visibility,
            'lgndCtx': symbolStyle.context,
            'd': path
        };


        svgRender.drawPath(options, element);


    },

    _drawDownArrow: function (location, symbolStyle, sender, element) {
        var svgRender = sender.svgRenderer;
        var svgObj = sender.svgObject;
        var style = symbolStyle.ShapeSize;
        var path;
        path = "M" + " " + ((location.startX - (style.width / 2) + (style.width / 4))) + " " + (location.startY - (style.height / 2)) + " " + "L" + " " + ((location.startX + (style.width / 2) - (style.width / 4))) + " " + (location.startY - (style.height / 2)) + " " + "L" + " " + ((location.startX + (style.width / 2) - (style.width / 4))) + " " + (location.startY - (style.height / 2) + (style.height / 2)) + " " + "L" + " " + ((location.startX + (style.width / 2))) + " " + (location.startY - (style.height / 2) + (style.height / 2)) + " " + "L" + " " + ((location.startX)) + " " + (location.startY - (style.height / 2) + (style.height)) + " " + "L" + " " + ((location.startX - (style.width / 2))) + " " + (location.startY - (style.height / 2) + (style.height / 2)) + " " + "L" + " " + ((location.startX - (style.width / 2) + (style.width / 4))) + " " + (location.startY - (style.height / 2) + (style.height / 2)) + " " + "L" + " " + ((location.startX - (style.width / 2) + (style.width / 4))) + " " + (location.startY - (style.height / 2)) + " z";
        var options = {
            'id': symbolStyle.ID,
            'fill': symbolStyle.Style.Color,
            'stroke-width': symbolStyle.Style.BorderWidth,
            'stroke': symbolStyle.Style.BorderColor,
            'opacity': symbolStyle.Style.Opacity,
            'visibility': symbolStyle.Style.Visibility,
            'lgndCtx': symbolStyle.context,
            'd': path
        };


        svgRender.drawPath(options, element);

    },

    _drawCross: function (location, symbolStyle, sender, element) {
        var svgRender = sender.svgRenderer;
        var svgObj = sender.svgObject;
        var style = symbolStyle.ShapeSize;

        var path;
        path = "M" + " " + (location.startX + (-style.width / 2)) + " " + (location.startY) + " " + "L" + " "+ (location.startX + (style.width / 2)) + " " + (location.startY) + " " +
        "M" + " " + (location.startX) + " " + (location.startY + (style.height / 2)) + " " + "L" + " " + (location.startX) + " " + (location.startY + (-style.height / 2));
        var options = {
            'id': symbolStyle.ID,
            'opacity': symbolStyle.Style.Opacity,
            'stroke-width': symbolStyle.Style.BorderWidth,
            'stroke': symbolStyle.Style.Color,
            'visibility': symbolStyle.Style.Visibility,
            'lgndCtx': symbolStyle.context,
            'd': path
        };

        svgRender.drawPath(options, element);

    },

    _drawHorizLine: function (location, symbolStyle, sender, element) {
        var svgRender = sender.svgRenderer;
        var svgObj = sender.svgObject;
        var style = symbolStyle.ShapeSize;

        var path;
        path = "M" + " " + (location.startX + (-style.width / 2)) + " " + (location.startY) + " " + "L" + " " + (location.startX + (style.width / 2)) + " " + (location.startY);
        var options = {
            'id': symbolStyle.ID,
            'opacity': symbolStyle.Style.Opacity,
            'stroke-width': symbolStyle.Style.BorderWidth,
            'stroke': symbolStyle.Style.Color,
            'visibility': symbolStyle.Style.Visibility,
            'lgndCtx': symbolStyle.context,
            'd': path
        };

        svgRender.drawPath(options, element);


    },
    _drawVertLine: function (location, symbolStyle, sender, element) {
        var svgRender = sender.svgRenderer;
        var svgObj = sender.svgObject;
        var style = symbolStyle.ShapeSize;
        var path;
        path = "M" + " " + (location.startX) + " " + (location.startY + (style.height / 2)) + " " + "L" + " " + (location.startX) + " " + (location.startY + (-style.height / 2));
        var options = {
            'id': symbolStyle.ID,
            'opacity': symbolStyle.Style.Opacity,
            'stroke-width': symbolStyle.Style.BorderWidth,
            'stroke': symbolStyle.Style.Color,
            'visibility': symbolStyle.Style.Visibility,
            'lgndCtx': symbolStyle.context,
            'd': path
        };


        svgRender.drawPath(options, element);

    },

    _drawTriangle: function (location, symbolStyle, sender, element) {
        var svgRender = sender.svgRenderer;
        var svgObj = sender.svgObject;
        var style = symbolStyle.ShapeSize;
        var legend = sender.model.legend;
        var path;
        if (legend.mode == "range" && !legend.enableMultiRange && (legend.position == "right" || legend.position == "left")) {
            path = "M" + " " + (location.startX) + " " + (location.startY) + " " +
            "L" + " " + (location.startX + (style.width / 2)) + " " + (location.startY + (-style.height / 2)) + " " +
            "L" + " " + (location.startX + (style.width / 2)) + " " + (location.startY + (style.height / 2)) + " " +
            "L" + " " + (location.startX) + " " + (location.startY) + " z";
        }
        else{
        path = "M" + " " + (location.startX + (-style.width / 2)) + " " + (location.startY + (style.height / 2)) + " " +
            "L" + " " + (location.startX) + " " + (location.startY + (-style.height / 2)) + " " +
            "L" + " " + (location.startX + (style.width / 2)) + " " + (location.startY + (style.height / 2)) + " " +
            "L" + " " + (location.startX + (-style.width / 2)) + " " + (location.startY + (style.height / 2)) + " z";
        }



        var options = {
            'id': symbolStyle.ID,
            'fill': symbolStyle.Style.Color,
            'stroke-width': symbolStyle.Style.BorderWidth,
            'stroke': symbolStyle.Style.BorderColor,
            'opacity': symbolStyle.Style.Opacity,
            'visibility': symbolStyle.Style.Visibility,
            'lgndCtx': symbolStyle.context,
            'd': path
        };

        svgRender.drawPath(options, element);

    },

    _drawInvertedTriangle: function (location, symbolStyle, sender, element) {
        var svgRender = sender.svgRenderer;
        var svgObj = sender.svgObject;
        var style = symbolStyle.ShapeSize;

        var path;
         path = "M" + " " + (location.startX + (style.width / 2)) + " " + (location.startY - (style.height / 2)) + " "
             + "L" + " " + (location.startX) + " " + (location.startY + (style.height / 2)) + " "
             + "L" + " " + (location.startX - (style.width / 2)) + " " + (location.startY - (style.height / 2)) + " "
             + "L" + " " + (location.startX + (style.width / 2)) + " " + (location.startY - (style.height / 2)) + " z";
        var x = location.startX;
        var y = location.startY;
        var options = {
            'id': symbolStyle.ID,
            'fill': symbolStyle.Style.Color,
            'stroke-width': symbolStyle.Style.BorderWidth,
            'stroke': symbolStyle.Style.BorderColor,
            'opacity': symbolStyle.Style.Opacity,
            'visibility': symbolStyle.Style.Visibility,
            'lgndCtx': symbolStyle.context,
            'd': path
        };

        svgRender.drawPath(options, element);


    },

    _drawHexagon: function (location, symbolStyle, sender, element) {
        var svgRender = sender.svgRenderer;
        var svgObj = sender.svgObject;
        var style = symbolStyle.ShapeSize;

        var path;
        path = "M" + " " + (location.startX + (-style.width / 2)) + " " + (location.startY) + " " + "L" + " " + (location.startX + (-style.width / 4)) + " " + (location.startY + (-style.height / 2)) + " " + "L" + " " + (location.startX + (style.width / 4)) + " " + (location.startY + (-style.height / 2)) + " " + "L" + " " + (location.startX + (style.width / 2)) + " " + (location.startY) + " " + "L" + " " + (location.startX + (style.width / 4)) + " " + (location.startY + (style.height / 2)) + " " + "L" + " " + (location.startX + (-style.width / 4)) + " " + (location.startY + (style.height / 2)) + " " + "L" + " " + (location.startX + (-style.width / 2)) + " " + (location.startY) + " z";
        var options = {
            'id': symbolStyle.ID,
            'fill': symbolStyle.Style.Color,
            'stroke-width': symbolStyle.Style.BorderWidth,
            'stroke': symbolStyle.Style.BorderColor,
            'opacity': symbolStyle.Style.Opacity,
            'visibility': symbolStyle.Style.Visibility,
            'lgndCtx': symbolStyle.context,
            'd': path
        };

        svgRender.drawPath(options, element);

    },

    _drawWedge: function (location, symbolStyle, sender, element) {
        var svgRender = sender.svgRenderer;
        var svgObj = sender.svgObject;
        var style = symbolStyle.ShapeSize;

        var path;
        path = "M" + " " + (location.startX - style.width) + " " + (location.startY) + " " + "L" + " " + (location.startX + style.width) + " " + (location.startY + (-style.height / 2)) + " " + "L" + " " + (location.startX + (3 * (style.width / 4))) + " " + (location.startY) + " " + "L" + " " + (location.startX + (style.width)) + " " + (location.startY + (style.height / 2)) + " " + "L" + " " + (location.startX - style.width) + " " + (location.startY) + " z";
        var options = {
            'id': symbolStyle.ID,
            'fill': symbolStyle.Style.Color,
            'stroke-width': symbolStyle.Style.BorderWidth,
            'stroke': symbolStyle.Style.BorderColor,
            'opacity': symbolStyle.Style.Opacity,
            'visibility': symbolStyle.Style.Visibility,
            'lgndCtx': symbolStyle.context,
            'd': path
        };

        svgRender.drawPath(options, element);

    },

    _drawPentagon: function (location, symbolStyle, sender, element) {
        var svgRender = sender.svgRenderer;
        var svgObj = sender.svgObject;
        var style = symbolStyle.ShapeSize;

        var eq = 72;
        var radius = Math.sqrt(style.height * style.height + style.width * style.width) / 2;
        var sb = BoldBIDashboard.EjSvgRender.utils._getStringBuilder();
        for (var i = 0; i <= 5; i++) {
            var deg = i * eq;
            var rad = (Math.PI / 180) * deg;
            var x1 = radius * Math.cos(rad);
            var y1 = radius * Math.sin(rad);
            if (i == 0)
                sb.append("M" + " " + (location.startX + x1) + " " + (location.startY + y1) + " ");

            else
                sb.append("L" + " " + (location.startX + x1) + " " + (location.startY + y1) + " ");


        }
        sb.append("z");
        var path = sb.toString();
        var options = {
            'id': symbolStyle.ID,
            'fill': symbolStyle.Style.Color,
            'stroke-width': symbolStyle.Style.BorderWidth,
            'stroke': symbolStyle.Style.BorderColor,
            'opacity': symbolStyle.Style.Opacity,
            'visibility': symbolStyle.Style.Visibility,
            'lgndCtx': symbolStyle.context,
            'd': path
        };

        svgRender.drawPath(options, element);


    },

    _drawStar: function (location, symbolStyle, sender, element) {
        var svgRender = sender.svgRenderer;
        var style = symbolStyle.ShapeSize;
        var svgObj = sender.svgObject;

        var path;
        path = "M" + " " + (location.startX + (style.width / 3)) + " " + (location.startY + (-style.height / 2)) + " " + "L" + " " + (location.startX + (-style.width / 2)) + " " + (location.startY + (style.height / 6)) + " " + "L" + " " + (location.startX + (style.width / 2)) + " " + (location.startY + (style.height / 6)) + " " + "L" + " " + (location.startX + (-style.width / 3)) + " " + (location.startY + (-style.height / 2)) + " " + "L" + " " + (location.startX) + " " + (location.startY + (style.height / 2)) + " " + "L" + " " + (location.startX + (style.width / 3)) + " " + (location.startY + (-style.height / 2)) + " z";
        var options = {
            'id': symbolStyle.ID,
            'fill': symbolStyle.Style.Color,
            'stroke-width': symbolStyle.Style.BorderWidth,
            'stroke': symbolStyle.Style.BorderColor,
            'opacity': symbolStyle.Style.Opacity,
            'visibility': symbolStyle.Style.Visibility,
            'lgndCtx': symbolStyle.context,
            'd': path
        };

        svgRender.drawPath(options, element);


    },

    _drawRectangle: function (location, symbolStyle, sender, element) {
        var svgRender = sender.svgRenderer;
        var svgObj = sender.svgObject;
        var style = symbolStyle.ShapeSize;

        var path;
        path = "M" + " " + (location.startX + (-style.width / 2)) + " " + (location.startY + (-style.height / 2)) + " " + "L" + " " + (location.startX + (style.width / 2)) + " " + (location.startY + (-style.height / 2)) + " " + "L" + " " + (location.startX + (style.width / 2)) + " " + (location.startY + (style.height / 2)) + " " + "L" + " " + (location.startX + (-style.width / 2)) + " " + (location.startY + (style.height / 2)) + " " + "L" + " " + (location.startX + (-style.width / 2)) + " " + (location.startY + (-style.height / 2))+ " z";
        var options = {
            'id': symbolStyle.ID,
            'fill': symbolStyle.Style.Color,
            'stroke-width': symbolStyle.Style.BorderWidth,
            'stroke': symbolStyle.Style.BorderColor,
            'opacity': symbolStyle.Style.Opacity,
            'visibility': symbolStyle.Style.Visibility,
            'lgndCtx': symbolStyle.context,
            'd': path
        };

        svgRender.drawPath(options, element);
    },

    _drawTrapezoid: function (location, symbolStyle, sender, element) {
        var svgRender = sender.svgRenderer;
        var svgObj = sender.svgObject;
        var style = symbolStyle.ShapeSize;

        var path;
        path = "M" + " " + (location.startX + (-style.width / 2)) + " " + (location.startY) + " " + "L" + " " + (location.startX + (-style.width / 2)) + " " + (location.startY + (-style.height / 4)) + " " + "L" + " " + (location.startX + (-style.width / 2) + (style.width)) + " " + (location.startY + (-style.height / 2)) + " " + "L" + " " + (location.startX + (-style.width / 2) + (style.width)) + " " + (location.startY + (style.height / 2)) + " " + "L" + " " + (location.startX + (-style.width / 2)) + " " + (location.startY + (style.height / 4)) + " " + "L" + " " + (location.startX + (-style.width / 2)) + " " + (location.startY) + " z";
        var options = {
            'id': symbolStyle.ID,
            'fill': symbolStyle.Style.Color,
            'stroke-width': symbolStyle.Style.BorderWidth,
            'stroke': symbolStyle.Style.BorderColor,
            'opacity': symbolStyle.Style.Opacity,
            'visibility': symbolStyle.Style.Visibility,
            'lgndCtx': symbolStyle.context,
            'd': path
        };

        svgRender.drawPath(options, element);

    },

    _drawDiamond: function (location, symbolStyle, sender, element) {
        var svgRender = sender.svgRenderer;
        var svgObj = sender.svgObject;
        var style = symbolStyle.ShapeSize;

        var path;
        path = "M" + " " + (location.startX + (-style.width / 2)) + " " + (location.startY) + " " + "L" + " " + (location.startX) + " " + (location.startY + (-style.height / 2)) + " " + "L" + " " + (location.startX + (style.width / 2)) + " " + (location.startY) + " " + "L" + " " + (location.startX) + " " + (location.startY + (style.height / 2)) + " " + "L" + " " + (location.startX + (-style.width / 2)) + " " + (location.startY) + " z";

        var options = {
            'id': symbolStyle.ID,
            'fill': symbolStyle.Style.Color,
            'stroke-width': symbolStyle.Style.BorderWidth,
            'stroke': symbolStyle.Style.BorderColor,
            'opacity': symbolStyle.Style.Opacity,
            'visibility': symbolStyle.Style.Visibility,
            'lgndCtx': symbolStyle.context,
            'd': path
        };

        svgRender.drawPath(options, element);


    },
    _drawEllipse: function (location, symbolStyle, sender, element) {
        var svgRender = sender.svgRenderer;
        var svgObj = sender.svgObject;
        var style = symbolStyle.ShapeSize;

        var x = location.startX;
        var y = location.startY;
        var options = {
            'id': symbolStyle.ID,
            'fill': symbolStyle.Style.Color,
            'stroke-width': symbolStyle.Style.BorderWidth,
            'stroke': symbolStyle.Style.BorderColor,
            'opacity': symbolStyle.Style.Opacity,
            'visibility': symbolStyle.Style.Visibility,
            'lgndCtx': symbolStyle.context,
            'cx': x,
            'cy': y,
            'rx': style.width,
            'ry': style.height / 2
        };


        svgRender.drawEllipse(options, element);


    },
    _drawImage: function (location, symbolStyle, sender, element) {
        var svgRender = sender.svgRenderer;
        var svgObj = sender.svgObject;
        var style = symbolStyle.ShapeSize;
        var x = location.startX + (-style.width / 2);
        var y = location.startY + (-style.width / 2);
        var width = style.width;
        var height = style.height;
        var options = { 'id': svgObj.id + '_image' + symbolStyle.PointIndex, 'height': height, 'width': width, 'href': symbolStyle.Imageurl,
            'x': x, 'y': y, 'visibility': 'visible', 'lgndCtx': symbolStyle.context
        };

        svgRender.drawImage(options, element);


    },
	
	 _drawStraightLine: function (location, symbolStyle, sender, element) {
        var svgRender = sender.svgRenderer;
        var svgObj = sender.svgObject;
        var style = symbolStyle.ShapeSize;
        var elementspace = symbolStyle.ElementSpace;
        var path;

        path = "M" + " " + (location.startX + (-style.width / 2) + (-elementspace / 4)) + " " + (location.startY + (style.height / 10)) + " " +
                "L" + " " + (location.startX + (style.width / 2) + (elementspace / 4)) + " " + (location.startY + (style.height / 10));
        var options = {
            'id': symbolStyle.ID,
            'fill': symbolStyle.Style.Color,
            'stroke-width': symbolStyle.Style.BorderWidth * 2,
            'stroke': symbolStyle.Style.Color,
            'opacity': symbolStyle.Style.Opacity,
            'visibility': symbolStyle.Style.Visibility,
            'd': path,
            'lgndCtx': true
        };
        svgRender.drawPath(options, element);
        return (location.startX + (-style.width / 2) + (-elementspace / 4));
    },
	
    _drawLine: function (location, symbolStyle, sender, element) {
        var svgRender = sender.svgRenderer;
        var svgObj = sender.svgObject;
        var style = symbolStyle.ShapeSize;
        var elementspace = symbolStyle.ElementSpace;
        var path;        
       
        if (sender.model.enableCanvasRendering === true) {
            path = "M" + " " + (location.startX + (-style.width / 2) + (-elementspace / 4)) + " " + (location.startY + (style.height / 10)) + " " + "L" + " " + (location.startX - Math.floor(style.width / 3)) + " " + (location.startY + (style.height / 10)) + " " + "M" + " " + (location.startX + Math.floor(style.width / 3)) + " " + (location.startY + (style.height / 10)) + " " + "L" + " " + (location.startX + (style.width / 2) + (elementspace / 4)) + " " + (location.startY + (style.height / 10));
            var options = {
                'id': symbolStyle.ID,
                'fill': symbolStyle.Style.Color,
                'stroke-width': symbolStyle.Style.BorderWidth * 2,
                'stroke': symbolStyle.Style.Color,
                'opacity': symbolStyle.Style.Opacity,
                'visibility': symbolStyle.Style.Visibility,
                'd': path,
                'lgndCtx': true
            };
            var circlepath = "M" + " " + (location.startX - Math.floor(style.width / 3)) + " " + (location.startY + (style.height / 10)) + " " + "a " + (Math.floor(style.width / 3)) + " " + (Math.floor(style.width / 3)) + " " + 0 + " " + 1 + " " + 0 + " " + 2 * (Math.floor(style.width / 3)) + " " + 0 + " " + "a" + (Math.floor(style.width / 3)) + " " + (Math.floor(style.width / 3)) + " " + 0 + " " + 1 + " " + 0 + " " + (-2 * (Math.floor(style.width / 3))) + " " + 0;
            var circleoptions = {
                'id': symbolStyle.ID,
                'fill': "transparent",
                'stroke-width': symbolStyle.Style.BorderWidth * 2,
                'stroke': symbolStyle.Style.Color,
                'opacity': symbolStyle.Style.Opacity,
                'visibility': symbolStyle.Style.Visibility,
                'd': circlepath,
                'lgndCtx': true
            };

            svgRender.drawPath(options, element);
            svgRender.drawPath(circleoptions, element);
        }
        else {
            path = "M" + " " + (location.startX + (-style.width / 2) + (-elementspace / 4)) + " " + (location.startY + (style.height / 10)) + " " + "L" + " " + (location.startX - Math.floor(style.width / 3)) + " " + (location.startY + (style.height / 10)) + " " + "M" + " " + (location.startX + Math.floor(style.width / 3)) + " " + (location.startY + (style.height / 10)) + " " + "L" + " " + (location.startX + (style.width / 2) + (elementspace / 4)) + " " + (location.startY + (style.height / 10)) + " " + "M" + " " + (location.startX - Math.floor(style.width / 3)) + " " + (location.startY + (style.height / 10)) + " " + "a " + (Math.floor(style.width / 3)) + " " + (Math.floor(style.width / 3)) + " " + 0 + " " + 1 + " " + 0 + " " + 2 * (Math.floor(style.width / 3)) + " " + 0 + " " + "a" + (Math.floor(style.width / 3)) + " " + (Math.floor(style.width / 3)) + " " + 0 + " " + 1 + " " + 0 + " " + (-2 * (Math.floor(style.width / 3))) + " " + 0;
            var options = {
                'id': symbolStyle.ID,
                'fill': "transparent",
                'stroke-width': symbolStyle.Style.BorderWidth * 2,
                'stroke': symbolStyle.Style.Color,
                'opacity': symbolStyle.Style.Opacity,
                'visibility': symbolStyle.Style.Visibility,
                'd': path,
                'lgndCtx': true
            };
            svgRender.drawPath(options, element);
        }
        return (location.startX + (-style.width / 2) + (-elementspace / 4));

    },
    _drawColumn: function (location, symbolStyle, sender, element) {
        var svgRender = sender.svgRenderer;
        var svgObj = sender.svgObject;
        var style = symbolStyle.ShapeSize;
        var elementspace = symbolStyle.ElementSpace;
        var path;       
         path = "M" + " " + (location.startX - 3 * (style.width / 5)) + " " + (location.startY - (style.height / 5)) + " " + "L" + " " + (location.startX + 3 * (-style.width / 10)) + " " + (location.startY - (style.height / 5)) + " " + "L" + " " + (location.startX + 3 * (-style.width / 10)) + " " + (location.startY + (style.height / 2)) + " " + "L" + " " + (location.startX - 3 * (style.height / 5)) + " " + (location.startY + (style.height / 2)) + " " + "Z" + " " + "M" + " " + (location.startX + (-style.width / 10) - (style.width / 20)) + " " + (location.startY - (style.height / 4) - (elementspace / 2)) + " " + "L" + " " + (location.startX + (style.width / 10) + (style.width / 20)) + " " + (location.startY - (style.height / 4) - (elementspace / 2)) + " " + "L" + " " + (location.startX + (style.width / 10) + (style.width / 20)) + " " + (location.startY + (style.height / 2)) + " " + "L" + " " + (location.startX + (-style.width / 10) - (style.width / 20)) + " " + (location.startY + (style.height / 2)) + " " + "Z" + " " + "M" + " " + (location.startX + 3 * (style.width / 10)) + " " + (location.startY) + " " + "L" + " " + (location.startX + 3 * (style.width / 5)) + " " + (location.startY) + " " + "L" + " " + (location.startX + 3 * (style.width / 5)) + " " + (location.startY + (style.height / 2)) + " " + "L" + " " + (location.startX + 3 * (style.width / 10)) + " " + (location.startY + (style.height / 2)) + " " + "Z";
      
         var options = {
            'id': symbolStyle.ID,
            'fill': symbolStyle.Style.Color,
            'stroke-width': symbolStyle.Style.BorderWidth,
            'stroke': symbolStyle.Style.BorderColor,
            'opacity': symbolStyle.Style.Opacity,
            'visibility': symbolStyle.Style.Visibility,
            'd': path,
             'lgndCtx': true
        };

        svgRender.drawPath(options, element);

         return (location.startX - 3 * (style.width / 5));

    },
    _drawRangeColumn: function (location, symbolStyle, sender, element) {
        var svgRender = sender.svgRenderer;
        var svgObj = sender.svgObject;
        var style = symbolStyle.ShapeSize;
        var elementspace = symbolStyle.ElementSpace;
        var path;       
        path = "M" + " " + (location.startX + (-style.width / 5)) + " " + (location.startY + (style.height / 2) + (elementspace / 4)) + " " + "L" + " " + (location.startX + (-style.width / 5)) + " " + (location.startY - (style.height / 2) - (elementspace / 4)) + " " + "L" + " " + (location.startX + (style.width / 2)) + " " + (location.startY + (-style.height / 2) + (-elementspace / 4)) + " " + "L" + " " + (location.startX + (style.width / 2)) + " " + (location.startY + (style.height / 2) + (elementspace / 4)) + " " + "Z";
       
        var options = {
            'id': symbolStyle.ID,
            'fill': symbolStyle.Style.Color,
            'stroke-width': symbolStyle.Style.BorderWidth,
            'stroke': symbolStyle.Style.BorderColor,
            'opacity': symbolStyle.Style.Opacity,
            'visibility': symbolStyle.Style.Visibility,
            'd': path,
            'lgndCtx': true
        };

        svgRender.drawPath(options, element);

        return (location.startX + (-style.width / 5));

    },

    _drawBar: function (location, symbolStyle, sender, element) {
        var svgRender = sender.svgRenderer;
        var svgObj = sender.svgObject;
        var style = symbolStyle.ShapeSize;
        var elementspace = symbolStyle.ElementSpace;
        var path;        
       
        path = "M" + " " + (location.startX + (-style.width / 2) + (-elementspace / 4)) + " " + (location.startY - 3 * (style.height / 5)) + " " + "L" + " " + (location.startX + 3 * (style.width / 10)) + " " + (location.startY - 3 * (style.height / 5)) + " " + "L" + " " + (location.startX + 3 * (style.width / 10)) + " " + (location.startY - 3 * (style.height / 10)) + " " + "L" + " " + (location.startX - (style.width / 2) + (-elementspace / 4)) + " " + (location.startY - 3 * (style.height / 10)) + " " + "Z" + " " + "M" + " " + (location.startX + (-style.width / 2) + (-elementspace / 4)) + " " + (location.startY - (style.height / 5) + (elementspace / 20)) + " " + "L" + " " + (location.startX + (style.width / 2) + (elementspace / 4)) + " " + (location.startY - (style.height / 5) + (elementspace / 20)) + " " + "L" + " " + (location.startX + (style.width / 2) + (elementspace / 4)) + " " + (location.startY + (style.height / 10) + (elementspace / 20)) + " " + "L" + " " + (location.startX - (style.width / 2) + (-elementspace / 4)) + " " + (location.startY + (style.height / 10) + (elementspace / 20)) + " " + "Z" + " " + "M" + " " + (location.startX - (style.width / 2) + (-elementspace / 4)) + " " + (location.startY + (style.height/5) + (elementspace / 10)) + " " + "L" + " " + (location.startX + (-style.width / 4)) + " " + (location.startY + (style.height/5) + (elementspace / 10)) + " " + "L" + " " + (location.startX + (-style.width / 4)) + " " + (location.startY + (style.height / 2)+(elementspace/10)) + " " + "L" + " " + (location.startX - (style.width / 2) + (-elementspace / 4)) + " " + (location.startY + (style.height / 2)+(elementspace/10)) + " " + "Z";
        var options = {
            'id': symbolStyle.ID,
            'fill': symbolStyle.Style.Color,
            'stroke-width': symbolStyle.Style.BorderWidth,
            'stroke': symbolStyle.Style.BorderColor,
            'opacity': symbolStyle.Style.Opacity,
            'visibility': symbolStyle.Style.Visibility,
            'd': path,
            'lgndCtx': true
        };

        svgRender.drawPath(options, element);

        return (location.startX + (-style.width / 2) + (-elementspace / 4));

    },
   
    _drawStepLine: function (location, symbolStyle, sender, element) {
        var svgRender = sender.svgRenderer;
        var svgObj = sender.svgObject;
        var style = symbolStyle.ShapeSize;
        var elementspace = symbolStyle.ElementSpace;
        var path;       
       
        path = "M" + " " + (location.startX + (-style.width / 2) - (elementspace/4)) + " " + (location.startY + (style.height / 2)) + " " + "L" + " " + (location.startX + (-style.width / 2) + (style.width / 10)) + " " + (location.startY + (style.height / 2)) + " " + "L" + " " + (location.startX + (-style.width / 2) + (style.width / 10)) + " " + (location.startY) + " " + "L" + " " + (location.startX + (-style.width / 10)) + " " + (location.startY) + " " + "L" + " " + (location.startX + (-style.width / 10)) + " " + (location.startY + (style.height / 2)) + " " + "L" + " " + (location.startX + (style.width / 5)) + " " + (location.startY + (style.height / 2)) + " " + "L" + " " + (location.startX + (style.width / 5)) + " " + (location.startY + (-style.height / 2)) + " " + "L" + " " + (location.startX + (style.width / 2)) + " " + (location.startY + (-style.height / 2)) + "L" + " " + (location.startX + (style.width / 2)) + " " + (location.startY + (style.height / 2)) + " " + "L" + "" + (location.startX + (style.width/2) + (elementspace/4)) + " " + (location.startY + (style.height / 2));
        var options = {
            'id': symbolStyle.ID,
            'fill': "transparent",
            'stroke-width': symbolStyle.Style.BorderWidth,
            'stroke': symbolStyle.Style.Color,
            'opacity': symbolStyle.Style.Opacity,
            'visibility': symbolStyle.Style.Visibility,
            'd': path,
            'lgndCtx': true
        };

        svgRender.drawPath(options, element);

        return (location.startX + (-style.width / 2) - (elementspace / 4));

    },
    _drawSpline: function (location, symbolStyle, sender, element) {
        var svgRender = sender.svgRenderer;
        var svgObj = sender.svgObject;
        var style = symbolStyle.ShapeSize;
        var path;        
        path = "M" + " " + (location.startX - (style.width / 2)) + " " + (location.startY + (style.height / 5)) + " " + "Q" + " " + location.startX + " " + (location.startY - style.height) + " " + location.startX + " " + (location.startY + (style.height / 5)) + " " + "M" + " " + location.startX + " " + (location.startY + (style.height / 5)) + " " + "Q" + " " + (location.startX + (style.width / 2)) + " " + (location.startY + (style.height / 2)) + " " + (location.startX + (style.width / 2)) + " " + (location.startY - (style.height / 2));		
        var options = {
            'id': symbolStyle.ID,
             'fill': "transparent",
            'stroke-width': symbolStyle.Style.BorderWidth*2,
            'stroke': symbolStyle.Style.Color,
            'opacity': symbolStyle.Style.Opacity,
            'visibility': symbolStyle.Style.Visibility,
            'd': path,
            'lgndCtx': true
        };

        svgRender.drawPath(options, element);

        return (location.startX - (style.width / 2));

    },
    _drawSplineArea: function (location, symbolStyle, sender, element) {
        var svgRender = sender.svgRenderer;
        var svgObj = sender.svgObject;
        var style = symbolStyle.ShapeSize;
        var path;       
        path = "M" + " " + (location.startX - (style.width / 2)) + " " + (location.startY + (style.height / 5)) + " " + "Q" + " " + location.startX + " " + (location.startY - style.height) + " " + location.startX + " " + (location.startY + (style.height / 5)) + " " +  "Z" +" " + "M" + " " + location.startX + " " + (location.startY + (style.height / 5)) + " " + "Q" + " " + (location.startX + (style.width / 2)) + " " + (location.startY + (style.height / 2)) + " " + (location.startX + (style.width / 2)) + " " + (location.startY - (style.height / 2)) +" " +" Z";
        var options = {
            'id': symbolStyle.ID,
            'fill': symbolStyle.Style.Color,
            'stroke-width': symbolStyle.Style.BorderWidth,
            'stroke': symbolStyle.Style.Color,
            'opacity': symbolStyle.Style.Opacity,
            'visibility': symbolStyle.Style.Visibility,
            'd': path,
            'lgndCtx': true
        };

        svgRender.drawPath(options, element);

        return (location.startX - (style.width / 2));

    },
    _drawArea: function (location, symbolStyle, sender, element) {
        var svgRender = sender.svgRenderer;
        var svgObj = sender.svgObject;
        var style = symbolStyle.ShapeSize;
        var elementspace = symbolStyle.ElementSpace;
        var path;
        path = "M" + " " + (location.startX - (style.width / 2) - (elementspace / 4)) + " " + (location.startY + (style.height / 2)) + " " + "L" + " " + (location.startX + (-style.width / 4) + (-elementspace / 8)) + " " + (location.startY - (style.height / 2)) + " " + "L" + " " + (location.startX) + " " + (location.startY + (style.height / 4)) + " " + "L" + " " + (location.startX + (style.width / 4) + (elementspace / 8)) + " " + (location.startY + (-style.height / 2) + (style.height / 4)) + " " + "L" + " " + (location.startX + (style.height / 2) + (elementspace / 4)) + " " + (location.startY + (style.height / 2)) + " " + "Z";
      
        var options = {
            'id': symbolStyle.ID,
            'fill': symbolStyle.Style.Color,
            'stroke-width': symbolStyle.Style.BorderWidth,
            'stroke': symbolStyle.Style.BorderColor,
            'opacity': symbolStyle.Style.Opacity,
            'visibility': symbolStyle.Style.Visibility,
            'd': path,
            'lgndCtx': true
        };

        svgRender.drawPath(options, element);

        return (location.startX - (style.width / 2) - (elementspace / 4));

    },
    _drawStepArea: function (location, symbolStyle, sender, element) {
        var svgRender = sender.svgRenderer;
        var svgObj = sender.svgObject;
        var style = symbolStyle.ShapeSize;
        var elementspace = symbolStyle.ElementSpace;
        var path;

        path = "M" + " " + (location.startX + (-style.width / 2) + (-elementspace / 4)) + " " + (location.startY + (style.height / 2)) + " " + "L" + " " + (location.startX + (-style.width / 2) + (-elementspace / 4)) + " " + (location.startY + (-style.height / 2)) + " " + "L" + " " + (location.startX - (style.width / 4)) + " " + (location.startY - (style.height / 2)) + " " + "L" + " " + (location.startX - (style.width / 4)) + " " + (location.startY - (style.height / 4)) + " " + "L" + " " + (location.startX + (style.width / 4)) + " " + (location.startY - (style.height / 4)) + " " + "L" + " " + (location.startX + (style.width / 4)) + " " + (location.startX) + " " + "L" + " " + (location.startX + (style.width / 2) + (elementspace / 4)) + " " + (location.startY) + " " + "L" + " " + (location.startX + (style.width / 2) + (elementspace / 4)) + " " + (location.startY + (style.height / 2)) + " " + "Z";       
        var options = {
            'id': symbolStyle.ID,
            'fill': symbolStyle.Style.Color,
            'stroke-width': symbolStyle.Style.BorderWidth,
            'stroke': symbolStyle.Style.BorderColor,
            'opacity': symbolStyle.Style.Opacity,
            'visibility': symbolStyle.Style.Visibility,
            'd': path,
            'lgndCtx': true
        };

        svgRender.drawPath(options, element);

        return (location.startX + (-style.width / 2) + (-elementspace / 4));

    },
    _drawPyramid: function (location, symbolStyle, sender, element) {
        var svgRender = sender.svgRenderer;
        var svgObj = sender.svgObject;
        var style = symbolStyle.ShapeSize;
        var elementspace = symbolStyle.ElementSpace;
        var path;        
       path = "M" + " " + (location.startX + (-style.width / 2) + (-elementspace / 4)) + " " + (location.startY + (style.height / 2)+(elementspace/8)) + " " + "L" + " " + (location.startX) + " " + (location.startY + (-style.height / 2) + (-elementspace / 8)) + " " + "L" + " " + (location.startX + (style.width / 2) + (elementspace / 4)) + " " + (location.startY + (style.height / 2)+(elementspace/8)) + " " + "Z";
      
        var options = {
            'id': symbolStyle.ID,
            'fill': symbolStyle.Style.Color,
            'stroke-width': symbolStyle.Style.BorderWidth,
            'stroke': symbolStyle.Style.BorderColor,
            'opacity': symbolStyle.Style.Opacity,
            'visibility': symbolStyle.Style.Visibility,
            'd': path,
            'lgndCtx': true
        };

        svgRender.drawPath(options, element);

        return (location.startX + (-style.width / 2) + (-elementspace / 4));


    },
    _drawFunnel: function (location, symbolStyle, sender, element) {
        var svgRender = sender.svgRenderer;
        var svgObj = sender.svgObject;
        var style = symbolStyle.ShapeSize;
        var elementspace = symbolStyle.ElementSpace;
        var path;
        path = "M" + " " + (location.startX + (-style.width / 2) + (-elementspace / 5)) + " " + (location.startY + (-style.height / 2) + (-elementspace / 4)) + " " + "L" + " " + (location.startX + (-style.width / 5)) + " " + (location.startY + (style.height / 4)) + " " + "L" + " " + (location.startX + (-style.width / 5)) + " " + (location.startY + (style.height / 2) + (elementspace / 4)) + " " + "L" + " " + (location.startX + (style.width / 5)) + " " + (location.startY + (style.height / 2) + (elementspace / 4)) + " " + "L" + " " + (location.startX + (style.width / 5)) + " " + (location.startY + (style.height / 4)) + " " + "L" + " " + (location.startX + (style.width / 2) + (elementspace / 5)) + " " + (location.startY + (-style.height / 2) + (-elementspace / 4)) + " " + "Z";
      
        var options = {
            'id': symbolStyle.ID,
            'fill': symbolStyle.Style.Color,
            'stroke-width': symbolStyle.Style.BorderWidth,
            'stroke': symbolStyle.Style.BorderColor,
            'opacity': symbolStyle.Style.Opacity,
            'visibility': symbolStyle.Style.Visibility,
            'd': path,
            'lgndCtx': true
        };

        svgRender.drawPath(options, element);

        return (location.startX + (-style.width / 2) + (-elementspace / 5));

    },
    _drawCandle: function (location, symbolStyle, sender, element) {
        var svgRender = sender.svgRenderer;
        var svgObj = sender.svgObject;
        var style = symbolStyle.ShapeSize;
        var elementspace = symbolStyle.ElementSpace;
        var path;       
       
        path = "M" + " " + (location.startX + (-style.width / 2)) + " " + (location.startY + (style.height / 4) + (elementspace / 8)) + " " + "L" + " " + (location.startX + (style.width / 2)) + " " + (location.startY + (style.height / 4) + (elementspace / 8)) + " " + "L" + " " + (location.startX + (style.width / 2)) + " " + (location.startY + (-style.height / 2) + (elementspace / 8)) + " " + "L" + " " + (location.startX + (-style.width / 2)) + " " + (location.startY + (-style.height / 2) + (elementspace / 8)) + " " + "Z" + " " + "M" + " " + (location.startX) + " " + (location.startY + (-style.height / 2) + (elementspace / 8)) + " " + "L" + " " + (location.startX) + " " + (location.startY + (-style.height / 2) + (-elementspace / 4)) + " " + "M" + " " + (location.startX) + " " + (location.startY + (style.height / 4) + (elementspace / 8)) + " " + "L" + " " + (location.startX) + " " + (location.startY + (style.height / 4) + (elementspace / 2));
        var options = {
            'id': symbolStyle.ID,
            'fill': symbolStyle.Style.Color,
            'stroke-width': symbolStyle.Style.BorderWidth,
            'stroke': symbolStyle.Style.Color,
            'opacity': symbolStyle.Style.Opacity,
            'visibility': symbolStyle.Style.Visibility,
            'd': path,
            'lgndCtx': true
        };

        svgRender.drawPath(options, element);

        return (location.startX + (-style.width / 2));

    },
    _drawHilo: function (location, symbolStyle, sender, element) {
        var svgRender = sender.svgRenderer;
        var svgObj = sender.svgObject;
        var style = symbolStyle.ShapeSize;
        var elementspace = symbolStyle.ElementSpace;
        var path;
        path = "M" + " " + (location.startX + (style.width / 2)) + " " + (location.startY + (style.height / 2)+(elementspace/4)) + " " + "L" + " " + (location.startX + (style.width / 2)) + " " + (location.startY + (-style.height / 2)+(-elementspace/4));        
        var options = {
            'id': symbolStyle.ID,
            'fill': symbolStyle.Style.Color,
            'stroke-width': symbolStyle.Style.BorderWidth,
            'stroke': symbolStyle.Style.Color,
            'opacity': symbolStyle.Style.Opacity,
            'visibility': symbolStyle.Style.Visibility,
            'd': path,
            'lgndCtx': true
        };

        svgRender.drawPath(options, element);

        return (location.startX + (style.width / 2));

    },
    _drawHiloOpenClose: function (location, symbolStyle, sender, element) {
        var svgRender = sender.svgRenderer;
        var svgObj = sender.svgObject;
        var style = symbolStyle.ShapeSize;
        var cartesian = polarToCartesian(18, 12, 4.0710678118654755, 270);
        var elementspace = symbolStyle.ElementSpace;
        var path;        
        
        path = "M" + " " + (location.startX) + " " + (location.startY - 3 * (style.height / 10)) + " " + "L" + " " + (location.startX - (style.width / 2) - (elementspace / 4)) + " " + (location.startY - 3 * (style.height / 10)) + " " + "M" + " " + (location.startX) + " " + (location.startY - (style.height / 2) - (elementspace / 4)) + " " + "L" + " " + (location.startX) + " " + (location.startY + (style.height / 2) + (elementspace / 4)) + " " + "M" + " " + (location.startX) + " " + (location.startY + 3 * (style.height / 10)) + " " + "L" + " " + (location.startX + (style.width / 2) + (elementspace / 4)) + " " + (location.startY + 3 * (style.height / 10));
        var options = {
            'id': symbolStyle.ID,
            'fill': "transparent",
            'stroke-width': symbolStyle.Style.BorderWidth,
            'stroke': symbolStyle.Style.Color,
            'opacity': symbolStyle.Style.Opacity,
            'visibility': symbolStyle.Style.Visibility,
            'd': path,
            'lgndCtx': true
        };

        svgRender.drawPath(options, element);

        return ((location.startX) - (style.width / 2));

    },

    _drawDoughnut: function (location, symbolStyle, sender, element) {
        var svgRender = sender.svgRenderer;
        var svgObj = sender.svgObject;
        var style = symbolStyle.ShapeSize;
        var elementspace = symbolStyle.ElementSpace;
        var radius = Math.sqrt(style.height * style.width) / 2;
        radius = radius + (elementspace / 5);
        var cartesianlarge = polarToCartesian(location.startX, location.startY, radius, 270);
        var cartesiansmall = polarToCartesian(location.startX + (style.width / 10), location.startY, radius, 270);
        var elementspace = symbolStyle.ElementSpace;
        path = "M" + " " + location.startX + " " + location.startY + " " + "L" + " " + (location.startX + radius) + " " + (location.startY) + " " + "A" + " " + (radius) + " " + (radius) + " " + 0 + " " + 1 + " " + 1 + " " + cartesianlarge[0] + " " + cartesianlarge[1] + " " + "Z" + " " + "M" + " " + (location.startX + (style.width / 10)) + " " + (location.startY - (style.height / 10)) + " " + "L" + (location.startX + (radius)) + " " + (location.startY - style.height / 10) + " " + "A" + " " + (radius) + " " + (radius) + " " + 0 + " " + 0 + " " + 0 + " " + cartesiansmall[0] + " " + cartesiansmall[1] + " " + "Z";

        var options = {
            'id': symbolStyle.ID,
            'fill': symbolStyle.Style.Color,
            'stroke-width': symbolStyle.Style.BorderWidth,
            'stroke': symbolStyle.Style.BorderColor,
            'opacity': symbolStyle.Style.Opacity,
            'visibility': symbolStyle.Style.Visibility,
            'd': path,
            'lgndCtx': true
        };
        var circle = {
            'id': symbolStyle.ID, 'cx': location.startX, 'cy': location.startY, 'r': (radius/2),'lgndCtx': true,
            'fill': "white", 'stroke-width': symbolStyle.Style.BorderWidth, 'stroke': symbolStyle.Style.BorderColor, 'opacity': symbolStyle.Style.Opacity, 'visibility': symbolStyle.Style.Visibility
        };

        svgRender.drawPath(options, element);
        svgRender.drawCircle(circle, element);

        return (location.startX-radius);
    },

    _drawPie: function (location, symbolStyle, sender, element) {
        var svgRender = sender.svgRenderer;
        var svgObj = sender.svgObject;
        var style = symbolStyle.ShapeSize;
        var elementspace = symbolStyle.ElementSpace;
        var radius = Math.sqrt(style.height * style.width) / 2;
        radius = radius + (elementspace / 5);
        var cartesianlarge = polarToCartesian(location.startX, location.startY, radius, 270);
        var cartesiansmall = polarToCartesian(location.startX + (style.width / 10), location.startY, radius, 270);
        var elementspace = symbolStyle.ElementSpace;
        path = "M" + " " + location.startX + " " + location.startY + " " + "L" + " " + (location.startX + radius) + " " + (location.startY) + " " + "A" + " " + (radius) + " " + (radius) + " " + 0 + " " + 1 + " " + 1 + " " + cartesianlarge[0] + " " + cartesianlarge[1] + " " + "Z" + " " + "M" + " " + (location.startX + (style.width / 10)) + " " + (location.startY - (style.height / 10)) + " " + "L" + (location.startX + (radius)) + " " + (location.startY - style.height / 10) + " " + "A" + " " + (radius) + " " + (radius) + " " + 0 + " " + 0 + " " + 0 + " " + cartesiansmall[0] + " " + cartesiansmall[1] + " " + "Z";

        var options = {
            'id': symbolStyle.ID,
            'fill': symbolStyle.Style.Color,
            'stroke-width': symbolStyle.Style.BorderWidth,
            'stroke': symbolStyle.Style.BorderColor,
            'opacity': symbolStyle.Style.Opacity,
            'visibility': symbolStyle.Style.Visibility,
            'd': path,
            'lgndCtx': true
        };

        svgRender.drawPath(options, element);
        return (location.startX - radius);
    }

};
function polarToCartesian(startX, startY, radius, angleInDegrees) {
    var angleInRadians = angleInDegrees * Math.PI / 180.0;
    var x = startX + radius * Math.cos(angleInRadians);
    var y = startY + radius * Math.sin(angleInRadians);
    return [x, y];
}
BoldBIDashboard.EjSvgRender.seriesPalette = {
    defaultMetro: ["#E94649", "#F6B53F", "#6FAAB0", "#C4C24A", "#FB954F", "#005277", "#8BC652", "#69D2E7", "#E27F2D", "#6A4B82"],
    defaultGradient:
        {
            borderColors: ["#F34649", "#F6D321", "#6EB9B0", "#CBC26A", "#FBAF4F", "#E2CDB1", "#FFC0B7", "#68E1E6", "#E1A62D", "#9C6EBF"],
            seriesColors: [[{ color: "#F34649", colorStop: "0%" }, { color: "#B74143", colorStop: "100%"}],
     [{ color: "#F6D321", colorStop: "0%" }, { color: "#F6AE26", colorStop: "100%"}],
     [{ color: "#6EB9B0", colorStop: "0%" }, { color: "#3F77BD", colorStop: "100%"}],
     [{ color: "#CBC26A", colorStop: "0%" }, { color: "#9AAD21", colorStop: "100%"}],
     [{ color: "#FBAF4F", colorStop: "0%" }, { color: "#F07542", colorStop: "100%"}],
     [{ color: "#E2CDB1", colorStop: "0%" }, { color: "#AAA089", colorStop: "100%"}],
     [{ color: "#8BC652", colorStop: "0%" }, { color: "#6F9E41", colorStop: "100%"}],
     [{ color: "#68E1E6", colorStop: "0%" }, { color: "#3D9CBE", colorStop: "100%"}],
     [{ color: "#E1A62D", colorStop: "0%" }, { color: "#B66824", colorStop: "100%"}],
     [{ color: "#9C6EBF", colorStop: "0%"}], [{ color: "#593F6D", colorStop: "100%"}]]
        },
    blueMetro: ["#005378", "#006691", "#007EB5", "#0D97D4", "#00AEFF", "#14B9FF", "#54CCFF", "#87DBFF", "#ADE5FF", "#C5EDFF"],
    blueGradient:
     {
         seriesColors: [[{ color: "#005277", colorStop: "0%" }, { color: "#00304F", colorStop: "100%"}],
            [{ color: "#006590", colorStop: "0%" }, { color: "#004068", colorStop: "100%"}],
            [{ color: "#007DB4", colorStop: "0%" }, { color: "#00558B", colorStop: "100%"}],
            [{ color: "#0D97D4", colorStop: "0%" }, { color: "#057FC7", colorStop: "100%"}],
            [{ color: "#00ADFE", colorStop: "0%" }, { color: "#008BE9", colorStop: "100%"}],
            [{ color: "#14B8FE", colorStop: "0%" }, { color: "#0798EB", colorStop: "100%"}],
            [{ color: "#53CBFF", colorStop: "0%" }, { color: "#35AFEB", colorStop: "100%"}],
            [{ color: "#86DAFF", colorStop: "0%" }, { color: "#64C0EC", colorStop: "100%"}],
            [{ color: "#ACE5FF", colorStop: "0%" }, { color: "#8DCEED", colorStop: "100%"}],
            [{ color: "#C4ECFF", colorStop: "0%"}], [{ color: "#A3D1E6", colorStop: "100%"}]],
         borderColors: ["#005277", "#006590", "#007DB4", "#0D97D4", "#00ADFE", "#14B8FE", "#53CBFF", "#86DAFF", "#ACE5FF", "#C4ECFF"]
     },
    greenMetro: ["#496612", "#597B15", "#709A1B", "#87B62A", "#9AD926", "#A6DC37", "#BCE654", "#C8E780", "#D5EFA5", "#E2F3BE"],
    greenGradient:
     {

         seriesColors: [[{ color: "#5C7F16", colorStop: "0%" }, { color: "#384C08", colorStop: "100%"}],
            [{ color: "#6A9319", colorStop: "0%" }, { color: "#486009", colorStop: "100%"}],
            [{ color: "#739D1C", colorStop: "0%" }, { color: "#57760B", colorStop: "100%"}],
            [{ color: "#90B546", colorStop: "0%" }, { color: "#6E9215", colorStop: "100%"}],
            [{ color: "#9AD826", colorStop: "0%" }, { color: "#75A010", colorStop: "100%"}],
            [{ color: "#A5DB36", colorStop: "0%" }, { color: "#8EB91D", colorStop: "100%"}],
            [{ color: "#BBE554", colorStop: "0%" }, { color: "#A4C849", colorStop: "100%"}],
            [{ color: "#C8E780", colorStop: "0%" }, { color: "#B4D072", colorStop: "100%"}],
            [{ color: "#D4EEA5", colorStop: "0%" }, { color: "#BFD593", colorStop: "100%"}],
            [{ color: "#E1F2BD", colorStop: "0%"}], [{ color: "#C8D7A8", colorStop: "100%"}]],
         borderColors: ["#5C7F16", "#6A9319", "#739D1C", "#90B546", "#9AD826", "#A5DB36", "#BBE554", "#C8E780", "#D4EEA5", "#E1F2BD"]
     },

    sandleMetro: ["#6C450C", "#82520D", "#A36812", "#C07F1F", "#E69719", "#E89A2B", "#EEB564", "#F3CB93", "#F7DEB4", "#F9E6CA"],
    sandleGradient:
     {


         seriesColors: [[{ color: "#7F602F", colorStop: "0%" }, { color: "#512D04", colorStop: "100%"}],
            [{ color: "#986827", colorStop: "0%" }, { color: "#673803", colorStop: "100%"}],
            [{ color: "#A16C1F", colorStop: "0%" }, { color: "#8A4B05", colorStop: "100%"}],
            [{ color: "#BF812A", colorStop: "0%" }, { color: "#AD630D", colorStop: "100%"}],
            [{ color: "#E49519", colorStop: "0%" }, { color: "#B86607", colorStop: "100%"}],
            [{ color: "#E7992A", colorStop: "0%" }, { color: "#D7780D", colorStop: "100%"}],
            [{ color: "#EDB463", colorStop: "0%" }, { color: "#D98F31", colorStop: "100%"}],
            [{ color: "#F2CA92", colorStop: "0%" }, { color: "#DAAC6F", colorStop: "100%"}],
            [{ color: "#F6DDB3", colorStop: "0%" }, { color: "#DABE8F", colorStop: "100%"}],
            [{ color: "#F8E5C9", colorStop: "0%"}], [{ color: "#DDBE92", colorStop: "100%"}]],
         borderColors: ["#7F602F", "#986827", "#A16C1F", "#BF812A", "#E49519", "#E7992A", "#EDB463", "#F2CA92", "#F6DDB3", "#F8E5C9"]

     }
};

BoldBIDashboard.EjSvgRender.themes = {
    flatlight:
    {
        background: 'transparent',
        border: {

            color: 'transparent',

            width: 0,

            opacity: 0.3
        },
        legend:
        {
            font: { color: "#282828"},
            title:
            {
               font: { color: "#282828"}
             }
        },
        title:
        {
            font: { color: '#565656'},
            subTitle:
                {
                    font: { color: '#565656'}
                }
        },
        primaryXAxis:
        {
            majorGridLines:
            {
                color: "#DFDFDF"
            },
            majorTickLines:
            {
                color: "#8E8E8E"
            },
            minorGridLines:
            {
                color: "#DFDFDF"
            },
            minorTickLines:
            {
                color: "#8E8E8E"
            },
            axisLine: { color: '#8E8E8E' },
            font: { color: '#282828' },
            title:
            {
                font: { color: '#282828' }
            },
            crosshairLabel: { rx: 0, ry: 0, border: { color: '#3D3D3D', width: 1 }, fill: '#3D3D3D', font: { fontFamily: 'Segoe UI', fontStyle: 'Normal', size: '13px', fontWeight: 'regular', opacity: 1, color: '#DBDBDB' } }
        },
        secondaryX:
        {
            majorGridLines:
            {
                color: "#DFDFDF"
            },
            majorTickLines:
            {
                color: "#8E8E8E"
            },
            minorGridLines:
            {
                color: "#DFDFDF"
            },
            minorTickLines:
            {
                color: "#8E8E8E"
            },
            axisLine: { color: '#8E8E8E' },
            font: { color: '#282828' },
            title:
            {
                font: { color: '#282828' }
            },
            crosshairLabel: { rx: 0, ry: 0, border: { color: '#3D3D3D' ,width: 1 }, fill: '#3D3D3D', font: { fontFamily: 'Segoe UI', fontStyle: 'Normal', size: '13px', fontWeight: 'regular', opacity: 1, color: '#DBDBDB'} }
        },

        primaryYAxis:
        {
            majorGridLines:
            {
                color: "#DFDFDF"
            },
            majorTickLines:
            {
                color: "#8E8E8E"
            },
            minorGridLines:
            {
                color: "#DFDFDF"
            },
            minorTickLines:
            {
                color: "#8E8E8E"
            },
            axisLine: { color: '#8E8E8E' },
            font: { color: '#282828' },
            title:
            {
                font: { color: '#282828' }
            },
            crosshairLabel: { rx: 0, ry: 0, border: { color: '#3D3D3D', borderWidth: 1 }, fill: '#3D3D3D', font: { fontFamily: 'Segoe UI', fontStyle: 'Normal', size: '13px', fontWeight: 'regular', opacity: 1, color: '#DBDBDB' } }
        },
        secondaryY:
        {
            majorGridLines:
            {
                color: "#DFDFDF"
            },
            majorTickLines:
            {
                color: "#8E8E8E"
            },
            minorGridLines:
            {
                color: "#DFDFDF"
            },
            minorTickLines:
            {
                color: "#8E8E8E"
            },
            axisLine: { color: '#8E8E8E' },
            font: { color: '#282828' },
            title:
            {
                font: { color: '#282828' }
            },
            crosshairLabel: { rx: 0, ry: 0, border: { color: '#3D3D3D', width: 1 }, fill: '#3D3D3D', font: { fontFamily: 'Segoe UI', fontStyle: 'Normal', size: '13px', fontWeight: 'regular', opacity: 1, color: '#DBDBDB' } }
        },
     commonSeriesOptions:
           {
marker:{
               dataLabel: { font: { color: '#565656' } }
},
  errorBar:{
        fill:"#000000",
		cap:
		{
			fill:"#000000"
		}
  },
  connectorLine: { color: '#565656' }
	},
        crosshair:
        {
            line:
            {
                width: 1,
                color: 'Black'
            }
        },
        
        seriesBorderDefaultColors: BoldBIDashboard.EjSvgRender.seriesPalette.defaultMetro,
        colors: BoldBIDashboard.EjSvgRender.seriesPalette.defaultMetro

    },

    flatdark:
        {
            background: '#111111',
            border: {

                color: 'transparent',

                width: 0,

                opacity: 1
            },
            legend:
            {
                font: { color: "#C9C9C9"},
                title:
                {
                  font: { color: "#C9C9C9"}
                }
            },
            title:
            {
                font: { color: '#C9C9C9'},
                subTitle:
                {
                    font: { color: '#C9C9C9'}
                }
            },
            primaryXAxis:
             {
                 majorGridLines:
                 {
                     color: "#333333"
                 },
                 majorTickLines:
                  {
                      color: "#AAAAAA"
                  },
                 minorGridLines:
                  {
                      color: "#333333"
                  },
                 minorTickLines:
                  {
                      color: "#AAAAAA"
                  },
                 axisLine: { color: '#AAAAAA' },
                 font: { color: '#C9C9C9' },
                 title:
                 {

                     font: { color: '#C9C9C9' }
                 },
                 crosshairLabel: { rx: 0, ry: 0, fill: '#B5B5B5', border: { color: '#B5B5B5', width: 1 }, font: { fontFamily: 'Segoe UI', fontStyle: 'Normal', size: '13px', fontWeight: 'regular', opacity: 1, color: '#444444' } }
             },
            secondaryX:
             {
                 majorGridLines:
                 {
                     color: "#333333"
                 }, 
                 majorTickLines:
                  {
                      color: "#AAAAAA"
                  },
                 minorGridLines:
                  {
                      color: "#333333"
                  },
                 minorTickLines:
                  {
                      color: "#AAAAAA"
                  },
                 axisLine: { color: '#AAAAAA' },
                 font: { color: '#C9C9C9' },
                 title:
                 {

                     font: { color: '#C9C9C9' }
                 },
                 crosshairLabel: {   rx: 0, ry: 0, fill: '#B5B5B5', border:{color: '#B5B5B5', width: 1 }, font: { fontFamily: 'Segoe UI', fontStyle: 'Normal', size: '13px', fontWeight: 'regular', opacity: 1, color: '#444444' } }
             },
            primaryYAxis:
             {
                 majorGridLines:
                 {
                     color: "#333333"
                 },
                 majorTickLines:
                  {
                      color: "#AAAAAA"
                  },
                 minorGridLines:
                  {
                      color: "#333333"
                  },
                 minorTickLines:
                  {
                      color: "#AAAAAA"
                  },
                 axisLine: { color: '#AAAAAA' },
                 font: { color: '#C9C9C9' },
                 title:
                 {

                     font: { color: '#C9C9C9' }
                 },
                 crosshairLabel: { rx: 0, ry: 0, fill: '#B5B5B5', border:{color: '#B5B5B5', width: 1 }, font: { fontFamily: 'Segoe UI', fontStyle: 'Normal', size: '13px', fontWeight: 'regular', opacity: 1, color: '#444444' } }
             },
            secondaryY:
             {
                 majorGridLines:
                 {
                     color: "#333333"
                 },
                 majorTickLines:
                  {
                      color: "#AAAAAA"
                  },
                 minorGridLines:
                  {
                      color: "#333333"
                  },
                 minorTickLines:
                  {
                      color: "#AAAAAA"
                  },
                 axisLine: { color: '#AAAAAA' },
                 font: { color: '#C9C9C9' },
                 title:
                 {

                     font: { color: '#C9C9C9' }
                 },
                 crosshairLabel: { rx: 0, ry: 0, fill: '#B5B5B5', border: { color: '#B5B5B5', width: 1 }, font: { fontFamily: 'Segoe UI', fontStyle: 'Normal', size: '13px', fontWeight: 'regular', opacity: 1, color: '#444444'} }
             },
     commonSeriesOptions:
           {
marker:{
               dataLabel: { font: { color: '#C9C9C9' } }
},
errorBar:{
           fill:"#ffffff",
		   cap:
		   {
			fill:"#ffffff"
		   }
},
connectorLine: { color: '#C9C9C9' }
        },
            crosshair:
             {
                 line:
                 {
                     width: 1,
                     color: 'White'
                 }
             },
            
            seriesBorderDefaultColors: BoldBIDashboard.EjSvgRender.seriesPalette.defaultMetro,
            colors: BoldBIDashboard.EjSvgRender.seriesPalette.defaultMetro

        },


    gradientlight:
        {
            background: 'transparent',
            border: {

                color: 'transparent',

                width: 0,

                opacity: 0.3
            },
            legend:
            {
                font: { color: "#282828"},
                title:
                {
                    font: { color: "#282828"}
                }
            },
            title:
            {
                font: { color: '#565656'},
                subTitle:
                {
                    font: { color: '#565656'}
                }
            },
            primaryXAxis:
             {
                 majorGridLines:
                 {
                     color: "#DFDFDF"
                 },
                 majorTickLines:
                  {
                      color: "#8E8E8E"
                  },
                 minorGridLines:
                  {
                      color: "#DFDFDF"
                  },
                 minorTickLines:
                  {
                      color: "#8E8E8E"
                  },
                 axisLine: { color: '#8E8E8E' },
                 font: { color: '#282828' },
                 title:
                 {

                     font: { color: '#282828' }
                 },
                 crosshairLabel: {rx: 3, ry: 3, fill: '#3D3D3D',border:{color: '#3D3D3D',  width: 2 }, font: { fontFamily: 'Segoe UI', fontStyle: 'Normal', size: '13px', fontWeight: 'regular', opacity: 1, color: '#DBDBDB'} }
             },
            secondaryX:
             {
                 majorGridLines:
                 {
                     color: "#DFDFDF"
                 },
                 majorTickLines:
                  {
                      color: "#8E8E8E"
                  },
                 minorGridLines:
                  {
                      color: "#DFDFDF"
                  },
                 minorTickLines:
                  {
                      color: "#8E8E8E"
                  },
                 axisLine: { color: '#8E8E8E' },
                 font: { color: '#282828' },
                 title:
                 {

                     font: { color: '#282828' }
                 },
                 crosshairLabel: {rx: 3, ry: 3, fill: '#3D3D3D',border:{color: '#3D3D3D',  width: 2 }, font: { fontFamily: 'Segoe UI', fontStyle: 'Normal', size: '13px', fontWeight: 'regular', opacity: 1, color: '#DBDBDB'} }
             },
            primaryYAxis:
             {
                 majorGridLines:
                 {
                     color: "#DFDFDF"
                 },
                 majorTickLines:
                  {
                      color: "#8E8E8E"
                  },
                 minorGridLines:
                  {
                      color: "#DFDFDF"
                  },
                 minorTickLines:
                  {
                      color: "#8E8E8E"
                  },
                 axisLine: { color: '#8E8E8E' },
                 font: { color: '#282828' },
                 title:
                 {

                     font: { color: '#282828' }
                 },
                 crosshairLabel: {rx: 3, ry: 3, fill: '#3D3D3D',border:{color: '#3D3D3D',  width: 2 }, font: { fontFamily: 'Segoe UI', fontStyle: 'Normal', size: '13px', fontWeight: 'regular', opacity: 1, color: '#DBDBDB'} }
             },
            secondaryY:
             {
                 majorGridLines:
                 {
                     color: "#DFDFDF"
                 },
                 majorTickLines:
                  {
                      color: "#8E8E8E"
                  },
                 minorGridLines:
                  {
                      color: "#DFDFDF"
                  },
                 minorTickLines:
                  {
                      color: "#8E8E8E"
                  },
                 axisLine: { color: '#8E8E8E' },
                 font: { color: '#282828' },
                 title:
                 {

                     font: { color: '#282828' }
                 },
                 crosshairLabel: {rx: 3, ry: 3, fill: '#3D3D3D',border:{color: '#3D3D3D',  width: 2 }, font: { fontFamily: 'Segoe UI', fontStyle: 'Normal', size: '13px', fontWeight: 'regular', opacity: 1, color: '#DBDBDB'} }
             },
     commonSeriesOptions:
           {
marker:{
               dataLabel: { font: { color: '#565656' } }
},
    errorBar:{
        fill:"#000000",
		cap:
		{
			fill:"#000000"
		}
    },
    connectorLine: { color: '#565656' }
	},
            crosshair:
             {
                 line:
                 {
                     width: 1,
                     color: 'Black'
                 }
             },
            
            seriesBorderDefaultColors: BoldBIDashboard.EjSvgRender.seriesPalette.defaultGradient.borderColors,
            colors: BoldBIDashboard.EjSvgRender.seriesPalette.defaultGradient.seriesColors

        },

    gradientdark:
        {
            background: '#111111',
            border: {

                color: 'transparent',

                width: 0,

                opacity: 1
            },
            legend:
            {
                font: { color: "#C9C9C9"},
                title:
               {
                   font: { color: "#C9C9C9"}
               }
            },
            title:
            {
                font: { color: '#C9C9C9'},
                subTitle:
                {
                    font: { color: '#C9C9C9'}
                }
            },
            primaryXAxis:
             {
                 majorGridLines:
                 {
                     color: "#333333"
                 },
                 majorTickLines:
                  {
                      color: "#AAAAAA"
                  },
                 minorGridLines:
                  {
                      color: "#333333"
                  },
                 minorTickLines:
                  {
                      color: "#AAAAAA"
                  },
                 axisLine: { color: '#AAAAAA' },
                 font: { color: '#C9C9C9' },
                 title:
                 {

                     font: { color: '#C9C9C9' }
                 },
                 crosshairLabel: {rx: 3, ry: 3, fill: '#B5B5B5',border:{color: '#B5B5B5',  width: 2 }, font: { fontFamily: 'Segoe UI', fontStyle: 'Normal', size: '13px', fontWeight: 'regular', opacity: 1, color: '#444444'} }
             },
            secondaryX:
             {
                 majorGridLines:
                 {
                     color: "#333333"
                 },
                 majorTickLines:
                  {
                      color: "#AAAAAA"
                  },
                 minorGridLines:
                  {
                      color: "#333333"
                  },
                 minorTickLines:
                  {
                      color: "#AAAAAA"
                  },
                 axisLine: { color: '#AAAAAA' },
                 font: { color: '#C9C9C9' },
                 title:
                 {

                     font: { color: '#C9C9C9' }
                 },
                 crosshairLabel: {rx: 3, ry: 3, fill: '#B5B5B5',border:{color: '#B5B5B5',  width: 2 }, font: { fontFamily: 'Segoe UI', fontStyle: 'Normal', size: '13px', fontWeight: 'regular', opacity: 1, color: '#444444'} }
             },
            primaryYAxis:
             {
                 majorGridLines:
                 {
                     color: "#333333"
                 },
                 majorTickLines:
                  {
                      color: "#AAAAAA"
                  },
                 minorGridLines:
                  {
                      color: "#333333"
                  },
                 minorTickLines:
                  {
                      color: "#AAAAAA"
                  },
                 axisLine: { color: '#AAAAAA' },
                 font: { color: '#C9C9C9' },
                 title:
                 {

                     font: { color: '#C9C9C9' }
                 },
                 crosshairLabel: {rx: 3, ry: 3, fill: '#B5B5B5',border:{color: '#B5B5B5',  width: 2 }, font: { fontFamily: 'Segoe UI', fontStyle: 'Normal', size: '13px', fontWeight: 'regular', opacity: 1, color: '#444444'} }
             },
            secondaryY:
             {
                 majorGridLines:
                 {
                     color: "#333333"
                 },
                 majorTickLines:
                  {
                      color: "#AAAAAA"
                  },
                 minorGridLines:
                  {
                      color: "#333333"
                  },
                 minorTickLines:
                  {
                      color: "#AAAAAA"
                  },
                 axisLine: { color: '#AAAAAA' },
                 font: { color: '#C9C9C9' },
                 title:
                 {

                     font: { color: '#C9C9C9' }
                 },
                 crosshairLabel: {rx: 3, ry: 3, fill: '#B5B5B5',border:{color: '#B5B5B5',  width: 2 }, font: { fontFamily: 'Segoe UI', fontStyle: 'Normal', size: '13px', fontWeight: 'regular', opacity: 1, color: '#444444'} }
             },
     commonSeriesOptions:
           {
marker:{
               dataLabel: { font: { color: '#C9C9C9' } }
      },
     errorBar:{
              fill:"#ffffff",
		      cap:
		      {
			     fill:"#ffffff"
		      }
     },
     connectorLine: { color: "#C9C9C9" }
        },
       
            crosshair:
             {
                 line:
                 {
                     width: 1,
                     color: 'White'
                 }
             },
             
            seriesBorderDefaultColors: BoldBIDashboard.EjSvgRender.seriesPalette.defaultGradient.borderColors,
            colors: BoldBIDashboard.EjSvgRender.seriesPalette.defaultGradient.seriesColors

        }
};
bbdesigner$.extend(BoldBIDashboard.EjSvgRender.themes, {

    "azure":
    {
        border: {

            color: 'transparent',

            width: 0,

            opacity: 0.3
        },
        seriesBorderDefaultColors: BoldBIDashboard.EjSvgRender.seriesPalette.blueMetro,
        colors: BoldBIDashboard.EjSvgRender.seriesPalette.blueMetro
    },

    "azuredark":
    {
        border: {

            color: 'transparent',

            width: 0,

            opacity: 1
        },
        seriesBorderDefaultColors: BoldBIDashboard.EjSvgRender.seriesPalette.blueMetro,
        colors: BoldBIDashboard.EjSvgRender.seriesPalette.blueMetro
    },
    "gradient-azure":
    {
        border: {

            color: 'transparent',

            width: 0,

            opacity: 0.3
        },
        seriesBorderDefaultColors: BoldBIDashboard.EjSvgRender.seriesPalette.blueGradient.borderColors,
        colors: BoldBIDashboard.EjSvgRender.seriesPalette.blueGradient.seriesColors
    },

    "gradient-azuredark":
    {
        
        border: {

            color: 'transparent',

            width: 0,

            opacity: 1
        },
        seriesBorderDefaultColors: BoldBIDashboard.EjSvgRender.seriesPalette.blueGradient.borderColors,
        colors: BoldBIDashboard.EjSvgRender.seriesPalette.blueGradient.seriesColors
    },

    "lime":
    {
        
        border: {

            color: 'transparent',

            width: 0,

            opacity: 0.3
        },
        seriesBorderDefaultColors: BoldBIDashboard.EjSvgRender.seriesPalette.greenMetro,
        colors: BoldBIDashboard.EjSvgRender.seriesPalette.greenMetro
    },

    "limedark":
    {
        
        border: {

            color: 'transparent',

            width: 0,

            opacity: 1
        },
        seriesBorderDefaultColors: BoldBIDashboard.EjSvgRender.seriesPalette.greenMetro,
        colors: BoldBIDashboard.EjSvgRender.seriesPalette.greenMetro
    },
    "gradient-lime":
    {
        
        border: {

            color: 'transparent',

            width: 0,

            opacity: 0.3
        },
        seriesBorderDefaultColors: BoldBIDashboard.EjSvgRender.seriesPalette.greenGradient.borderColors,
        colors: BoldBIDashboard.EjSvgRender.seriesPalette.greenGradient.seriesColors
    },

    "gradient-limedark":
    {
        
        border: {

            color: 'transparent',

            width: 0,

            opacity: 1
        },
        seriesBorderDefaultColors: BoldBIDashboard.EjSvgRender.seriesPalette.greenGradient.borderColors,
        colors: BoldBIDashboard.EjSvgRender.seriesPalette.greenGradient.seriesColors
    },
    "saffron":
    {
        
        border: {

            color: 'transparent',

            width: 0,

            opacity: 0.3
        },
        seriesBorderDefaultColors: BoldBIDashboard.EjSvgRender.seriesPalette.sandleMetro,
        colors: BoldBIDashboard.EjSvgRender.seriesPalette.sandleMetro
    },

    "saffrondark":
    {
        
        border: {

            color: 'transparent',

            width: 0,

            opacity: 1
        },
        seriesBorderDefaultColors: BoldBIDashboard.EjSvgRender.seriesPalette.sandleMetro,
        colors: BoldBIDashboard.EjSvgRender.seriesPalette.sandleMetro
    },
    "gradient-saffron":
{
    
    border: {

        color: 'transparent',

        width: 0,

        opacity: 0.3
    },
    seriesBorderDefaultColors: BoldBIDashboard.EjSvgRender.seriesPalette.sandleGradient.borderColors,
    colors: BoldBIDashboard.EjSvgRender.seriesPalette.sandleGradient.seriesColors
},

    "gradient-saffrondark":
{
    border: {

        color: 'transparent',

        width: 0,

        opacity: 1
    },
    seriesBorderDefaultColors: BoldBIDashboard.EjSvgRender.seriesPalette.sandleGradient.borderColors,
    colors: BoldBIDashboard.EjSvgRender.seriesPalette.sandleGradient.seriesColors
}
});
})(bbdesigner$);;
BoldBIDashboard.axisTypes = {};

BoldBIDashboard.EjAxisRenderer = function () {
};
var _sideBySeriesPadding = function (chartObj, start, end, axis) {
    var visibleSeries = BoldBIDashboard.DataManager(chartObj.model._visibleSeries, BoldBIDashboard.Query().sortBy("_zOrder")).executeLocal();
    var isPadding = false;
    var data, startPadding, endPadding;
    var visibleSeriesLength = visibleSeries.length;
	var axisOrientation = axis.orientation.toLowerCase();
    for (var i = 0; i < visibleSeriesLength; i++) {
        var type = visibleSeries[i].type.toLowerCase();
        if (((type.indexOf("column") != -1 || type.indexOf("bar") != -1 || type.indexOf("waterfall") != -1 || type == "candle" || type.indexOf("hilo") != -1)))
        {
            isPadding = true;
            break;
        }

    }
    if (chartObj.model.AreaType != "polaraxes" && isPadding) {
        axis.m_minPointsDelta = undefined;
        var padding = BoldBIDashboard.EjSvgRender.utils.getMinPointsDelta(axis, chartObj, start) * 0.5;
        start = start - padding;
        end = end + padding;
        axis.padding = padding;
    }
    else
		axis.padding=0;
    return data = { startPadding: start, endPadding: end };
};
BoldBIDashboard.EjStripline = function (chartobj) {
    this.chart = chartobj;
};
(function (bbdesigner$) {
    BoldBIDashboard.EjAxisRenderer.prototype = {

        //Calculate min/max value for series
        _seriesMinMax: function (chartObj, axis, seriesCollection, type, params) {
     		var orientation = axis.orientation.toLowerCase(), seriesLength = seriesCollection.length;
			if (BoldBIDashboard.util.isNullOrUndefined(params.seriesCollection))
			    params.seriesCollection = {};
            var count;
            if ((seriesLength > 0 && seriesCollection[0].points.length > 0) || this.chartObj.model.indicators[0]._points.length>0) {

                var maxX, minY, minX, maxY;
                var maxMinXValue = { maxX: null, minX: null };
                var maxMinYValue = { maxY: null, minY: null };
                var xMax = maxMinXValue.maxX;
                var xMin = maxMinXValue.minX;
                var yMax = maxMinYValue.maxY;
                var yMin = maxMinYValue.minY;
                var seriesVisibility,pointsLength,visibleLength,seriesType;
				var yIndex = 0, yIndex1 = 1;
                for (var i = 0; i < seriesLength; i++) {
                    seriesVisibility = seriesCollection[i].visibility.toLowerCase();
                    pointsLength = seriesCollection[i].points.length;
                    count = 0;
                    if (seriesVisibility === 'visible') {
                        seriesCollection[i]._visiblePoints = [];
                        for (var j = 0; j < pointsLength; j++) {
                            var point = seriesCollection[i].points[j];
                            if ((point.x != null && point.x != undefined) && ((typeof point.y == "object" || !isNaN(point.y)) && (point.y != null && point.y != undefined) || point.showIntermediateSum || point.showTotalSum || point.isEmpty == false)) {
                                seriesCollection[i]._visiblePoints[count] = point;
                                count++;
                            }
                        }
                    }
                    if (!axis.maxPointLength || axis.maxPointLength < pointsLength)
                        axis.maxPointLength = pointsLength;
                }

                for (var i = 0; i < seriesLength; i++) {
                    visibleLength = seriesCollection[i]._visiblePoints.length;
					var series = seriesCollection[i];
                    if (visibleLength > 0) {
                        seriesVisibility = seriesCollection[i].visibility.toLowerCase();
                        pointsLength = seriesCollection[i].points.length;
                        if (seriesVisibility === 'visible' && pointsLength > 0) {
                            if ((orientation == "horizontal" && !(chartObj.model.requireInvertedAxes)) || (orientation == "vertical" && chartObj.model.requireInvertedAxes) ) {
                                minX = maxX = seriesCollection[i]._visiblePoints[0].xValue;
                                for (var j = 0; j < visibleLength; j++) {
                                    var currentPoint = seriesCollection[i]._visiblePoints[j].xValue;
                                    if (minX > currentPoint)
                                        minX = currentPoint;
                                    if (maxX < currentPoint)
                                        maxX = currentPoint;
                                }
                                seriesCollection[i].minX = minX;
                                seriesCollection[i].maxX = maxX;

                                if ((xMin === null || xMin === undefined) && visibleLength > 0) {
                                    xMax = seriesCollection[i].maxX;
                                    xMin = seriesCollection[i].minX;
                                }
                                if (xMin > seriesCollection[i].minX) {
                                    xMin = seriesCollection[i].minX;
                                }
                                if (xMax < seriesCollection[i].maxX) {
                                    xMax = seriesCollection[i].maxX;
                                }
                            }
                            else {
                                      var isSpline = (series.type.toLowerCase().indexOf('spline')!=-1), controlPoint, naturalSpline, naturalSpline1, getBezierControlPoints,splineVisiblePoints,									
									  controlPointsCount = 0, 
									  visiblePoints = seriesCollection[i]._visiblePoints;
								if(isSpline){
									var seriesKey = series._name = series.name || 'series' + i;									
									params.seriesCollection[seriesKey] = {};
									visiblePoints = BoldBIDashboard.ejSplineSeries.prototype._isVisiblePoints(series, chartObj);
                                    naturalSpline = params.seriesCollection[seriesKey].naturalSpline = BoldBIDashboard.ejSplineSeries.prototype.naturalSpline(visiblePoints, series,yIndex );
                                    if(series.type.toLowerCase() == "splinerangearea")
                                    naturalSpline1 = params.seriesCollection[seriesKey].naturalSpline1 = BoldBIDashboard.ejSplineSeries.prototype.naturalSpline(visiblePoints, series, yIndex1);
									params.seriesCollection[seriesKey].controlPoints = [];
									getBezierControlPoints = BoldBIDashboard.ejSplineSeries.prototype.getBezierControlPoints;	
									splineVisiblePoints=visiblePoints.filter(function(currentPt,index,array){
										return !BoldBIDashboard.isNullOrUndefined(currentPt.YValues[0])&&!isNaN(currentPt.YValues[0]);
									});		
									
                                }
                                if(visiblePoints.length > 0)
                                 maxY = minY = !isSpline ? visiblePoints[0].YValues[0] : splineVisiblePoints[0].YValues[0];
                                for (var j = 0; j < visiblePoints.length; j++) {
                                    var currentPoint = visiblePoints[j];
                                    if (seriesCollection[i]._hiloTypes && series.type.toLowerCase() != "splinerangearea") {
                                        for (var y = 0; y < 2; y++) {
                                            if (minY > currentPoint.YValues[y])
                                                minY = currentPoint.YValues[y];
                                            if (maxY < currentPoint.YValues[y])
                                                maxY = currentPoint.YValues[y];
                                        }
                                    }
									else if(isSpline){
										if(j!=0 && currentPoint.visible && visiblePoints[j-1].visible){											
											params.seriesCollection[seriesKey].controlPoints.push(getBezierControlPoints(visiblePoints[j-1], currentPoint, naturalSpline[j-1], naturalSpline[j], 0)); 
											if (series.type.toLowerCase() == "splinerangearea") {
                                                var lowPoints = getBezierControlPoints(visiblePoints[j - 1], currentPoint, naturalSpline1[j - 1], naturalSpline1[j], 1, series, this);
                                                params.seriesCollection[seriesKey].controlPoints[controlPointsCount].controlPoint1.YValues[1] = lowPoints.controlPoint1.YValues[0];
                                                params.seriesCollection[seriesKey].controlPoints[controlPointsCount].controlPoint2.YValues[1] = lowPoints.controlPoint2.YValues[0];
                                            }
											controlPoint = params.seriesCollection[seriesKey].controlPoints[controlPointsCount++];
											minY = Math.min(minY, currentPoint.YValues[0], controlPoint.controlPoint1.YValues[0], controlPoint.controlPoint2.YValues[0]);
											maxY = Math.max(maxY, currentPoint.YValues[0], controlPoint.controlPoint1.YValues[0], controlPoint.controlPoint2.YValues[0]);
											if (series.type.toLowerCase() == "splinerangearea") {
                                                minY = Math.min(minY, currentPoint.YValues[1], controlPoint.controlPoint1.YValues[1], controlPoint.controlPoint2.YValues[1]);
                                                maxY = Math.max(maxY, currentPoint.YValues[1], controlPoint.controlPoint1.YValues[1], controlPoint.controlPoint2.YValues[1]);
                                            }
										}
										else{
											if (j != 0 && (series.type.toLowerCase().indexOf("stacking") != -1 || series.type.toLowerCase() == "splinerangearea")) {
                                                params.seriesCollection[seriesKey].controlPoints.push(getBezierControlPoints(visiblePoints[j - 1], currentPoint, naturalSpline[j - 1], naturalSpline[j], 0, series, this));
                                                if (series.type.toLowerCase() == "splinerangearea") {
                                                    var lowPoints = getBezierControlPoints(visiblePoints[j - 1], currentPoint, naturalSpline1[j - 1], naturalSpline1[j], 1, series, this);
                                                    params.seriesCollection[seriesKey].controlPoints[controlPointsCount].controlPoint1.YValues[1] = lowPoints.controlPoint1.YValues[0];
                                                    params.seriesCollection[seriesKey].controlPoints[controlPointsCount].controlPoint2.YValues[1] = lowPoints.controlPoint2.YValues[0];
                                                }
                                                controlPoint = params.seriesCollection[seriesKey].controlPoints[controlPointsCount++];
                                            }
											minY = Math.min(minY, isNaN(currentPoint.YValues[0]) ? minY : currentPoint.YValues[0]);
											maxY = Math.max(maxY, isNaN(currentPoint.YValues[0]) ? maxY : currentPoint.YValues[0]);
											if (series.type.toLowerCase() == "splinerangearea") {
                                                minY = Math.min(minY, isNaN(currentPoint.YValues[1]) ? minY : (currentPoint.YValues[1] || null));
                                                maxY = Math.max(maxY, currentPoint.YValues[1] || null);
                                            }														
										}
									}
									else {
                                        if (minY > currentPoint.YValues[0])
                                            minY = currentPoint.YValues[0];
                                        if (maxY < currentPoint.YValues[0])
                                            maxY = currentPoint.YValues[0];
                                    }
                                }
                                seriesCollection[i].minY = minY;
                                seriesCollection[i].maxY = maxY;

                                if ((yMin === null || yMin === undefined) && visibleLength > 0) {
                                    yMax = seriesCollection[i].maxY;
                                    yMin = seriesCollection[i].minY;
                                }
                                if (yMin > seriesCollection[i].minY) {
                                    yMin = seriesCollection[i].minY;
                                }
                                if (yMax < seriesCollection[i].maxY) {
                                    yMax = seriesCollection[i].maxY;
                                }

                                // Finding Min and Max for Column and Bar series
                                seriesType = seriesCollection[i].type
                                if (seriesType == 'column' || seriesType == 'bar')
                                    yMin = (yMin < 0) ? yMin : 0;
                            }
                        }
                    }
                }
                if ((orientation == "horizontal" && !(chartObj.model.requireInvertedAxes)) || (orientation == "vertical" && chartObj.model.requireInvertedAxes)) {

                    // Find min/max for indicator series
                    if (this.chartObj.model.indicatorRange && this.chartObj.model.indicatorRange[axis.name]) {
                        var value = this.chartObj.model.indicatorRange[axis.name];
                        if (yMin > value.min || yMin == null)
                            yMin = value.min;
                        if (yMax < value.max || yMax == null)
                            yMax = value.max;                       
                    }

                    if (xMax == xMin)
                        xMax += 1;

                    if (type == "double") {
                        var data = _sideBySeriesPadding(chartObj, xMin, xMax, axis);
                        xMin = data.startPadding;
                        xMax = data.endPadding;
                        deltaX = xMax - xMin;
                        axis.range = this._getDoubleAutoRange(axis, xMin, xMax, deltaX);    
                    }                        
                    else
                        axis.range = this._getLogAutoRange(axis, xMin, xMax, xMax - xMin);

                }
                else {

                    // Find min/max for stacked series
                    if (this.chartObj.model.stackedValue[axis.name]) {
                        var value = this.chartObj.model.stackedValue[axis.name];
                        if (yMin > value.min)
                            yMin = value.min;
                        if (yMax < value.max)
                            yMax = value.max;
                    }

                    // Find min/max for indicator series
                    if (this.chartObj.model.indicatorRange && this.chartObj.model.indicatorRange[axis.name]) {
                        value = this.chartObj.model.indicatorRange[axis.name];
                        
                        if (yMin > value.min || yMin == null)
                            yMin = value.min;
                        if (yMax < value.max || yMax == null)
                            yMax = value.max;                        
                    }

                    if (yMax == yMin) {                   // max == min
                        if (yMax < 0)                                  // value less than 0
                            yMax = 0;
                        else if (yMax <= 1 && yMax > 0)   // value between 0 and 1
                            yMin = 0;
                        else {                                                      // value greater than 1
                            yMin = 0;
                            yMax += 1;
                        }
                    }

                    var deltaY = yMax - yMin;

                    if (type == "double")
                        axis.range = this._getDoubleAutoRange(axis, yMin, yMax, deltaY)
                    else
                        axis.range = this._getLogAutoRange(axis, yMin, yMax, deltaY)

                }
            }
            else {
                if (!axis.setRange){
                    axis.range = { min: 0, max: 5, interval: 1, Delta: 4 };
				}
				else {
                    min=( axis.range.min== null || axis.range.min == undefined )?0:axis.range.min;
                    max = (axis.range.max == null || axis.range.max == undefined) ? 5 : axis.range.max;
			        delta=max-min;
			        axis.range=this._getDoubleAutoRange(axis,min,max,delta)
				}
            }
			 var commonAxisEventArgs = bbdesigner$.extend({}, BoldBIDashboard.EjSvgRender.commonChartEventArgs);
            commonAxisEventArgs.data = { range: axis.range, axis: axis };
            this.chartObj._trigger("axesRangeCalculate", commonAxisEventArgs);
            var range = commonAxisEventArgs.data.range;
            axis.range = { min: range.min, max: range.max, interval: range.interval, delta: (range.max - range.min) };

        },

        //Calculate ranges for Trendline series
        _calculateTrendLineRange: function (chart, axis, seriesCollection) {            
            var series, trendlines, trendline, count, serLength, trendLength, trendlineType;
            var serLength = seriesCollection.length;
            for (var m = 0; m < serLength; m++) {
                series = seriesCollection[m];
                trendlines = series.trendlines;
                if (chart.model.AreaType == "cartesianaxes" && (axis.name == series._xAxisName || axis.name == series._yAxisName)) {
                    trendLength = trendlines.length;
                    for (var i = 0; i < trendLength; i++) {
                        trendline = trendlines[i];
                        if (trendline.visibility.toLowerCase() === 'visible') {                            
                            
                            if (axis.name == series._xAxisName) {
                                trendlineType = trendline.type.toLowerCase();
                                options = new BoldBIDashboard.trendlineTypes[trendlineType]();
                                options.calculateTrendLineSegment(series, trendline, axis, chart);
                            } else
                                if (axis.name == series._yAxisName && !axis.setRange && trendline.points && trendline.points.length > 1) {
                                    count = trendline.points.length - 1;
                                    axis.range.min = axis.range.min > trendline.minY ? trendline.minY : axis.range.min;
                                    axis.range.max = axis.range.max < trendline.maxY ? trendline.maxY : axis.range.max;
                                }
                        }
                    }
                }
            }
            return false;
        },

        AlignRangeStart: function (sDate, intervalSize, intervalType) {
            var sResult = new Date(sDate);
            if (intervalType.toLowerCase() == "days") {
                var day = Math.floor(Math.floor((sDate.getDate()) / intervalSize) * intervalSize);
                sResult = new Date(sDate.getFullYear(), sDate.getMonth(), day, 0, 0, 0);
            } else if (intervalType.toLowerCase() == "hours") {
                var hour = Math.floor(Math.floor((sDate.getHours()) / intervalSize) * intervalSize);
                sResult = new Date(sDate.getFullYear(), sDate.getMonth(), sDate.getDate(), hour, 0, 0);
            } else if (intervalType.toLowerCase() == "milliseconds") {
                var milliseconds = Math.floor(Math.floor((sDate.getMilliseconds()) / intervalSize) * intervalSize);
                sResult = new Date(sDate.getFullYear(), sDate.getMonth(), sDate.getDate(), sDate.getHours(), sDate.getMinutes(), sDate.getSeconds(), milliseconds);
            } else if (intervalType.toLowerCase() == "seconds") {
                var seconds = Math.floor(Math.floor((sDate.getSeconds()) / intervalSize) * intervalSize);
                sResult = new Date(sDate.getFullYear(), sDate.getMonth(), sDate.getDate(), sDate.getHours(), sDate.getMinutes(), seconds, 0);
            } else if (intervalType.toLowerCase() == "minutes") {
                var minutes = Math.floor(Math.floor((sDate.getMinutes()) / intervalSize) * intervalSize);
                sResult = new Date(sDate.getFullYear(), sDate.getMonth(), sDate.getDate(), sDate.getHours(), minutes, 0, 0);
            } else if (intervalType.toLowerCase() == "months") {
                var month = Math.floor(Math.floor((sDate.getMonth()) / intervalSize) * intervalSize);
                sResult = new Date(sDate.getFullYear(), month, sDate.getDate(), 0, 0, 0);
            } else if (intervalType.toLowerCase() == "years") {
                var year = Math.floor(Math.floor(sDate.getFullYear() / intervalSize) * intervalSize);
                sResult = new Date(year, sDate.getMonth(), sDate.getDate(), 0, 0, 0);
            }
            return sResult;
        },
        _increaseDateTimeInterval: function (date, interval, intervalType) {
            var result = new Date(date);
            if (intervalType.toLowerCase() == "days") {
                result.setDate(date.getDate() + interval);
            } else if (intervalType.toLowerCase() == "hours") {
                result.setHours(date.getHours() + interval);
            } else if (intervalType.toLowerCase() == "milliseconds") {
                result.setMilliseconds(date.getMilliseconds() + interval);
            } else if (intervalType.toLowerCase() == "seconds") {
                result.setSeconds(date.getSeconds() + interval);
            } else if (intervalType.toLowerCase() == "minutes") {
                result.setMinutes(date.getMinutes() + interval);
            } else if (intervalType.toLowerCase() == "months") {
                result.setMonth(date.getMonth() + interval);
            } else if (intervalType.toLowerCase() == "years") {
                result.setYear(date.getFullYear() + interval);
            }

            return result;
        },

        _calculatePadding: function (axis) {

            var start = (typeof axis.range.min == "string" && !isNaN(Date.parse(axis.range.min))) ? Date.parse(axis.range.min) : (axis.range.min).getTime();
            var end = (typeof axis.range.max == "string" && !isNaN(Date.parse(axis.range.max))) ? Date.parse(axis.range.max) : (axis.range.max).getTime();
            var interval = ((this._increaseDateTimeInterval(new Date(start), axis.range.interval, axis._intervalType)).getTime()) - start;
            var rangePadding =axis.rangePadding.toLowerCase();
            if (!this.chartObj.zoomed && !axis.setRange) {
                start = new Date(start);
                end = new Date(end);
                var intervalType = axis._intervalType.toLowerCase();
                if (axis.rangePadding.toLowerCase() == 'none') {
                start =  start.getTime();
                end = end.getTime();
            } else if (rangePadding == 'additional' || rangePadding == 'round') {
                switch (intervalType) {
                    case 'years':
                        var startYear = start.getFullYear();
                        var endYear = end.getFullYear();
                        if (axis.rangePadding.toLowerCase() == 'additional') {
                            start = (new Date(startYear - axis.range.interval, 1, 1, 0, 0, 0)).getTime();
                            end = (new Date(endYear + axis.range.interval, 1, 1, 0, 0, 0)).getTime();
                        } else {
                            start = new Date(startYear, 0, 0, 0, 0, 0).getTime();
                            end=new Date(endYear, 11, 30, 23, 59, 59).getTime();
                        }
                        break;
                    case 'months':                        
                        var month = start.getMonth();
                        var endMonth = end.getMonth();
                        if (rangePadding == 'round') {
                            start = (new Date(start.getFullYear(), month, 0, 0, 0, 0)).getTime();
                            end = (new Date(end.getFullYear(), endMonth, new Date(end.getFullYear(), end.getMonth(), 0).getDate(), 23, 59, 59)).getTime();
                        } else {
                            start = (new Date(start.getFullYear(), month + (-axis.range.interval), 1, 0, 0, 0)).getTime();
                            end = (new Date(end.getFullYear(), endMonth + (axis.range.interval), endMonth == 2 ? 28 : 30, 0, 0, 0)).getTime();
                        }
                        break;
                    case 'days':
                        var day = start.getDate();
                        var endDay = end.getDate();
                        if (rangePadding == 'round') {
                            start = (new Date(start.getFullYear(), start.getMonth(), day, 0, 0, 0)).getTime();
                            end = (new Date(end.getFullYear(), end.getMonth(), endDay, 23, 59, 59)).getTime();
                        } else {
                            start = (new Date(start.getFullYear(), start.getMonth(), day + (-axis.range.interval), 0, 0, 0)).getTime();
                            end = (new Date(end.getFullYear(), end.getMonth(), endDay + (axis.range.interval), 0, 0, 0)).getTime();
                        }
                        break;
                    case 'hours':
                        var hour = (start.getHours() / axis.range.interval) * axis.range.interval;
                        var endHour = end.getHours() + (start.getHours() - hour);
                        if (rangePadding == 'round') {
                            start = (new Date(start.getFullYear(), start.getMonth(), start.getDay(), hour, 0, 0)).getTime();
                            end = (new Date(end.getFullYear(), end.getMonth(), end.getDay(), endHour, 59, 59)).getTime();
                        } else {
                            start = (new Date(start.getFullYear(), start.getMonth(), start.getDay(), hour + (-axis.range.interval), 0, 0)).getTime();
                            end = (new Date(end.getFullYear(), end.getMonth(), end.getDay(), endHour + (axis.range.interval), 0, 0)).getTime();
                        }
                        break;
                    case 'minutes':
                        var minute = (start.getMinutes() / axis.range.interval) * axis.range.interval;
                        var endMinute = end.getMinutes() + (start.getMinutes() - minute);
                        if (rangePadding == 'round') {
                            start = (new Date(start.getFullYear(), start.getMonth(), start.getDay(), start.getHour(), minute, 0)).getTime();
                            end = (new Date(end.getFullYear(), end.getMonth(), end.getDay(), end.getHour(), endMinute, 59)).getTime();
                        } else {
                            start = (new Date(start.getFullYear(), start.getMonth(), start.getDay(), start.getHours(), minute + (-axis.range.interval), 0)).getTime();
                            end = (new Date(end.getFullYear(), end.getMonth(), end.getDay(), end.getHours(), minute + (axis.range.interval), 0)).getTime();
                        }
                        break;
                    case 'seconds':
                        var second = (start.getSeconds() / axis.range.interval) * axis.range.interval;
                        var endSecond = end.getSeconds() + (start.getSeconds() - second);
                        if (rangePadding == 'round') {
                            start = (new Date(start.getFullYear(), start.getMonth(), start.getDay(), start.getHours(), start.getMinutes(), second, 0)).getTime();
                            end = (new Date(end.getFullYear(), end.getMonth(), end.getDay(), end.getHour(), end.getMinutes(), endSecond, 0)).getTime();
                        } else {
                            start = (new Date(start.getFullYear(), start.getMonth(), start.getDay(), start.getHours(), start.getMinutes(), second + (-axis.range.interval), 0)).getTime();
                            end = (new Date(end.getFullYear(), end.getMonth(), end.getDay(), end.getHours(), end.getMinutes(), endSecond + (axis.range.interval), 0)).getTime();
                        }
                        break;
                    case 'milliseconds':
                        var milliSecond = (start.getMilliseconds() / axis.range.interval) * axis.range.interval;
                        var endMilliSecond = end.getMilliseconds() + (start.getMilliseconds() - milliSecond);
                        if (rangePadding == 'round') {
                            start = (new Date(start.getFullYear(), start.getMonth(), start.getDay(), start.getHours(), start.getMinutes(), start.getSeconds(), milliSecond)).getTime();
                            end = (new Date(end.getFullYear(), end.getMonth(), end.getDay(), end.getHours(), end.getMinutes(), end.getSeconds(), endMilliSecond)).getTime();
                        } else {
                            start = (new Date(start.getFullYear(), start.getMonth(), start.getDay(), start.getHours(), start.getMinutes(), start.getSeconds(), milliSecond + (-axis.range.interval))).getTime();
                            end = (new Date(end.getFullYear(), end.getMonth(), end.getDay(), end.getHours(), end.getMinutes(), end.getSeconds(), endMilliSecond + (axis.range.interval))).getTime();
                        }
                        break;
                }

            }

        }
        axis.actualRange.interval = interval;
        axis.actualRange.min = start;
        axis.actualRange.max = end;
        axis._interval = axis.range.interval;
        axis.actualRange.delta = (axis.actualRange.max - axis.actualRange.min);
        axis.range.min = new Date(start);
        axis.range.max = new Date(end);
        this._calculateVisibleRange(axis);

    },
    _calculateVisibleRange: function (axis, sender, isScroll) {
        this.chartObj = sender ? sender : this.chartObj;
        axis.visibleRange = (!isScroll) ? bbdesigner$.extend(true, {}, axis.actualRange) : axis.visibleRange;
        if ((axis.zoomFactor < 1 || axis.zoomPosition > 0) && this.chartObj.model.AreaType != "polaraxes" && !this.chartObj.model.disableZoom) {

            axis.zoomFactor = axis.zoomFactor > 1 ? 1 : (axis.zoomFactor < 0 ? 0 : axis.zoomFactor);
            axis.zoomPosition = axis.zoomPosition < 0 ? 0 : (axis.zoomPosition > 1 ? 1 : axis.zoomPosition);
            var baseRange = axis.actualRange;
            if (axis.isInversed) {
                var start = axis.actualRange.max - axis.zoomPosition * axis.actualRange.delta;
                var end = start - axis.zoomFactor * axis.actualRange.delta;
            }
            else {
                var start = axis.actualRange.min + axis.zoomPosition * axis.actualRange.delta;
                var end = start + axis.zoomFactor * axis.actualRange.delta;
            }

            if (start < baseRange.min) {
                end = end + (baseRange.min - start);
                start = baseRange.min;
            }

            if (end > baseRange.max) {
                start = start - (end - baseRange.max);
                end = baseRange.max;
            }

            var startDate = new Date(start);
            var endDate = new Date(end);
			 if (start == end)
            {
                startDate = new Date(Date.parse(startDate) - 2592000000);
                endDate = new Date(Date.parse(endDate) + 2592000000);
            }
            //Use below code to find min,max and interval for visible range
			 var min = Math.min(startDate.getTime(), endDate.getTime());
			 var max = Math.max(startDate.getTime(), endDate.getTime());
			 var intervalX = axis.enableAutoIntervalOnZooming ? this.calculateDateTimeNiceInterval(axis, startDate, endDate) : { 'interval': axis._interval, 'intervalType': axis._intervalType };
			 var interval = ((this._increaseDateTimeInterval(startDate, intervalX.interval, intervalX.intervalType)).getTime()) - min;

			 if (isScroll) {
			     return {min:min, max:max, interval:interval};
			 }
			 else {
			     axis._intervalType = intervalX.intervalType;
			     axis.visibleRange.min = min;
			     axis.visibleRange.max = max;
			     axis.visibleRange.interval = interval;
			     axis.visibleRange.delta = Math.abs(axis.visibleRange.max - axis.visibleRange.min);
			     axis._interval = intervalX.interval;
			 }
        }

    },
    _calculateAxisLabels: function (axis) {
        var position,text;
		var minRange = axis.enableAutoIntervalOnZooming ? axis.visibleRange.min : axis.actualRange.min;
        if (this.chartObj.zoomed || axis.zoomed || !axis.setRange)
            position = (this.AlignRangeStart(new Date(minRange), axis._interval, axis._intervalType)).getTime();

        else
            position = axis.visibleRange.min;
        while (position <= axis.visibleRange.max) {
            if (position >= axis.visibleRange.min && position <= axis.visibleRange.max) {
                text=(BoldBIDashboard.format(new Date(position), ((!(axis.labelFormat)) ? BoldBIDashboard.EjSvgRender.utils._dateTimeLabelFormat(axis._intervalType) : axis.labelFormat)));
				 var commonAxesEventArgs = bbdesigner$.extend({}, BoldBIDashboard.EjSvgRender.commonChartEventArgs);
				 commonAxesEventArgs.data = { label: { Text: text, Value: position }, axis: axis };
                this.chartObj._trigger("axesLabelRendering", commonAxesEventArgs);
                axis.visibleLabels.push({ Value: position, Text: commonAxesEventArgs.data.label.Text });
            }
            position = (this._increaseDateTimeInterval(new Date(position), axis._interval, axis._intervalType)).getTime();
            
            axis.visibleLabels[axis.visibleLabels.length - 1] = axis.visibleLabels[axis.visibleLabels.length-1];
        }
        axis._LableMaxWidth = BoldBIDashboard.EjSvgRender.utils._getMaxLabelWidth(axis, this.chartObj);
		if (axis.isAllXValuesNull)
            axis.visibleLabels = [];
    },
    calculateDateTimeNiceInterval: function (axis, startDate, endDate) { 
        var oneDay = 24 * 60 * 60 * 1000;
        //var axisInterval ;
        var totalDays = (Math.abs((startDate.getTime() - endDate.getTime()) / (oneDay)));
        var interval = this.calculateNumericNiceInterval(totalDays / 365, axis, "years");

        if (interval >= 1) {
            return { interval: interval, intervalType: "Years" };
        }

        interval = this.calculateNumericNiceInterval(totalDays / 30, axis, "months");

        if (interval >= 1) {
            return { interval: interval, intervalType: "Months" };
        }

        interval = this.calculateNumericNiceInterval(totalDays, axis, "days");

        if (interval >= 1) {


            return { interval: interval, intervalType: "Days" };
        }

        var totalHours = totalDays * 24;

        interval = this.calculateNumericNiceInterval(totalHours, axis, "hours");

        if (interval >= 1) {

            return { interval: interval, intervalType: "Hours" };
        }

        var totalMinutes = totalDays * 24 * 60;

        interval = this.calculateNumericNiceInterval(totalMinutes, axis, "minutes");

        if (interval >= 1) {

            return { interval: interval, intervalType: "Minutes" };
        }

        var totalSeconds = totalDays * 24 * 60 * 60;

        interval = this.calculateNumericNiceInterval(totalSeconds, axis, "seconds");

        if (interval >= 1) {

            return { interval: interval, intervalType: "Seconds" };
        }

        var totalMilliseconds = totalDays * 24 * 60 * 60 * 1000;

        interval = this.calculateNumericNiceInterval(totalMilliseconds, axis, "milliseconds");

        if (interval >= 1) {

            return { interval: interval, intervalType: "Milliseconds" };
        }

    },
    calculateNumericNiceInterval: function (delta, axis, setInterval) {
        var desiredIntervalsCount = this.GetActualDesiredIntervalsCount(axis, axis.length);
        var niceInterval = delta / desiredIntervalsCount;
        if (axis._valueType=='double'){
            if (axis.desiredIntervals!= null)
                return niceInterval;
        }
        var minInterval = Math.pow(10, Math.floor(BoldBIDashboard.EjSvgRender.utils._logBase(niceInterval, 10)));
        var intervalDivs = [10, 5, 2, 1];

        for (var i = 0; i < intervalDivs.length; i++) {
            var currentInterval = minInterval * intervalDivs[i];
            if (desiredIntervalsCount < (delta / currentInterval)) {
                if ((axis.intervalType) && axis._valueType == "datetime") {
                    niceInterval=(axis.intervalType.toLowerCase() == setInterval)?Math.ceil(niceInterval):niceInterval;
                }
                return niceInterval;
            }

            niceInterval = currentInterval;
        }

        return niceInterval;
    },
    GetActualDesiredIntervalsCount: function (axis, size) {
        if (BoldBIDashboard.util.isNullOrUndefined(axis.desiredIntervals)) {
            var desiredIntervalsCount = (axis.orientation.toLowerCase() == "horizontal" ? 0.533 : 1) * axis.maximumLabels;
            desiredIntervalsCount = Math.max((size * (desiredIntervalsCount / 100)), 1);
        
                return desiredIntervalsCount;
            } else {
                return axis.desiredIntervals;
            }
        },
        _calculateRange: function (axis, seriesCollection) {
            if (!this.chartObj.zoomed) {
                var defaultDate = new Date();
                if (seriesCollection.length > 0 && seriesCollection[0].points.length > 0 || this.chartObj.model.indicators[0]._points.length > 0) {
                    var maxX, minY;
                    var maxY, minX;
                    var maxMinXValue = { maxX: null, minX: null };
                    var maxMinYValue = { maxY: null, minY: null };
                    var pointLength;
                    for (var i = 0; i < seriesCollection.length; i++) {
                        pointLength = seriesCollection[i].points.length;
                        if (pointLength > 0) {
                            if (seriesCollection[i].visibility.toLowerCase() === 'visible' && seriesCollection[i].points.length > 0) {
                                minX = maxX = seriesCollection[i].points[0].xValue;
                                maxY = minY = seriesCollection[i].points[0].YValues[0];                                
                                for (var j = 0; j < pointLength; j++) {
                                    if (minX != null && minX != undefined) {
                                        if (minX > seriesCollection[i].points[j].xValue)
                                            minX = seriesCollection[i].points[j].xValue;
                                        if (maxX < seriesCollection[i].points[j].xValue)
                                            maxX = seriesCollection[i].points[j].xValue;
                                    }
                                    else {
                                         minX = maxX = seriesCollection[i].points[j+1]?seriesCollection[i].points[j+1].xValue:null;
                                    }
                                    if (minY > seriesCollection[i].points[j].YValues[0])
                                        minY = seriesCollection[i].points[j].YValues[0];
                                    if (maxY < seriesCollection[i].points[j].YValues[0])
                                        maxY = seriesCollection[i].points[j].YValues[0];
                                }
                                seriesCollection[i].minX = minX;
                                seriesCollection[i].maxX = maxX;
                                seriesCollection[i].minY = minY;
                                seriesCollection[i].maxY = maxY;
                                if (!axis.maxPointLength || axis.maxPointLength < pointLength)
                                    axis.maxPointLength = pointLength;
                            }
                        }
                    
                    if ((maxMinXValue.minX = (maxMinXValue.minX == null  && typeof seriesCollection[i].minX != "number") ? seriesCollection[i].minX : maxMinXValue.minX) > seriesCollection[i].minX) {
                            maxMinXValue.minX = (typeof seriesCollection[i].minX != "number") ? seriesCollection[i].minX : maxMinXValue.minX;
                        }
                        if ((maxMinXValue.maxX = (maxMinXValue.maxX == null && typeof seriesCollection[i].maxX != "number") ? seriesCollection[i].maxX : maxMinXValue.maxX) < seriesCollection[i].maxX) {
                            maxMinXValue.maxX = (typeof seriesCollection[i].maxX != "number") ? seriesCollection[i].maxX : maxMinXValue.maxX;
                        }
                        if (maxMinYValue.minY > seriesCollection[i].minY) {
                            maxMinYValue.minY = seriesCollection[i].minY;
                        }
                        if (maxMinYValue.maxY < seriesCollection[i].maxY) {
                            maxMinYValue.maxY = seriesCollection[i].maxY;
                        }
               
                }
				// Find min/max for indicator series

                  if (this.chartObj.model.indicatorRange && this.chartObj.model.indicatorRange[axis.name]) {
                    var value = this.chartObj.model.indicatorRange[axis.name];
                    if (maxMinXValue.minX > new Date(value.min) || maxMinXValue.minX == null)
                        maxMinXValue.minX = new Date(value.min);
                    if (maxMinXValue.maxX < new Date(value.max) || maxMinXValue.maxX == null)
                        maxMinXValue.maxX = new Date(value.max);
                 }
				if (maxMinXValue.minX == maxMinXValue.maxX && BoldBIDashboard.util.isNullOrUndefined(maxMinXValue.minX && maxMinXValue.maxX))
                    axis.isAllXValuesNull = true; 
                maxMinXValue.minX = (maxMinXValue.minX == null) ? defaultDate : maxMinXValue.minX;
                maxMinXValue.maxX = (maxMinXValue.maxX == null) ? new Date(new Date().setMonth(defaultDate.getMonth() + 5)) : maxMinXValue.maxX;
                if (maxMinXValue.minX == maxMinXValue.maxX) {
                    maxMinXValue.minX = new Date(Date.parse(maxMinXValue.minX) - 2592000000);
                    maxMinXValue.maxX = new Date(Date.parse(maxMinXValue.maxX) + 2592000000);
                }

                var data = _sideBySeriesPadding(this.chartObj, Date.parse(maxMinXValue.minX), Date.parse(maxMinXValue.maxX), axis);
                maxMinXValue.minX = new Date(data.startPadding);
                maxMinXValue.maxX = new Date(data.endPadding);

                

                var intervalX = this.calculateDateTimeNiceInterval(axis, maxMinXValue.minX, maxMinXValue.maxX);                
                axis._intervalType = (axis.intervalType) ? axis.intervalType : intervalX.intervalType;
               if (axis.intervalType == "auto")
                    axis._intervalType = axis.intervalType = intervalX.intervalType;
                if (axis.setAxisInterval == null || axis.setAxisInterval==undefined) {
                    axis.setAxisInterval = (axis.range && axis.range.interval) ? true : false;
                }

                if ((!axis.setRange)) {
                    axis.range = { min: maxMinXValue.minX, max: maxMinXValue.maxX, interval: intervalX.interval };
                } else {
                    if (axis.actual_Range== null ||axis.actual_Range== undefined) {
                        if (!axis.range.max)
                            axis.range.max = maxMinXValue.maxX;
                        if (!axis.range.min)
                            axis.range.min = maxMinXValue.minX;
                        if (typeof axis.range.min == "string" && axis.range.min.indexOf("/Date(") != -1)
                            axis.range.min = new Date(parseInt(axis.range.min.substr(6)));
                        if (typeof axis.range.max == "string" && axis.range.max.indexOf("/Date(") != -1)
                            axis.range.max = new Date(parseInt(axis.range.max.substr(6)));
                        if ( new Date(axis.range.min).getTime() ==  new Date(axis.range.max).getTime()) {                            
                            axis.range.max = new Date(Date.parse(axis.range.max) + 86400000);
                        }
                        var intervalX = this.calculateDateTimeNiceInterval(axis, new Date(axis.range.min), new Date(axis.range.max));
                        axis._intervalType = (axis.intervalType) ? axis.intervalType : intervalX.intervalType;
                        if (!axis.setAxisInterval)
                            axis.range.interval = intervalX.interval;
                        axis.actual_Range = bbdesigner$.extend(true, {}, axis.range);
                        axis.setRange = true;
                    }
                    axis.range = { min: axis.actual_Range.min, max: axis.actual_Range.max, interval: axis.actual_Range.interval };
                  }
                } else {
                    if (!axis.setRange) {
                        axis.range = { min: defaultDate, max: new Date(new Date().setMonth(defaultDate.getMonth() + 5)), interval: 1 };
                        axis._intervalType = 'Months';
                    }
					else {
                        axis.range.min=( axis.range.min === null || axis.range.min === undefined) ?defaultDate:axis.range.min;
                        axis.range.max=(axis.range.max === null || axis.range.max=== undefined)?new Date(new Date().setMonth(defaultDate.getMonth() + 5)):axis.range.max;
                        axis.range.interval = (axis.range.interval === null || axis.range.interval === undefined) ? 1 : axis.range.interval;
			            axis._intervalType='Months';
                    }

                }
				 var commonAxisEventArgs = bbdesigner$.extend({}, BoldBIDashboard.EjSvgRender.commonChartEventArgs);
                commonAxisEventArgs.data = { range: axis.range, axis: axis };
                this.chartObj._trigger("axesRangeCalculate", commonAxisEventArgs);
                var range = commonAxisEventArgs.data.range;
                axis.range = { min: range.min, max: range.max, interval: range.interval, delta: (range.max - range.min) };

            }
        },
        _calculateRanges: function (chartObj, axis, seriesCollection) {

            this.chartObj = chartObj;
			this._saveRange(chartObj, axis);
            this._calculateRange(axis, seriesCollection);
			axis._range = axis.range;
            if (chartObj.model._drawTrendline)
                this._calculateTrendLineRange(chartObj, axis, seriesCollection);

            this._calculatePadding(axis);

        this._calculateAxisLabels(axis);
    },
		_saveRange: function (chartObj, axis) {
            if (chartObj.zoomed || chartObj.resetZooming)
                axis.range = axis._range;
            //To check range is set in while redrawing the chart
            if (axis._initialRange) {
                if (axis._initialRange != axis.range && axis.range != null)
                    axis.setRange = true;
                else if (axis.range == null)
                    axis.setRange = false;
            }
            if (!chartObj.zoomed && !chartObj.resetZooming)
                axis._initialRange = axis.range == null ? { min: null, max: null, interval: null } : { min: axis.range.min, max: axis.range.max, interval: axis.range.interval };
        }
};

function ejExtendClass(parent, members) {
    var object = function () {
    };
    object.prototype = new parent();
    bbdesigner$.extend(object.prototype, members);
    return object;
}

//DateTime calculation
var ejDateTimeValue = ejExtendClass(BoldBIDashboard.EjAxisRenderer);
BoldBIDashboard.axisTypes.datetime = ejDateTimeValue;

var ejDoubleValue = ejExtendClass(BoldBIDashboard.EjAxisRenderer, {
    
  
    _calculateRange: function (chartObj, axis, seriesCollection, params) {
        if (!chartObj.zoomed) {
            this._seriesMinMax(chartObj,axis, seriesCollection, "double", params);
        }
    },
    
    _getDoubleAutoRange: function (axis, min, max) {
        var delta;
        var interval;
        if (!axis.setRange) {
            axis.range = { min: min, max: max};

        } else {
           
            if (BoldBIDashboard.util.isNullOrUndefined(axis.range.max))
                       axis.range.max = max;          
            if (BoldBIDashboard.util.isNullOrUndefined(axis.range.min))
                       axis.range.min = min;
     
            axis.actual_Range = bbdesigner$.extend(true, {}, axis.range);
            axis.setRange = true;
        }
        delta = axis.range.max - axis.range.min;
        interval = this.calculateNumericNiceInterval(delta, axis);
        if ((BoldBIDashboard.util.isNullOrUndefined(axis.range.interval))||(axis.range.interval<0))
            axis.range.interval = interval;
        axis.range.delta = delta;

        return axis.range;
    },
    _calculatePadding: function (chartObj, axis, baseRange) {
        var start = baseRange.min;
        var end = baseRange.max;
        var rangePadding = axis.rangePadding.toLowerCase();
        var interval= baseRange.interval;
		var setMinRange = axis._initialRange.min != null && axis._initialRange.max == null ? true : false; //JS-64032 && JS-64136
        if ((!axis.setRange ||setMinRange ) && (!chartObj.zoomed)) {
               
            if (rangePadding == 'normal') {
                var minimum = 0, remaining;
                if (start < 0) {
                    start = setMinRange ? start : 0;
                    minimum = baseRange.min + (baseRange.min / 20);

                    remaining =  interval + (minimum %  interval);

                    if ((0.365 *  interval) >= remaining) {
                        minimum -= interval;
                    }

                    if (minimum %  interval < 0) {
                        minimum = (minimum -  interval) - (minimum % interval);
                    }
                } else {
                    minimum = start < ((5.0 / 6.0) * end)
                        ? 0
                        : (start - (end - start) / 2);
                    if (minimum %  interval > 0) {
                        minimum -= (minimum %  interval);
                    }
                }
				minimum = setMinRange ? start : minimum;
                if (end > 0)
                    var maximum = (end + (end - start) / 20);
                else
                    var maximum = (end - (end - start) / 20);

                remaining = interval - (maximum % interval);

                if ((0.365 *  interval) >= remaining) {
                    maximum +=  interval;
                }

                if (maximum %  interval > 0) {
                    maximum = (maximum +  interval) - (maximum % interval);
                }
                 if (minimum <= 0) {
                    interval = this.calculateNumericNiceInterval(maximum - minimum, axis);
                    maximum = Math.ceil(maximum / interval) * interval;
                }
                start = (!(axis.roundingPlaces)) ? parseFloat(minimum.toFixed((BoldBIDashboard.EjSvgRender.utils._decimalPlaces(interval) == 0 ? 1 : BoldBIDashboard.EjSvgRender.utils._decimalPlaces(interval)))) : parseFloat(minimum.toFixed(axis.roundingPlaces));
                end = (!(axis.roundingPlaces)) ? parseFloat(maximum.toFixed((BoldBIDashboard.EjSvgRender.utils._decimalPlaces(interval) == 0 ? 1 : BoldBIDashboard.EjSvgRender.utils._decimalPlaces(interval)))) : parseFloat(maximum.toFixed(axis.roundingPlaces));

            } else if (rangePadding == 'additional' || rangePadding == 'round') {
                start = setMinRange ? start : Math.floor(start / interval) * interval;
                end = Math.ceil(end / interval) * interval;
                if (rangePadding == 'additional') {
                    start = setMinRange ? start : start - interval;
                    end +=  interval;
                }
            }


        }
        axis.actualRange.min = start;
        axis.actualRange.max = end;
        axis.actualRange.interval = interval;
        axis.range.min = start;
        axis.range.max = end;
        axis.range.interval =  interval;
        axis.actualRange.delta = end - start;
        this._calculateVisibleRange(axis);
    },
    _calculateVisibleRange: function (axis, sender, isScroll) {
        this.chartObj = sender ? sender : this.chartObj;
        axis.visibleRange = (!isScroll) ? bbdesigner$.extend(true, {}, axis.actualRange) : axis.visibleRange;
        if ((axis.zoomFactor < 1 || axis.zoomPosition > 0) && this.chartObj.model.AreaType != "polaraxes" && !this.chartObj.model.disableZoom) {
            var baseRange = axis.actualRange;

            axis.zoomFactor = axis.zoomFactor > 1 ? 1 : (axis.zoomFactor < 0 ? 0 : axis.zoomFactor);
            axis.zoomPosition = axis.zoomPosition < 0 ? 0 : (axis.zoomPosition > 1 ? 1 : axis.zoomPosition);
            if (axis.isInversed) {
                var start=axis.actualRange.max - axis.zoomPosition * axis.actualRange.delta;
                var end = start - axis.zoomFactor * axis.actualRange.delta;
            }
            else {
                var start = axis.actualRange.min + axis.zoomPosition * axis.actualRange.delta;
                var end = start + axis.zoomFactor * axis.actualRange.delta;
            }

            if (start < baseRange.min) {
                end = end + (baseRange.min - start);
                start = baseRange.min;
            }

            if (end > baseRange.max) {
                start = start - (end - baseRange.max);
                end = baseRange.max;
            }
          
            var delta =Math.abs(end-start);
            var interval = axis.enableAutoIntervalOnZooming ? this.calculateNumericNiceInterval(delta, axis) : axis.actualRange.interval;
            var factor = (BoldBIDashboard.util.isNullOrUndefined(axis.roundingPlaces)) ? (BoldBIDashboard.EjSvgRender.utils._decimalPlaces(interval) == 0 ? 1 : BoldBIDashboard.EjSvgRender.utils._decimalPlaces(interval)) : axis.roundingPlaces;
            interval = parseFloat(interval.toFixed(factor));
            if (isScroll) {
                return { min: Math.min(start, end), max: Math.max(start, end), delta: delta, interval: interval };
            }
            else {                
                axis.visibleRange.min = Math.min(start, end);
                axis.visibleRange.max = Math.max(start, end);
                axis.visibleRange.delta = delta;
                axis.visibleRange.interval = interval;
                axis.zoomed = (this.chartObj.zoomed === null || this.chartObj.zoomed === undefined) ? true : this.chartObj.zoomed;
            }
        }

    },
    _calculateAxisLabels: function (chartObj, currentAxis) {

        var tempInterval,
            customFormat,
             round = currentAxis.roundingPlaces,
             tempPlace,
            commonAxesEventArgs,
            labelText;
		if (chartObj.zoomed || currentAxis.zoomed || currentAxis.padding)
            tempInterval = currentAxis.visibleRange.min - (currentAxis.visibleRange.min % currentAxis.visibleRange.interval);
		else
            tempInterval = currentAxis.visibleRange.min;
        for (; tempInterval <= currentAxis.visibleRange.max; tempInterval += currentAxis.visibleRange.interval) {          

            if (BoldBIDashboard.EjSvgRender.utils._inside(tempInterval, currentAxis.visibleRange)) {
                tempPlace = (tempInterval.toString().split(0).length - 1 > 10) ? 10 : 20;
                tempInterval = parseFloat(tempInterval.toFixed((!round && round > tempPlace) ? round : tempPlace));
                labelText = (!(round)) ? parseFloat(tempInterval.toFixed((BoldBIDashboard.EjSvgRender.utils._decimalPlaces(currentAxis.visibleRange.interval) == 0 ? 1 : BoldBIDashboard.EjSvgRender.utils._decimalPlaces(currentAxis.visibleRange.interval)))) : parseFloat(tempInterval.toFixed(round));
                
                customFormat = currentAxis.labelFormat;
                labelText = (!(customFormat)) ? (!currentAxis.isStacked100 ? labelText : labelText + "%") : (customFormat.match('{value}') != null ? customFormat.replace('{value}', labelText) : BoldBIDashboard.format(labelText, customFormat));
				 // customize label by event
                commonAxesEventArgs = bbdesigner$.extend({}, BoldBIDashboard.EjSvgRender.commonChartEventArgs);
                commonAxesEventArgs.data = { label: { Text: labelText, Value: tempInterval }, axis: currentAxis };
                chartObj._trigger("axesLabelRendering", commonAxesEventArgs); 
                currentAxis.visibleLabels.push({ Value: tempInterval, Text: commonAxesEventArgs.data.label.Text });
       
            }
        }

        currentAxis._LableMaxWidth = BoldBIDashboard.EjSvgRender.utils._getMaxLabelWidth(currentAxis, this.chartObj);

    },

    _calculateRanges: function (chartObj, axis, seriesCollection, params) {
        this.chartObj = chartObj;
		this._saveRange(chartObj, axis);
        this._calculateRange(chartObj, axis, seriesCollection, params);
		axis._range = axis.range;
        if (chartObj.model._drawTrendline)
            this._calculateTrendLineRange(chartObj, axis, seriesCollection);

        this._calculatePadding(chartObj, axis, axis.range);

        if(axis.maximumLabels > 0)  // to calculate only if labels have to be displayed
        this._calculateAxisLabels(chartObj, axis);

    }
});
BoldBIDashboard.axisTypes.double = ejDoubleValue;
//log axis
var ejLogValue = ejExtendClass(BoldBIDashboard.EjAxisRenderer, {
    
    // Get value for log min and max
   _getRoundValue:function (x,div,up)
    {
        return (up ? Math.ceil(x / div) : Math.floor(x / div)) * div;
   },
   
   // Caculate log nice interval
  calculateLogNiceInterval: function (delta, axis) {
       var desiredIntervalsCount = this.GetActualDesiredIntervalsCount(axis, axis.length);
       var niceInterval = delta;
       var minInterval = Math.pow(10, Math.floor(BoldBIDashboard.EjSvgRender.utils._logBase(niceInterval, 10)));
       var intervalDivs = [10, 5, 2, 1];

       for (var i = 0; i < intervalDivs.length; i++) {
           var currentInterval = minInterval * intervalDivs[i];
           if (desiredIntervalsCount < (delta / currentInterval)) {
               return niceInterval;
           }

           niceInterval = currentInterval;
       }

       return niceInterval;
  },
   
    // Get log value for auto range
    _getLogAutoRange: function (axis, min, max, delta) {
        
        var logStart = BoldBIDashboard.EjSvgRender.utils._logBase(min, axis.logBase);
        logStart = bbdesigner$.isNumeric(logStart) ? logStart : min;
        var logEnd = BoldBIDashboard.EjSvgRender.utils._logBase(max, axis.logBase);
        logEnd = bbdesigner$.isNumeric(logEnd) ? logEnd : max;
     
        var mulS = this._getRoundValue(logStart, 1, false);
        var mulE = this._getRoundValue(logEnd, 1, true);
        if (mulS == 0 && mulE == 0) {
            mulS = BoldBIDashboard.EjSvgRender.utils._logBase((max - max / 2), axis.logBase);
            mulE = BoldBIDashboard.EjSvgRender.utils._logBase((max + max / 2), axis.logBase);
        }
        delta = mulE - mulS;
        var interval = this.calculateLogNiceInterval(delta, axis);

        axis.actual_Range = { min: mulS, max: mulE, interval: interval, Delta: delta };

        mulS = Math.pow(axis.logBase, Math.floor(logStart));
        mulE = Math.pow(axis.logBase, Math.ceil(logEnd));

        delta = mulE - mulS;        
      
        if (!axis.setRange) {        
          
            return axis.range = { min: mulS, max: mulE, interval: interval, Delta: delta };

        } else {
            if (BoldBIDashboard.util.isNullOrUndefined(axis.range.interval))
                axis.range.interval = interval;
            if (BoldBIDashboard.util.isNullOrUndefined(axis.range.max))
                axis.range.max = mulE;
            if (BoldBIDashboard.util.isNullOrUndefined(axis.range.min))
                axis.range.min = mulS;

            axis.actual_Range = bbdesigner$.extend(true, {}, axis.range);

            if (!BoldBIDashboard.util.isNullOrUndefined(axis.actual_Range.max)) {
                axis.actual_Range.max = BoldBIDashboard.EjSvgRender.utils._logBase(axis.actual_Range.max, axis.logBase);
                axis.actual_Range.max = this._getRoundValue(axis.actual_Range.max, 1, true);
            }               
            if (!BoldBIDashboard.util.isNullOrUndefined(axis.range.min)) {
                axis.actual_Range.min = BoldBIDashboard.EjSvgRender.utils._logBase(axis.actual_Range.min, axis.logBase);
                axis.actual_Range.min = this._getRoundValue(axis.actual_Range.min, 1, false);
            }            
            
            axis.setRange = true;
          
            return axis.range;
        }
    },
   
      //Calcualte auto log range from series
        _calculateLogRange: function (chartObj, axis, seriesCollection, params) {
            if (!chartObj.zoomed) {
                this._seriesMinMax(chartObj,axis, seriesCollection, "logarithmic", params);
            }
        },
   
       //Assign base range values to actual range
        _calculateLogPadding: function (chartObj, axis, baseRange) {
            // No padding support for log axis
            var start = baseRange.min;
            var end = baseRange.max;
            var interval = baseRange.interval;
            axis.actualRange.min = start;
            axis.actualRange.max = end;
            axis.actualRange.interval = interval;         
            axis.actualRange.delta = end - start;
            this._calculateVisibleRange(axis);
        },
   
        // Calculate visible range for zooming
        _calculateVisibleRange: function (axis, sender, isScroll) {
            this.chartObj = sender ? sender : this.chartObj;
            axis.visibleRange = (!isScroll) ? bbdesigner$.extend(true, {}, axis.actualRange) : axis.visibleRange;
            if ((axis.zoomFactor < 1 || axis.zoomPosition > 0) && this.chartObj.model.AreaType != "polaraxes" && !this.chartObj.model.disableZoom) {
			     axis.zoomFactor = axis.zoomFactor > 1 ? 1 : (axis.zoomFactor < 0 ? 0 : axis.zoomFactor);
                axis.zoomPosition = axis.zoomPosition < 0 ? 0 : (axis.zoomPosition > 1 ? 1 : axis.zoomPosition);
                var baseRange = axis.actualRange;
                if (axis.isInversed) {
                    var start = axis.actualRange.max - axis.zoomPosition * axis.actualRange.delta;
                    var end = start - axis.zoomFactor * axis.actualRange.delta;
                }
                else {
                    var start = axis.actualRange.min + axis.zoomPosition * axis.actualRange.delta;
                    var end = start + axis.zoomFactor * axis.actualRange.delta;
                }

                if (start < baseRange.min) {
                    end = end + (baseRange.min - start);
                    start = baseRange.min;
                }

                if (end > baseRange.max) {
                    start = start - (end - baseRange.max);
                    end = baseRange.max;
                }
                var delta = Math.abs(end - start);
                var interval = axis.enableAutoIntervalOnZooming ? (this.calculateLogNiceInterval(delta, axis)) : axis.visibleRange.interval;
                var factor = (BoldBIDashboard.util.isNullOrUndefined(axis.roundingPlaces)) ?
                    (BoldBIDashboard.EjSvgRender.utils._decimalPlaces(axis.visibleRange.interval) == 0 ? 1
                    : BoldBIDashboard.EjSvgRender.utils._decimalPlaces(axis.visibleRange.interval)) : axis.roundingPlaces;
                interval = parseFloat(axis.visibleRange.interval.toFixed(factor));
                if (isScroll)
                    return { min: Math.min(start, end), max: Math.max(start, end), interval: interval };
                else{
                    axis.visibleRange.interval = interval;
                    axis.visibleRange.min = Math.min(start, end);
                    axis.visibleRange.max = Math.max(start, end);
                    axis.visibleRange.delta = delta;
                    axis.zoomed = (this.chartObj.zoomed === null || this.chartObj.zoomed === undefined) ? true : this.chartObj.zoomed;
                }
            }

        },
   
        //Method implementation for Generate Labels in ChartAxis
        _calculateAxisLabels: function (chartObj, currentAxis) {

            var tempInterval;
            if (chartObj.zoomed || currentAxis.zoomed)
                tempInterval = currentAxis.visibleRange.min - (currentAxis.visibleRange.min % currentAxis.visibleRange.interval);
            else
                tempInterval = currentAxis.visibleRange.min;
            for (; tempInterval <= currentAxis.visibleRange.max; tempInterval += currentAxis.visibleRange.interval) {
                

                if (BoldBIDashboard.EjSvgRender.utils._inside(tempInterval, currentAxis.visibleRange)) {      
                    var customFormat = (!(currentAxis.labelFormat)) ? null : currentAxis.labelFormat.match('{value}');
                    var tempIntervaltext = Math.pow(currentAxis.logBase, tempInterval);
                    tempIntervaltext = (!(currentAxis.roundingPlaces)) ?
                        parseFloat(tempIntervaltext.toFixed((BoldBIDashboard.EjSvgRender.utils._decimalPlaces(currentAxis.visibleRange.interval) == 0 ? 1
                            : BoldBIDashboard.EjSvgRender.utils._decimalPlaces(currentAxis.visibleRange.interval))))
                            : parseFloat(tempIntervaltext.toFixed(currentAxis.roundingPlaces));
                    var labelText = (!(currentAxis.labelFormat)) ? tempIntervaltext : (customFormat != null) ?
                             currentAxis.labelFormat.replace('{value}', tempIntervaltext) :
                              (BoldBIDashboard.format(tempIntervaltext, currentAxis.labelFormat));
					 // customize label by event
                    var commonAxesEventArgs = bbdesigner$.extend({}, BoldBIDashboard.EjSvgRender.commonChartEventArgs);
                    commonAxesEventArgs.data = { label: { Text: labelText, Value: tempInterval }, axis: currentAxis };
                    chartObj._trigger("axesLabelRendering", commonAxesEventArgs);
                    currentAxis.visibleLabels.push({ Value:tempInterval, Text: commonAxesEventArgs.data.label.Text });
                }
            }

            currentAxis._LableMaxWidth = BoldBIDashboard.EjSvgRender.utils._getMaxLabelWidth(currentAxis, this.chartObj);

        },


        //Category axis calculation
        _calculateRanges: function (chartObj, axis, seriesCollection, params) {
            this.chartObj = chartObj;
			this._saveRange(chartObj, axis);
            this._calculateLogRange(chartObj,axis, seriesCollection, params);
            if (chartObj.model._drawTrendline)
                this._calculateTrendLineRange(chartObj, axis, seriesCollection);
            this._calculateLogPadding(chartObj, axis, axis.actual_Range);
            this._calculateAxisLabels(chartObj,axis);
        }

        
    });
    BoldBIDashboard.axisTypes.logarithmic = ejLogValue;
    
//Category Axes calculation
    var ejCategoryValue = ejExtendClass(BoldBIDashboard.EjAxisRenderer, {
        //axis range calculation and assign indexed value to x value of points
        _calculateCategoryRange: function (axis, seriesCollection) {
            var legendCollapsed = (this.chartObj.model.legendCollapsed == undefined) ? !this.chartObj.zoomed : this.chartObj.model.legendCollapsed;
            if (!this.chartObj.model.excludeDataUpdate || legendCollapsed) {
            var maxXValue = { maxX: null, minX: 0 },
                labels = [],
                pointX,
                intervalX,
                deltaX,
                index,
                isIndex = axis.isIndexed;
            if (seriesCollection.length > 0 && seriesCollection[0].points.length > 0  || this.chartObj.model.indicators[0]._points.length>0) {
                for (var m = 0; m < seriesCollection.length; m++) {
                    pointsLength = seriesCollection[m].points.length;
                    for (var n = 0; n < pointsLength; n++) {
                        if (seriesCollection[m]._xAxisValueType == "date")
                            pointX = BoldBIDashboard.format(new Date(seriesCollection[m].points[n].x), (BoldBIDashboard.util.isNullOrUndefined(axis.labelFormat) ? "dd/MM/yyyy" : axis.labelFormat));
                        else
                            pointX = seriesCollection[m].points[n].x;
                        if (!isIndex) {
                            index = bbdesigner$.inArray(pointX, labels);
                            if (index < 0 && !(pointX === null || pointX === undefined))
                                labels.push(pointX);
                        }
                        else {
                            if (m == 0)
                                labels[n] = pointX;
                            else
                                labels[n] = labels[n] + ", " + pointX;
                        }

                    }
                    if (!axis.maxPointLength || axis.maxPointLength < pointsLength)
                        axis.maxPointLength = pointsLength;
                }
                for (var l = 0; l < seriesCollection.length; l++) {
                    seriesCollection[l]._pointCollection = [];
                    for (var k = 0; k < seriesCollection[l].points.length; k++) {
                        seriesCollection[l]._pointCollection.push(seriesCollection[l].points[k].x);
                        if (seriesCollection[l]._xAxisValueType == "date")
                            pointX = BoldBIDashboard.format(new Date(seriesCollection[l].points[k].x), (BoldBIDashboard.util.isNullOrUndefined(axis.labelFormat) ? "dd/MM/yyyy" : axis.labelFormat));
                        else
                            pointX = seriesCollection[l].points[k].x;
                        if (!isIndex)
                        seriesCollection[l].points[k].xValue = bbdesigner$.inArray(pointX, labels);
                        else
                            seriesCollection[l].points[k].xValue = k;
                       
                    }
                    seriesCollection[l].minX = 0;
                    seriesCollection[l].maxX = (seriesCollection[l]._xAxisValueType == "date") ? seriesCollection[l]._pointCollection.length - 1 : labels.length - 1;
                    // To find maximum x value of axis from series collection
                    if (l == 0) {
                        maxXValue.maxX = seriesCollection[l].maxX;
                        axis.labels = (seriesCollection[l]._xAxisValueType == "date") ? seriesCollection[l]._pointCollection : labels;
                    }
                    // Fix for axis label render issue (JS-63966)
                    axis._categoryValueType = seriesCollection[l]._xAxisValueType;
                    if (maxXValue.maxX < (seriesCollection[l].maxX)) {
                        maxXValue.maxX = seriesCollection[l].maxX;
                        axis.labels = [];
                        axis.labels = labels;
                    }
                }
                if (this.chartObj.model.indicatorRange && this.chartObj.model.indicatorRange[axis.name]) {
                          var value = this.chartObj.model.indicatorRange[axis.name];
                          if (maxXValue.minX > value.min || maxXValue.minX == null)
                              maxXValue.minX = value.min;
                          if (maxXValue.maxX < value.max || maxXValue.maxX == null)
                              maxXValue.maxX = value.max;
                }
                if (maxXValue.minX == maxXValue.maxX && axis.labelPlacement && axis.labelPlacement.toLowerCase() == "onticks") {
                    maxXValue.maxX += 1;
                }
                deltaX = maxXValue.maxX - maxXValue.minX;
                
                if (axis.setRange && axis.range.interval) {
                    intervalX = Math.ceil(axis.range.interval);
                }
                else {
                    intervalX = this._calculateActualInterval(deltaX, axis);
                }

                axis.range = { min: maxXValue.minX, max: maxXValue.maxX, interval: intervalX, Delta: deltaX };
            }
            else {
                var labelLength = axis.labels.length;
                if (labelLength > 0) {
                    deltaX = labelLength - 1;
                    intervalX = this._calculateActualInterval(deltaX, axis); 
                    axis.range = { min: 0, max: labelLength - 1, interval: intervalX, Delta: deltaX };
                }
                else if (!axis.range) // set default range when no series points added to category axes
                    axis.range = { min: 0, max: 6, interval: 1, Delta: 6 };
            }       
            }

        },

    //Calculates actual interval
    _calculateActualInterval: function (delta, axis) {
        if (axis.categoryInterval == null)
            return Math.max(1, Math.floor(delta / this.GetActualDesiredIntervalsCount(axis, axis.length)));
        else
            return axis.categoryInterval;
    },

    //Apply padding based on labelPlacement
    _applyRangePadding: function (axis) {
        if (!this.chartObj.zoomed && !this.chartObj._scrollBarEnabled) {
            // ticks based on labelplacement and polaraxes
            var ticks = 0;
            if(this.chartObj.model.AreaType !== 'polaraxes')
            ticks = ((axis.labelPlacement === null || axis.labelPlacement === undefined)) ? -0.5 : (axis.labelPlacement.toLowerCase() == "betweenticks") ? (-0.5) : 0;
			 if (ticks < 0) {
                axis.range.min = axis.range.min + ticks;
                axis.range.max = axis.range.max - ticks;
                axis.range.delta = axis.range.max - axis.range.min;
                axis.actualRange = axis.range;
            } else {
                var data = _sideBySeriesPadding(this.chartObj, axis.range.min, axis.range.max, axis);
                axis.range.min = data.startPadding;
                axis.range.max = data.endPadding;
                axis.range.delta = axis.range.max - axis.range.min;
                axis.actualRange = axis.range;
			}
        }
        this._calculateVisibleRange(axis);
    },

    //Calculates the visible range  
    _calculateVisibleRange: function (axis, sender, isScroll) {
        this.chartObj = sender ? sender : this.chartObj;
        axis.visibleRange = (!isScroll) ? bbdesigner$.extend(true, {}, axis.actualRange) : axis.visibleRange;
        if ((axis.zoomFactor < 1 || axis.zoomPosition > 0) && this.chartObj.model.AreaType != "polaraxes" && !this.chartObj.model.disableZoom) {
		     axis.zoomFactor = axis.zoomFactor > 1 ? 1 : (axis.zoomFactor < 0 ? 0 : axis.zoomFactor);
            axis.zoomPosition = axis.zoomPosition < 0 ? 0 : (axis.zoomPosition > 1 ? 1 : axis.zoomPosition);
            var baseRange = axis.actualRange;
            if (axis.isInversed) {
                var start = axis.actualRange.max - axis.zoomPosition * axis.actualRange.delta;
                var end = start - axis.zoomFactor * axis.actualRange.delta;
            }
            else {
                var start = axis.actualRange.min + (axis.zoomPosition * axis.actualRange.delta);
                var end = start + axis.zoomFactor * axis.actualRange.delta;
            }

            if (start < baseRange.min) {
                end = end + (baseRange.min - start);
                start = baseRange.min;
            }

            if (end > baseRange.max) {
                start = start - (end - baseRange.max);
                end = baseRange.max;
            }
            var delta = Math.abs(end - start);
            var interval = this._calculateActualInterval(delta, axis);
            var min = Math.min(start, end);
            var max = Math.max(start, end);
            if (isScroll) {
                return {min:min, max:max, interval:interval};
            }
            else {
                var delta = Math.abs(end - start);
                axis.visibleRange.interval = interval;
                axis.visibleRange.min = min;
                axis.visibleRange.max = max;
                axis.visibleRange.delta = delta;
                axis.zoomed = (this.chartObj.zoomed === null || this.chartObj.zoomed === undefined) ? true : this.chartObj.zoomed;
            }
        }

    },

    //Generate category label for axis
    _calculateAxisLabels: function (axis) {
        var interval = axis.visibleRange.interval;
        var position = axis.visibleRange.min - (axis.visibleRange.min % axis.range.interval);
        for (; position <= axis.visibleRange.max; position += interval) {
            if (BoldBIDashboard.EjSvgRender.utils._inside(position, axis.visibleRange)) {
                var pos = Math.round(position);
                axis.visibleLabels.push({ Value: pos, Text: BoldBIDashboard.EjSvgRender.utils._getLabelContent(pos, axis) });

                // customize label by event
                var commonAxesEventArgs = bbdesigner$.extend({}, BoldBIDashboard.EjSvgRender.commonChartEventArgs);
                commonAxesEventArgs.data = { label: axis.visibleLabels[axis.visibleLabels.length - 1], axis: axis };
                this.chartObj._trigger("axesLabelRendering", commonAxesEventArgs);
                axis.visibleLabels[axis.visibleLabels.length - 1] = commonAxesEventArgs.data.label;
            }
        }
        axis._LableMaxWidth = BoldBIDashboard.EjSvgRender.utils._getMaxLabelWidth(axis, this.chartObj);
    },

    //Category axis calculation
    _calculateRanges: function (chartObj, axis, seriesCollection) {
        this.chartObj = chartObj;
		this._saveRange(chartObj, axis);
        this._calculateCategoryRange(axis, seriesCollection);
		axis._range = axis.range;
        if (chartObj.model._drawTrendline)
            this._calculateTrendLineRange(chartObj, axis, seriesCollection);
        this._applyRangePadding(axis);

        this._calculateAxisLabels(axis);
    }
});
BoldBIDashboard.axisTypes.category = ejCategoryValue;

    // for Datetime category axis calculation

    var ejDateTimeCategory = ejExtendClass(BoldBIDashboard.EjAxisRenderer, {
        _calculateDateTimeCategoryRange: function (axis, seriesCollection) {
            ///Variables declaration part here ///
            var xRange = { minX: 0, MaxX: null },xLabels = [],xValue=[], xPoint,index,index1, deltaX,intervalX,
                         prevDateVal, points, xVerfiedPoints = [], dateDouble, xValues= [],
                         xDateVal, xVal, previous, current, pointsLength, point, m, pt, ser;
		  if (seriesCollection.length > 0 && seriesCollection[0].points.length > 0){
            for (ser = 0; ser < seriesCollection.length; ser++) {
                seriesCollection[ser]._pointCollection = [], points = [],seriesCollection[ser]._points=[], seriesCollection[ser]._xPoints = [], seriesCollection[ser]._yPoints=[],
                pointsLength = seriesCollection[ser].points.length;
                for (pt = 0; pt < pointsLength; pt++) {
                    dateDouble = !isNaN(new Date(seriesCollection[ser].points[pt].x).getTime()) ? new Date(seriesCollection[ser].points[pt].x).getTime() : null;
                    points.push(dateDouble);
                    seriesCollection[ser]._xPoints.push(dateDouble);
                    seriesCollection[ser]._yPoints.push(seriesCollection[ser].points[pt].y);
                    if (dateDouble != null)
                        xValues.push(dateDouble);
                }
                points.sort(function (a, b) { return a - b; }); // date time values sorted
				 //to check all xvalues are null
                   var count = 0;
                    for (i = 0; i < points.length; i++) {
                        if (points[i] == 0 || isNaN(points[i]))
                        { count++; }
                    }
                    if (count == points.length) {
                        axis.isAllXValuesNull = true;
                    }
					
                if(BoldBIDashboard.isNullOrUndefined(axis.intervalType)){
                    intervalX = this.calculateDateTimeNiceInterval(axis, new Date(Math.min.apply(null, xValues)), new Date(Math.max.apply(null, xValues)));
                    axis.intervalType = (BoldBIDashboard.isNullOrUndefined(intervalX)) ? "auto" : intervalX.intervalType.toLowerCase();
                }
                for (point = 0; point < points.length; point++) {
                    xPoint = new Date(points[point]);
                    seriesCollection[ser]._points.push(xPoint.getTime());
                    var ySortPos = bbdesigner$.inArray(points[point], seriesCollection[ser]._xPoints);
                    seriesCollection[ser].points[point].y = seriesCollection[ser].points[point].YValues[0] = seriesCollection[ser]._yPoints[ySortPos];
                    seriesCollection[ser]._pointCollection.push(new Date(seriesCollection[ser].points[point].x));
                    if (ser == 0)
                        seriesCollection[ser].points[point].xValue = point;
                    else {
                        for (var i = 0; i <= ser - 1; i++) {
                            index1 = bbdesigner$.inArray(new Date(seriesCollection[ser].points[point].x).getTime(), seriesCollection[i]._points);
                            if (index1 >= 0) {
                                seriesCollection[ser].points[point].xValue = index1;
                            }
                            else if(i = ser) {
                                seriesCollection[ser].points[point].xValue = (axis.maxPointLength - 1) + (point + 1);
                                break;
                            }
                        }                           
                    }
                    index = (ser == 0)? -1 : bbdesigner$.inArray(xPoint.getTime(), xVerfiedPoints);
                    if (index < 0) {
                        switch (axis.intervalType) {
                            case "auto": // for auto calculate
                                xLabels.push(xPoint.getTime());
                                break;
                            case "years":  // for years calculate
                                xVal = xPoint.getFullYear();                              
                                break;
                            case "months":  // for months calculate
                                current = xPoint.getFullYear();
                                xDateVal = xPoint.getMonth();
                                if (point <= 0) xVal = point + 1;
                                else {
                                    previous = new Date(points[point - 1]).getFullYear();
                                    xVal += (current != previous) ? ((12 - prevDateVal) + (xDateVal)) : (xDateVal - prevDateVal);
                                }
                                prevDateVal = xDateVal;
                                break;
                            case "days":  // for days calculate
                                current = xPoint.getMonth();
                                xDateVal = xPoint.getDate();
                                if (point <= 0) xVal = point + 1;
                                else {
                                    previous = new Date(points[point - 1]).getMonth();
                                    xVal += (current != previous) ? (((new Date(xPoint.getFullYear(), previous, 0).getDate() - prevDateVal) + (xDateVal))) : (xDateVal - prevDateVal);
                                    if(current == previous)
                                    {
                                        var diff = this._diffDate(xPoint, new Date(points[point - 1]),1);
                                        var days = (new Date(xPoint.getFullYear(), previous, 0).getDate());
                                        xVal = (diff > days) ? (xValue[xValue.length - 1]) + 1 : xVal;
                                    }
                                }
                                prevDateVal = xDateVal;
                                break;
                            case "hours":  // for hours calculate
                                current = xPoint.getDate();
                                xDateVal = xPoint.getHours();
                                if (point <= 0) xVal = point + 1;
                                else {
                                    previous = new Date(points[point - 1]).getDate();
                                    xVal += (current != previous) ? ((24 - prevDateVal) + (xDateVal)) : (xDateVal - prevDateVal);
                                    if (current == previous) {
                                        var diff = this._diffDate(xPoint, new Date(points[point - 1]),24);
                                        xVal = (diff> 24) ? (xValue[xValue.length - 1]) + 1 : xVal;
                                    }
                                }
                                prevDateVal = xDateVal;
                                break;
                            case "minutes": // for minutes calculate
                                current = xPoint.getHours();
                                xDateVal = xPoint.getMinutes();
                                if (point <= 0) xVal = point + 1;
                                else {
                                    previous = new Date(points[point - 1]).getHours();
                                    xVal += (current != previous) ? ((60 - prevDateVal) + (xDateVal)) : (xDateVal - prevDateVal);
                                    if (current == previous) {
                                        var diff = this._diffDate(xPoint, new Date(points[point - 1]),(24 * 60));
                                        xVal = (diff > 60) ? (xValue[xValue.length - 1]) + 1 : xVal;
                                    }
                                }
                                prevDateVal = xDateVal;
                                break;
                            case "seconds": // for seconds calculate
                                current = xPoint.getMinutes();
                                xDateVal = xPoint.getSeconds();
                                if (point <= 0) xVal = point + 1;
                                else {
                                    previous = new Date(points[point - 1]).getMinutes();
                                    xVal += (current != previous) ? ((60 - prevDateVal) + (xDateVal)) : (xDateVal - prevDateVal);
                                    if (current == previous) {
                                        var diff = this._diffDate(xPoint, new Date(points[point - 1]),( 24 * 60 * 60));
                                        xVal = (diff > 60) ? (xValue[xValue.length - 1]) + 1 : xVal;
                                    }
                                }
                                prevDateVal = xDateVal;
                                break;
                            case "milliseconds": // for milliseconds calculate
                                current = xPoint.getSeconds();
                                xDateVal = xPoint.getMilliseconds();
                                if (point <= 0) xVal = point + 1;
                                else {
                                    previous = new Date(points[point - 1]).getSeconds();
                                    xVal += (current != previous) ? ((1000 - prevDateVal) + (xDateVal)) : (xDateVal - prevDateVal);
                                    if (current == previous) {
                                        var diff = this._diffDate(xPoint, new Date(points[point - 1]), (24 * 60 * 60 * 1000));
                                        xVal = (diff > 1000) ? (xValue[xValue.length - 1]) + 1 : xVal;
                                    }
                                }
                                prevDateVal = xDateVal;
                                break;
                        }
                        if (axis.intervalType != "auto")
                            xLabels.push(xPoint.getTime());  
                        xValue.push(xVal);
                        xVerfiedPoints.push(new Date(points[point]).getTime());                      
                    }
               }           
                   if (!axis.maxPointLength || axis.maxPointLength < pointsLength) axis.maxPointLength = pointsLength;
            }
            for (m = 0; m < seriesCollection.length; m++) { // set the min and max range for axis
                if (!axis.setRange) axis.range = { min: null, max: null, interval: null };
				if(!BoldBIDashboard.isNullOrUndefined(axis.m_minPointsDelta)) axis.m_minPointsDelta = undefined;
                seriesCollection[m].minX = (BoldBIDashboard.isNullOrUndefined(axis.range.min)) ? 0 : (axis.range.min < xRange.minX) ? 0 : axis.range.min;
                seriesCollection[m].maxX = (BoldBIDashboard.isNullOrUndefined(axis.range.max)) ? xLabels.length - 1 : (axis.range.max > xLabels.length - 1) ? xLabels.length-1 : axis.range.max;
                    if (m == 0) {
                        xRange.MaxX = seriesCollection[m].maxX;
                        xRange.minX = seriesCollection[m].minX;
                        axis.labels = xLabels;
                        axis.dateLabels = xValue;
                        axis._categoryValueType = "date";
                    }
                }
            if (xRange.minX == xRange.MaxX && !(BoldBIDashboard.isNullOrUndefined(axis.labelPlacement))) xRange.MaxX = (axis.labelPlacement.toLowerCase() == "onticks") ? (xRange.MaxX + 1) : xRange.MaxX;
                deltaX = xRange.MaxX - xRange.minX;
                intervalX = ((axis.range.interval == null || axis.range.interval == undefined)) ? 1 : (axis.range.interval < 1) ? 1 : Math.ceil(axis.range.interval);               
                axis.range = { min: xRange.minX, max: xRange.MaxX, interval: intervalX, Delta: deltaX };
			}
            else{
			    var labelLength = axis.labels.length;
                if (labelLength > 0) {
                    deltaX = labelLength - 1;
                    intervalX = this._calculateActualInterval(deltaX, axis); 
                    axis.range = { min: 0, max: labelLength - 1, interval: intervalX, Delta: deltaX };
                }
           }			
        },

        _diffDate:function(currentPoint,previousPoint,mul)
        {
            var oneDay, diff;
             oneDay = 24 * 60 * 60 * 1000;
            diff = (Math.abs((currentPoint.getTime() - previousPoint.getTime()))/ (oneDay));
            return (Math.round(diff*mul));
        },

        _calculateAxisLabels:function(axis) // calculate visible labels for axis
        {
            var interval = axis.visibleRange.interval, currentLabels = [], count = 0,
                           prevLabelVal, pos,arr, currentLabel, expectLabel, index, i, isCurrentLabel, isNextLabel, commonAxesEventArgs;
            var position = axis.visibleRange.min - (axis.visibleRange.min % axis.range.interval);
            for (; position <= axis.visibleRange.max; position += interval) {
                if (BoldBIDashboard.EjSvgRender.utils._inside(position, axis.visibleRange)) {
                     pos = Math.round(position);
                     arr = axis.dateLabels;
                     if (axis.intervalType != "auto") {
                         if (count > 0 && interval > 1) {
                             if (pos > arr.length - 1)
                                 pos = arr.length - 1;
                             currentLabel = arr[count];
                             expectLabel = prevLabelVal + interval;
                             isCurrentLabel = bbdesigner$.inArray(currentLabel, arr);
                             isNextLabel = bbdesigner$.inArray(expectLabel, arr);
                             if (isCurrentLabel > 0 && (Math.abs(currentLabel - prevLabelVal) == interval) && currentLabel > prevLabelVal) {
                                 pos = isCurrentLabel;
                                 prevLabelVal = arr[pos];
                             }
                             else {
                                 for (i = 0; i < i + 1; i++) {
                                     expectLabel += (i == 0) ? i : 1;
                                     isNextLabel = bbdesigner$.inArray(expectLabel, arr);
                                     if (isNextLabel > 0) {
                                         pos = isNextLabel;
                                         prevLabelVal = arr[pos];
                                         break;
                                     }
                                 }
                             }
                         }
                     }
                    count++;
                    if(!BoldBIDashboard.util.isNullOrUndefined(arr)){
                        if (((arr[arr.length - 1] - arr[pos]) >= interval) && (axis.visibleRange.max < (position + interval))) axis.visibleRange.max += ((position + interval) - axis.visibleRange.max);
                        index = bbdesigner$.inArray(arr[pos], currentLabels);
                     }
                    if((index < 0 || axis.intervalType == "auto") && (pos < axis.labels.length)) {
                        if (axis.intervalType != "auto") {
                            prevLabelVal = arr[pos];
                            currentLabels.push(prevLabelVal);
                        }                    
                        axis.visibleLabels.push({ Value: pos, Text: BoldBIDashboard.EjSvgRender.utils._getLabelContent(pos, axis, this.chartObj.model.locale) });
                        commonAxesEventArgs = bbdesigner$.extend({}, BoldBIDashboard.EjSvgRender.commonChartEventArgs);
                        commonAxesEventArgs.data = { label: axis.visibleLabels[axis.visibleLabels.length - 1], axis: axis };
                        this.chartObj._trigger("axesLabelRendering", commonAxesEventArgs);
                        axis.visibleLabels[axis.visibleLabels.length - 1] = commonAxesEventArgs.data.label;                    
                    }
                }
            }
            axis._LableMaxWidth = BoldBIDashboard.EjSvgRender.utils._getMaxLabelWidth(axis, this.chartObj);
			 if (axis.isAllXValuesNull) {
               axis.visibleLabels = [];
                for (i = 0; i < this.chartObj.model._visibleSeries.length; i++)
                    this.chartObj.model._visibleSeries[i].points = [];
            }
        },

        //Calculates actual interval
        _calculateActualInterval: function (delta, axis) {
            if (axis.categoryInterval == null)
                return Math.max(1, Math.floor(delta / this.GetActualDesiredIntervalsCount(axis, axis.length)));
            else
                return axis.categoryInterval;
        },

        //Apply padding based on labelPlacement
        _applyRangePadding: function (axis) {
            if (!this.chartObj.zoomed && !this.chartObj._scrollBarEnabled) {
                // ticks based on labelplacement and polaraxes
                var ticks = 0;
                if (this.chartObj.model.AreaType !== 'polaraxes')
                    ticks = ((axis.labelPlacement === null || axis.labelPlacement === undefined)) ? -0.5 : (axis.labelPlacement.toLowerCase() == "betweenticks") ? (-0.5) : 0;
                if (ticks < 0) {
                    axis.range.min = axis.range.min + ticks;
                    axis.range.max = axis.range.max - ticks;
                    axis.range.delta = axis.range.max - axis.range.min;
                    axis.actualRange = axis.range;
                } else {
                    var data = _sideBySeriesPadding(this.chartObj, axis.range.min, axis.range.max, axis);
                    axis.range.min = data.startPadding;
                    axis.range.max = data.endPadding;
                    axis.range.delta = axis.range.max - axis.range.min;
                    axis.actualRange = axis.range;
                }
            }
            this._calculateVisibleRange(axis);
        },

        //Calculates the visible range  
        _calculateVisibleRange: function (axis, sender, isScroll) {
            this.chartObj = sender ? sender : this.chartObj;
            axis.visibleRange = (!isScroll) ? bbdesigner$.extend(true, {}, axis.actualRange) : axis.visibleRange;
            if ((axis.zoomFactor < 1 || axis.zoomPosition > 0) && this.chartObj.model.AreaType != "polaraxes" && !this.chartObj.model.disableZoom) {
                axis.zoomFactor = axis.zoomFactor > 1 ? 1 : (axis.zoomFactor < 0 ? 0 : axis.zoomFactor);
                axis.zoomPosition = axis.zoomPosition < 0 ? 0 : (axis.zoomPosition > 1 ? 1 : axis.zoomPosition);
                var baseRange = axis.actualRange;
                if (axis.isInversed) {
                    var start = axis.actualRange.max - axis.zoomPosition * axis.actualRange.delta;
                    var end = start - axis.zoomFactor * axis.actualRange.delta;
                }
                else {
                    var start = axis.actualRange.min + (axis.zoomPosition * axis.actualRange.delta);
                    var end = start + axis.zoomFactor * axis.actualRange.delta;
                }

                if (start < baseRange.min) {
                    end = end + (baseRange.min - start);
                    start = baseRange.min;
                }

                if (end > baseRange.max) {
                    start = start - (end - baseRange.max);
                    end = baseRange.max;
                }
                var delta = Math.abs(end - start);
                var interval = this._calculateActualInterval(delta, axis);
                var min = Math.min(start, end);
                var max = Math.max(start, end);
                if (isScroll) {
                    return { min: min, max: max, interval: interval };
                }
                else {
                    var delta = Math.abs(end - start);
                    axis.visibleRange.interval = interval;
                    axis.visibleRange.min = min;
                    axis.visibleRange.max = max;
                    axis.visibleRange.delta = delta;
                    axis.zoomed = (this.chartObj.zoomed === null || this.chartObj.zoomed === undefined) ? true : this.chartObj.zoomed;
                }
            }

        },

        _calculateRanges: function (chartObj, axis, seriesCollection) {
            this.chartObj = chartObj;
			this._saveRange(chartObj, axis);
            this._calculateDateTimeCategoryRange(axis, seriesCollection);   
			axis._range = axis.range;
            this._applyRangePadding(axis);
            this._calculateAxisLabels(axis);          
        }
    });

    BoldBIDashboard.axisTypes.datetimecategory = ejDateTimeCategory;

BoldBIDashboard.EjAxisRenderer.prototype = {
    _drawGridLines: function (axisIndex, axis, params) {
        if (this.model.AreaType == "cartesianaxes") {
            if (axis.orientation.toLowerCase() == "horizontal" && ((this.model.adaptiveRendering &&  !(this.svgHeight <= 100)) || !this.model.adaptiveRendering))
                this._drawXAxisGridLine(axisIndex, axis, params);

            else if(axis.orientation.toLowerCase() == "vertical" && ((this.model.adaptiveRendering &&  !(this.svgWidth <= 100)) || !this.model.adaptiveRendering))
                this._drawYAxisGridLine(axisIndex, axis, params);
        }
        else {
            if (axis.orientation.toLowerCase() == "horizontal" && axisIndex == 0) {
                this._drawPolarGridLine(axis);
                this._drawPolarLabels(axis);

            }
            else if (axisIndex == 1)
                this._drawPolarCircle(axis);
        }
    },
    _drawAxes: function (axisIndex, axis, params) {

        if (this.model.AreaType == "cartesianaxes") {
            if (axis.visible && axis.responsiveVisibility && axis.orientation.toLowerCase() == "horizontal") {
                this._drawXAxisLabels(axisIndex, axis);
			    if (axis.title.visible && axis.title.responsiveVisibility)
                    this._drawXTitle(axisIndex, axis);
            }

            if (axis.visible && axis.responsiveVisibility && axis.orientation.toLowerCase() == "vertical") {
                this._drawYAxisLabels(axisIndex, axis, params);
			    if (axis.title.visible && axis.title.responsiveVisibility)
                     this._drawYTitle(axisIndex, axis);
            }
        }
    },
    _getSharpPath:function (width) {
        var value = ((width % 2) == 0) ? 0 : 0.5;
        return value;
    },
    _drawAxisLine: function (axis) {

        // Yaxis MajorGridlines, Ticklines and Labels.
        var gEle = this.svgRenderer.createGroup({ 'id': this.svgObject.id + '_YAxisLine' });
        var sbYMajorTick = BoldBIDashboard.EjSvgRender.utils._getStringBuilder();
        var x1 = this.model.centerX;
        var y1 = this.model.centerY;
        var x2 = this.model.centerX;
        var y2 = this.model.centerY - this.model.Radius;
        var axisLine = "M" + " " + x1 + " " + y1 + " " + "L" + " " + x2 + " " + y2;
        if (axis.visible && axis.axisLine.visible) {
            var options = {
                'id': this.svgObject.id + '_YAxisLines',
                'fill': 'none',
                'stroke-width': axis.axisLine.width,
                'stroke': axis.axisLine.color,
                'opacity': axis.axisLine.opacity,
                'stroke-dasharray': axis.axisLine.dashArray,
                'd': axisLine
            };
            this.svgRenderer.drawPath(options, gEle);

            //Drawing Major Grid Lines 
            bbdesigner$(gEle).appendTo(this.gPolarAxisEle);
        }
       

        if (axis.visible && axis.majorTickLines.visible) {
            gEle = this.svgRenderer.createGroup({ 'id': this.svgObject.id + '_YAxisMajorTicks' });
                for (var j = 0; j < axis.visibleLabels.length; j++) {
                    var label = axis.visibleLabels[j];
                    var radius = this.model.Radius * BoldBIDashboard.EjSvgRender.utils._valueToCoefficient(axis, label.Value, this);
                    var line = {};
                    line.X1 = this.model.centerX;
                    line.Y1 = this.model.centerY - radius;
                    line.X2 = line.X1 - axis.majorTickLines.size;
                    line.Y2 = line.Y1;
                    sbYMajorTick.append("M" + " " + line.X1 + " " + line.Y1 + " " + "L" + " " + line.X2 + " " + line.Y2 + " ");
                }
               
                  yMajorTickDir = sbYMajorTick.toString();
                    var options = {
                        'id': this.svgObject.id + '_YAxisMajorTicks',
                        'fill': 'none',
                        'stroke-width': axis.majorTickLines.width,
                        'stroke': axis.majorTickLines.color,
                        'd': yMajorTickDir
                    };
            //Drawing Major Tickline Lines
                    this.svgRenderer.drawPath(options, gEle);
                    bbdesigner$(gEle).appendTo(this.gPolarAxisEle);
                
        }
        if (axis.visible) {
            var gEle = this.svgRenderer.createGroup({ 'id': this.svgObject.id + '_YAxisLabels' }),
                font = axis.font,
                bounds,
                regionX,
                labelsLength = axis.visibleLabels.length;
            for (var j = 0; j < labelsLength; j++) {
                var radius = this.model.Radius * BoldBIDashboard.EjSvgRender.utils._valueToCoefficient(axis, axis.visibleLabels[j].Value, this);
                var labelText = axis.visibleLabels[j].Text;

                var size = BoldBIDashboard.EjSvgRender.utils._measureText(labelText, null, axis.font);

                var X = this.model.centerX - axis.majorTickLines.size - (this.model.elementSpacing / 3);
                var Y = this.model.centerY - radius + (size.height / 5);


                var options = {
                    'id': this.svgObject.id + '_' + axis.name + '_YLabel_' + j,
                    'x': X,
                    'y': Y,
                    'fill': font.color,
                    'font-size': font.size,
                    'font-family': font.fontFamily,
                    'font-style': font.fontStyle,
                    'font-weight': font.fontWeight,
                    'opacity': font.opacity,
                    'text-anchor': 'end'
                };

                this.svgRenderer.drawText(options, labelText, gEle);
                regionX = options.x - size.width;
                bounds = { x: regionX, y: options.y, width: size.width, height: size.height };
                axis.visibleLabels[j].region = { bounds: bounds, labelText: labelText };
            }
            //Drawing YAxis Labels
            bbdesigner$(gEle).appendTo(this.gPolarAxisEle);
        }
       

    },
    _drawPolarLabels: function (axis) {
	     if (!axis.visible || !axis.responsiveVisibility )
			return 0;
        var gEle = this.svgRenderer.createGroup({ 'id': this.svgObject.id + '_XAxisLabels'  }),
            aroundRadius = this.model.Radius + axis.majorTickLines.size,
            font = axis.font,
            length = axis.visibleLabels.length,
            firstLabelX,
            bounds,
            regionX,
            lastLabelX;
        for (var j = 0; j < length; j++) {
            var coef = BoldBIDashboard.EjSvgRender.utils._valueToPolarCoefficient(axis, axis.visibleLabels[j].Value);

            var vector = BoldBIDashboard.EjSvgRender.utils._valueToVector(axis, axis.visibleLabels[j].Value);
		 if (!isNaN(vector.X) && !isNaN(vector.Y)) {
            var labelText = axis.visibleLabels[j].Text;
            var x = this.model.centerX + aroundRadius * vector.X;
            var y = this.model.centerY + aroundRadius * vector.Y;
            var textAnchor = (x < this.model.centerX) ? 'end' : ((x > this.model.centerX) ? 'start' : 'middle');

            var size= BoldBIDashboard.EjSvgRender.utils._measureText(labelText, this.model.m_AreaBounds.Height, axis.font);
            // calculation for positioning the label along the arc
            if (coef == 0.25)
            {
                x -= this.model.elementSpacing / 2;
                y += (size.height) / 4;
            }
           else if (coef == 0.5)
            {
               y += (size.height) ;
            }
           else if (coef == 0.75)
           {
               x += this.model.elementSpacing / 2;
               y += (size.height) / 4;
           }
           else if (coef == 1 || coef==0) {
               y -= (size.height) / 2;
           }
               
           else if (0.25 < coef && coef < 0.5) {
               x -= this.model.elementSpacing / 2;
               y += (size.height) / 2;
           }
           else if (0.5 < coef && coef <= 0.75) {
               x += this.model.elementSpacing / 2;
               y += (size.height) / 2;
           }
           else if (0 < coef && coef < 0.25)
             {
                   x -= this.model.elementSpacing / 2;
           }
           else
               x += this.model.elementSpacing / 2;

            if (j == 0) {
                firstLabelX = x;
            }
            if (j == length - 1 && axis._valueType !="category" ) {
                lastLabelX = BoldBIDashboard.EjSvgRender.utils._measureText(labelText, null, font).width;
                lastLabelX += x;
                if (lastLabelX > firstLabelX)
                    labelText = ""; //Hide the last overlapping labels
            }
            var options = {
                'id': this.svgObject.id + '_' + axis.name + '_XLabel_' + j,
                'x': x,
                'y': y,
                'fill': font.color,
                'font-size': font.size,
                'font-family': font.fontFamily,
                'font-style': font.fontStyle,
                'font-weight': font.fontWeight,
                'opacity': font.opacity,
                'text-anchor': textAnchor
            };

            this.svgRenderer.drawText(options, labelText, gEle);
			 if (textAnchor == "middle") 
               regionX = options.x - size.width / 2;
           
            else if (textAnchor == "end") 
               regionX = options.x - size.width;
            else
                regionX = options.x;
				
            bounds = { x: regionX, y: options.y, width: size.width, height: size.height };
            axis.visibleLabels[j].region = { bounds: bounds, labelText: labelText };
          }
        }
		
        bbdesigner$(gEle).appendTo(this.gXaxisEle);

    },
    _drawPolarCircle: function (axis) {
        if (axis.majorGridLines.visible) {
            var sbYMajorGrid = BoldBIDashboard.EjSvgRender.utils._getStringBuilder();
            var gEle = this.svgRenderer.createGroup({ 'id': this.svgObject.id + '_YAxisGrid' });
            if (this.model.isPolar) {
                for (var j = 0; j < axis.visibleLabels.length; j++) {
                    var label = axis.visibleLabels[j];
                    var radius = this.model.Radius * BoldBIDashboard.EjSvgRender.utils._valueToCoefficient(axis, label.Value, this);

                    var options = {
                        'id': this.svgObject.id + '_YAxisGridLines_' + j,
                        'cx': this.model.centerX,
                        'cy': this.model.centerY,
                        'r': radius,
                        'fill': 'transparent',
                        'stroke-width': axis.majorGridLines.width,
                        'stroke': axis.majorGridLines.color,
                         'opacity': (this.vmlRendering) ? 0.3: axis.majorGridLines.opacity
                    };

                    //Drawing Major Grid Lines for polar
                    this.svgRenderer.drawCircle(options, gEle);
                   
                }
            }
            else {
                for (var j = 0; j < axis.visibleLabels.length; j++) {
                    
                        var label = axis.visibleLabels[j];
                        var radius = this.model.Radius * BoldBIDashboard.EjSvgRender.utils._valueToCoefficient(axis, label.Value, this);
                        // calculation for spider web
                        for (var i = 0; i < this.model._axes[0].visibleLabels.length; i++) {
                            var xAxis = this.model._axes[0];
                            var vector = BoldBIDashboard.EjSvgRender.utils._valueToVector(xAxis, xAxis.visibleLabels[i].Value);
						    if (!isNaN(vector.X) && !isNaN(vector.Y)){
                              var vector2;
                              if ((i + 1) < xAxis.visibleLabels.length) {
                                vector2 = BoldBIDashboard.EjSvgRender.utils._valueToVector(xAxis, xAxis.visibleLabels[i + 1].Value);
                              }
                              else {
                                vector2 = BoldBIDashboard.EjSvgRender.utils._valueToVector(xAxis, xAxis.visibleLabels[0].Value);
                              }
                              var connectPoint = { X: this.model.centerX + radius * vector.X, Y: this.model.centerY + radius * vector.Y };
                              var endPoint = { X: this.model.centerX + radius * vector2.X, Y: this.model.centerY + radius * vector2.Y };
                              sbYMajorGrid.append("M" + " " + connectPoint.X + " " + connectPoint.Y + " " + "L" + " " + endPoint.X + " " + endPoint.Y + " ");
						    }
                        }
                }
                if (axis.majorGridLines.visible) {
                    yMajorGridDir = sbYMajorGrid.toString();
                    var options = {
                        'id': this.svgObject.id + '_YAxisGridLines',
                        'fill': 'none',
                        'stroke-width': axis.majorGridLines.width,
                        'stroke': axis.majorGridLines.color,
                        'opacity': axis.majorGridLines.opacity,
                        'stroke-dasharray': axis.majorGridLines.dashArray,
                        'd': yMajorGridDir
                    };
                    //Drawing Major Grid Lines for radar
                    this.svgRenderer.drawPath(options, gEle);
                }
            }
        }
        bbdesigner$(gEle).appendTo(this.gYaxisEle);

    },

    _polarRadius: function () {
        var legXSpace = 0;
        var legYSpace = 0;
		var chartModel = this.model;
        var legend = chartModel.legend,maxLabelHeight;
        var borderSize = legend.border.width;
        var chartBorder = chartModel.border.width;
        var legendTitleHeight = BoldBIDashboard.EjSvgRender.utils._measureText(legend.title.text, null, legend.title.font).height;
        var legendPosition = !BoldBIDashboard.util.isNullOrUndefined(this.model.legend.responsivePosition) ? this.model.legend.responsivePosition : this.model.legend.position.toLowerCase();
        if (legend.visible && legend.responsiveVisibility && legendPosition != "custom") {
            if (legendPosition == "right" || legendPosition == "left")
                legXSpace = ((legendPosition == "right") ? chartModel.margin.right : chartModel.margin.left) + chartModel.LegendActualBounds.Width + (borderSize + chartBorder) * 2;
            else
                legYSpace = ((legendPosition == "top") ? chartModel.margin.top : chartModel.margin.bottom) + chartModel.LegendActualBounds.Height + legendTitleHeight + (borderSize + chartBorder) * 2;

        }
        // calculating the radius of the chart with avaible size
        yOffset = ((chartModel.title.text) && !BoldBIDashboard.util.isNullOrUndefined(chartModel._titleLocation) ? chartModel._titleLocation.Y : 0) + legYSpace;

        actualWidth = chartModel.svgWidth - legXSpace;
        actualHeight = chartModel.svgHeight - yOffset;

        chartModel.centerX = actualWidth * 0.5 + ((legendPosition === "left") ? legXSpace : 0);
        chartModel.centerY = actualHeight * 0.5 + ((legendPosition === "top") ? yOffset : (chartModel.title.text && !BoldBIDashboard.util.isNullOrUndefined(chartModel._titleLocation)) ? (chartModel._titleLocation.Y) : 0);

        var gEle = this.svgRenderer.createGroup({ 'id': this.svgObject.id + '_XAxisGrid' });
        chartModel.finalSize = { width: actualWidth, height: actualHeight };
         maxLabelHeight=  axis.responsiveVisibility ?axis._LableMaxWidth.maxHeight : 0;
        chartModel.Radius = Math.min(chartModel.finalSize.width, chartModel.finalSize.height) / 2 - (2 * chartModel.elementSpacing) - axis.majorTickLines.size - maxLabelHeight;


    },
    _drawPolarGridLine: function (axis) {

        var chartModel = this.model,
            legend = chartModel.legend,
            legendTitleHeight = BoldBIDashboard.EjSvgRender.utils._measureText(legend.title.text, null, legend.title.font).height,
            legendPosition = legend.position.toLowerCase(),
            legXSpace = 0,
            legYSpace = 0,
            sbXMajorGrid = BoldBIDashboard.EjSvgRender.utils._getStringBuilder(),
            sbXMajorTick = BoldBIDashboard.EjSvgRender.utils._getStringBuilder(),
            borderSize = legend.border.width,
            yOffset, actualWidth, actualHeight,
            isRadar = false, vector, line,
            length = axis.visibleLabels.length,
            chartBorder = chartModel.border.width;

        var sbXMajorGrid = BoldBIDashboard.EjSvgRender.utils._getStringBuilder();
        var sbXMajorTick = BoldBIDashboard.EjSvgRender.utils._getStringBuilder();
        var gEle = this.svgRenderer.createGroup({ 'id': this.svgObject.id + '_XAxisGrid' });

        this._polarRadius();
        this.flag = false;
        this.count = 0;
        var chartObj = this;
        if (this.model.adaptiveRendering) {
            if (chartObj.model.legend.visible && chartObj.model.legend.responsiveVisibility) {
                if (chartObj.svgWidth > chartObj.svgHeight && chartObj.svgWidth > chartObj.model.Radius * 2)
                    chartObj.model.legend.responsivePosition = "right";
                else
                    chartObj.model.legend.responsivePosition = "top";
            }

            this._polarRadius();

            while (((this.model.Radius*2) < chartObj.svgHeight / 2 || chartObj.svgHeight <= 150) && chartObj.svgHeight < chartObj.svgWidth && !this.flag) {
                this.count = BoldBIDashboard.util.isNullOrUndefined(this.count) ? 1 : this.count + 1;
				chartObj.responsiveFlag = true;
                BoldBIDashboard.EjSeriesRender.prototype.responsiveAccLayout(this.count, null, null, null, chartObj);
            }
             if (chartObj.svgWidth <= 200 || chartObj.svgHeight <= 200) {
                 chartObj.model.series[0].responsiveLabelPosition = "inside";
                 chartObj.model.legend.responsiveVisibility = false;
                 chartObj.model.title.responsiveVisibility = false;
                 chartObj.model.title.subTitle.responsiveVisibility = false;
             }
             else
                 chartObj.model.series[0].responsiveLabelPosition = chartObj.model.series[0].labelPosition.toLowerCase();
			 
			 BoldBIDashboard.EjSeriesRender.prototype.accumulationLayout(chartObj, radius);
             BoldBIDashboard.BoldBIDashboardChart._calculateLegendBounds(chartObj);
             BoldBIDashboard.BoldBIDashboardChart._calculateAreaBounds(chartObj.params, chartObj);
             this._polarRadius();
        }

        var pos = 0;

        if (axis.majorGridLines.visible) {

            for (var j = 0; j < length; j++) {

                vector = BoldBIDashboard.EjSvgRender.utils._valueToVector(axis, axis.visibleLabels[j].Value);
                line = {};
                line.X1 = chartModel.centerX;

                line.Y1 = chartModel.centerY;
                line.X2 = chartModel.centerX + chartModel.Radius * vector.X;
                line.Y2 = chartModel.centerY + chartModel.Radius * vector.Y;
                sbXMajorGrid.append("M" + " " + line.X1 + " " + line.Y1 + " " + "L" + " " + line.X2 + " " + line.Y2 + " ");
            }

        }
        if (axis.visible  && axis.responsiveVisibility && axis.majorTickLines.visible) {
            var radius = chartModel.Radius;
            for (var j = 0; j < length; j++) {
                vector = BoldBIDashboard.EjSvgRender.utils._valueToVector(axis, axis.visibleLabels[j].Value);
                line = {};
                line.X1 = chartModel.centerX + radius * vector.X;
                line.Y1 = chartModel.centerY + radius * vector.Y;
                line.X2 = line.X1 + axis.majorTickLines.size * vector.X;
                line.Y2 = line.Y1 + axis.majorTickLines.size * vector.Y;
                var direction = "M" + " " + line.X1 + " " + line.Y1 + " " + "L" + " " + line.X2 + " " + line.Y2 + " ";
                if (direction.indexOf("NaN") == -1)
                    sbXMajorTick.append(direction);
            }
        }
    

   
        if (axis.majorGridLines.visible) {
            xMajorGridDir = sbXMajorGrid.toString();
            var options = {
                'id': this.svgObject.id + '_XAxisGridLines',
                'fill': 'none',
                'stroke-width': axis.majorGridLines.width,
                'stroke': axis.majorGridLines.color,
                'opacity': axis.majorGridLines.opacity,
                'stroke-dasharray': axis.majorGridLines.dashArray,
                'd': xMajorGridDir
            };
            //Drawing XAxis Major Grid Lines
			if (xMajorGridDir.indexOf("NaN")== -1) {
              this.svgRenderer.drawPath(options, gEle);
              bbdesigner$(gEle).appendTo(this.gXaxisEle);
			}
        }

          if (axis.visible  && axis.responsiveVisibility  && axis.majorTickLines.visible) {
                xMajorTickDir = sbXMajorTick.toString();
                var options = {
                    'id': this.svgObject.id + '_XAxisMajorTicks',
                    'fill': 'none',
                    'stroke-width': axis.majorTickLines.width,
                    'stroke': axis.majorTickLines.color,
                    'd': xMajorTickDir
                };
                //Drawing XAxis Major Ticks Lines
                this.svgRenderer.drawPath(options, gEle);
                bbdesigner$(gEle).appendTo(this.gXaxisEle);
            }       
    },
    _drawXAxisTickLine:function(axisIndex,xAxis,gEle)
    {
        var xMajorTicksDir, xMinorTicksDir;
        var sbXMinorTicks = BoldBIDashboard.EjSvgRender.utils._getStringBuilder();       
        var sbXMajorTicks = BoldBIDashboard.EjSvgRender.utils._getStringBuilder();       
        var minorPointX;
        var x1 = Math.floor(xAxis.x);
        var x2 = Math.floor(xAxis.x + xAxis.width);
        var opposedPosition = xAxis._opposed;
        var labelValue;

        if (axisIndex != 0 && ((xAxis.labelPosition == 'inside' && xAxis.tickLinesPosition == 'inside') || (xAxis.labelPosition == 'inside' && xAxis.tickLinesPosition != 'inside')) && (!(xAxis.y == (this.model.m_AreaBounds.Height + this.model.m_AreaBounds.Y) || (xAxis.y == this.model.m_AreaBounds.Y))))
        {
            var y1 = (!opposedPosition) ? Math.floor(xAxis.y + xAxis._LableMaxWidth.height) : Math.floor(xAxis.y - xAxis._LableMaxWidth.height);
            var y2 = (!opposedPosition) ? Math.floor(xAxis.y + xAxis._LableMaxWidth.height) : Math.floor(xAxis.y - xAxis._LableMaxWidth.height);
        }
        else if (axisIndex != 0 && (xAxis.labelPosition != 'inside' && xAxis.tickLinesPosition == 'inside') && (!(xAxis.y == (this.model.m_AreaBounds.Height + this.model.m_AreaBounds.Y) || (xAxis.y == this.model.m_AreaBounds.Y)))) {
            var y1 = (!opposedPosition) ? Math.floor(xAxis.y + xAxis.majorTickLines.size) : Math.floor(xAxis.y - xAxis.majorTickLines.size);
            var y2 = (!opposedPosition) ? Math.floor(xAxis.y + xAxis.majorTickLines.size) : Math.floor(xAxis.y - xAxis.majorTickLines.size);
        }

        else
        {
            var y1 = Math.floor(xAxis.y);
            var y2 = Math.floor(xAxis.y);
        }
        if (!gEle)
        var gTickEle = this.svgRenderer.createGroup({ 'id': this.svgObject.id + '_XAxisTicklines' + '_' + axisIndex });
        xAxis.labelPlacement = (!(xAxis.labelPlacement)) ? BoldBIDashboard.datavisualization.Chart.LabelPlacement.BetweenTicks : xAxis.labelPlacement;
        var ticksbwtLabel = ((xAxis.labels.length > 0) && (xAxis.labelPlacement.toLowerCase() == "betweenticks")) ? -0.5 : 0;
        var collectionLength = xAxis.visibleLabels.length;
        //For between ticks and gridlines
        if ((xAxis._valueType.toLowerCase() == BoldBIDashboard.datavisualization.Chart.ValueType.Category) && ticksbwtLabel < 0) {
            collectionLength = collectionLength > 0 ? xAxis.visibleLabels.length + 1 : collectionLength;
        }
        for (var i = 0; i < collectionLength; i++) {

            labelValue = (!xAxis.visibleLabels[i]) ? xAxis.visibleLabels[i - 1].Value + xAxis.range.interval : xAxis.visibleLabels[i].Value;
 
            var tempInterval = ((xAxis.labels.length > 0) && (ticksbwtLabel < 0)) ? labelValue + ticksbwtLabel : labelValue;

            tempInterval = (!(xAxis.roundingPlaces)) ? parseFloat(tempInterval.toFixed((BoldBIDashboard.EjSvgRender.utils._decimalPlaces(xAxis.visibleRange.interval) == 0 ? 1 : BoldBIDashboard.EjSvgRender.utils._decimalPlaces(xAxis.visibleRange.interval)))) : parseFloat(tempInterval.toFixed(xAxis.roundingPlaces));

            if (BoldBIDashboard.EjSvgRender.utils._inside(tempInterval, xAxis.visibleRange)) {

                if ((xAxis.hidePartialLabels) && ((i == 0) || (i == (collectionLength - 1))))
                    continue;
                if (xAxis.minorGridLines.visible || xAxis.minorTickLines.visible) {
                    var ticksVal = this._getSharpPath(xAxis.minorTickLines.width);
                    var linesVal = this._getSharpPath(xAxis.minorGridLines.width);
                    var yTickPosition;
                    if (xAxis._valueType == "logarithmic") {
                        minorTicks = tempInterval;
                        var logmax = xAxis.visibleRange.max;
                        var logmin = xAxis.visibleRange.min;

                        var logtickstart = Math.pow(xAxis.logBase, minorTicks - xAxis.visibleRange.interval);
                        var logtickend = Math.pow(xAxis.logBase, minorTicks);
                        var logtickInterval = (logtickend - logtickstart) / (xAxis.minorTicksPerInterval + 1);
                        var logtickPos = logtickstart + logtickInterval;
                        minorTicks = BoldBIDashboard.EjSvgRender.utils._logBase(logtickPos, xAxis.logBase);
                        for (var j = 0; j < xAxis.minorTicksPerInterval; j++) {


                            if (minorTicks < logmax && minorTicks > logmin) {

                                minorPointX = Math.ceil(((minorTicks - logmin) / (logmax - logmin)) * (xAxis.width));

                                //Calculate Minor Ticks
                                if ((xAxis.minorTickLines) && xAxis.minorTickLines.visible) {
                                    var xTickPosition = Math.floor(minorPointX + x1);
                                    if ((xAxis.tickLinesPosition != 'inside' && xAxis.labelPosition != 'inside') || (xAxis.tickLinesPosition != 'inside' && xAxis.labelPosition == 'inside'))
                                        yTickPosition = (opposedPosition) ? Math.floor(y1 - xAxis.minorTickLines.size) : Math.floor(xAxis.minorTickLines.size + y1);
                                    else
                                        yTickPosition = (opposedPosition) ? Math.floor(y1 + xAxis.minorTickLines.size) : y1 - Math.floor(xAxis.minorTickLines.size);
                                    sbXMinorTicks.append("M" + " " + (xTickPosition + ticksVal) + " " + (yTickPosition + ticksVal) + " " + "L" + " " + (xTickPosition + ticksVal) + " " + (y1 + ticksVal) + " ");
                                }
                            }
                        }
                    }
                    else {
                        for (var j = 0, minorTicks = tempInterval ; j < xAxis.minorTicksPerInterval; j++) {
                            minorTicks += xAxis.visibleRange.interval / (xAxis.minorTicksPerInterval + 1);
                            if (minorTicks < xAxis.visibleRange.max && minorTicks > xAxis.visibleRange.min) {
                                minorPointX = Math.ceil(((minorTicks - xAxis.visibleRange.min) / (xAxis.visibleRange.max - xAxis.visibleRange.min)) * (xAxis.width));

                                //Calculate Minor Ticks
                                if ((xAxis.minorTickLines) && xAxis.minorTickLines.visible) {
                                    if ((xAxis.tickLinesPosition != 'inside' && xAxis.labelPosition != 'inside') || (xAxis.tickLinesPosition != 'inside' && xAxis.labelPosition == 'inside'))
                                        yTickPosition = (opposedPosition) ? Math.floor(y1 - xAxis.minorTickLines.size) : Math.floor(xAxis.minorTickLines.size + y1);
                                    else
                                        yTickPosition = (opposedPosition) ? Math.floor(y1 + xAxis.minorTickLines.size) : Math.floor(y1 - xAxis.minorTickLines.size);
                                    var points = Math.floor(minorPointX + x1);
                                    sbXMinorTicks.append("M" + " " + (points + ticksVal) + " " + (yTickPosition + ticksVal) + " " + "L" + " " + (points + ticksVal) + " " + (y1 + ticksVal) + " ");
                                }
                            }
                        }
                    }

                }

                //calculate major ticks
                if (xAxis.majorTickLines.visible || xAxis.majorGridLines.visible) {
                    var mtVal = this._getSharpPath(xAxis.majorTickLines.width);
                    var mlVal = this._getSharpPath(xAxis.majorGridLines.width);
                    //Calculate Major Ticks and Grid lines
                    var pointX = this.pointX = Math.ceil(BoldBIDashboard.EjSvgRender.utils._getPointXY(tempInterval, xAxis.visibleRange, xAxis.isInversed) * (xAxis.width));
                    //Calculate Major Ticks
                    if (xAxis.majorTickLines.visible) {
                     
                        var lineStart = xAxis.majorTickLines.size + xAxis.axisLine.width / 2;
                        if ((xAxis.tickLinesPosition == 'inside' && xAxis.labelPosition == 'inside') || (xAxis.tickLinesPosition == 'inside' && xAxis.labelPosition != 'inside'))
                            var yPosition = (opposedPosition) ? y1 + lineStart : y1 - lineStart;
                        else
                            var yPosition = (opposedPosition) ? y1 - lineStart : lineStart + y1 + ((xAxis.zoomFactor < 1 && this.model.zooming.enableScrollbar && axisIndex==0) ? this.model.scrollerSize : 0);
                        sbXMajorTicks.append("M" + " " + (Math.floor(pointX + x1) + mtVal) + " " + (Math.floor(yPosition) + mtVal) + " " + "L" + " " + (Math.floor(pointX + x1) + mtVal) + " " + (Math.floor(y1 + ((opposedPosition) ? (-xAxis.axisLine.width / 2) : (xAxis.axisLine.width / 2))) + mtVal) + " ");
                    }
                }
            }
        }
        //draw minor ticks
        if (xAxis.minorTickLines.visible && xAxis.visible && xAxis.minorTicksPerInterval > 0 && xAxis.responsiveVisibility) {
            xMinorTicksDir = sbXMinorTicks.toString();
            var optionsMinorTicks = {
                'id': this.svgObject.id + '_XAxisMinorTicks_' + axisIndex,
                'fill': 'none',
                'stroke-width': xAxis.minorTickLines.width,
                'stroke': xAxis.minorTickLines.color,
                'd': xMinorTicksDir
            };
            if(!gEle)
                this.svgRenderer.drawPath(optionsMinorTicks, gTickEle);
            else
                this.svgRenderer.drawPath(optionsMinorTicks, gEle);

        }
        if (xAxis.majorTickLines.visible && xAxis.visible && xAxis.responsiveVisibility) {
            xMajorTicksDir = sbXMajorTicks.toString();
            var optionsMajorTicks = {
                'id': this.svgObject.id + '_XAxisMajorTicks_' + axisIndex,
                'fill': 'none',
                'stroke-width': xAxis.majorTickLines.width,
                'stroke': xAxis.majorTickLines.color,
                'd': xMajorTicksDir
            };
            if (!gEle) {
                
                this.svgRenderer.drawPath(optionsMajorTicks, gTickEle);
            }
            else
                this.svgRenderer.drawPath(optionsMajorTicks, gEle);
        }
        if(xAxis.tickLinesPosition=='inside')
            bbdesigner$(gTickEle).appendTo(this.gXaxisEle);
        else
            bbdesigner$(gEle).appendTo(this.gXaxisEle);

    },
    _drawXAxisGridLine: function (axisIndex, xAxis, params) {
        var xMajorGridDir, xMinorGridDir,
			sbXMinorGrid = BoldBIDashboard.EjSvgRender.utils._getStringBuilder(),        
			sbXMajorGrid = BoldBIDashboard.EjSvgRender.utils._getStringBuilder(),
			minorPointX,
			xPoint = [],
			labelValue,
			opposedPosition = xAxis._opposed,
			x1 = Math.floor(xAxis.x),
			x2 = Math.floor(xAxis.x + xAxis.width),
			gEle = this.svgRenderer.createGroup({ 'id': this.svgObject.id + '_XAxisGrid' + '_' + axisIndex }),
			gAgb = this.svgRenderer.createGroup({ 'id': this.svgObject.id + '_XAxisAlternateGridBand' + '_' + axisIndex });
        
        if (axisIndex != 0 && (xAxis.labelPosition == 'inside' && xAxis.tickLinesPosition == 'inside') && (!(xAxis.y == (this.model.m_AreaBounds.Height + this.model.m_AreaBounds.Y) || (xAxis.y == this.model.m_AreaBounds.Y))))
        {
            var y1 = (!opposedPosition) ? Math.floor(xAxis.y + xAxis._LableMaxWidth.height) : Math.floor(xAxis.y - xAxis._LableMaxWidth.height);
            var y2 = (!opposedPosition) ? Math.floor(xAxis.y + xAxis._LableMaxWidth.height) : Math.floor(xAxis.y - xAxis._LableMaxWidth.height);
        }
        else if((xAxis.labelPosition == 'inside' && xAxis.tickLinesPosition != 'inside') && (!(xAxis.y == (this.model.m_AreaBounds.Height + this.model.m_AreaBounds.Y) || (xAxis.y == this.model.m_AreaBounds.Y))))
        {
            var y1 = (!opposedPosition) ? Math.floor(xAxis.y + xAxis._LableMaxWidth.height) : Math.floor(xAxis.y - xAxis._LableMaxWidth.height);
            var y2 = (!opposedPosition) ? Math.floor(xAxis.y + xAxis._LableMaxWidth.height) : Math.floor(xAxis.y - xAxis._LableMaxWidth.height);
        }
        else if (axisIndex != 0 && (xAxis.labelPosition != 'inside' && xAxis.tickLinesPosition == 'inside') && (!(xAxis.y == (this.model.m_AreaBounds.Height + this.model.m_AreaBounds.Y) || (xAxis.y == this.model.m_AreaBounds.Y)))) {
            var y1 = (!opposedPosition) ? Math.floor(xAxis.y + xAxis.majorTickLines.size) : Math.floor(xAxis.y - xAxis.majorTickLines.size);
            var y2 = (!opposedPosition) ? Math.floor(xAxis.y + xAxis.majorTickLines.size) : Math.floor(xAxis.y - xAxis.majorTickLines.size);
        }
        else
        {
            var y1 = Math.floor(xAxis.y);
            var y2 = Math.floor(xAxis.y);
        }
       
        if (xAxis.visible && xAxis.axisLine.visible) {
            var offset = xAxis.axisLine.offset > 0 ? xAxis.axisLine.offset : 0;
            var val=this._getSharpPath(xAxis.axisLine.width);
            var optionsLine = {
                'id': this.svgObject.id + '_XAxisLine_' + axisIndex,
                x1: (x1 - xAxis.plotOffset)+ val + offset ,
                y1: y1+val,
                x2: (x2 + xAxis.plotOffset) -offset+val,
                y2: y2+val,
                'stroke-dasharray': xAxis.axisLine.dashArray,
                'stroke-width': xAxis.axisLine.width,
                'stroke': xAxis.axisLine.color,
                'opacity': xAxis.axisLine.opacity || 1
            };

            params.axes[xAxis.name]._lineOption = [optionsLine, this.gXaxisEle];
        }
		else
			params.axes[xAxis.name]._lineOption = [null, this.gXaxisEle];
        xAxis.labelPlacement = (!(xAxis.labelPlacement)) ? BoldBIDashboard.datavisualization.Chart.LabelPlacement.BetweenTicks : xAxis.labelPlacement;
        var ticksbwtLabel = ((xAxis.labels.length > 0) && (xAxis.labelPlacement.toLowerCase() == "betweenticks")) ? -0.5 : 0;
        var collectionLength = xAxis.visibleLabels.length;
		//For between ticks and gridlines
        if ((xAxis._valueType.toLowerCase() == BoldBIDashboard.datavisualization.Chart.ValueType.Category) && ticksbwtLabel < 0) {
            collectionLength = collectionLength > 0 ? xAxis.visibleLabels.length + 1 : collectionLength;
        }
        for (var i = 0; i < collectionLength; i++) {
			 labelValue = (!xAxis.visibleLabels[i]) ? xAxis.visibleLabels[i - 1].Value + xAxis.range.interval : xAxis.visibleLabels[i].Value;

            var tempInterval = ((xAxis.labels.length > 0) && (ticksbwtLabel < 0)) ? labelValue + ticksbwtLabel : labelValue;

            tempInterval = (!(xAxis.roundingPlaces)) ? parseFloat(tempInterval.toFixed((BoldBIDashboard.EjSvgRender.utils._decimalPlaces(xAxis.visibleRange.interval) == 0 ? 1 : BoldBIDashboard.EjSvgRender.utils._decimalPlaces(xAxis.visibleRange.interval)))) : parseFloat(tempInterval.toFixed(xAxis.roundingPlaces));

            if (BoldBIDashboard.EjSvgRender.utils._inside(tempInterval, xAxis.visibleRange)) {

                if ((xAxis.hidePartialLabels) && ((i == 0) || (i == (collectionLength - 1))))
                    continue;
            
                //Calculate Minor Ticks and Grid lines
                if (xAxis.minorGridLines.visible || xAxis.minorTickLines.visible) {
                    var ticksVal = this._getSharpPath(xAxis.minorTickLines.width);
                    var linesVal = this._getSharpPath(xAxis.minorGridLines.width);
                    var yTickPosition;
                    if (xAxis._valueType == "logarithmic"){
                    minorTicks = tempInterval;
                    var logmax = xAxis.visibleRange.max;
                    var logmin = xAxis.visibleRange.min;

                    var logtickstart = Math.pow(xAxis.logBase, minorTicks - xAxis.visibleRange.interval);
                    var logtickend = Math.pow(xAxis.logBase, minorTicks);
                    var logtickInterval = (logtickend - logtickstart) / (xAxis.minorTicksPerInterval + 1);
                    var logtickPos = logtickstart + logtickInterval;
                    minorTicks = BoldBIDashboard.EjSvgRender.utils._logBase(logtickPos, xAxis.logBase);
                    for (var j = 0; j < xAxis.minorTicksPerInterval; j++) {


                        if (minorTicks < logmax && minorTicks > logmin) {

                            minorPointX = Math.ceil(((minorTicks - logmin) / (logmax - logmin)) * (xAxis.width));

                           

                            //Calculate Minor Gridlines
                            if ((xAxis.minorGridLines) && xAxis.minorGridLines.visible) {
                                var tickPosition = Math.floor(minorPointX + x1) ;
                                sbXMinorGrid.append("M" + " " + (tickPosition + linesVal) + " " + (y1 + linesVal) + " " + "L" + " " + (tickPosition + linesVal) + " " + ( Math.floor(opposedPosition ?  this.model.m_AreaBounds.Y + this.model.m_AreaBounds.Height: this.model.m_AreaBounds.Y) + linesVal) + " ");
                            }

                        }
                        logtickPos += logtickInterval;
                        minorTicks = BoldBIDashboard.EjSvgRender.utils._logBase(logtickPos, xAxis.logBase);
                    }
                    } else {
                        for (var j = 0, minorTicks = tempInterval ; j < xAxis.minorTicksPerInterval; j++) {
                            minorTicks += xAxis.visibleRange.interval / (xAxis.minorTicksPerInterval + 1);
                            if (minorTicks < xAxis.visibleRange.max && minorTicks > xAxis.visibleRange.min) {
                                minorPointX = Math.ceil(((minorTicks - xAxis.visibleRange.min) / (xAxis.visibleRange.max - xAxis.visibleRange.min)) * (xAxis.width));


                                //Calculate Minor Gridlines
                                if ((xAxis.minorGridLines) && xAxis.minorGridLines.visible)
                                    sbXMinorGrid.append("M" + " " + (Math.floor(minorPointX + x1) + linesVal) + " " + (y1 + linesVal) + " " + "L" + " " + (Math.floor(minorPointX + x1) + linesVal) + " " + ( Math.floor(opposedPosition ?  this.model.m_AreaBounds.Y + this.model.m_AreaBounds.Height: this.model.m_AreaBounds.Y) + linesVal) + " ");
                            }
                        }
                    }
            }

                if (xAxis.majorTickLines.visible || xAxis.majorGridLines.visible) {
                    var mtVal = this._getSharpPath(xAxis.majorTickLines.width);
                    var mlVal = this._getSharpPath(xAxis.majorGridLines.width);
                    var pointX = this.pointX = Math.ceil(BoldBIDashboard.EjSvgRender.utils._getPointXY(tempInterval, xAxis.visibleRange, xAxis.isInversed) * (xAxis.width));
                    var mX1 = (Math.floor(pointX + x1));
                    if (xAxis.zoomed)
                        xPoint[0] = xAxis.x;
                    if (i == 0) {
                        if (mX1 == Math.floor(this.model.m_AreaBounds.X)) {
                            xPoint.push(mX1 + mlVal);
                            continue;
                            
                        }
                    }
                    if ((i == (collectionLength - 1)) && (this.model.chartArea.border.color != "transparent" && this.model.chartArea.border.width > 0)) {
                         if (mX1 == Math.floor(this.model.m_AreaBounds.X + this.model.m_AreaBounds.Width))
                             continue;
                         if (xAxis.zoomed)
                             xPoint[collectionLength] = mX1 + mlVal;
                       
                    }
                     
                    //Calculate Major Gridlines
                    if (xAxis.majorGridLines.visible)
                        sbXMajorGrid.append("M" + " " + (mX1 + mlVal) + " " + (Math.floor(this.model.m_AreaBounds.Y + this.model.m_AreaBounds.Height) + mlVal) + " " + "L" + " " + (mX1 + mlVal) + " " + (Math.floor(this.model.m_AreaBounds.Y) + mlVal) + " ");
                    if ((xAxis._valueType.toLowerCase() != "category") && i == collectionLength - 1)
                        continue;
                    xPoint.push((mX1 + mlVal));
                }

            }

        }

       
        if (xAxis.alternateGridBand.odd.fill != "transparent" || xAxis.alternateGridBand.even.fill != "transparent") {
            var height = this.model.m_AreaBounds.Height;
            
            for (var i = 1; i < xPoint.length; i += 2) {
                var width = xPoint[i + 1] - xPoint[i];
                width = (width || xAxis.labelPlacement.toLowerCase() == 'onticks') ? width : (xAxis.width+xAxis.x) - xPoint[i];
                if (i == xPoint.length - 1 && xAxis.zoomed) {
                    var zoomWidth = this.model.m_AreaBounds.X + this.model.m_AreaBounds.Width - xPoint[xPoint.length - 1] - xAxis.plotOffset;
                    width = zoomWidth;
                }
                var optionsAlternateodd = {
                    'id': this.svgObject.id + '_XAxis' + axisIndex + '_Alternateodd' + [i],
                    'x': xPoint[i],
                    'y': Math.floor(this.model.m_AreaBounds.Y),
                    'width': width,
                    'height': height,
                    'fill': xAxis.alternateGridBand.odd.fill,
                    'opacity': xAxis.alternateGridBand.odd.opacity,
                    'stroke': "transparent",
                    'clip-path': 'url(#' + this.svgObject.id + '_ChartAreaClipRect)'

                };
                this.svgRenderer.drawRect(optionsAlternateodd, gAgb);
            }

            for (var i = 0; i < xPoint.length; i += 2) {
                var width = xPoint[i + 1] - xPoint[i];
                width = (width || xAxis.labelPlacement.toLowerCase() == 'onticks') ? width : (xAxis.width + xAxis.x) - xPoint[i];
                if (i == 0 && xAxis.zoomed) {
                    var zoomWidth = xPoint[1] - xAxis.x;
                    width = zoomWidth;
                }
                if (i == xPoint.length - 1 && xAxis.zoomed) {
                    var zoomWidth = this.model.m_AreaBounds.X + this.model.m_AreaBounds.Width - xPoint[xPoint.length - 1]-xAxis.plotOffset;
                    width = zoomWidth;
                }
                var optionsAlternateeven = {
                    'id': this.svgObject.id + '_XAxis' + axisIndex + '_Alternateeven' + [i],
                    'x': xPoint[i],
                    'y': Math.floor(this.model.m_AreaBounds.Y),
                    'width': width,
                    'height': height,
                    'fill': xAxis.alternateGridBand.even.fill,
                    'opacity': xAxis.alternateGridBand.even.opacity,
                    'clip-path': 'url(#' + this.svgObject.id + '_ChartAreaClipRect)',
                    'stroke': "transparent"
                };
                this.svgRenderer.drawRect(optionsAlternateeven, gAgb);
            }
            bbdesigner$(gAgb).appendTo(gEle);
        }
        if (xAxis.minorGridLines.visible && xAxis.minorTicksPerInterval > 0) {
            xMinorGridDir = sbXMinorGrid.toString();
            //Drawing Minor Grid Lines
            var optionsMinorGrid = {
                'id': this.svgObject.id + '_XAxisMinorGridLines_' + axisIndex,
                'fill': 'none',
                'stroke-width': xAxis.minorGridLines.width,
                'stroke': xAxis.minorGridLines.color,
                'stroke-dasharray': xAxis.minorGridLines.dashArray,
                'd': xMinorGridDir
            };
            this.svgRenderer.drawPath(optionsMinorGrid, gEle);
        }       
        xMajorGridDir = sbXMajorGrid.toString();
        if (xAxis.majorGridLines.visible) {
            var options = {
                'id': this.svgObject.id + '_XAxisMajorGridLines_' + axisIndex,
                'fill': 'none',
                'stroke-width': xAxis.majorGridLines.width,
                'stroke': xAxis.majorGridLines.color,
                'opacity': xAxis.majorGridLines.opacity,
                'stroke-dasharray': xAxis.majorGridLines.dashArray,
                'd': xMajorGridDir
            };

            //Drawing Major Grid Lines
            if(options.d != '')
            this.svgRenderer.drawPath(options, gEle);

        }
        bbdesigner$(gEle).appendTo(this.svgObject);
         
        
    },

    _drawYAxisTickLine:function(axisIndex,yAxis,gEle)
    {
        var yMajorTicksDir = "", yMinorTicksDir = "";
        var pointY = 0;
        var opposedPosition = yAxis._opposed;
		 var labelValue;
        if (axisIndex != 1 && ((yAxis.labelPosition == 'inside' && yAxis.tickLinesPosition == 'inside') || (yAxis.labelPosition == 'inside' && yAxis.tickLinesPosition != 'inside')) && (!(yAxis.x == (this.model.m_AreaBounds.Width + this.model.m_AreaBounds.X) || (yAxis.x == (this.model.m_AreaBounds.X))))) {
            var x1 = (!opposedPosition) ? Math.floor(yAxis.x - yAxis._LableMaxWidth.width - this.model.elementSpacing) : Math.floor(yAxis.x + yAxis._LableMaxWidth.width + this.model.elementSpacing);
            var x2 = (!opposedPosition) ? Math.floor(yAxis.x - yAxis._LableMaxWidth.width - this.model.elementSpacing) : Math.floor(yAxis.x + yAxis._LableMaxWidth.width + this.model.elementSpacing);
        }
        else if (axisIndex != 1 && (yAxis.labelPosition != 'inside' && yAxis.tickLinesPosition == 'inside') && (!(yAxis.x == (this.model.m_AreaBounds.Width + this.model.m_AreaBounds.X) || (yAxis.x == (this.model.m_AreaBounds.X))))) {
            var x1 = Math.floor(yAxis.x+yAxis.majorTickLines.size);
            var x2 = Math.floor(yAxis.x+yAxis.majorTickLines.size);
        }
        else            
        {
            var x1 = Math.floor(yAxis.x);
            var x2 = Math.floor(yAxis.x);
        }   

        var y1 = Math.floor(yAxis.y + yAxis.height);
        var y2 = Math.floor(yAxis.y);       
    

        var sbYMinorTicks = BoldBIDashboard.EjSvgRender.utils._getStringBuilder();   
        var sbYMajorTicks = BoldBIDashboard.EjSvgRender.utils._getStringBuilder();      
        var gTickEle = this.svgRenderer.createGroup({ 'id': this.svgObject.id + '_YAxisTicklines' + '_' + axisIndex });
      
		 yAxis.labelPlacement = (!(yAxis.labelPlacement)) ? BoldBIDashboard.datavisualization.Chart.LabelPlacement.BetweenTicks : yAxis.labelPlacement;
        var ticksbwtLabel = ((yAxis.labels.length > 0) && (yAxis.labelPlacement.toLowerCase() == "betweenticks")) ? -0.5 : 0;
        var collectionLength = yAxis.visibleLabels.length;
        //For between ticks and gridlines
        if ((yAxis._valueType.toLowerCase() == BoldBIDashboard.datavisualization.Chart.ValueType.Category) && ticksbwtLabel < 0) {
            collectionLength = collectionLength > 0 ? yAxis.visibleLabels.length + 1 : collectionLength;
        }
        for (var i = 0; i < collectionLength; i++)
        {
            labelValue = (!yAxis.visibleLabels[i]) ? yAxis.visibleLabels[i - 1].Value + yAxis.range.interval : yAxis.visibleLabels[i].Value;
            var tempInterval = ((yAxis.labels.length > 0) && (ticksbwtLabel < 0)) ? labelValue + ticksbwtLabel : labelValue;
            tempInterval = (!(yAxis.roundingPlaces)) ? parseFloat(tempInterval.toFixed((BoldBIDashboard.EjSvgRender.utils._decimalPlaces(yAxis.visibleRange.interval) == 0 ? 1 : BoldBIDashboard.EjSvgRender.utils._decimalPlaces(yAxis.visibleRange.interval)))) : parseFloat(tempInterval.toFixed(yAxis.roundingPlaces));

            if (BoldBIDashboard.EjSvgRender.utils._inside(tempInterval, yAxis.visibleRange))
            {
 
                if ((yAxis.hidePartialLabels) && ((i == 0) || (i == (yAxis.visibleLabels.length - 1))))
                    continue;

                // Calculate Minor Ticks and Grid lines      
                if (yAxis.minorGridLines.visible || yAxis.minorTickLines.visible) {
                    var minorPointY;
                    var tickVal = this._getSharpPath(yAxis.minorTickLines.width);
                    var lineVal = this._getSharpPath(yAxis.minorGridLines.width);
                    if (yAxis._valueType == "logarithmic") {
                        minorTicks = tempInterval;
                        var logmax = yAxis.visibleRange.max;
                        var logmin = yAxis.visibleRange.min;

                        var logtickstart = Math.pow(yAxis.logBase, minorTicks - yAxis.visibleRange.interval);
                        var logtickend = Math.pow(yAxis.logBase, minorTicks);
                        var logtickInterval = (logtickend - logtickstart) / (yAxis.minorTicksPerInterval + 1);
                        var logtickPos = logtickstart + logtickInterval;
                        minorTicks = BoldBIDashboard.EjSvgRender.utils._logBase(logtickPos, yAxis.logBase);
                        for (var j = 0; j < yAxis.minorTicksPerInterval; j++) {


                            if (minorTicks < logmax && minorTicks > logmin) {

                                minorPointY = Math.ceil(((minorTicks - logmin) / (logmax - logmin)) * (yAxis.height));

                                //Calculate Minor Ticks
                                if ((yAxis.minorTickLines) && yAxis.minorTickLines.visible) {

                                    if (yAxis.minorTickLines.visible) {
                                        if ((yAxis.tickLinesPosition != 'inside' && yAxis.labelPosition != 'inside') || (yAxis.tickLinesPosition != 'inside' && yAxis.labelPosition == 'inside'))
                                            ytickPosition = (opposedPosition) ? yAxis.minorTickLines.size : -yAxis.minorTickLines.size;
                                        else
                                            var ytickPosition = (opposedPosition) ? -yAxis.minorTickLines.size : yAxis.minorTickLines.size;
                                        sbYMinorTicks.append("M" + " " + (Math.floor(ytickPosition + x1) + tickVal) + " " + (Math.floor((minorPointY * -1) + y1) + tickVal) + " " + "L" + " " + (x1 + tickVal) + " " + (Math.floor((minorPointY * -1) + y1) + tickVal) + " ");
                                    }
                                }                              
                            }
                            logtickPos += logtickInterval;
                            minorTicks = BoldBIDashboard.EjSvgRender.utils._logBase(logtickPos, yAxis.logBase);
                        }
                    }
                    else {
                        for (var j = 0, minorTicks = tempInterval; j < yAxis.minorTicksPerInterval; j++) {

                            minorTicks += yAxis.visibleRange.interval / (yAxis.minorTicksPerInterval + 1);
                            if (minorTicks < yAxis.visibleRange.max && minorTicks > yAxis.visibleRange.min) {
                                minorPointY = ((minorTicks - yAxis.visibleRange.min) / (yAxis.visibleRange.delta)) * (yAxis.height);
                                // Calculate Minor Ticks   
                                if (yAxis.minorTickLines.visible) {
                                    if ((yAxis.tickLinesPosition != 'inside' && yAxis.labelPosition != 'inside') || (yAxis.tickLinesPosition != 'inside' && yAxis.labelPosition == 'inside'))
                                        var ytickPosition = (opposedPosition) ? yAxis.minorTickLines.size : -yAxis.minorTickLines.size;
                                    else
                                        var ytickPosition = (opposedPosition) ? -yAxis.minorTickLines.size : yAxis.minorTickLines.size;
                                    sbYMinorTicks.append("M" + " " + (Math.floor(ytickPosition + x1) + tickVal) + " " + (Math.floor((minorPointY * -1) + y1) + tickVal) + " " + "L" + " " + (x1 + tickVal) + " " + (Math.floor((minorPointY * -1) + y1) + tickVal) + " ");
                                }
                               
                            }
                        }
                    }
                }
                // Calculate Major Ticks and Grid lines
                if (yAxis.majorTickLines.visible || yAxis.majorGridLines.visible) {
                    var mtVal = this._getSharpPath(yAxis.minorTickLines.width);
                    var mlVal = this._getSharpPath(yAxis.majorGridLines.width);
                    // Calculate Major Ticks
                    if (yAxis.majorTickLines.visible)
                    {
                        pointY = BoldBIDashboard.EjSvgRender.utils._getPointXY(tempInterval, yAxis.visibleRange, yAxis.isInversed) * (yAxis.height);
                        if ((yAxis.tickLinesPosition != 'inside' && yAxis.labelPosition != 'inside') || (yAxis.tickLinesPosition != 'inside' && yAxis.labelPosition == 'inside'))
                            var xPosition = (opposedPosition) ? yAxis.majorTickLines.size + yAxis.axisLine.width / 2 : -(yAxis.majorTickLines.size + yAxis.axisLine.width / 2) - ((yAxis.zoomFactor < 1 && this.model.zooming.enableScrollbar && axisIndex == 1) ? this.model.scrollerSize : 0);
                        else if ((yAxis.tickLinesPosition == 'inside' && yAxis.labelPosition != 'inside') || (yAxis.tickLinesPosition == 'inside' && yAxis.labelPosition == 'inside'))
                            var xPosition = (opposedPosition) ? -(yAxis.majorTickLines.size + yAxis.axisLine.width / 2) : (yAxis.majorTickLines.size + yAxis.axisLine.width / 2);

                        sbYMajorTicks.append("M" + " " + (Math.floor(xPosition + x1) + mtVal) + " " + (Math.floor((pointY * -1) + y1) + mtVal) + " " + "L" + " " + (Math.floor(x1 + ((opposedPosition) ? (yAxis.axisLine.width / 2) : (yAxis.axisLine.width / 2))) + mtVal) + " " + (Math.floor((pointY * -1) + y1) + mtVal) + " ");

                    }


                   
                }
            }
        }

        //Drawning Minor Ticks
        if (yAxis.minorTickLines.visible && yAxis.visible && yAxis.responsiveVisibility && yAxis.minorTicksPerInterval > 0) {
            yMinorTicksDir = sbYMinorTicks.toString();
            var optionsMinotTick = {
                'id': this.svgObject.id + '_YAxisMinorTicks_' + axisIndex,
                'fill': 'none',
                'stroke-width': yAxis.minorTickLines.width,
                'stroke': yAxis.minorTickLines.color,
                'd': yMinorTicksDir
            };
			this.svgRenderer.drawPath(optionsMinotTick, gEle);
        }
       

        if (yAxis.majorTickLines.visible && yAxis.visible && yAxis.responsiveVisibility) {
            yMajorTicksDir = sbYMajorTicks.toString();
            //Drawning Major Ticks
            var optionsMajorTick = {
                'id': this.svgObject.id + '_YAxisMajorTicks_' + axisIndex,
                'fill': 'none',
                'stroke-width': yAxis.majorTickLines.width,
                'stroke': yAxis.majorTickLines.color,
                'd': yMajorTicksDir
            };
			this.svgRenderer.drawPath(optionsMajorTick, gEle);
        }
		bbdesigner$(gEle).appendTo(this.gYaxisEle);

    },

    _drawYAxisGridLine: function (axisIndex, yAxis, params) {

        var yMajorGridDir = "", yMajorTicksDir = "", yMinorTicksDir = "", yMinorGridDir = "";
        var pointY = 0;
        var labelValue;
        var y1 = Math.floor(yAxis.y + yAxis.height);
        var y2 = Math.floor(yAxis.y);
        var opposedPosition = yAxis._opposed;
        var yPoint = [];
        var axisName = (yAxis.name).replace(/[^a-zA-Z0-9]/g, "");
        if (axisIndex != 1 && ((yAxis.labelPosition == 'inside' && yAxis.tickLinesPosition == 'inside') || (yAxis.labelPosition == 'inside' && yAxis.tickLinesPosition != 'inside')) && (!(yAxis.x == (this.model.m_AreaBounds.Width + this.model.m_AreaBounds.X) || (yAxis.x == (this.model.m_AreaBounds.X))))) {
            var x1 = (!opposedPosition) ? Math.floor(yAxis.x - yAxis._LableMaxWidth.width - this.model.elementSpacing) : Math.floor(yAxis.x + yAxis._LableMaxWidth.width + this.model.elementSpacing);
            var x2 = (!opposedPosition) ? Math.floor(yAxis.x - yAxis._LableMaxWidth.width - this.model.elementSpacing) : Math.floor(yAxis.x + yAxis._LableMaxWidth.width + this.model.elementSpacing);
        }
    else if(axisIndex != 1 && (yAxis.labelPosition != 'inside' && yAxis.tickLinesPosition == 'inside') && (!(yAxis.x == (this.model.m_AreaBounds.Width + this.model.m_AreaBounds.X) || (yAxis.x == (this.model.m_AreaBounds.X))))) 
        {
            var x1 = (!opposedPosition) ? Math.floor(yAxis.x - yAxis.majorTickLines.size) : Math.floor(yAxis.x + yAxis.majorTickLines.size);
            var x2 = (!opposedPosition) ? Math.floor(yAxis.x - yAxis.majorTickLines.size) : Math.floor(yAxis.x + yAxis.majorTickLines.size);
        }
        else {
            var x1 = Math.floor(yAxis.x);
            var x2 = Math.floor(yAxis.x);
        }             
        var sbYMinorGrid = BoldBIDashboard.EjSvgRender.utils._getStringBuilder();        
        var sbYMajorGrid = BoldBIDashboard.EjSvgRender.utils._getStringBuilder();
        var gEle = this.svgRenderer.createGroup({ 'id': this.svgObject.id + '_YAxisGrid' + '_' + axisIndex });
        var gAgb = this.svgRenderer.createGroup({ 'id': this.svgObject.id + '_YAxisAlternateGridBand' + '_' + axisIndex });

        if (yAxis.visible && yAxis.axisLine.visible) {
            var offset = yAxis.axisLine.offset > 0 ? yAxis.axisLine.offset : 0;
            var val = this._getSharpPath(yAxis.axisLine.width);
            
            var optionsLine = {
                'id': this.svgObject.id +axisName + '_YAxisLine_' + axisIndex,
                x1: x1+val,
                y1: (y2 - yAxis.plotOffset) + offset+val,
                x2: x2+val,
                y2: (y1 + yAxis.plotOffset) - offset+val,
                'stroke-width': yAxis.axisLine.width,
                'stroke-dasharray': yAxis.axisLine.dashArray,
                'stroke': yAxis.axisLine.color,
                'opacity': yAxis.axisLine.opacity||1
            };
            params.axes[yAxis.name]._lineOption = [optionsLine, this.gYaxisEle];
        }
		else
			params.axes[yAxis.name]._lineOption = [null, this.gYaxisEle];
     
        if (yAxis.axisBottomLine) {
            if (yAxis.axisBottomLine.visible) {
                var optionsBottomLine = {
                    'id': this.svgObject.id +axisName+ '_YAxisBottomLine_' + axisIndex,
                    x1: this.model.m_AreaBounds.X,
                    y1: y1,
                    x2: this.model.m_AreaBounds.X + this.model.m_AreaBounds.Width,
                    y2: y1,
                    'stroke-width': yAxis.axisBottomLine.width,
                    'stroke': yAxis.axisBottomLine.color
                };
                this.svgRenderer.drawLine(optionsBottomLine, gEle);
            }
        }
        yAxis.labelPlacement = (!(yAxis.labelPlacement)) ? BoldBIDashboard.datavisualization.Chart.LabelPlacement.BetweenTicks : yAxis.labelPlacement;
        var ticksbwtLabel = ((yAxis.labels.length > 0) && (yAxis.labelPlacement.toLowerCase() == "betweenticks")) ? -0.5 : 0;
        var collectionLength = yAxis.visibleLabels.length;
        for (var i = 0; i < collectionLength; i++) {
            labelValue = yAxis.visibleLabels[i].Value;
            var tempInterval = ((yAxis.labels.length > 0) && (ticksbwtLabel < 0)) ? labelValue + ticksbwtLabel : labelValue;
            tempInterval = (!(yAxis.roundingPlaces)) ? parseFloat(tempInterval.toFixed((BoldBIDashboard.EjSvgRender.utils._decimalPlaces(yAxis.visibleRange.interval) == 0 ? 1 : BoldBIDashboard.EjSvgRender.utils._decimalPlaces(yAxis.visibleRange.interval)))) : parseFloat(tempInterval.toFixed(yAxis.roundingPlaces));

            if (BoldBIDashboard.EjSvgRender.utils._inside(tempInterval, yAxis.visibleRange)) {

                if ((yAxis.hidePartialLabels) && ((i == 0) || (i == (yAxis.visibleLabels.length - 1))))
                    continue;

                // Calculate Minor Ticks and Grid lines      
                if (yAxis.minorGridLines.visible || yAxis.minorTickLines.visible) {
                    var minorPointY;
                    var tickVal = this._getSharpPath(yAxis.minorTickLines.width);
                    var lineVal = this._getSharpPath(yAxis.minorGridLines.width);
                    if (yAxis._valueType == "logarithmic") {
                        minorTicks = tempInterval;
                        var logmax = yAxis.visibleRange.max;
                        var logmin = yAxis.visibleRange.min;

                        var logtickstart = Math.pow(yAxis.logBase, minorTicks - yAxis.visibleRange.interval);
                        var logtickend = Math.pow(yAxis.logBase, minorTicks);
                        var logtickInterval = (logtickend - logtickstart) / (yAxis.minorTicksPerInterval + 1);
                        var logtickPos = logtickstart + logtickInterval;
                        minorTicks = BoldBIDashboard.EjSvgRender.utils._logBase(logtickPos, yAxis.logBase);
                        for (var j = 0; j < yAxis.minorTicksPerInterval; j++) {


                            if (minorTicks < logmax && minorTicks > logmin) {

                                minorPointY = Math.ceil(((minorTicks - logmin) / (logmax - logmin)) * (yAxis.height));

                            
                              
                                //Calculate Minor Gridlines
                                if (yAxis.minorGridLines.visible)
                                    sbYMinorGrid.append("M" + " " + (Math.floor(this.model.m_AreaBounds.X) + lineVal) + " " + (Math.floor((minorPointY * -1) + y1) + lineVal) + " " + "L" + " " + (Math.floor(this.model.m_AreaBounds.Width + this.model.m_AreaBounds.X) + lineVal) + " " + (Math.floor((minorPointY * -1) + y1) + lineVal) + " ");

                            }
                            logtickPos += logtickInterval;
                            minorTicks = BoldBIDashboard.EjSvgRender.utils._logBase(logtickPos,yAxis.logBase);
                        }
                    } else {
                        for (var j = 0, minorTicks = tempInterval; j < yAxis.minorTicksPerInterval; j++) {

                            minorTicks += yAxis.visibleRange.interval / (yAxis.minorTicksPerInterval + 1);
                            if (minorTicks < yAxis.visibleRange.max && minorTicks > yAxis.visibleRange.min) {
                                  minorPointY = ((minorTicks - yAxis.visibleRange.min) / (yAxis.visibleRange.delta)) * (yAxis.height);
                              
                                // Calculate Minor Grid lines   
                                if (yAxis.minorGridLines.visible)
                                    sbYMinorGrid.append("M" + " " + (Math.floor(this.model.m_AreaBounds.X) + lineVal) + " " + (Math.floor((minorPointY * -1) + y1) + lineVal) + " " + "L" + " " + (Math.floor(this.model.m_AreaBounds.Width + this.model.m_AreaBounds.X) + lineVal) + " " + (Math.floor((minorPointY * -1) + y1) + lineVal) + " ");
                            }
                        }
                    }
                } 
                // Calculate Grid lines
                if (yAxis.majorTickLines.visible || yAxis.majorGridLines.visible) {
                    var mtVal = this._getSharpPath(yAxis.minorTickLines.width);
                    var mlVal = this._getSharpPath(yAxis.majorGridLines.width);
                   
                    // Calculate Major Grid lines
                    if (yAxis.majorGridLines.visible) {
                        pointY = BoldBIDashboard.EjSvgRender.utils._getPointXY(tempInterval, yAxis.visibleRange, yAxis.isInversed) * (yAxis.height);
                        var mX1 = (Math.floor(this.model.m_AreaBounds.X) + mlVal);
                        var mY1 = (Math.floor((pointY * -1) + y1) );
                        var mX2 = (Math.floor(this.model.m_AreaBounds.Width + this.model.m_AreaBounds.X) + mlVal);
                        if (i == 0) {
                            if (mY1==Math.floor(this.model.m_AreaBounds.Y + this.model.m_AreaBounds.Height))
                                continue;
                            if (yAxis.zoomed)
                                yPoint[0] = mY1 + mlVal;
                            
                        }
                        if ((i == (yAxis.visibleLabels.length - 1)) && (this.model.chartArea.border.color != "transparent" && this.model.chartArea.border.width > 0)) {
                           
                            if (mY1 == (Math.floor(this.model.m_AreaBounds.Y))) {
                                yPoint.push(mY1 + mlVal);
                                continue;
                            }

                        }
                       
                        

                        sbYMajorGrid.append("M" + " " + mX1 + " " + (mY1 + mlVal) + " " + "L" + " " + mX2 + " " + (mY1 + mlVal) + " ");
                        if (i == 0) 
                            continue;
                        
                        yPoint.push(mY1 + mlVal);
                        
                    }
                }
            }
        }
        
        if (yAxis.alternateGridBand.odd.fill != "transparent" || yAxis.alternateGridBand.even.fill != "transparent") {
           
            var width = this.model.m_AreaBounds.Width;
            if (yAxis.zoomed) {
                yPoint[yPoint.length] = yAxis.y;
                
            }
            for (var i = 1; i < yPoint.length; i += 2) {
                var height = yPoint[0] - yPoint[1];
                if (i == yPoint.length - 1 && yAxis.zoomed) {
                    var zoomHeight = yPoint[yPoint.length - 2] - yAxis.y;
                    height = zoomHeight;
                }
                var yoptionsAlternateodd = {
                    'id': this.svgObject.id + '_YAxisAlternateodd' + [i],
                    'x': Math.floor(this.model.m_AreaBounds.X),
                    'y': yPoint[i],
                    'width': width,
                    'height': height,
                    'fill': yAxis.alternateGridBand.odd.fill,
                    'opacity': yAxis.alternateGridBand.odd.opacity,
                    'stroke' : "transparent",
                    'clip-path': 'url(#' + this.svgObject.id + '_ChartAreaClipRect)'
                };
                this.svgRenderer.drawRect(yoptionsAlternateodd, gAgb);
            }
            
            for (var i = 0; i < yPoint.length; i += 2) {
                var height = yPoint[0] - yPoint[1];
                if (i == yPoint.length - 1 && yAxis.zoomed) {
                    var zoomHeight = yPoint[yPoint.length - 2] - yAxis.y;
                    height = zoomHeight;
                }
                if (i == 0 && yAxis.zoomed) {
                    var zoomHeight = yAxis.y + yAxis.height - yPoint[0] - yAxis.plotOffset;
                    height = zoomHeight;
                }
                var yoptionsAlternateeven = {
                    'id': this.svgObject.id + '_YAxisAlternateeven' + [i],
                    'x': Math.floor(this.model.m_AreaBounds.X),
                    'y': yPoint[i],
                    'width': width,
                    'height': height,
                    'fill': yAxis.alternateGridBand.even.fill,
                    'opacity': yAxis.alternateGridBand.even.opacity,
                    'stroke': "transparent",
                    'clip-path': 'url(#' + this.svgObject.id + '_ChartAreaClipRect)'
                };
                this.svgRenderer.drawRect(yoptionsAlternateeven, gAgb);
            }
            bbdesigner$(gAgb).appendTo(gEle);
        }

     
        if (yAxis.minorGridLines.visible && yAxis.minorTicksPerInterval > 0) {
            //Drawning Minor Grid Lines
            yMinorGridDir = sbYMinorGrid.toString();
            var optionsMinorGrid = {
                'id': this.svgObject.id + '_YAxisMinorGridLines_' + axisIndex,
                'fill': 'none',
                'stroke-width': yAxis.minorGridLines.width,
                'stroke': yAxis.minorGridLines.color,
                'stroke-dasharray': yAxis.minorGridLines.dashArray,
                'd': yMinorGridDir
            };
            this.svgRenderer.drawPath(optionsMinorGrid, gEle);

        }

        //Drawing Major Grid Lines
        yMajorGridDir = sbYMajorGrid.toString();
        if (yAxis.majorGridLines.visible) {
            var options = {
                'id': this.svgObject.id + '_YAxisMajorGridLines_' + axisIndex,
                'fill': 'none',
                'stroke-width': yAxis.majorGridLines.width,
                'opacity': yAxis.majorGridLines.opacity,
                'stroke-dasharray': yAxis.majorGridLines.dashArray,
                'stroke': yAxis.majorGridLines.color,
                'd': yMajorGridDir
            };

            if(options.d != '')
                this.svgRenderer.drawPath(options, gEle);

        }
        bbdesigner$(gEle).appendTo(this.svgObject);
    },
	
    _drawXAxisLabels: function (axisIndex, xAxis) {
        var gTickEle = this.svgRenderer.createGroup({ 'id': this.svgObject.id + '_XAxisLabels' + '_' + axisIndex, 'cursor': 'default' }),
            gEle = this.svgRenderer.createGroup({ 'id': this.svgObject.id + '_XAxisLabels' + '_' + axisIndex, 'cursor': 'default' }),
            prevLabels = [],
            bounds,
            labelSize,
            axisName = (xAxis.name).replace(/[^a-zA-Z0-9]/g, ""),
            isScroll = this.model._xScroll;
        var opposedPosition = xAxis._opposed;
        if (axisIndex != 0 && ((xAxis.labelPosition == 'inside' && xAxis.tickLinesPosition == 'inside')||(xAxis.labelPosition == 'inside' && xAxis.tickLinesPosition != 'inside')) && (!(xAxis.y == (this.model.m_AreaBounds.Height + this.model.m_AreaBounds.Y) || (xAxis.y == this.model.m_AreaBounds.Y)))) {

            xAxis.y = (!opposedPosition) ? Math.floor(xAxis.y + xAxis._LableMaxWidth.height) : Math.floor(xAxis.y - xAxis._LableMaxWidth.height);
        }
        else if (axisIndex != 0 && (xAxis.labelPosition != 'inside' && xAxis.tickLinesPosition == 'inside') && (!(xAxis.y == (this.model.m_AreaBounds.Height + this.model.m_AreaBounds.Y) || (xAxis.y == this.model.m_AreaBounds.Y)))) {
            xAxis.y = (!opposedPosition) ? Math.floor(xAxis.y+xAxis.majorTickLines.size) : Math.floor(xAxis.y-xAxis.majorTickLines.size);
        }
        else
            xAxis.y = Math.floor(xAxis.y); 
			
		var labels = xAxis.visibleLabels;
        // loop to draw labels
        for (var i = 0; i < labels.length; i++) {
            var label = labels[i];
            var labelText = label.displayText = BoldBIDashboard.util.isNullOrUndefined(label.displayText) ? label.Text : label.displayText;
            if (BoldBIDashboard.EjSvgRender.utils._inside(label.Value, xAxis.visibleRange)) {
                //Declaration
               var textanchor = null, newGapVal1, newGapVal2, nextPointX, nextLabel, nextLabelValue;
                var textcollection = [];
                    var gap = xAxis.width / labels.length;       //space between ticks
                    var trimGap = xAxis.maximumLabelWidth // this holds maximumLabelWidth value 
                    var enableTrim = xAxis.enableTrim;
                    var range = xAxis.visibleRange;
                    var areaBoundWidth = this.model.m_AreaBounds.Width;
                    if(!BoldBIDashboard.isNullOrUndefined(xAxis.valueType)){
                    if (i<labels.length-1 && xAxis.valueType.toLowerCase() == "datetimecategory" && xAxis.labelIntersectAction == "wrap" && xAxis.labelPlacement.toLowerCase() == "betweenticks")
                    {
                        nextLabel = labels[i + 1];
                        label.Value -= .5;
                        nextLabelValue = nextLabel.Value - .5;
                    }
					}
                    var pointX = Math.abs(Math.floor(BoldBIDashboard.EjSvgRender.utils._getPointXY(label.Value, range, xAxis.isInversed) * (xAxis.width)));
                    if(!BoldBIDashboard.isNullOrUndefined(xAxis.valueType)){
                    if (i < labels.length - 1 && xAxis.valueType.toLowerCase() == "datetimecategory" && xAxis.labelIntersectAction == "wrap" && xAxis.labelPlacement.toLowerCase() == "betweenticks") {
                        nextPointX = Math.abs(Math.floor(BoldBIDashboard.EjSvgRender.utils._getPointXY(nextLabelValue, range, xAxis.isInversed) * (xAxis.width)));
                        newGapVal1 = (i == 0) ? (xAxis.x + pointX) + (xAxis.majorTickLines.width - 0.5) : (xAxis.x + pointX) + (xAxis.majorTickLines.width + 0.5);
                        newGapVal2 = (xAxis.x + nextPointX) + (xAxis.majorTickLines.width + 0.5);
                        gap = newGapVal2 - newGapVal1;
                    }
                    else if (xAxis.valueType.toLowerCase() == "datetimecategory" && xAxis.labelIntersectAction == "wrap" && xAxis.labelPlacement.toLowerCase() == "betweenticks") {
                        gap = (xAxis.width + xAxis.x) - newGapVal2;
                        newGapVal1 = newGapVal2;
                    }
                    else if (xAxis.valueType.toLowerCase() == "datetimecategory" && xAxis.labelIntersectAction == "wrap" && xAxis.labelPlacement.toLowerCase() == "onticks") {
                        gap = xAxis.width / xAxis.labels.length;
                    }
					}					
                    xAxis._gap = newGapVal1;
                    var textSize = BoldBIDashboard.EjSvgRender.utils._measureText(labelText, areaBoundWidth, xAxis.font);
                    var textWidth = textSize.width;
                    var textHeight = textSize.height;
                    var labelMaxWidth = xAxis._LableMaxWidth;
                    var labelMaxHeight = labelMaxWidth.height;
                    var labelMaxRow = labelMaxWidth.rows == 0 ? 1 : labelMaxWidth.rows;
                    var vmlrendering = this.svgRenderer.vmlNamespace;
                    var opposedPosition = xAxis.opposedPosition;
                    var lineWidth = xAxis.axisLine.width;
                    var font = xAxis.font;
					var labelIntersectAction = xAxis.labelIntersectAction;
                    var labelPlacement = xAxis.labelPlacement.toLowerCase();
					var labelRotation = BoldBIDashboard.util.isNullOrUndefined(xAxis.rotationValue) ? 0 : xAxis.rotationValue;
					var count = 0, currentLabel;
                    var flag = false;
                    this.edgeLabel = false; // flag to find the supprot for edge labels
                    var chartAreaWidth = this.model.m_AreaBounds.Width;
                    var chartAreaX = this.model.m_AreaBounds.X;
                    var svgWidth = bbdesigner$(this.svgObject).width();                   
                    //To Perform trim 
                    var intersectAction = labelIntersectAction.toLowerCase();
                    if (this.model.adaptiveRendering && intersectAction == "")
                        intersectAction = (gap < 20) ? "hide" : "trim";
                    if (intersectAction == "trim" || enableTrim) {
                        if (labelPlacement == "onticks" && i != labels.length -1) {
                            var nextLabel = labels[i+1];
                            var nextPoint = Math.abs(Math.floor(BoldBIDashboard.EjSvgRender.utils._getPointXY(nextLabel.Value, range, xAxis.isInversed) * (xAxis.width)));
                            var nextTextWidth = BoldBIDashboard.EjSvgRender.utils._measureText(nextLabel.Text, areaBoundWidth, xAxis.font).width;
                            var value = nextPoint - nextTextWidth / 2;
                            var count = 0, current = false;
                            while (value < pointX + textWidth / 2 &&  count<2) {             // intersect
                                count++; 
                                if (nextTextWidth > textWidth) {                            // getting max label
                                    otherLabel = trimLabel = nextLabel;
                                    current = false;
                                }
                                else {
                                    trimLabel = label;
                                    current = true;
                                }
                                var trimLabelText = trimLabel.displayText = trimLabel.Text.toString();
                                for (var t = 1; t < trimLabelText.length; t++) {
                                    trimLabelText = trimLabel.displayText.substring(0, t) + '... ';
                                    newTextWidth = BoldBIDashboard.EjSvgRender.utils._measureText(trimLabelText, areaBoundWidth, font).width;
                                    if (!current) {                                                  // to trim next label
                                        value = nextPoint - newTextWidth / 2;
                                        if (value < pointX + textWidth / 2) {
                                            if (t - 1 != 0) 
                                                trimLabelText = trimLabelText.toString().substring(0, t - 1) + '... ';
                                            nextTextWidth = newTextWidth;
                                            trimLabel.displayText = trimLabelText;
                                            break;
                                        }
                                    }
                                    else {                                                           // to trim current label
                                        value = nextPoint - nextTextWidth / 2;
                                        if (value < pointX + newTextWidth / 2) {
                                            if (t - 1 != 0) 
                                                trimLabelText = trimLabelText.toString().substring(0, t - 1) + '... ';
                                            textWidth = newTextWidth;
                                            labelText = trimLabel.displayText = trimLabelText;
                                            break;
                                        }
                                    }
                                }
                            }
                        } else if (labelPlacement == "betweenticks") {
                            var derivedGap = (xAxis.enableTrim || (intersectAction == "trim" && labelRotation != 0)) ? trimGap : gap;
                        if (textWidth > derivedGap && labelText != "") { // check textwidth is greater than gap
                            for (var t = 1; t < labelText.toString().length; t++) {
                                labelText = label.displayText.toString().substring(0, t) + '... ';
                                textWidth = BoldBIDashboard.EjSvgRender.utils._measureText(labelText, areaBoundWidth, font).width;                                
                                if (textWidth >= derivedGap) {
                                    labelText = labelText.toString().substring(0, t - 1) + '... ';
                                    label.displayText = labelText;
                                    if (i == labels.length - 1) {
                                        if (((pointX + xAxis.x) + (textWidth / 2) > (svgWidth)) && derivedGap==gap ) {
                                            derivedGap -= (textWidth / 2);
                                            t = 1;
                                            continue;
                                        }
                                    }
                                    break;
                                }
                            }
                            label.displayText = labelText; // trimed text is assigned to displayText
                        }
                      }
                    }
                 var textSize = BoldBIDashboard.EjSvgRender.utils._measureText(label.displayText, areaBoundWidth, font);                    
                 var anchor = textSize.width / 2;
                 if (!BoldBIDashboard.util.isNullOrUndefined(label.Text)) {
                    var x = pointX + xAxis.x - anchor;
                    if ((xAxis.labelPosition == "inside" && xAxis.tickLinesPosition == 'inside') || ((xAxis.labelPosition == 'inside' && xAxis.tickLinesPosition != 'inside') && intersectAction == 'multiplerows'))
                    {                        
                        y = (opposedPosition) ? (xAxis.y + xAxis.majorTickLines.size + textHeight / 2 + (lineWidth / 2)
                       + (labelMaxHeight / (2 * labelMaxRow)) - 5) : (xAxis.y - xAxis.majorTickLines.size - (lineWidth / 2)
                      - (labelMaxHeight / (2 * labelMaxRow)) + 5);
                    }                        
                    else if (xAxis.labelPosition == 'inside'&& xAxis.tickLinesPosition!='inside')
                    {                        
                          y = (opposedPosition) ? (xAxis.y + textHeight / 2 + (lineWidth / 2)
                       + (labelMaxHeight / (2 * labelMaxRow)) - 5) : (xAxis.y - (lineWidth / 2)
                      - (labelMaxHeight / (2 * labelMaxRow)) + 5);                    
                    }
                    else if ((xAxis.labelPosition != 'inside' && xAxis.tickLinesPosition != 'inside') || ((xAxis.labelPosition != 'inside' && xAxis.tickLinesPosition == 'inside') && intersectAction == 'multiplerows')) {
                        var y = (opposedPosition) ? (xAxis.y - xAxis.majorTickLines.size + textHeight / 2 - (lineWidth / 2)
                            - (labelMaxHeight / (2 * labelMaxRow)) - 5) : (xAxis.y + xAxis.majorTickLines.size + (lineWidth / 2)
                            + (labelMaxHeight / (2 * labelMaxRow)) + 5);
                        y = y + ((isScroll && !opposedPosition) ? this.model.scrollerSize : 0)
                    }
                    else if (xAxis.labelPosition != 'inside' && xAxis.tickLinesPosition == 'inside')
                    {                      
                            var y = (opposedPosition) ? (xAxis.y + textHeight / 2 - (lineWidth / 2)
                             - (labelMaxHeight / (2 * labelMaxRow)) - 5) : (xAxis.y + (lineWidth / 2)
                             + (labelMaxHeight / (2 * labelMaxRow)) + 5);                       
                            y = y + ((isScroll && !opposedPosition) ? this.model.scrollerSize : 0);
                    }
                   
                    
                    if (xAxis.labelPosition == 'inside' && xAxis.tickLinesPosition != 'inside') {
                        if (xAxis.labelRotation == 90 || intersectAction == 'rotate90')
                            y = (opposedPosition) ? y  : y - xAxis.majorTickLines.size;
                    }
                    else if (xAxis.labelPosition != 'inside' && xAxis.tickLinesPosition == 'inside') {
                        if (xAxis.labelRotation == 90 || intersectAction == 'rotate90')
                            y = (opposedPosition) ? y - xAxis.majorTickLines.size : y - xAxis.majorTickLines.size;
                    }
                    else if (xAxis.labelPosition == 'inside' && xAxis.tickLinesPosition == 'inside') {
                        if (xAxis.labelRotation == 90 || intersectAction == 'rotate90')
                            y = (opposedPosition) ? y : y - xAxis.majorTickLines.size;
                    }

                        var options = {
                            'id': this.svgObject.id + '_' + axisName + '_XLabel_' + i,
                            'x': x,
                            'y': y,
                            'fill': font.color,
                            'font-size': font.size,
                            'font-family': font.fontFamily,
                            'font-style': font.fontStyle,
                            'font-weight': font.fontWeight,
                            'opacity': font.opacity
                        };
              
                    // To set position of edge labels
                        if (xAxis.edgeLabelPlacement) {
                            var position = xAxis.edgeLabelPlacement.toLowerCase();
                            var lastLabel = labels.length - 1;
                            switch (position) {
                                case "none":
                                    break;
                                case "shift":
                                    {
                                        if (i == 0) {  // Shift first label
                                            if (options.x < xAxis.x) {
                                                var diff = xAxis.x - options.x;
                                                options.x = x = options.x + diff;
                                                this.diff = diff;
                                                this.edgeLabel = true;
                                            }
                                        } else if (i == lastLabel)  // Shift last label
                                            if (options.x + textSize.width > xAxis.x + xAxis.width) {
                                                diff = (options.x + textSize.width) - (xAxis.x + xAxis.width);
                                                options.x = x = options.x - diff;
                                                this.diff = diff;
                                                this.edgeLabel = true;
                                            }
                                        break;
                                    }
                                  case "hide": // to hide the edge labels
                                    if ((i == 0 && options.x < xAxis.x) || (i == lastLabel && options.x + textWidth >  chartAreaWidth + chartAreaX)) {
                                        labelText = "";
                                    }
                            }
                        }
                    //To perform rotation             
                        if (labelRotation != 0 && !vmlrendering) {
                            this.labelRotation(xAxis, x + anchor, y, options, label, labelRotation);
                            currentLabel = labels[i];
                            var radian = labelRotation * Math.PI / 180;
                            currentLabel.point1 = { x: x, y: y };
                            currentLabel.point2 = { x: x + textSize.width, y: y };
                            currentLabel.point3 = { x: x + textSize.width, y: y + textHeight };
                            currentLabel.point4 = { x: x, y: y + textHeight };
                            currentLabel.pointValues = [];
                            currentLabel.pointValues[0] = {
                                x: (currentLabel.point1.x * Math.cos(radian)) + (currentLabel.point1.y * Math.sin(radian)) + x,
                                y: ((-currentLabel.point1.x) * Math.sin(radian)) + (currentLabel.point1.y * Math.cos(radian)) + y
                            };
                            currentLabel.pointValues[1] = {
                                x: (currentLabel.point2.x * Math.cos(radian)) + (currentLabel.point2.y * Math.sin(radian)) + x,
                                y: ((-currentLabel.point2.x) * Math.sin(radian)) + (currentLabel.point2.y * Math.cos(radian)) + y
                            };
                            currentLabel.pointValues[2] = {
                                x: (currentLabel.point3.x * Math.cos(radian)) + (currentLabel.point3.y * Math.sin(radian)) + x,
                                y: ((-currentLabel.point3.x) * Math.sin(radian)) + (currentLabel.point3.y * Math.cos(radian)) + y
                            };
                            currentLabel.pointValues[3] = {
                                x: (currentLabel.point4.x * Math.cos(radian)) + (currentLabel.point4.y * Math.sin(radian)) + x,
                                y: ((-currentLabel.point4.x) * Math.sin(radian)) + (currentLabel.point4.y * Math.cos(radian)) + y
                            };
                        }

                    //To perform labelIntersect Actions none , wrap, hide ,multiplerows
                         if (intersectAction || xAxis.enableTrim) {
                            this.diff = BoldBIDashboard.util.isNullOrUndefined(this.diff) ? 0 : this.diff;
                            if (intersectAction == 'none' && !xAxis.enableTrim) { 
                               
                                this.svgRenderer.drawText(options, labelText, gTickEle);
								 //create region to chart axis labels
                                labels[i].region = this.calculateRegion(labelText, font, options, label);
                                this.model.xAxisLabelRegions.push(labels[i].region)
                                if(xAxis.labelPosition=='inside')
                                    bbdesigner$(gTickEle).appendTo(this.gXaxisTickEle);
                                else
                                    bbdesigner$(gTickEle).appendTo(this.gXaxisEle);
                                continue;
                            } 
                            else if (intersectAction == 'wrap' || intersectAction == 'wrapbyword') {
                                
                                var line = 0,
                                    textcoll = this.rowscalculation(labelText.toString(), areaBoundWidth, xAxis, gap, options),
                                    count = textcoll.length,
                                    displayText = '';

                                if (xAxis.labelPosition != 'inside')
                                    options.y = opposedPosition ? options.y + textHeight : options.y - textHeight;
                                else
                                    options.y = opposedPosition ? options.y - textHeight : options.y - textHeight * (count);

                                for (k = 0; k < textcoll.length; k++)
                                {
                                    if (xAxis.labelPosition != 'inside')
                                    {
                                        options.y = opposedPosition ? options.y - (textHeight) : options.y + (textHeight);
                                        this.svgRenderer.drawText(options, textcoll[k], gTickEle);
                                    }
                                    else
                                    {                                        
                                        options.y = opposedPosition ? options.y + (textHeight) : options.y + (textHeight);
                                        this.svgRenderer.drawText(options, textcoll[k], gTickEle);
                                        count -= 1;
                                    }

                                    displayText = displayText + textcoll[k];
                                }
                                
                                labelSize = BoldBIDashboard.EjSvgRender.utils._measureText(labelText, null, font);
                                var textheight = labelSize.height * count;                        
                                bounds = { x: options.x, y: options.y, width: labelSize.width, height: (count) * textheight };
                                labels[i].region = { bounds: bounds, labelText: label.Text, displayText: displayText };
                                labels[i].displayText = displayText;
                                this.model.xAxisLabelRegions.push(labels[i].region)
                                continue;
                            } 
                            else if (intersectAction == 'hide') {
                                var xAxisLabelLength = labels.length - 1,
                                    preLabel, currentRegion, previousRegion,
                                    state, prePoint, width, preTextWidth, value;
                                    xAxisLabelLength = labels.length - 1;
                                   textWidth = textSize.width;
                                for (var j = 0; j < i; j++) {
                                    // loop to get previous label
                                    preLabel = labels[j];
                                   
                                    if (labelRotation == 0) {
                                        prePoint = Math.abs(Math.floor(BoldBIDashboard.EjSvgRender.utils._getPointXY(preLabel.Value, range, xAxis.isInversed) * (xAxis.width)));
                                        preTextWidth = BoldBIDashboard.EjSvgRender.utils._measureText(preLabel.displayText, areaBoundWidth, xAxis.font).width;
                                        value = prePoint + ((xAxis.isInversed) ? -preTextWidth / 2 : preTextWidth / 2);
                                        value = (j == 0) ? value + this.diff : value;
                                        width = (preTextWidth == 0) ? preTextWidth : textWidth;
                                        if ((i != xAxisLabelLength) || ((i == xAxisLabelLength && textWidth <= preTextWidth) || (i == xAxisLabelLength && options.x + textWidth < chartAreaWidth + chartAreaX)))
                                            width = width / 2;
										if(width){
											var prevStartX = prePoint + xAxis.x - (preTextWidth/2);
											var currStartX = options.x - (textWidth/2);
										}
                                        if ((xAxis.isInversed) ? (value < pointX + width) : (value > pointX - width || currStartX < prevStartX))
                                            label.displayText = labelText = '';
                                    } else {
                                        previousRegion = labels[i].pointValues;
                                        currentRegion = labels[j].pointValues;
                                        state = this.shapeIntersect(previousRegion, currentRegion);
                                        if (state) {
                                            label.displayText = labelText = '';
                                            break;
                                        }
                                    }
                                }
							}
                            else if(intersectAction == 'multiplerows'){ // to perform multipleRows on intersect
                                for (var k = 0; k < prevLabels.length && !flag; k++) {
                                    var xAxisLabelLength = labels.length - 1;
                                    if (i != xAxisLabelLength)
                                        textWidth = textWidth / 2;
                                    for (var l = 0; prevLabels[k] && l < prevLabels[k].length; l++) {
                                        var preLabel = prevLabels[k][l];
                                        var temp = 0;
                                        areaBoundWidth = this.model.m_AreaBounds.Width;

                                        var prePoint = Math.abs(Math.floor(BoldBIDashboard.EjSvgRender.utils._getPointXY(preLabel.Value, range, xAxis.isInversed) * (xAxis.width)));
                                        var preTextWidth = BoldBIDashboard.EjSvgRender.utils._measureText(preLabel.displayText, areaBoundWidth, xAxis.font).width;
                                        var value = prePoint + ((xAxis.isInversed) ? -preTextWidth / 2 : preTextWidth / 2);
                                        if (this.edgeLabel || prevLabels.length==1) {
                                            value = value + this.diff;
                                        }
                                        if ((xAxis.isInversed) ? (value < pointX + textWidth) : (value > pointX - textWidth)) {
                                            if (opposedPosition) {
                                                if (xAxis.labelPosition != 'inside')
                                                    temp = options.y - textHeight;
                                                else
                                                    temp = options.y + textHeight;
                                                options.y = temp;
                                                if (k + 1 == prevLabels.length)
                                                    flag = true;
                                                count++;
                                                break;
                                            } else {
                                                if (xAxis.labelPosition != 'inside')
                                                    temp = options.y + textHeight;
                                                else
                                                    temp = options.y - textHeight;
                                                options.y = temp;
                                                if (k + 1 == prevLabels.length)
                                                    flag = true;
                                                count++;
                                                break;
                                              
                                            }
                                        }
                                        else {
                                            if (l + 1 == prevLabels[k].length) {
                                                flag = true;
                                                break;
                                            }
                                        }                           
                                    }
                                }
                                if (temp == undefined) {
                                    if (prevLabels[0] == undefined)
                                        prevLabels[0] = [];
                                    prevLabels[0].push(label);
                                }
                                else {                                  
                                    if (prevLabels[count] == undefined)
                                        prevLabels[count] = [];
                                    prevLabels[count].push(label);
                                }
                         }         
                        }                  
                         if ((!this.edgeLabel) && !this.zoomed && !xAxis.zoomed && !(labelRotation) && !(intersectAction == "rotate90") && !(intersectAction == "rotate45") && (((pointX + xAxis.x) + (textWidth / 2)) > (bbdesigner$(this.svgObject).width()))) {
                        bbdesigner$(options).attr('x', (bbdesigner$(this.svgObject).width() - 2));
                        bbdesigner$(options).attr('text-anchor', 'end');
                    }
					labels[i].y = options.y;
					
					if (this.model.enableCanvasRendering && xAxis.labelPosition == "inside" && (intersectAction == "rotate45" || intersectAction == "rotate90")) {
					options.y = options.y - textWidth;
					}
					
                    this.svgRenderer.drawText(options, labelText, gTickEle);
					 //create region to chart axis labels
                    
					 labels[i].region = this.calculateRegion(labelText, font,options,label);
                    this.model.xAxisLabelRegions.push( labels[i].region)
                }
            }
        }
        bbdesigner$(gTickEle).appendTo(this.gXaxisEle);

    },
    shapeIntersect: function (shape1Points, shape2Points) {
        var shape1PointsCount = shape1Points.length,
            shape2PointsCount = shape2Points.length,
            point11, nextIndex, point12, point21, point22;
        for (var i = 0; i < shape1PointsCount; i++) {
            point11 = shape1Points[i];
            nextIndex = i == shape1PointsCount - 1 ? 0 : i + 1;
            point12 = shape1Points[nextIndex];
            for (var j = 0; j < shape2PointsCount; j++) {
                point21 = shape2Points[j];
                nextIndex = j == shape2PointsCount - 1 ? 0 : j + 1;
                point22 = shape2Points[nextIndex];
                if (this.doLinesIntersect(point11, point12, point21, point22))
                    return true;
            }
        }
    },
    doLinesIntersect: function (point11, point12, point21, point22) {
		var d, na, nb;
        d = (point22.y - point21.y) * (point12.x - point11.x) -
                    (point22.x - point21.x) * (point12.y - point11.y);
        na = (point22.x - point21.x) * (point11.y - point21.y) -
                     (point22.y - point21.y) * (point11.x - point21.x);
        nb = (point12.x - point11.x) * (point11.y - point21.y) -
                     (point12.y - point11.y) * (point11.x - point21.x);
        if (d == 0)
            return false;
        var ua = na / d, ub = nb / d;

        return (ua >= 0.0 && ua <= 1.0 && ub >= 0.0 && ub <= 1.0);
    },
	calculateRegion: function (labelText, font, options, label) {
        var labelSize = BoldBIDashboard.EjSvgRender.utils._measureText(labelText, null, font);
        var bounds = { x: options.x, y: options.y, width: labelSize.width, height: labelSize.height };
        var xAxisLabelRegions = { bounds: bounds, trimText: labelText, labelText: label.Text };
        return xAxisLabelRegions;
    },
    rowscalculation: function (labelText, areaBoundWidth,xAxis,gap,options)
    {
        var measureText = BoldBIDashboard.EjSvgRender.utils._measureText,
            font = xAxis.font,
            textSize = measureText(labelText, areaBoundWidth, font),
            textWidth = textSize.width,
            anchor = textWidth / 2,
            text = labelText.toString(),
            textLength = text.length,
            textcollection = [],
            i = 0,
            intersectAction = xAxis.labelIntersectAction,
            labelCollection = labelText.split(' '),
            labelCollectionLength = labelCollection.length;

        if (this.edgeLabel) gap = (i == 0) ? gap - this.diff : gap;

        if (textWidth > gap) {
            options.x = options.x + anchor;
            line = 0;
            if (this.edgeLabel) options.x = (i == 0) ? options.x - this.diff : options.x + this.diff;
        }

        if (intersectAction == 'wrap') {
            if (textWidth > gap) {
                for (var w = 1; w <= text.length; w++) {
                    labelText = text.substring(0, w);
                    textWidth = measureText(labelText, areaBoundWidth, font).width;
                    if (textWidth > gap) {
                        line = line + 1; // To find the no of rows splitted
                        labelText = text.substring(0, w - 1);
                        textcollection[i] = labelText;
                        text = text.slice(w - 1, textLength);
                        currentTextCollextion = text.split(' ');
                        text = labelCollection.indexOf(currentTextCollextion[0]) > -1 ? text : '-' + text;
                        var newTextWidth = measureText(labelText, areaBoundWidth, font).width;
                        if (line == 1) options.x = options.x - newTextWidth / 2;
                        i++;
                        w = 0;
                    }
                }
            }
            options.x = (xAxis.valueType == "datetimeCategory" && xAxis.labelPlacement.toLowerCase() == "betweenticks") ? xAxis._gap : options.x;
            textcollection[i] = labelText;
        }
        else {
            var max = 0, word, currentWidth, nextWidth;

            for (var i = 0; i < labelCollectionLength; i++) {
                word = labelCollection[i];
                currentWidth = measureText(word, areaBoundWidth, font).width;
                if (currentWidth < gap && textWidth > gap) {
                    while (i < labelCollectionLength) {
                        currentWidth = measureText(word, areaBoundWidth, font).width;
                        nextWidth = (labelCollection[i + 1]) ? measureText(labelCollection[i + 1], areaBoundWidth, font).width : 0;
                        if ((currentWidth + nextWidth) <= gap && nextWidth > 0) {
                            word = word.concat(' ' + labelCollection[i + 1]);
                            i++;
                        }
                        else {
                            // find the maximum width of the lines
                            max = Math.max(max, currentWidth);
                            break;
                        }
                    }
                    textcollection.push(word);
                }
                else {
                    if (textWidth > gap) {
                        word = BoldBIDashboard.EjSvgRender.utils._trimText(word, gap, font);
                        newTextWidth = measureText(word, areaBoundWidth, font).width;
                        max = Math.max(max , newTextWidth)
                        textcollection.push(word);
                    } else {
                        textcollection.push(labelText);
                        break;
                    }
                }
            }
            options.x = options.x - max / 2;
        }
        
        return textcollection;
    },

    labelRotation: function (axis, x, y, options, label, degree, i) {
            var opposedPosition = axis._opposed;
	        // To rotate axis labels
	        var labelText = (label.displayText) ? label.displayText : label.Text;
            var angle = (degree > 360) ? degree - 360 : (degree < -360) ? degree + 360 : degree;
            var rotate = 'rotate(' + angle + ',' + (x) + ',' + y + ')';
            bbdesigner$(options).attr('transform', rotate);
			bbdesigner$(options).attr('labelRotation', angle);
            var textElement = this.svgRenderer.createText(options, labelText);
            var diffHeight = Math.ceil(BoldBIDashboard.EjSvgRender.utils._measureBounds(textElement, this).height - BoldBIDashboard.EjSvgRender.utils._measureText(labelText, null, axis.font).height);
            diffHeight = axis._LableMaxWidth.height - diffHeight - BoldBIDashboard.EjSvgRender.utils._measureText(labelText, null, axis.font).height;
            
        if(axis.labelPosition!='inside')
            var yLocation = (opposedPosition) ? (diffHeight / 2) : (-diffHeight / 2);
        else
            var yLocation = (opposedPosition) ? (-diffHeight / 2) : (diffHeight / 2);

        rotate = 'rotate(' + angle + ',' + (x) + ',' + (y + yLocation) + ')';
        if (this.edgeLabel && degree == 90)               
            y = (i == 0) ? options.y + this.diff : options.y - this.diff;
       
	        bbdesigner$(options).attr({
                'transform' :rotate,
                'y': (y + yLocation)
            });
        },
		
    _drawYAxisLabels: function (axisIndex, yAxis, params) {
        // method to draw y axis labels
        //if(yAxis.labelPosition=='inside')
        var axisName = (yAxis.name).replace(/[^a-zA-Z0-9]/g, ""),
            gEle = this.svgRenderer.createGroup({ 'id': this.svgObject.id + '_YAxisLabels' + '_' + axisIndex, 'cursor': 'default' }),
            labelSize,
            yAxisLabelRegions, opposedPosition = yAxis._opposed,
            bounds,
            regionX,
			chartObj = this,
			maximumBoundsWidth = 0,
			seriesCollection = this.model.series,
			axisRange = new BoldBIDashboard.axisTypes[yAxis._valueType.toLowerCase()](),
            requireInvertedAxes = this.model.requireInvertedAxes,
            isScroll = this.model._yScroll;
        if (axisIndex != 1 && ((yAxis.labelPosition == 'inside' && yAxis.tickLinesPosition == 'inside') || (yAxis.labelPosition == 'inside' && yAxis.tickLinesPosition != 'inside'))&& !((yAxis.x == (this.model.m_AreaBounds.Width + this.model.m_AreaBounds.X)) || (yAxis.x == (this.model.m_AreaBounds.X))))
        {
            yAxis.x = (!opposedPosition) ? Math.floor(yAxis.x - yAxis._LableMaxWidth.width - this.model.elementSpacing) : Math.floor(yAxis.x + yAxis._LableMaxWidth.width + this.model.elementSpacing);
        }
        else if (axisIndex != 1 && (!(yAxis.x == (this.model.m_AreaBounds.Width + this.model.m_AreaBounds.X)) || (yAxis.x == (this.model.m_AreaBounds.X))) && (yAxis.labelPosition!='inside' && yAxis.tickLinesPosition=='inside'))
        {
            yAxis.x = (!opposedPosition) ? Math.floor(yAxis.x - yAxis.majorTickLines.size) : Math.floor(yAxis.x + yAxis.majorTickLines.size);
        }      
        else
        {
            yAxis.x = Math.floor(yAxis.x);
        }   
      
        for (var i = 0; i < yAxis.visibleLabels.length; i++) {
            var label = yAxis.visibleLabels[i];
			var visibleRange = yAxis.visibleRange;
			if (BoldBIDashboard.EjSvgRender.utils._inside(label.Value, visibleRange)) {
			    var pointY = Math.abs(BoldBIDashboard.EjSvgRender.utils._getPointXY(label.Value, visibleRange, yAxis.isInversed) * (yAxis.height));
			    var text = BoldBIDashboard.EjSvgRender.utils._measureText(label.Text, this.model.m_AreaBounds.Height, yAxis.font);
			    var textHeight = text.height;			    
			    var font = yAxis.font;
			    var range = yAxis.visibleRange;
			    var lineWidth = yAxis.axisLine.width;
			    var labelMaxWidth = yAxis._LableMaxWidth;
			    var labelMaxHeight = labelMaxWidth.height;
			    var labelMaxRow = labelMaxWidth.rows;
               var areaBoundWidth = this.model.m_AreaBounds.Width;
               var gap = yAxis.maximumLabelWidth;  // width for 4 digits
               var labelText = label.displayText = label.Text;
			    var textSize = BoldBIDashboard.EjSvgRender.utils._measureText(labelText, areaBoundWidth, yAxis.font);
			    var textWidth = textSize.width;
			    var font = yAxis.font;
				var intersectAction = yAxis.labelIntersectAction.toLowerCase();
				var degree = yAxis.labelRotation;
				padding = 5;

			    if(yAxis.labelPosition=='inside' && yAxis.tickLinesPosition=='inside')
			    {
			        var x = (opposedPosition) ? (yAxis.x - (yAxis.majorTickLines.size) - (lineWidth / 2) - 5)
               : (yAxis.x + (lineWidth / 2) + 5 + yAxis.majorTickLines.size);
			        var textanchor = (opposedPosition) ? 'end' : 'start';			       
			    }
			    else if (yAxis.labelPosition == 'inside' && yAxis.tickLinesPosition != 'inside')
			    {			        
			        var x = (opposedPosition) ? (yAxis.x - (lineWidth / 2)  - 5)
                : (yAxis.x + (lineWidth / 2) + 5);
			        var textanchor = (opposedPosition) ? 'end' : 'start';			       
			    }
			    else if (yAxis.tickLinesPosition == 'inside' && yAxis.labelPosition != 'inside')
			    {

			        var x = (opposedPosition) ? ((lineWidth / 2) + yAxis.x + 5)
                        : (yAxis.x - (lineWidth / 2) - 5);
			        var textanchor = (opposedPosition) ? 'start' : 'end';
			        x = x - ((isScroll && !opposedPosition) ? this.model.scrollerSize : 0);
			    }
			    else
			    {
			        var x = (opposedPosition) ? ((yAxis.majorTickLines.size) + (lineWidth / 2) + yAxis.x + 5)
                        : (yAxis.x - (lineWidth / 2) - 5 - yAxis.majorTickLines.size);
			        var textanchor = (opposedPosition) ? 'start' : 'end';			    
			        x = x - ((isScroll && !opposedPosition) ? this.model.scrollerSize : 0);
			   }                       

                    var y = ((pointY * -1) + (yAxis.y + yAxis.height) + textHeight/4);					
					var angle = BoldBIDashboard.util.isNullOrUndefined(degree) ? null : Math.abs(degree);
					if (!BoldBIDashboard.util.isNullOrUndefined(angle) && angle != 0){
					   if (angle == 180)
					      anchor = opposedPosition? "end" : "start";
					   else if (angle == 0 || angle % 360 == 0)
					      anchor = opposedPosition ? "start" : "end";
					   else if (angle%90 == 0)
						  anchor = "middle";
					    else if (angle <90 || (angle > 270 && angle < 360))
						  anchor = opposedPosition ? "start" : "end";
						else
						  anchor = opposedPosition? "end" : "start";
					}
					else
					   anchor = textanchor;
					   
                    var options = {
                        'id': this.svgObject.id + '_' + axisName + '_YLabel_' + i,
                        'x': x,
                        'y': y,
                        'fill': font.color,
                        'font-size': font.size,
                        'font-family': font.fontFamily,
                        'font-style': font.fontStyle,
                        'font-weight': font.fontWeight,
                        'opacity': font.opacity,
                        'text-anchor': !BoldBIDashboard.util.isNullOrUndefined(degree) && degree != 0 ? "middle" : anchor
                    };
					
                // To set position of edge labels in yAxis
                    if (yAxis.edgeLabelPlacement) {
                        var position = yAxis.edgeLabelPlacement.toLowerCase();
                        var lastLabel = yAxis.visibleLabels.length - 1;

                        switch (position) {
                            case "none":
                                break;
                            case "shift":
                                {
                                    if (i == 0) {  // Shift first label
                                        if (options.y > yAxis.y + yAxis.height) {
                                            var diff = options.y - (yAxis.y + yAxis.height);
                                            options.y = y = options.y - diff;
                                            this.diff = diff;
                                            this.edgeLabel = true;
                                        }
                                    } else if (i == lastLabel) // Shift last label
                                        if (options.y - textHeight/2 < yAxis.y) {
                                            diff = yAxis.y - (options.y - textHeight / 2);
                                            options.y = y = options.y + diff;
                                            this.diff = diff;
                                            this.edgeLabel = true;
                                        }
                                    break;
                                }
                            case "hide": //to hide the edge labels
                                if ((i == 0 && options.y > yAxis.y + yAxis.height) || (i == lastLabel && options.y - textHeight / 2 < this.model.m_AreaBounds.Y)) {
                                    labelText = label.Text = "";
                                }
                        }
                    }
					
					// to perform label trim
					if (yAxis.enableTrim || yAxis.labelIntersectAction == "trim") {
                            if (textWidth > gap && labelText != "") { // check textwidth is greater than gap
                                for (var t = 1; t < labelText.toString().length; t++) {
                                    labelText = label.displayText.toString().substring(0, t - 1) + '...';
                                    textWidth = BoldBIDashboard.EjSvgRender.utils._measureText(labelText, areaBoundWidth, font).width;
                                    if (textWidth >= gap) {
                                        labelText = labelText.toString().substring(0, t - 1) + '...';                                      
                                        break;
                                    }
                                }
                                label.displayText = labelText;
								textSize = BoldBIDashboard.EjSvgRender.utils._measureText(labelText, areaBoundWidth, yAxis.font);
			                    textWidth = textSize.width;
                            }
                        }

			      //To perform rotation         
                        if (!BoldBIDashboard.util.isNullOrUndefined(degree) && degree != 0 && !this.svgRenderer.vmlNamespace){
						  if (angle == 90){
						    if (yAxis.labelPosition!='inside')
                               x = (opposedPosition) ? (x + textWidth/2) : (x - textWidth/2);
                            else
                               x = (opposedPosition) ? (x - textWidth/2) : (x + textWidth/2);
						  } 
						  else {
						     if (yAxis.labelPosition!='inside')
                               x = (opposedPosition) ? (x + textWidth / 2) : (x - textWidth / 2);
                             else
                               x = (opposedPosition) ? (x - textWidth/2) : (x);
						  }
							   
						    var labelText = (label.displayText) ? label.displayText : label.Text;
                            var rotateAngle = (degree > 360) ? degree - 360 : (degree < -360) ? degree + 360 : degree;
                            var rotate = 'rotate(' + rotateAngle + ',' + (x) + ',' + y + ')';
                            bbdesigner$(options).attr('transform', rotate);
			                bbdesigner$(options).attr('labelRotation', rotateAngle);
                            var textElement = this.svgRenderer.createText(options, labelText);
							currentLabel = yAxis.visibleLabels[i];
							radian = degree * Math.PI / 180;
							currentLabel.point1 = {x : 0, y: 0};
							currentLabel.point2 = {x : textSize.width, y: 0};
							currentLabel.point3 = {x : textSize.width, y: text.height};
							currentLabel.point4 = {x : 0, y: text.height };
							currentLabel.pointValues = [];
						    currentLabel.pointValues[0] = { x: (currentLabel.point1.x * Math.cos(radian)) + (currentLabel.point1.y * Math.sin(radian)) + x,
							                                y: ((-currentLabel.point1.x) * Math.sin(radian)) + (currentLabel.point1.y * Math.cos(radian)) + y};
							currentLabel.pointValues[1] = { x: (currentLabel.point2.x * Math.cos(radian)) + (currentLabel.point2.y * Math.sin(radian)) + x,
							                                y: ((-currentLabel.point2.x) * Math.sin(radian)) + (currentLabel.point2.y * Math.cos(radian)) + y}
							currentLabel.pointValues[2] = { x: (currentLabel.point3.x * Math.cos(radian)) + (currentLabel.point3.y * Math.sin(radian)) + x,
							                                y: ((-currentLabel.point3.x) * Math.sin(radian)) + (currentLabel.point3.y * Math.cos(radian)) + y}
							currentLabel.pointValues[3] = { x: (currentLabel.point4.x * Math.cos(radian))+ (currentLabel.point4.y * Math.sin(radian)) + x,
							                                y: ((-currentLabel.point4.x) * Math.sin(radian)) + (currentLabel.point4.y * Math.cos(radian)) + y}
                            var diffHeight = Math.ceil(BoldBIDashboard.EjSvgRender.utils._measureBounds(textElement, this).width - 
							                           BoldBIDashboard.EjSvgRender.utils._measureText(labelText, null, yAxis.font).width);
            
                            if (angle == 90){
                                if (yAxis.labelPosition!='inside')
                                   var yLocation = (opposedPosition) ? (diffHeight / 2) : (-diffHeight / 2);
                                else
                                   var yLocation = (opposedPosition) ? (-diffHeight / 2) : (diffHeight / 2);
						    } else {
							    if (yAxis.labelPosition!='inside')
                                   var yLocation = (opposedPosition) ? (diffHeight / 2) : (-diffHeight / 2);
                                else
                                   var yLocation = (opposedPosition) ? (-diffHeight / 2) : (diffHeight / 4);
							}

                           rotate = 'rotate(' + rotateAngle + ',' + (x + yLocation) + ',' + (y) + ')';
       
	                        bbdesigner$(options).attr({
                                'transform' :rotate,
                                'x': (x + yLocation)
                            });
						}
				 //Label intersection
                        intersectAction = (this.model.isResponsive && intersectAction == "") ? "hide" : intersectAction;
                        if (intersectAction == "hide" && !BoldBIDashboard.util.isNullOrUndefined(yAxis.labelRotation) && yAxis.labelRotation != 0) {
                            yAxis.flag = BoldBIDashboard.util.isNullOrUndefined(yAxis.flag) ? true : yAxis.flag;
							textElement = this.svgRenderer.createText(options, labelText);
							bbdesigner$(this.svgObject).append(textElement);
							yAxis.visibleLabels[i].bounds = bbdesigner$(textElement)[0].getBoundingClientRect();
							bbdesigner$(textElement).remove();
                            for (var j = 0; j < i; j++) {
                                yAxis.visibleLabels[j].hide = BoldBIDashboard.util.isNullOrUndefined(yAxis.visibleLabels[j].hide) ? false : yAxis.visibleLabels[j].hide;
                                if (!yAxis.visibleLabels[j].hide) {
								  if (angle != 90){
                                      var a = yAxis.visibleLabels[i].pointValues;
                                      var b = yAxis.visibleLabels[j].pointValues;
									  var state = this.shapeIntersect(a, b); 
                                   } else{
								       var a = yAxis.visibleLabels[i].bounds;
                                       var b = yAxis.visibleLabels[j].bounds;
                                       state = !(                   
                                          ((a.top + a.height) < (b.top)) ||
                                          (a.top > (b.top + b.height)) ||
                                          ((a.width / 2) < -b.width / 2) ||
                                          (a.left - a.width / 2 > (b.left + b.width / 2)));
								   }
								    if (state) {
                                        yAxis.visibleLabels[i].hide = true;
                                        break;
                                    } 
                                }
                            }
                        }
                        if (intersectAction == 'none' && !(yAxis.enableTrim)) {
                            this.svgRenderer.drawText(options, label.Text, gEle);
						     labelSize = BoldBIDashboard.EjSvgRender.utils._measureText(labelText, null, font);
                            if (yAxis.opposedPosition)
                                regionX = options.x;
                            else
                                regionX = options.x - labelSize.width;
                            // yAxis labels region stored 
                            bounds = { x: regionX, y: options.y, width: labelSize.width, height: labelSize.height };
                            yAxisLabelRegions = { bounds: bounds, trimText: labelText, labelText: label.Text };
                            yAxis.visibleLabels[i].region = { bounds: bounds, trimText: labelText, labelText: label.Text };
                            this.model.yAxisLabelRegions.push(yAxisLabelRegions)
                            continue;
                        }
                        else if (yAxis.enableTrim || yAxis.labelIntersectAction == "trim") {
                            if (textWidth > gap && labelText != "") { // check textwidth is greater than gap
                                for (var t = 1; t < labelText.toString().length; t++) {
                                    labelText = label.displayText.toString().substring(0, t - 1) + '...';
                                    textWidth = BoldBIDashboard.EjSvgRender.utils._measureText(labelText, areaBoundWidth, font).width;
                                    if (textWidth >= gap) {
                                        labelText = labelText.toString().substring(0, t - 1) + '...';                                      
                                        break;
                                    }
                                }
                                label.displayText = labelText;
                            }
                        }
                        var intersectAction = yAxis.labelIntersectAction.toLowerCase();
                        for (var j = 0; j < i; j++) {                           
                            var prevLabel = yAxis.visibleLabels[j];
                            var temp = 0;
                            var prevPoint = Math.abs((BoldBIDashboard.EjSvgRender.utils._getPointXY(prevLabel.Value, range, yAxis.isInversed) * (yAxis.height)));
                                var prevTextHeight = BoldBIDashboard.EjSvgRender.utils._measureText(prevLabel.Text, this.model.m_AreaBounds.Height, font).height;
                                var value = ((prevPoint * -1) + (yAxis.y + yAxis.height) + prevTextHeight/4);
                                value = value + ((yAxis.isInversed) ? prevTextHeight / 2 : -prevTextHeight / 2);
                            if (this.edgeLabel)
                                value = (j == 0) ? value - prevTextHeight / 4 : value;
                                if (intersectAction == 'hide' && prevLabel.Text.toString()!="" && ((yAxis.isInversed) ? value > options.y - textHeight / 4 : value < options.y + textHeight / 4))
                                    labelText=label.Text = '';
                                else if (intersectAction == 'multiplerows' && ((yAxis.isInversed) ? value > options.y - textHeight / 4 : value < options.y + textHeight / 4) && prevLabel.x == options.x) {
                                    if (opposedPosition) {
                                        if(yAxis.labelPosition !="inside")
                                            temp = prevLabel.x + yAxis._LableMaxWidth.maxWidth + 5;  // gap between the rows
                                        else
                                            temp = prevLabel.x - yAxis._LableMaxWidth.maxWidth - 5;                                            
                                        options.x = temp;
                                    }
                                    else {
                                        if (yAxis.labelPosition != "inside")
                                            temp = prevLabel.x - yAxis._LableMaxWidth.maxWidth - 5; // gap between the rows
                                        else
                                            temp = prevLabel.x + yAxis._LableMaxWidth.maxWidth + 5;
                                        options.x = temp;
                                     }
                                }
                            }

                    yAxis.visibleLabels[i].x = options.x;	
					if (!label.hide && !yAxis.flag)
                       this.svgRenderer.drawText(options, labelText, gEle);
                      //create region to chart axis labels
                   var labelSize = BoldBIDashboard.EjSvgRender.utils._measureText(labelText, null, font);
                   
                   if (yAxis.opposedPosition)
                       var x = options.x;
                    else
                        x = options.x - labelSize.width;
                   
                      // yAxis labels region stored when enableTrim is true and for all label intersect action
                       var bounds = { x: x, y: options.y, width: labelSize.width, height: labelSize.height };
                       var yAxisLabelRegions = { bounds: bounds, trimText: labelText, labelText: label.Text };
                       yAxis.visibleLabels[i].region = yAxisLabelRegions;
					   this.model.yAxisLabelRegions.push(yAxisLabelRegions)
                   

            }
        }
		// trim the text if it exceeds the bounds
		 var labelsTrim = yAxis.enableTrim;
		 if (intersectAction == "hide" && !BoldBIDashboard.util.isNullOrUndefined(yAxis.labelRotation) && yAxis.labelRotation != 0){  
		    var l, m, svgHeight, point, exceedState, currentVisibleLabel, labelsLength;
			labelsLength = yAxis.visibleLabels.length;
            for (l = 0; l < labelsLength; l++) {
			   currentVisibleLabel = yAxis.visibleLabels[l];
               if (!currentVisibleLabel.hide){
				   svgHeight = bbdesigner$(this.svgObject).height();
				   for (m = 0; m < 4; m++) {
					   if (angle == 90)
					      point = currentVisibleLabel.pointValues[m].y - currentVisibleLabel.bounds.height/2 ;
					   else
						   point = currentVisibleLabel.pointValues[m].y;
					   exceedState = point > padding && point < svgHeight;
					   if (!exceedState) {
						  currentVisibleLabel.trim = true;
						  yAxis.enableTrim = true;
						  if (!yAxis.flag)
							  bbdesigner$(gEle).find("#" + this.svgObject.id + '_' + axisName + '_YLabel_' + l).remove();
					      break;
					   }
				   }  
			   }
			   if (!currentVisibleLabel.hide && !currentVisibleLabel.trim)
                  maximumBoundsWidth = maximumBoundsWidth > currentVisibleLabel.bounds.width ? maximumBoundsWidth : currentVisibleLabel.bounds.width;
			}
			if(maximumBoundsWidth < yAxis.AxisMaxWidth && !labelsTrim)
				 yAxis.enableTrim = false;
		 }
          if (yAxis.flag) {
            yAxis.flag = false;
			if (!yAxis.enableTrim)
               yAxis.maximumBoundsWidth = maximumBoundsWidth;
            axisRange._calculateRanges(chartObj, yAxis, seriesCollection, params);
            this._calculateAreaBounds(params, this);
            this._calculateAxisSize(params);
            this._drawYAxisLabels(axisIndex, yAxis, params);
          }

        if (yAxis.labelPosition == 'inside')
            bbdesigner$(gEle).appendTo(this.gYaxisTickEle);
        else
            bbdesigner$(gEle).appendTo(this.gYaxisEle);
    },
	//To Trim axis title
	 trimText: function (text, maxLength, ellipsis) {
        maxLength--;
        text = text.substring(0, maxLength - ellipsis.length);
        return text + ellipsis;
    },
	
    _drawXTitle: function (axisIndex, axis) {
        var titleText = axis.trimmedText == "" ? "" : axis.title.text;
        if (titleText != "" && titleText && axis.title.visible) {
            var gEle = this.svgRenderer.createGroup({ 'id': this.svgObject.id + '_XAxisTitle' + '_' + axisIndex,'cursor': 'default'});
            var xtitleLocation = (this.model.elementSpacing) + axis._LableMaxWidth.height;
            var axisTitleSize = BoldBIDashboard.EjSvgRender.utils._measureText(titleText, (axis.width), axis.title.font);
            var titlesize = axisTitleSize.height / 2;
            var opposedPosition = axis._opposed;
			var titleText = axis.title.text;
            var isEnableTrim = this.model.adaptiveRendering ? true :axis.title.enableTrim;
            var isScroll = this.model._xScroll;
			var axisTitleWidth=axis.title.maximumTitleWidth;
            if(isEnableTrim &&(BoldBIDashboard.util.isNullOrUndefined(axisTitleWidth)||axisTitleWidth>0||isNaN(axisTitleWidth))){
                var maxTitleWidth = (!axisTitleWidth) ? axis.width - (this.model.elementSpacing * 2) : axisTitleWidth;
			    while (axisTitleSize.width > maxTitleWidth) {
			        titleText = this.trimText(titleText, titleText.length, "...");
			        axisTitleSize = BoldBIDashboard.EjSvgRender.utils._measureText(titleText, (axis.width), axis.title.font);
			        if (titleText == "...") {
			            titleText = "";
			            break;
			        }
			    }
            }
            axis.trimmedText = titleText;
            var commonEventArgs = bbdesigner$.extend({}, BoldBIDashboard.EjSvgRender.commonChartEventArgs);

            var y = this.model.elementSpacing + axis._LableMaxWidth.height + titlesize + axis.majorTickLines.size + axis.axisLine.width;

            if ((axis.tickLinesPosition == 'inside' && axis.labelPosition == 'inside') && (axisIndex == 0 || (axis.y == (this.model.m_AreaBounds.Height + this.model.m_AreaBounds.Y)) || (axis.y == (this.model.m_AreaBounds.Y))))
                var y =this.model.elementSpacing + titlesize + axis.axisLine.width;
            else if ((axisIndex == 0 || (axis.y == (this.model.m_AreaBounds.Width + this.model.m_AreaBounds.X)) || (axis.y == (this.model.m_AreaBounds.X))) && (axis.tickLinesPosition != 'inside' && axis.labelPosition == 'inside'))
                var y = this.model.elementSpacing + titlesize +axis.majorTickLines.size+ axis.axisLine.width;
            else if ((axisIndex == 0 || (axis.y == (this.model.m_AreaBounds.Width + this.model.m_AreaBounds.X)) || (axis.y == (this.model.m_AreaBounds.X))) && (axis.tickLinesPosition == 'inside' && axis.labelPosition != 'inside'))
                var y = this.model.elementSpacing + axis._LableMaxWidth.height+titlesize + axis.axisLine.width;
            else if ((axis.tickLinesPosition != 'inside' && axis.labelPosition != 'inside') || (axisIndex != 1))
                var y = this.model.elementSpacing + axis._LableMaxWidth.height + titlesize + axis.majorTickLines.size + axis.axisLine.width;

            commonEventArgs.data = { title: titleText, location: { x: (axis.width) / 2, y: y }, axes: axis };
            this._trigger("axesTitleRendering", commonEventArgs);
            var options = {
                'id': this.svgObject.id + '_XAxisTitle' + '_' + axisIndex,
                'x': commonEventArgs.data.location.x + axis.x,
                'y': ((opposedPosition) ? (axis.y - commonEventArgs.data.location.y) : (isScroll ? this.model.scrollerSize : 0) + (commonEventArgs.data.location.y + axis.y)) + axisTitleSize.height / 3.5,
                'fill': axis.title.font.color,
                'font-size': axis.title.font.size,
                'font-family': axis.title.font.fontFamily,
                'font-style': axis.title.font.fontStyle,
                'font-weight': axis.title.font.fontWeight,
                'opacity': axis.title.font.opacity,
                'text-anchor': 'middle'
            };
            if (this.model.enableCanvasRendering) {
                var matched = bbdesigner$.uaMatch(navigator.userAgent);
                var isIE11 = !!navigator.userAgent.match(/Trident\/7\./);
                var browser = matched.browser.toLowerCase();
                 if (browser != "msie" && !isIE11)
                     options.y = !opposedPosition ? options.y + (titlesize / 2) + (browser == "mozilla" ? 1 : -2) : options.y + (titlesize / 2) + 1; // text dominant baseline for canvas
            }
            if (bbdesigner$(this.svgObject).find("#" + this.svgObject.id + '_XAxisTitle' + '_' + axisIndex).length > 0)
                bbdesigner$(this.svgObject).find("#" + this.svgObject.id + '_XAxisTitle' + '_' + axisIndex).attr(options);
            else if (!isEnableTrim)
                this.svgRenderer.drawText(options, commonEventArgs.data.title, gEle);
		    else if(isEnableTrim &&(BoldBIDashboard.util.isNullOrUndefined(axisTitleWidth)||axisTitleWidth>0||isNaN(axisTitleWidth))){
                var bounds = { X: options.x - (axisTitleSize.width) / 2, Y: options.y, Width: axisTitleSize.width, Height: axisTitleSize.height };
                var xAxisTitleRegion = { Bounds: bounds, trimText: titleText, labelText: axis.title.text };
                this.model.xAxisTitleRegion.push(xAxisTitleRegion)
                this.svgRenderer.drawText(options, titleText, gEle);
            }
            bbdesigner$(gEle).appendTo(this.gXaxisEle);
			}
        },
    _drawYTitle: function (axisIndex, yAxis) {
        var titleText = !BoldBIDashboard.util.isNullOrUndefined(yAxis.title.trimmedText) ? "" : yAxis.title.text;
        if (titleText != "" && titleText && yAxis.title.visible) {
            var opposedPosition = yAxis._opposed;
            var gEle = this.svgRenderer.createGroup({ 'id': this.svgObject.id + '_YAxisTitleGroup' + '_' + axisIndex,'cursor': 'default' });//Group id and text element id should not be same
            var titleSize = BoldBIDashboard.EjSvgRender.utils._measureText(titleText, (yAxis.height), yAxis.title.font);
            if ((yAxis.tickLinesPosition == 'inside' && yAxis.labelPosition == 'inside') && (axisIndex == 1 || (yAxis.x == (this.model.m_AreaBounds.Width + this.model.m_AreaBounds.X)) || (yAxis.x == (this.model.m_AreaBounds.X))))
                var x = (opposedPosition) ? yAxis.x + ((3 * this.model.elementSpacing) + yAxis.axisLine.width-5) : yAxis.x - ((3 * this.model.elementSpacing) + yAxis.axisLine.width);
            else if ((axisIndex == 1 || (yAxis.x == (this.model.m_AreaBounds.Width + this.model.m_AreaBounds.X)) || (yAxis.x == (this.model.m_AreaBounds.X))) && (yAxis.tickLinesPosition != 'inside' && yAxis.labelPosition == 'inside'))
                var x = (opposedPosition) ? yAxis.x + ((3 * this.model.elementSpacing) + yAxis.majorTickLines.size + yAxis.axisLine.width) : yAxis.x - ((3 * this.model.elementSpacing) + yAxis.majorTickLines.size + yAxis.axisLine.width);
            else if ((axisIndex == 1 || (yAxis.x == (this.model.m_AreaBounds.Width + this.model.m_AreaBounds.X)) || (yAxis.x == (this.model.m_AreaBounds.X))) && (yAxis.tickLinesPosition == 'inside' && yAxis.labelPosition != 'inside'))
                var x = (opposedPosition) ? yAxis.x + ((3 * this.model.elementSpacing) + yAxis._LableMaxWidth.width + yAxis.axisLine.width) : yAxis.x - ((3 * this.model.elementSpacing) + yAxis._LableMaxWidth.width + yAxis.axisLine.width);
            else if ((yAxis.tickLinesPosition != 'inside' && yAxis.labelPosition != 'inside')||(axisIndex!=1))
                var x = (opposedPosition) ? yAxis.x + ((3 * this.model.elementSpacing) + yAxis._LableMaxWidth.width + yAxis.majorTickLines.size + yAxis.axisLine.width) : yAxis.x - ((3 * this.model.elementSpacing) + yAxis._LableMaxWidth.width + yAxis.majorTickLines.size + yAxis.axisLine.width);
            var titleText = yAxis.title.text;
            var isEnableTrim = this.model.adaptiveRendering ? true :yAxis.title.enableTrim;
            var requireInvertedAxes = this.model.requireInvertedAxes;
            var isScroll = this.model._yScroll;
            var axisTitleWidth = yAxis.title.maximumTitleWidth;
            var axisTitleSize = BoldBIDashboard.EjSvgRender.utils._measureText(titleText, (yAxis.height), yAxis.title.font);
            if(isEnableTrim &&(BoldBIDashboard.util.isNullOrUndefined(axisTitleWidth)||axisTitleWidth>0||isNaN(axisTitleWidth))){
                var maxTitleWidth = (!axisTitleWidth)? yAxis.height - (this.model.elementSpacing * 2) : axisTitleWidth;                
                while (axisTitleSize.width > maxTitleWidth) {
                    titleText = this.trimText(titleText, titleText.length, "...");
                    axisTitleSize = BoldBIDashboard.EjSvgRender.utils._measureText(titleText, (yAxis.height), yAxis.title.font);
                    if (titleText == "..."){
                        titleText = "";
                        break;
                    }
                        
                }
            }
            yAxis.trimmedText = titleText;
			x = (yAxis.opposedPosition) ? x : x - (isScroll ? this.model.scrollerSize : 0)
            if (document.documentMode === 8)
                x = (!opposedPosition) ? (x - axisTitleSize.width / 2 + this.model.elementSpacing) : (x + axisTitleSize.width / 2 - this.model.elementSpacing);
            var commonEventArgs = bbdesigner$.extend({}, BoldBIDashboard.EjSvgRender.commonChartEventArgs);
            commonEventArgs.data = { title: titleText, location: { x: titleSize.width / 2, y: 0 }, axes: yAxis };
            this._trigger("axesTitleRendering", commonEventArgs);

            var y = commonEventArgs.data.location.y + (yAxis.y + yAxis.height) + (((yAxis.height) / 2) * -1);

            var labelRotation = (opposedPosition) ? 90 : -90;

            if (this.model.elementSpacing == 0)
                x = x - titleSize.height;

            var options = {
                'id': this.svgObject.id + '_YAxisTitle' + '_' + axisIndex,
                'x': x,
                'y': y,
                'fill': yAxis.title.font.color,
				'labelRotation': labelRotation,
                'transform': 'rotate(' + labelRotation + ',' + (x) + ',' + y + ')',
                'font-size': yAxis.title.font.size,
                'font-family': yAxis.title.font.fontFamily,
                'font-style': yAxis.title.font.fontStyle,
                'font-weight': yAxis.title.font.fontWeight,
                'opacity': yAxis.title.font.opacity,
                'text-anchor': 'middle',
                'dominant-baseline': 'middle'
            };
             if (this.model.enableCanvasRendering) {
                var matched = bbdesigner$.uaMatch(navigator.userAgent);
                var isIE11 = !!navigator.userAgent.match(/Trident\/7\./);
                var browser = matched.browser.toLowerCase();
                 if (browser != "msie" && !isIE11)
                    options.x = !opposedPosition ? options.x + (titleSize.height / 4) + (browser == "mozilla" ? 1 : -2) : options.x - (titleSize.height / 4) + 1; // text dominant baseline for canvas
            }
            if (bbdesigner$(this.svgObject).find("#" + this.svgObject.id + '_YAxisTitle' + '_' + axisIndex).length > 0)
                bbdesigner$(this.svgObject).find("#" + this.svgObject.id + '_YAxisTitle' + '_' + axisIndex).attr(options);
            else if (!isEnableTrim)
                this.svgRenderer.drawText(options, commonEventArgs.data.title, gEle);
			else if(isEnableTrim &&(BoldBIDashboard.util.isNullOrUndefined(axisTitleWidth)||axisTitleWidth>0||isNaN(axisTitleWidth))){
                 if (!this.svgRenderer.vmlNamespace)
                    var bounds = { X: options.x - (axisTitleSize.height / 2), Y: options.y + (axisTitleSize.width / 2), Width: (axisTitleSize.height)/2, Height: axisTitleSize.width };
                 else
                    var bounds = { X: options.x - (axisTitleSize.width)/2, Y: options.y + (axisTitleSize.height / 2), Width: (axisTitleSize.width), Height: axisTitleSize.height };
                var yAxisTitleRegion = { Bounds: bounds, trimText: titleText, labelText: yAxis.title.text };
                this.model.yAxisTitleRegion.push(yAxisTitleRegion)
                this.svgRenderer.drawText(options, titleText, gEle);
            }	
            bbdesigner$(gEle).appendTo(this.gYaxisEle);
			}
		}
    },
BoldBIDashboard.EjStripline.prototype = {
    _drawStripline: function (axis, stripLine) {

        var start = (stripLine.start < axis.range.min) ? axis.range.min : stripLine.start;
        var end = (stripLine.end > axis.range.max) ? axis.range.max : stripLine.end;
        var x = 0, height = 0, angle = 0;
        var y = 0, pointYstart = 0, yHeight = 0;
        var width = 0, widthValue = 0, textX = 0, textY = 0;
        if (stripLine.visible) {
		     this.model._stripeline = true;
            var striplineid = (stripLine.zIndex == 'over') ? this.gStriplineOver : this.gStriplineBehind;
            striplineid = BoldBIDashboard.util.isNullOrUndefined(striplineid) ? "" : striplineid;
            var isVisible = true;
            if (axis.orientation.toLowerCase() == "horizontal") {
                var pointstart = 0;

                if (stripLine.startFromAxis) {

                    var point = (BoldBIDashboard.util.isNullOrUndefined(stripLine.offset)) ? axis.visibleRange.min : axis.visibleRange.min + stripLine.offset;
                    pointstart = (((point - axis.visibleRange.min) / (axis.visibleRange.delta)) * (axis.width)) + axis.x; //(bbdesigner$(this.svgObject).width() - this.model.m_Spacing.Left - this.model.m_Spacing.Right);

                    widthValue = (((point + (BoldBIDashboard.util.isNullOrUndefined(stripLine.width) ? 0 : stripLine.width) - axis.visibleRange.min) / (axis.visibleRange.delta)) * (axis.width));

                } else {
                    if (BoldBIDashboard.util.isNullOrUndefined(start) && (BoldBIDashboard.util.isNullOrUndefined(end) || BoldBIDashboard.util.isNullOrUndefined(stripLine.width))) {
                        isVisible = false;
                    } else {
                        start = (bbdesigner$.type(start) == "date") ? (start).getTime() : start;
                        if (!BoldBIDashboard.util.isNullOrUndefined(end) && (bbdesigner$.type(end) == "date")) {
                            end = (end).getTime();
                        }
                        pointstart = (BoldBIDashboard.EjSvgRender.utils._getPointXY(start, axis.visibleRange, axis.isInversed) * (axis.width)) + axis.x; //(bbdesigner$(this.svgObject).width() - this.model.m_Spacing.Left - this.model.m_Spacing.Right);
                        var pointend = (BoldBIDashboard.EjSvgRender.utils._getPointXY(end, axis.visibleRange, axis.isInversed) * (axis.width)) + axis.x; //(bbdesigner$(this.svgObject).width() - this.model.m_Spacing.Left - this.model.m_Spacing.Right);
                        var widthMax = (BoldBIDashboard.EjSvgRender.utils._getPointXY((start + (BoldBIDashboard.util.isNullOrUndefined(stripLine.width) ? 0 : stripLine.width)), axis.visibleRange, axis.isInversed) * (axis.width)) + axis.x;

                        widthValue = (axis.isInversed ? (pointend < widthMax) : (pointend > widthMax)) ? Math.abs(pointstart - pointend) : Math.abs(pointstart - widthMax);
                        
                    }
                }
                width = widthValue;
                height = this.chart.model.m_AreaBounds.Height;
                x = (axis.isInversed) ? (pointstart - widthValue) : pointstart;
                y = this.chart.model.m_AreaBounds.Y;
                angle = -90;
                var textWidth = BoldBIDashboard.EjSvgRender.utils._measureText(stripLine.text, null, stripLine.font).height;
                if (stripLine.textAlignment == 'middletop') {
                    textX = x+textWidth;
                    textY = Math.abs(y + height / 2);
                } else if (stripLine.textAlignment == 'middlecenter') {
                    textX = (Math.floor(x + width / 2) + (textWidth / 3));
                    textY = Math.abs(y + height / 2);
                } else if (stripLine.textAlignment == 'middlebottom') {
                    textX = x + width - (textWidth);
                    textY = Math.abs(y + height / 2);
                }


            } else {
                if (stripLine.startFromAxis) {
                    var pointY = (BoldBIDashboard.util.isNullOrUndefined(stripLine.offset)) ? axis.visibleRange.min : axis.visibleRange.min + stripLine.offset;
                    pointYstart = (axis.y + axis.height) - (((pointY - axis.visibleRange.min) / (axis.visibleRange.delta)) * (axis.height));
                    widthValue = (((pointY + (BoldBIDashboard.util.isNullOrUndefined(stripLine.width) ? 0 : stripLine.width) - axis.visibleRange.min) / (axis.visibleRange.delta)) * (axis.height));
                    yHeight = widthValue;
                } else {

                    if (BoldBIDashboard.util.isNullOrUndefined(start) && (BoldBIDashboard.util.isNullOrUndefined(end) || BoldBIDashboard.util.isNullOrUndefined(stripLine.width))) {
                        isVisible = false;
                    } else {
                        start = (bbdesigner$.type(start) == "date") ? (start).getTime() : start;
                        if (!BoldBIDashboard.util.isNullOrUndefined(end) && (bbdesigner$.type(end) == "date")) {
                            end = (end).getTime();
                        }
                        pointYstart = (axis.y + axis.height) - (BoldBIDashboard.EjSvgRender.utils._getPointXY(start, axis.visibleRange, axis.isInversed) * (axis.height));
                        var pointYend = (axis.y + axis.height) - (BoldBIDashboard.EjSvgRender.utils._getPointXY((BoldBIDashboard.util.isNullOrUndefined(end) ? 0 : end), axis.visibleRange, axis.isInversed) * (axis.height));
                        var widthYValue = (axis.y + axis.height) - (BoldBIDashboard.EjSvgRender.utils._getPointXY((start + (BoldBIDashboard.util.isNullOrUndefined(stripLine.width) ? 0 : stripLine.width)), axis.visibleRange, axis.isInversed) * (axis.height));
                        yHeight = (axis.isInversed ? (pointYend > widthYValue) : (pointYend < widthYValue)) ? Math.abs(pointYstart - pointYend) : Math.abs(pointYstart - widthYValue);
                    }
                }
                height = yHeight;
                x = this.chart.model.m_AreaBounds.X;
                width = this.chart.model.m_AreaBounds.Width;
                y = pointYstart + ((axis.isInversed) ? 0 : -yHeight);
                var textHeight = BoldBIDashboard.EjSvgRender.utils._measureText(stripLine.text, width, stripLine.font).height;

                if (stripLine.textAlignment == 'middletop') {
                    textX = x + width / 2;
                    textY = y + textHeight;
                } else if (stripLine.textAlignment == 'middlecenter') {
                    textX = x + width / 2;
                    textY = (Math.abs(y + (height / 2)) + (textHeight / 3));
                } else if (stripLine.textAlignment == 'middlebottom') {
                    textX = x + width / 2;
                    textY = (y + height) - textHeight;

                }


            }
            if (isVisible) {
                if (!BoldBIDashboard.util.isNullOrUndefined(stripLine.imageUrl)) {
                    var imgOptions = {
                        'height': height,
                        'width': width,
                        'href': stripLine.imageUrl,
                        'x': x,
                        'y': y,
                        'id': striplineid.id + '_backImage',
                        'visibility': 'visible',
                        'preserveAspectRatio': 'none'
                    };

                    this.svgRenderer.drawImage(imgOptions, striplineid);
                } else {
                    var options = {
                        'id': striplineid.id + '_striplineRect',
                        'x': x,
                        'y': y,
                        'width': width,
                        'height': height,
                        'fill': stripLine.color,
                        'opacity': stripLine.opacity,
                        'stroke-width': stripLine.borderWidth,
                        'stroke':(stripLine.borderWidth==0)?"transparent": stripLine.borderColor
                    };
                    var textOptions = {
                        'id': striplineid.id + '_striplineRectText',
                        'x': textX,
                        'y': textY,
                        'fill': stripLine.font.color,
                        'transform': 'rotate(' + angle + ',' + (textX) + ',' + textY + ')',
                        'labelRotation': angle,
                        'font-size': stripLine.font.size,
                        'font-family': stripLine.font.fontFamily,
                        'font-style': stripLine.font.fontStyle,
                        'font-weight': stripLine.font.fontWeight,
						'opacity': stripLine.font.opacity,
                        'text-anchor': 'middle'
                    };

                    var bounds = { X: x, Y: y, Width: width, Height: height };
                    var isStripline = stripLine.zIndex == "over" ? true : false;
                    BoldBIDashboard.EjSvgRender.utils.AddRegion(this.chart, bounds, isStripline)

                    if (this.chart.model.enableCanvasRendering) {
                        var ctx = this.chart.svgObject.getContext("2d");
                        var clipBounds = axis.orientation.toLowerCase() == 'horizontal' ? { X: axis.x, Y: y, Width: axis.width, Height: this.chart.model.m_AreaBounds.Height }
                        : { X: x, Y: axis.y, Width: this.chart.model.m_AreaBounds.Width, Height: axis.height };
                        ctx.save();
                        ctx.beginPath();
                        ctx.rect(clipBounds.X, clipBounds.Y, clipBounds.Width, clipBounds.Height);
                        ctx.clip();
                        this.svgRenderer.drawRect(options, striplineid);
                        this.svgRenderer.drawText(textOptions, stripLine.text, striplineid);
                        ctx.closePath();
                        ctx.restore();
                    }
                    else {
                        this.svgRenderer.drawRect(options, striplineid);
                        this.svgRenderer.drawText(textOptions, stripLine.text, striplineid);
                    }
                }
            }

        }
    }
};
})(bbdesigner$)
;
BoldBIDashboard.EjLegendRender = function (chartobj) {

    this.chartObj = chartobj;
};


(function (bbdesigner$) {
BoldBIDashboard.EjLegendRender.prototype =
{
		sumofArray: function(array) {
            var sum = 0,
            length = array.length;
            for (var i = 0; i < length; i++)
                sum += array[i];
            return sum;
		},

        legendRectSpace: function(svgBounds,divBounds) {
            var width = svgBounds.Width - 10;
            var height = svgBounds.Height - 10;
            var isVisible = false;
            if (Math.ceil(divBounds.Width) >= width && Math.ceil(divBounds.Height) >= height)
                isVisible = true;
            return isVisible;
        },

		drawLegendTitle: function () {
            //draw legend title

            var chart = this.chartObj,
                chartModel = chart.model,
                legend = chartModel.legend,
				isRTL = legend.isReversed,
                legendBounds = chartModel.LegendBounds,
                elementSpacing = chartModel.elementSpacing,
                legendTitle = legend.title,
                measureText = BoldBIDashboard.EjSvgRender.utils._measureText,
                font = legendTitle.font,
                legendBoundsWidth = legendBounds.Width,
                titleSize = measureText(legendTitle.text, null, font),
                titleWidth = titleSize.width,
                titleHeight = titleSize.height,
                textAlignment = legendTitle.textAlignment.toLowerCase(),
                startX = 0,
                startY = elementSpacing + (titleHeight / 2);

            switch (textAlignment) {
                case 'far':
                    startX = isRTL ? startX : legendBoundsWidth - titleWidth - startX;
                    break;
                case 'center':
                    startX = legendBoundsWidth / 2 - (titleWidth) / 2;
                    break;
            }

            if (startX < 0) {
                startX = 0;
                legendBoundsWidth = titleWidth;
            }
            if (legendBoundsWidth < titleWidth + startX)
                legendBoundsWidth = titleWidth + startX;

            var options = {
                'id': chart.svgObject.id + '_LegendTitleText',
                'x': isRTL && textAlignment == "near" ?legendBoundsWidth - titleWidth - startX : startX,
                'y': startY,
                'fill': font.color,
                'font-size': font.size,
                'font-style': font.fontStyle,
                'font-family': font.fontFamily,
                'font-weight': font.fontWeight,
                'text-anchor': 'start',
				'direction':'ltr',
                'lgndCtx': true
            };

            chart.svgRenderer.drawText(options, legendTitle.text, this.chartObj.gLegendEle);

        },
    
        drawLegendItem: function (legendItem, x, y) {
            var chart = this.chartObj,
                chartModel = chart.model,
                legend = chartModel.legend,
				isRTL = legend.isReversed,
                textOverflow = legend.textOverflow.toLowerCase(),
                textMaxWidth = legend.textWidth,
                legendMode = legend.mode,
                columnCount = legend.columnCount,
                enableMultiRange = legend.enableMultiRange,
                legendPosition = legend.position.toLowerCase(),
                legendBounds = chartModel.LegendBounds,
                elementSpacing = chartModel.elementSpacing,
                legendBorder = legend.border.width,
                measureText = BoldBIDashboard.EjSvgRender.utils._measureText,
                svgRender = BoldBIDashboard.EjSvgRender,
                chartSvgRender = chart.svgRenderer,
                legendFont = legendItem.Font,
                symbolShape = chartModel.symbolShape,
                isCanvas = chartModel.enableCanvasRendering,
				seriesLength = chartModel.series.length,
                shapeSize = legendMode == "range" && !enableMultiRange ? (legendPosition == "top" || legendPosition == "bottom" ? { width: 200, height: 15, border: legend.itemStyle.border } : { width: 15, height: 200, border: legend.itemStyle.border }) : legend.itemStyle,
                textHeight = measureText(legendMode == "range" && !enableMultiRange ? legendItem.Text[0] : legendItem.Text, legendBounds.Width, legendFont).height,
                textWidth = measureText(legendMode == "range" && !enableMultiRange ? legendItem.Text[0] : legendItem.Text, legendBounds.Width, legendFont).width,
                location = {
                    startX: isRTL ? textWidth + x + elementSpacing : ( x + shapeSize.width / 2),
                    startY: (y + (textHeight > shapeSize.height ? textHeight : shapeSize.height) / 2)
                },
                pointIndex = legendItem.PointIndex,
                seriesIndex = legendItem.SeriesIndex,
                index = pointIndex ? pointIndex : seriesIndex,
                series = chartModel.series[seriesIndex],
                svgObject = chart.svgObject,
                legendStyle = legendItem.LegendStyle,
                matched = bbdesigner$.uaMatch(navigator.userAgent),
                isIE11 = !!navigator.userAgent.match(/Trident\/7\./),
                color,itemInfo, data,style,
                seriesType = series.type.toLowerCase(),
                symbolName, symbol,textinfo,legendTextRegion,textLength;

            for (name in symbolShape) {
                if (legendItem.Shape.toLowerCase() == name.toLowerCase()) {
                    if (name.toLowerCase() == "seriestype")
                        symbolName = "SeriesType";
                    else
                        symbolName = name;
                    break;
                }
            }

            if (symbolName == "SeriesType") {
                if (seriesType == "radar" || seriesType == "polar") {
                    symbol = series.drawType;
                    symbolName = symbol.capitalizeFirstString();
                }
                if (seriesType == "scatter") {
                    symbol = series.marker.shape;
                    symbolName = symbol.capitalizeFirstString();
                }
                if (legendItem.drawType)// // TrendLine drawType assigned to legend shape
                    symbolName = "SeriesType";
				if (chart.vmlRendering && (seriesType == "pie" || seriesType == "doughnut"))
					symbolName = "Circle";          // VML legend shape for pie & doughnut
            }

            if (symbolName == "None") {
                if (seriesType == "pie" || seriesType == "doughnut"){
					if(legendMode == "range" && !enableMultiRange && seriesLength == 1)
						symbolName = "Rectangle";
					else
						symbolName = "Circle";
					}
                else
                    symbolName = "Rectangle";
            }

            index = (BoldBIDashboard.util.isNullOrUndefined(pointIndex)) ? seriesIndex : pointIndex;
            chart.gLegendItemEle = chartSvgRender.createGroup({ 'id': svgObject.id + '_Legend' + index, 'cursor': 'pointer' });
            legendItem.CommonEventArgs.data.gLegendItemEle = chart.gLegendItemEle;
            data = bbdesigner$.extend(true, {}, legendItem.CommonEventArgs.data);
            data.model = chart.model;
            style = data.style;
			style.ShapeSize = legendMode == "range" && !enableMultiRange ? (legendPosition == "top" || legendPosition == "bottom" ? { width: 200, height: 15, border: style.ShapeSize.border } : { width: 15, height: 200, border: style.ShapeSize.border }) : style.ShapeSize;
            if (legendMode == "range" && !enableMultiRange && (chartModel.AreaType == "none" || chartModel.AreaType == "cartesianaxes")) {
                if (legendPosition == "top" || legendPosition == "bottom")
                    location.startX = location.startX + textWidth + elementSpacing / 2;
            }
            if (!legendItem.CommonEventArgs.cancel) {
                startLocation = svgRender.chartSymbol["_draw" + symbolName](location, style, data, chart.gLegendItemEle);
                if (legendMode == "range" && !enableMultiRange) {
                    xpos = legendPosition == "right" || legendPosition == "left" ? location.startX + style.ShapeSize.width : location.startX + style.ShapeSize.height;
                    ypos = location.startY;
                    style.ShapeSize.height = 12;
                    style.ShapeSize.width = 12;
                    style.ID = style.ID + "Icon";
                    var pointerLocation = {
                        startX: legendPosition == "right" || legendPosition == "left" ? location.startX + style.ShapeSize.width : x + textWidth + elementSpacing / 2,
                        startY: legendPosition == "right" || legendPosition == "left" ? y + elementSpacing : y + style.ShapeSize.height + elementSpacing
                    };                    
                    svgRender.chartSymbol["_drawTriangle"](pointerLocation, style, data, chart.gLegendItemEle);
                }
                if (legendStyle.Color && legendStyle.Color.toString().toLowerCase() !== 'gray' && isCanvas) // for canvas gradient color
                    color = legendFont.color;
                else if (legendStyle.Color && legendStyle.Color.toLowerCase() !== 'gray') // for svg
                    color = legendFont.color;
                else
                    color = 'gray';

                itemInfo = legendItem;
                textLength = itemInfo.Text.length;
                if (legend.shape == "seriestype" || legend.shape == "seriesType")
                    x = isRTL ? x - elementSpacing / 2 : x + elementSpacing / 2;
                var options = {
                    'id': this.chartObj.svgObject.id + '_LegendItemText' + index,
                    'x': isRTL ? x : shapeSize.width + x + elementSpacing / 2,
                    'y': location.startY,
                    'fill': color,
                    'font-size': legendFont.size,
                    'font-style': legendFont.fontStyle,
                    'font-family': legendFont.fontFamily,
                    'font-weight': legendFont.fontWeight,
                    'text-anchor': 'start',
					'direction':'ltr',
                    'lgndCtx': true
                };

                options.y = (location.startY + (textHeight / 4));

                if (legendMode == "range" && !enableMultiRange && (chartModel.AreaType == "none" || chartModel.AreaType == "cartesianaxes")) {
                    for (var k = 0; k < textLength; k++) {
                        if(legendPosition == "left" || legendPosition == "right")
                            options.y = location.startY + (k == 0 ? (-(shapeSize.height / 2) + elementSpacing) : (shapeSize.height / 2));
                        else if (legendPosition == "top" || legendPosition == "bottom"){
                            options.x = k == 0 ? options.x - shapeSize.width - elementSpacing: options.x + textWidth + shapeSize.width  + x + elementSpacing;
                            options.y = location.startY + (shapeSize.height / 2);
                        }
                        chartSvgRender.drawText(options, itemInfo.Text[k], chart.gLegendItemEle);
                    }                    
                }
                else{
                if (textOverflow == "wrap" || textOverflow == "wrapandtrim") {
                    options.y = options.y - textHeight;
                    for (k = 0; k < textLength; k++) {
                        options.y = options.y + (textHeight);
                        chartSvgRender.drawText(options, itemInfo.Text[k], chart.gLegendItemEle);
                        if (textOverflow == "wrapandtrim") {
                            if (chartModel.AreaType == "none" && columnCount == 1) textMaxWidth = measureText(itemInfo.Text, legendBounds.Width, legendFont).width;
                            textinfo = { x: options.x + legendBounds.X, y: options.y + legendBounds.Y, height: textHeight * (textLength), width: textMaxWidth };
                            legendTextRegion = { bounds: textinfo, trimText: itemInfo.Text, labelText: itemInfo.displayText };
                            chartModel.legendTextRegion.push(legendTextRegion);
                        }
                    }
                }
                else {
                    if (textOverflow == "trim") {
                        if (chartModel.AreaType == "none" && columnCount == 1) textMaxWidth = measureText(itemInfo.Text, legendBounds.Width, legendFont).width;
                        textinfo = { x: options.x + legendBounds.X, y: options.y + legendBounds.Y, height: textHeight + elementSpacing, width: textMaxWidth };
                        legendTextRegion = { bounds: textinfo, trimText: itemInfo.Text, labelText: itemInfo.displayText };
                        chartModel.legendTextRegion.push(legendTextRegion);
                    }
                    chartSvgRender.drawText(options, itemInfo.Text, chart.gLegendItemEle);
                }
                }
                chartSvgRender.append(chart.gLegendItemEle, chart.gLegendEle);
                legendbound = {
                    X: legendBounds.X + legendBorder,
                    Y: legendBounds.Y + legendBorder
                };
                
                x = (startLocation) ? isRTL ? location.startX - textWidth - elementSpacing : startLocation : x;
                var itembound = { 
                    X: (x), Y: (y), Width: legendItem.Bounds.Width, Height: legendItem.Bounds.Height
                };
                var bounds = { LegendBound: legendbound, ItemBound: itembound };
				location.startX = isRTL ? location.startX - textWidth - elementSpacing/2: location.startX;
                var legendRegion = {
                    LegendItem: legendItem,
                    Location: location, SymbolShape: symbolName, Style: legendItem.CommonEventArgs.data.style, Bounds: bounds
                };
                chartModel.legendRegion.push(legendRegion);
            }
        },

        drawLegend: function (params) {
            var chart = this.chartObj,
                chartModel = chart.model,
                legend = chartModel.legend,
                columnCount = legend.columnCount,
				isRTL = legend.isReversed,
                legendViewerBounds = chartModel.LegendViewerBounds,
                legendBounds = chartModel.LegendBounds,
                actualBounds = chartModel.LegendActualBounds,
                AreaType = chartModel.AreaType,
                legendPosition = !BoldBIDashboard.util.isNullOrUndefined(legend.responsivePosition) ? legend.responsivePosition : legend.position.toLowerCase(),
                alignment = legend.alignment.toLowerCase(),
                elementSpacing = chartModel.elementSpacing,
                svgObjectWidth = chartModel.svgWidth,
                svgObjectHeight = chartModel.svgHeight,
                title = chartModel.title,
                titleFontHeight = title.font.size,
                subTitle = title.subTitle,
                subTitleFontHeight = title.subTitle.font.size,
                legendTitle = legend.title,
                legendBorder = legend.border.width,
                measureText = BoldBIDashboard.EjSvgRender.utils._measureText,
                margin = chartModel.margin,
                borderSize = chartModel.border.width,
                legendCollection = chartModel.legendCollection,
                collectionLength = legendCollection.length,
                svgWidth = svgObjectWidth - ((borderSize * 2)),
                svgHeight = svgObjectHeight - ((borderSize * 2)),
                itemPadding = legend.itemPadding > 0 ? legend.itemPadding : 0,
                padding = 20,
                hPadding = 10,
                vPadding = 10,
                modelsubTitleHeight = subTitle.responsiveVisibility ? (subTitle.text == "" ? 0 : measureText(subTitle.text, svgWidth - margin.left - margin.right, subTitle.font).height + elementSpacing) : 0,
                titleLocation = chartModel._titleLocation ? chartModel._titleLocation.Y : 0 + modelsubTitleHeight,
                legendTitleBounds = measureText(legendTitle.text, null, legendTitle.font),
                legendTitleHeight = legendTitleBounds.height,
                legendTitleWidth = legendTitleBounds.width,
                rowDefinitions = chartModel._rowDefinitions,
                maxWidth = 0, startX, startY,
                columnDefinitions = chartModel._columnDefinitions,
                vSizeFar = this.sumofArray(rowDefinitions.farSizes),
                vSizeNear = this.sumofArray(rowDefinitions.nearSizes),
                hSizeFar = this.sumofArray(columnDefinitions.farSizes),
                hSizeNear = this.sumofArray(columnDefinitions.nearSizes),
                isScrolling = false,
                areaBounds = chartModel.m_AreaBounds,
                isScroll = legend.enableScrollbar,
                legendContainer = bbdesigner$(chart.legendContainer),
                leftScroll = bbdesigner$("#ScrollerParent_" + 'vertical' + "_" + chart._id).length > 0 ? 18 : 0,
                bottomScroll = bbdesigner$("#ScrollerParent_" + 'horizontal' + "_" + chart._id).length > 0 ? 18 : 0,
                legendSvgContainer = bbdesigner$(chart.legendSvgContainer);
            var textBorderConstant = 1.2,
                titleBorderSpacing = 10,
                subTitleBorderSpacing = 10,
                titleTextHeight = parseInt(titleFontHeight) * textBorderConstant;
                subTitleTextHeight = parseInt(subTitleFontHeight) * textBorderConstant;
                if ((chartModel.legend.border) && (!subTitle.text)) {
                    subTitleTextHeight = 0;
                    subTitleBorderSpacing = 5;
                }
            
            if (legendPosition == 'right' || legendPosition == 'left') {
                hPadding = 10;
            } else {
                vPadding = isScroll ? svgHeight > 200 ? 10 : svgHeight > 100 ? 5 : 0 : 10;
            }
            legendViewerBounds.Height += legendTitleHeight,
            legendBounds.Height += legendTitleHeight;            
            if (legend.visible) {                
                // draw legend.
                if (legendPosition != 'custom') {
                    if (AreaType == "cartesianaxes") {
                        switch (legendPosition) {
                            case "bottom":
                                legendBounds.Y = svgHeight - (elementSpacing + legendViewerBounds.Height);
                                break;
                            case "top":
                                legendBounds.Y = titleLocation == 0 ? borderSize + elementSpacing : (titleTextHeight + titleBorderSpacing + subTitleTextHeight + subTitleBorderSpacing + elementSpacing);
                                break;
                            case "right":
                                legendBounds.X = areaBounds.X + areaBounds.Width + vSizeFar + elementSpacing * 2;
                                break;
                            case "left":
                                legendBounds.X = areaBounds.X - vSizeNear - actualBounds.Width - (elementSpacing / 2) - (legendBorder * 2) - leftScroll;
                                break;
                        }
                    } else {
                        switch (legendPosition) {
                            case "bottom":
                                legendBounds.Y = svgHeight - (actualBounds.Height + (legendBorder)) - (elementSpacing * 2);
                                break;
                            case "top":
                                legendBounds.Y = titleLocation == 0 ? borderSize + elementSpacing : (titleTextHeight + titleBorderSpacing + subTitleTextHeight + subTitleBorderSpacing + elementSpacing);
                                break;
                            case "right":
                                legendBounds.X = svgWidth - actualBounds.Width - (elementSpacing * 2);
                                break;
                            case "left":
                                legendBounds.X = borderSize + (elementSpacing * 2);
                                break;
                        }
                    }                    
                    //Avoid axis and legend overlapping during crossing
                    if (!chartModel.enable3D && AreaType == "cartesianaxes" && params._crossAxisOverlap!=null) {                        						
                        for (var i = 0, len = chartModel._axes.length; i < len; i++) {
                            var axis = chartModel._axes[i], axisBounds = params.axes[axis.name]._bounds;
                                var hor = axis.orientation.toLowerCase() === 'horizontal';
                                if (legendPosition=="top" && hor && axis._opposed && (axis.y - axisBounds < legendBounds.Y + legendBounds.Height))
                                    legendBounds.Y -= legendBounds.Y + legendBounds.Height - axis.y + axisBounds;
                                else if (legendPosition=="bottom" && hor && !axis._opposed && (axis.y + axisBounds > legendBounds.Y))                                    
                                    legendBounds.Y += axis.y + axisBounds - legendBounds.Y;
                                else if (legendPosition=="left" && !hor && axis._opposed && (axis.x - axisBounds < legendBounds.X + legendBounds.Width))
                                    legendBounds.X += axis.x + axisBounds - legendBounds.X;                                    
                                else if (legendPosition=="right" && !hor && !axis._opposed && (axis.x + axisBounds > legendBounds.X))
                                    legendBounds.X -= legendBounds.X + legendBounds.Width - axis.x + axisBounds;                            
                        }
                    }
                    if (legendPosition == 'left' || legendPosition == 'right') {
                        if (isScroll) {
                            switch (alignment) {
                                case "center":
                                    legendBounds.Y = areaBounds.Height / 2 - (actualBounds.Height / 2) + areaBounds.Y - legendBorder;
                                    break;
                                case "near":
                                    legendBounds.Y = areaBounds.Y;
                                    break;
                                case "far":
                                    legendBounds.Y = areaBounds.Y + areaBounds.Height - actualBounds.Height - (legendBorder * 2);
                                    break;
                            }
                        } else {
                            switch (alignment) {
                                case "center":
                                    legendBounds.Y = (svgHeight / 2) - ((actualBounds.Height + legendBorder * 2) / 2) + (elementSpacing / 2);
                                    break;
                                case "near":
                                    legendBounds.Y = borderSize + (elementSpacing * 2);
                                    break;
                                case "far":
                                    legendBounds.Y = svgHeight - (actualBounds.Height + (legendBorder)) - (elementSpacing * 2);
                                    break;
                            }
                        }

                    } else {
                        switch (alignment) {
                            case "center":
                                legendBounds.X = (svgWidth / 2) - ((actualBounds.Width + legendBorder * 2) / 2) + (elementSpacing / 2);
                                break;
                            case "near":
                                legendBounds.X = isRTL? svgWidth - (actualBounds.Width + (legendBorder)) - (elementSpacing * 2) : borderSize + (elementSpacing * 2);
                                break;
                            case "far":
                                legendBounds.X = isRTL? borderSize + (elementSpacing * 2) : svgWidth - (actualBounds.Width + (legendBorder)) - (elementSpacing * 2);
                                break;
                        }
                    }
                } else {
                    legendBounds.Y = (legend.location.y < svgHeight) ? legend.location.y : 0;
                    legendBounds.X = (legend.location.x < svgWidth) ? legend.location.x : 0;
                }
                if (isScroll) {
                    if (legendPosition == 'right' || legendPosition == 'left') {
                        if (legendBounds.Y < areaBounds.Y || actualBounds.Height + (legendBorder * 2) >= areaBounds.Height) {
                            var legendHeight = (legendBorder * 2);
                            for (var k = 0; k < collectionLength; k++) {
                                legendHeight += legendCollection[k].Bounds.Height + itemPadding;
                                if (legendHeight > areaBounds.Height) {
                                    actualBounds.Height = areaBounds.Height - (legendBorder * 2);
                                    legendBounds.Y = areaBounds.Y;
                                    break;
                                }
                            }
                        }
                    }
                    else {
                        if ((legendBorder * 2 + actualBounds.Width) >= svgWidth) {
                            var legendWidth = (legendBorder * 2);
                            for (var k = 0; k < collectionLength; k++) {
                                legendWidth += legendCollection[k].Bounds.Width + itemPadding;
                                if (legendWidth > svgWidth) {
                                    actualBounds.Width = svgWidth - (legendBorder * 2) - actualBounds.vScrollSize - (borderSize * 2);
                                    legendBounds.X = (svgWidth / 2) - ((actualBounds.Width + legendBorder * 2) / 2) + (elementSpacing / 2);
                                    break;
                                }

                            }
                        }
                    }
                }
                    
                //Set height and width to legend Canvas element
                chart.legendSvgContainer.height = legendBounds.Height;
                chart.legendSvgContainer.width = Math.max(legendTitleWidth, legendBounds.Width);
                currentX = startX = hPadding;
                currentY = startY = vPadding;
                if (legendTitle.text != "" && legendTitle.text) {
                    this.drawLegendTitle();
                    currentY = startY = vPadding + legendTitleHeight;
                }
                for (var k = 0; k < collectionLength; k++) {
                    if ((legend.rowCount < legend.columnCount || legend.rowCount == legend.columnCount )&& (legendPosition == 'top'|| legendPosition == 'bottom'|| legendPosition == 'custom' )) {
                        if ((currentX + legendCollection[k].Bounds.Width) > legendBounds.Width + startX) {
                            currentX = hPadding;
                            currentY += legendCollection[k].Bounds.Height + itemPadding;
                        }
                        this.drawLegendItem(legendCollection[k], currentX, (currentY));
                        currentX += legendCollection[k].Bounds.Width + itemPadding;
                    }
                    else {
                        if (((currentY + legendCollection[k].Bounds.Height) + legendTitleHeight + borderSize > legendBounds.Height + startY)) {
                            currentY = startY;
                            currentX += maxWidth + (itemPadding);
                        }
                        this.drawLegendItem(legendCollection[k], (currentX), (currentY));
                        currentY += legendCollection[k].Bounds.Height + itemPadding;
                        maxWidth = Math.max(maxWidth, legendCollection[k].Bounds.Width);
                    }
                }
                var legendVal  = chart.legendContainer[0].offsetLeft;
                var chartOffsetVal = bbdesigner$('#' + chart._id).offset();				
                var offsetVal = (chart.vmlRendering) ? (legendVal <= 0) ? legendBounds.X : (legendVal  - chartOffsetVal.left) : 
                                (bbdesigner$(chart.svgObject).offset().left - chartOffsetVal.left);
                var legnTx = (chart.vmlRendering) ? offsetVal : legendBounds.X + (offsetVal <= 0 ? 0 : offsetVal);
                legendContainer.attr('style','');
                var hrScrlrHight = 0;
				if (legend._BoldBIDashboardScroller  && bbdesigner$('#' + legendContainer[0].id).BoldBIDashboardScroller("instance").length > 0 ) {                    
                    bbdesigner$('#' + legendContainer[0].id).BoldBIDashboardScroller("instance").destroy();
                    hrScrlrHight = (actualBounds.Height - bbdesigner$('#legend_Scroller'+ chart._id).height()) <= 13 ? 10 : 0;//13-hrzScrollbar height, to render vertical scrollbar
                }
                legendContainer.show();
				if(isRTL)
					legendContainer.css({"direction":"rtl"});
			    else
					legendContainer.css({"direction":"ltr"});
                legendContainer.css({ "position": "absolute", "background": legend.background, "left": legnTx, "top": legendBounds.Y, "width": actualBounds.Width, "height": actualBounds.Height, "border-width": legend.border.width, "border-color": legend.border.color, "border-style": "solid" });
                legendSvgContainer.css({ "height": legendBounds.Height + hrScrlrHight, "width": legendBounds.Width });
                legendBounds.Height = legendBounds.Height - (padding - (vPadding * 2));
                var isVisible = this.legendRectSpace(legendBounds, actualBounds);
                if (isScroll) {
                    if (legend._BoldBIDashboardScroller) {
                        if (!isVisible && (legendBounds.Width > Math.ceil(actualBounds.Width) || legendBounds.Height > Math.ceil(actualBounds.Height))) {
                            bbdesigner$('#' + legendContainer[0].id).BoldBIDashboardScroller({ scrollTop: chart.scrolltop, scrollLeft: chart.scrollleft,height: actualBounds.Height, width: actualBounds.Width });
                            isScrolling = true;
                            if (legendBounds.Height > Math.ceil(actualBounds.Height)) {
                                if (actualBounds.vScrollSize == 0) {
                                    vScrollSize = legendContainer[0].offsetWidth + (legendBorder * 5) - legendContainer[0].clientWidth;
                                    legendContainer.css({ "width": actualBounds.Width + vScrollSize });
                                }
                            }
                        } else {
							bbdesigner$('#' + legendContainer[0].id).BoldBIDashboardScroller("instance").destroy();
                            legend._BoldBIDashboardScroller = false;
                        }
                    }
                    else {
                        if (AreaType == "none" && columnCount == 1) {
                            if (!isVisible && legendBounds.Height > Math.ceil(actualBounds.Height) && actualBounds.vScrollSize >= 0) {
                                legendContainer[0].style.overflowY = "scroll";
                                legendContainer[0].style.overflowX = "hidden";
                                if (actualBounds.vScrollSize == 0) {
                                    vScrollSize = legendContainer[0].offsetWidth - (legendBorder * 2) - legendContainer[0].clientWidth;
                                    legendContainer.css({ "width": actualBounds.Width + vScrollSize });
                                }
                                isScrolling = true;
                            }
                        }
                        else{
                        if (!isVisible && legendBounds.Width > Math.ceil(actualBounds.Width) && legendBounds.Height > Math.ceil(actualBounds.Height)) {                           
                            legendContainer.css({ "overflow": "scroll" });
                            isScrolling = true;
                        } else {
                            if (!isVisible && legendBounds.Height > Math.ceil(actualBounds.Height) && actualBounds.vScrollSize >= 0) {
                                legendContainer[0].style.overflowY = "scroll";
                                legendContainer[0].style.overflowX = "hidden";
                                if (actualBounds.vScrollSize == 0) {
                                    vScrollSize = legendContainer[0].offsetWidth - (legendBorder * 2) - legendContainer[0].clientWidth;
                                    legendContainer.css({ "width": actualBounds.Width + vScrollSize });
                                }
                                isScrolling = true;
                            }
                            if (!isVisible && legendBounds.Width > Math.ceil(actualBounds.Width) && actualBounds.hScrollSize >= 0) {
                                legendContainer[0].style.overflowX = "scroll";
                                legendContainer[0].style.overflowY = "hidden";
                                if (actualBounds.hScrollSize == 0) {
                                    hScrollSize = legendContainer[0].offsetHeight - (legendBorder * 2) - legendContainer[0].clientHeight;
                                    legendContainer.css({ "height": actualBounds.Height + hScrollSize });
                                }
                                isScrolling = true;
                            }
                        }
                       }
                    }
                }
                
                chart.svgRenderer.append(chart.gLegendEle, chart.legendSvgContainer);
                if (!isScrolling) {
                    legendContainer.css({ "width": actualBounds.Width - actualBounds.vScrollSize, "height": actualBounds.Height - actualBounds.hScrollSize });
                }
				if (!legend._BoldBIDashboardScroller) {
					if (chart.scrolltop != undefined)
						legendContainer.scrollTop(chart.scrolltop);
					if (chart.scrollleft != undefined)
						legendContainer.scrollLeft(chart.scrollleft);
				}                

            }
            else
                legendContainer.hide();
        }
    };
})(bbdesigner$);
;

BoldBIDashboard.seriesTypes = {};

BoldBIDashboard.EjSeriesRender = function () {

};
BoldBIDashboard.indicatorTypes = {};

BoldBIDashboard.EjIndicatorRender = function () {

};
BoldBIDashboard.trendlineTypes = {};

BoldBIDashboard.EjTrendLineRenderer = function () {

};
(function (bbdesigner$) {
    BoldBIDashboard.EjTrendLineRenderer.prototype = {
        draw: function (trendline, series, sender) {
            this.chartObj = sender;
            var trendIndex = bbdesigner$.inArray(trendline, series.trendlines);
			trendline._isTransposed = sender.model.requireInvertedAxes;
            trendline.xAxis = series.xAxis;
            trendline.yAxis = series.yAxis;
            var type = trendline.type.toLowerCase();
            if (type == "linear" || type == "movingaverage")
                this.calculateLineDirection(trendline, series, trendIndex);
            else
                this.calculateSplineDirection(trendline, series, trendIndex);

            return false;
        },        
        calculateSplineDirection: function (trendline, series, trendIndex) {
            //var series = trendline;
            var spDirection = "";
            var splinesb = BoldBIDashboard.EjSvgRender.utils._getStringBuilder();
            var startingPoint = true;
            var yIndex = 0;
            var visiblePoints = trendline.points;
            var ySpline = BoldBIDashboard.EjSeriesRender.prototype.naturalSpline(visiblePoints, series, yIndex);
            var firstPoint = null;
            var secondPoint = null;
            var firstIndex = -1;
            var canvasX = 0;
            var canvasY = 0;
            var point, pointIndex;
            var length = visiblePoints.length;
            for (var i = 0; i < length; i++) {
                pointIndex = i;
                secondPoint = visiblePoints[i];
                    if (firstPoint != null) {
                        var controlPoint1 = null;
                        var controlPoint2 = null;
                        var data = BoldBIDashboard.EjSeriesRender.prototype.getBezierControlPoints(firstPoint, secondPoint, ySpline[firstIndex], ySpline[pointIndex], yIndex);
                        controlPoint1 = data["controlPoint1"];
                        controlPoint2 = data["controlPoint2"];
                        var pt1 = BoldBIDashboard.EjSvgRender.utils._getPoint(firstPoint, trendline);
                        var pt2 = BoldBIDashboard.EjSvgRender.utils._getPoint(secondPoint, trendline);
                        var bpt1 = BoldBIDashboard.EjSvgRender.utils._getPoint(controlPoint1, trendline);
                        var bpt2 = BoldBIDashboard.EjSvgRender.utils._getPoint(controlPoint2, trendline);
                        var chartObj = this.chartObj;
                        if (startingPoint) {
                            splinesb.append("M" + " " + (pt1.X) + " " + (pt1.Y) + " " + "C" + " " + (bpt1.X) + " " + (bpt1.Y) + " " + (bpt2.X) + " " + (bpt2.Y) + " " + (pt2.X) + " " + (pt2.Y) + " ");
                            startingPoint = false;
                        }
                        else
                            splinesb.append("C" + " " + (bpt1.X) + " " + (bpt1.Y) + " " + (bpt2.X) + " " + (bpt2.Y) + " " + (pt2.X) + " " + (pt2.Y) + " ");
                    }
                    firstPoint = secondPoint;
                    firstIndex = pointIndex;
            }
            spDirection = splinesb.toString();
            this._drawLinePath(trendline, series, spDirection, trendIndex);

            return false;
        },
        calculateLineDirection: function (trendline, series, trendIndex) {
            var canvasX = 0;
            var canvasY = 0;
            var point;           
            var lDirection;
            var sb = BoldBIDashboard.EjSvgRender.utils._getStringBuilder();

            var firstPoint = false;
            var secondPoint;
            var length = trendline.points.length;
            for (var i = 0; i < length; i++) {
                secondPoint = trendline.points[i];
                    point = BoldBIDashboard.EjSvgRender.utils._getPoint(secondPoint, trendline);
                    if (firstPoint)
                        sb.append("L" + " " + (point.X) + " " + ((point.Y)) + " ");
                    else {
                        sb.append("M" + " " + (point.X) + " " + ((point.Y)) + " ");
                        sb.append("L" + " " + (point.X) + " " + ((point.Y)) + " ");
                        firstPoint = true;
                    }
            }
            lDirection = sb.toString();
            this._drawLinePath(trendline, series, lDirection, trendIndex);
            return false;
        },
        _drawLinePath: function (trendline, series, lDirection, trendIndex) {
            var translate = [];
            translate[0] = trendline.xAxis.x;
            translate[1] = trendline.yAxis.y;

            if (lDirection != "") {
                var options = {
                    'id': this.chartObj.svgObject.id + "_" + trendline.seriesIndex + "_" + trendIndex + "_" + trendline.name.replace(/[^a-zA-Z ]/g, ""),
                    'fill': 'none',
                    'stroke-dasharray': trendline.dashArray,
                    'stroke-width': trendline.width,
                    'stroke': trendline.fill,
                    'opacity': trendline.opacity,
                    'd': lDirection
                };
                trendline.id = options.id;
                this.chartObj.svgRenderer.drawPath(options, series.gTrendGroupEle, translate);
            }
            this.chartObj.svgRenderer.append(series.gTrendGroupEle, this.chartObj.gTrendlinesGroupEle[trendline.seriesIndex]);

            return false;
        },

        calculateTrendLineSegment: function (series, trendline, axis, sender) {
            var chartmodel = sender.model;
            var axis, points = series.points;
            var trendlineType = trendline.type.toLowerCase();
			trendline.xAxis = series.xAxis ? series.xAxis : chartmodel.primaryXAxis;
            trendline.yAxis = series.yAxis ? series.yAxis : chartmodel.primaryYAxis;
            trendline.backwardForecast = trendline.backwardForecast < 0 ? 0 : trendline.backwardForecast;
            trendline.forwardForecast = trendline.forwardForecast < 0 ? 0 : trendline.forwardForecast;
			points = points.sort(function(a,b) {return (a.xValue> b.xValue) ? 1 : ((b.xValue > a.xValue) ? -1 : 0);});
            switch (trendlineType) {
                case "linear":
                    this.updateTrendSource(points, trendline);
                    this.calculateLinearTrendline(series, trendline, axis);
                    break;
                case "exponential":
                    this.updateExponentialTrendSource(points, trendline);
                    this.calculateExponentialTrendline(series, trendline, axis);
                    break;
                case "logarithmic":
                    this.updateLogarithmicTrendSource(points, trendline);
                    this.calculateLogarithmicTrendline(series, trendline, axis);
                    break;
                case "power":
                    this.updatePowerTrendSource(points, trendline);
                    this.calculatePowerTrendline(series, trendline, axis);
                    break;
                case "polynomial":
				    var length = series.points.length;
				    trendline.polynomialOrder = length <= trendline.polynomialOrder ? length : trendline.polynomialOrder;
                    trendline.polynomialOrder = trendline.polynomialOrder < 2 ? 2 : trendline.polynomialOrder;
                    trendline.polynomialOrder = trendline.polynomialOrder > 6 ? 6 : trendline.polynomialOrder;
                    if (length > 1) {
                        this.updateTrendSource(points, trendline);
                        this.calculatePolynomialTrendline(series, trendline, axis);
                    }
                    break;
                case "movingaverage":
                    this.updateMovingAverageTrendSource(points, trendline);
                    this.calculateMovingAverageTrendline(series, trendline, axis);
                    break;
            }
            if (series.points.length > 1 && trendline.points.length > 1)
                this.calculateTrendLineRange(trendline, axis);
            return false;
        },
        updateTrendSource: function (points, trendline) {
            var len = points.length;

            trendline.xPoints = [];
            trendline.xValues = [];
            trendline.yValues = [];
            for (var i = 0; i < len; i++) {
                if (!points[i].isEmpty) {                    
                    trendline.xPoints.push(points[i].xValue);
                    trendline.xValues.push(i + 1);
                    trendline.yValues.push(points[i].y);
                }
            }
            this.calculateSumXAndYValue(trendline);
            return false;
        },
        calculateLinearTrendline: function (series, trendline, axis) {            
            
            var count = trendline.xValues.length;
            var x1, x2;
            trendline.points = [];

            if (count > 1) {
                if (axis._valueType == "datetime") {
                    x1 = this._increaseDateTimeInterval(trendline.xPoints[0], -trendline.backwardForecast, axis._intervalType);
                    x2 = this._increaseDateTimeInterval(trendline.xPoints[count - 1], trendline.forwardForecast, axis._intervalType);
                } else {
                     x1 = (trendline.xPoints[0] - trendline.backwardForecast);
                     x2 = (trendline.xPoints[count - 1] + trendline.forwardForecast );
                }

                //trendline linear segment  y = ax + b;
                var y1 = (trendline.slope * (1 - ((count - 1) * (trendline.backwardForecast) / (series.maxX - series.minX)))) + trendline._intercept;
                var y2 = (trendline.slope * (count + ((count - 1) * (trendline.forwardForecast)/(series.maxX - series.minX)))) + trendline._intercept;
                trendline.points.push({ x: x1, xValue: x1, y: y1, YValues: [], visible: true });
                trendline.points.push({ x: x2, xValue: x2, y: y2, YValues: [], visible: true });

                trendline.points[0].YValues[0] = trendline.points[0].y;
                trendline.points[1].YValues[0] = trendline.points[1].y;
            }
            return false;
        },
       
        //// Calculate Trendline range
        calculateTrendLineRange: function (trendline, axis) {

            var length = trendline.points.length;
            var y;
            trendline.minY = trendline.points[0].y;
            trendline.maxY = trendline.points[length-1].y;
            if (!axis.setRange) {
                if (trendline.backwardForecast > 0 && axis._valueType != "category" && length > 1) {
                    axis.range.min = axis.range.min > trendline.points[0].x ? trendline.points[0].x : axis.range.min;
                    axis.visibleRange.min = axis.range.min;
                }
                if (trendline.forwardForecast > 0 && length > 1) {
                    axis.range.max = axis.range.max < trendline.points[length - 1].x ? trendline.points[length - 1].x : axis.range.max;
                    axis.visibleRange.max = axis.range.max;
                }
            }
            for (var i = 0; i < length; i++) {
                y = trendline.points[i].y;
                trendline.minY = Math.min(trendline.minY, y);
                trendline.maxY = Math.max(trendline.maxY, y);
            }
            return false;
        },

        /// Calculate Sum of x and y values
        calculateSumXAndYValue: function (trendline) {
            var points = trendline.points,
            N = trendline.xValues.length,
            type = trendline.type.toLowerCase(),
            Slope, Intercept, SX = 0, SY = 0,
            SXX = 0, SXY = 0, SYY = 0, i,
            SumProduct = 0, X = trendline.xValues, Y = trendline.yValues;

            for (i = 0; i < N; i++) {
                SX = SX + X[i];
                SY = SY + Y[i];
                SumProduct = SumProduct + (X[i] * Y[i]);
                SXY = SXY + X[i] * Y[i];
                SXX = SXX + X[i] * X[i];
                SYY = SYY + Y[i] * Y[i];
				}
            if (!BoldBIDashboard.util.isNullOrUndefined(trendline.intercept) && (type == "linear" || type == "exponential" || type == "polynomial")) { //Set intercept value externally
                switch (type) {
                    case "polynomial":
                        Slope = (((SumProduct) - (Math.log(trendline.intercept) * SX)) / SXX) * 3;
                        break;
                    case "linear":
                        Slope = ((SumProduct) - (trendline.intercept * SX)) / SXX;
                        break;
                    case "exponential":
                        Slope = ((SumProduct) - (Math.log(trendline.intercept) * SX)) / SXX;
                        break;

                }
                trendline._intercept = trendline.intercept;
            }
            else {
                Slope = ((N * SXY) - (SX * SY)) / ((N * SXX) - (SX * SX));
                if (type == "exponential" || type == "power")
                    Intercept = Math.exp((SY - (Slope * SX)) / N);
                else
                    Intercept = (SY - (Slope * SX)) / N;

                trendline._intercept = Intercept;
            }
            trendline.slope = Slope;
            return false;
        },

        ////Calculate forward backward Forecast points for dateTime axis
        _increaseDateTimeInterval: function (date, interval, intervalType) {
        var result = new Date(date);
        if (intervalType.toLowerCase() == "days") {
            result.setDate(date.getDate() + interval);
        } else if (intervalType.toLowerCase() == "hours") {
            result.setHours(date.getHours() + interval);
        } else if (intervalType.toLowerCase() == "milliseconds") {
            result.setMilliseconds(date.getMilliseconds() + interval);
        } else if (intervalType.toLowerCase() == "seconds") {
            result.setSeconds(date.getSeconds() + interval);
        } else if (intervalType.toLowerCase() == "minutes") {
            result.setMinutes(date.getMinutes() + interval);
        } else if (intervalType.toLowerCase() == "months") {
            result.setMonth(date.getMonth() + interval);
        } else if (intervalType.toLowerCase() == "years") {
            result.setYear(date.getFullYear() + interval);
        }
        return result;
        }

    },

    BoldBIDashboard.ejLinear = ejExtendClass(BoldBIDashboard.EjTrendLineRenderer);
    BoldBIDashboard.trendlineTypes.linear = BoldBIDashboard.ejLinear;

    BoldBIDashboard.Exponential = ejExtendClass(BoldBIDashboard.EjTrendLineRenderer, {

        updateExponentialTrendSource: function (points, trendline) {
            var len = points.length, yVal;
            trendline.xPoints = [];
            trendline.xValues = [];
            trendline.yValues = [];
            for (var i = 0; i < len; i++) {
                if (!points[i].isEmpty) {
                    trendline.xPoints.push(points[i].xValue);
                    trendline.xValues.push(i + 1);
					yVal = points[i].y ? Math.log(points[i].y) : 0;
                    trendline.yValues.push(yVal);
                }
            }
            this.calculateSumXAndYValue(trendline);
            return false;
        },
        calculateExponentialTrendline: function (series, trendline, axis) {
            var count = trendline.xValues.length;
            var x1, x2, x3;
            var X1, X2, X3;
            
            var midPoint = Math.round((count / 2));
            trendline.points = [];
            
            if (count > 1) {
                if (axis._valueType == "datetime") {
                    x1 = this._increaseDateTimeInterval(trendline.xPoints[0], -trendline.backwardForecast, axis._intervalType);
                    X1 = x1.getTime();
                    x2 = (trendline.xPoints[midPoint - 1]);
                    X2 = x2.getTime();
                    x3 = this._increaseDateTimeInterval(trendline.xPoints[count - 1], trendline.forwardForecast, axis._intervalType);
                    X3 = x3.getTime();
                } else {
                    x1 = X1 = (trendline.xPoints[0] - trendline.backwardForecast);
                    x2 = X2 = (trendline.xPoints[midPoint-1]);
                    x3 = X3 =(trendline.xPoints[count - 1] + trendline.forwardForecast);
                }

                //trendline exponential segment  (Intercept * Math.Exp(Slope * xValue));
                var y1 = (trendline._intercept * Math.exp((trendline.slope) * (1 - ((count - 1) * (trendline.backwardForecast) / (series.maxX - series.minX)))));
                var y2 = (trendline._intercept * Math.exp((trendline.slope) * (midPoint)));
                var y3 = (trendline._intercept * Math.exp((trendline.slope) * (count + ((count - 1) * (trendline.forwardForecast) / (series.maxX - series.minX)))));
                trendline.points.push({ x: x1, xValue: X1, y: y1, YValues: [], visible: true });
                trendline.points.push({ x: x2, xValue: X2, y: y2, YValues: [], visible: true });
                trendline.points.push({ x: x3, xValue: X3, y: y3, YValues: [], visible: true });

                trendline.points[0].YValues[0] = trendline.points[0].y;
                trendline.points[1].YValues[0] = trendline.points[1].y;
                trendline.points[2].YValues[0] = trendline.points[2].y;
            }
            return false;
        }
    });
    BoldBIDashboard.trendlineTypes.exponential = BoldBIDashboard.Exponential;

    BoldBIDashboard.Logarithmic = ejExtendClass(BoldBIDashboard.EjTrendLineRenderer, {

        updateLogarithmicTrendSource: function (points, trendline) {
            var len = points.length;
            trendline.xPoints = [];
            trendline.xValues = [];
            trendline.yValues = [];
            for (var i = 0; i < len; i++) {
                if (!points[i].isEmpty) {
                    trendline.xPoints.push(points[i].xValue);
                    trendline.xValues.push(Math.log(i + 1));
                    trendline.yValues.push(points[i].y);
                }
            }
            this.calculateSumXAndYValue(trendline);
            return false;
        },
        calculateLogarithmicTrendline: function (series, trendline, axis) {
            var count = trendline.xValues.length;
            var x1, x2, x3;
            var X1, X2, X3;
            var midPoint = Math.round((count / 2));
            trendline.points = [];

            if (count > 1) {
                if (axis._valueType == "datetime") {
                    x1 = this._increaseDateTimeInterval(trendline.xPoints[0], -trendline.backwardForecast, axis._intervalType);
                    X1 = x1.getTime();
                    x2 = (trendline.xPoints[midPoint - 1]);
                    X2 = x2.getTime();
                    x3 = this._increaseDateTimeInterval(trendline.xPoints[count - 1], trendline.forwardForecast, axis._intervalType);
                    X3 = x3.getTime();
                } else {
                    x1 = X1 = (trendline.xPoints[0] - trendline.backwardForecast);
                    x2 = X2 = (trendline.xPoints[midPoint-1]);
                    x3 = X3 = (trendline.xPoints[count - 1] + trendline.forwardForecast);
                }

                //trendline logarithmic segment  Intercept + Slope * Math.Log(xValue);
                var y1 = (trendline._intercept + (trendline.slope * (isFinite(Math.log(x1)) ? Math.log(x1) : x1)));
                var y2 = (trendline._intercept + (trendline.slope * (isFinite(Math.log(x2))? Math.log(x2) : x2)));
                var y3 = (trendline._intercept + (trendline.slope * (isFinite(Math.log(x3))? Math.log(x3) : x3)));
                trendline.points.push({ x: x1, xValue: X1, y: y1, YValues: [], visible: true });
                trendline.points.push({ x: x2, xValue: X2, y: y2, YValues: [], visible: true });
                trendline.points.push({ x: x3, xValue: X3, y: y3, YValues: [], visible: true });

                trendline.points[0].YValues[0] = trendline.points[0].y;
                trendline.points[1].YValues[0] = trendline.points[1].y;
                trendline.points[2].YValues[0] = trendline.points[2].y;
            }
            return false;
        }
    });
    BoldBIDashboard.trendlineTypes.logarithmic = BoldBIDashboard.Logarithmic;

    BoldBIDashboard.Power = ejExtendClass(BoldBIDashboard.EjTrendLineRenderer, {

        updatePowerTrendSource: function (points, trendline) {
            var len = points.length, yVal;
            trendline.xPoints = [];
            trendline.xValues = [];
            trendline.yValues = [];
            for (var i = 0; i < len; i++) {
                if (!points[i].isEmpty) {
                    trendline.xPoints.push(points[i].xValue);
                    trendline.xValues.push(Math.log(i + 1));
					yVal = points[i].y ? Math.log(points[i].y) : 0;
                    trendline.yValues.push(yVal);
                }
            }
            this.calculateSumXAndYValue(trendline);
            return false;
        },
        calculatePowerTrendline: function (series, trendline, axis) {
            var count = trendline.xValues.length;
            var x1, x2, x3;
            var X1, X2, X3;
            var midPoint = Math.round((count / 2));
            trendline.points = [];

            if (count > 1) {
                if (axis._valueType == "datetime") {
                    x1 = this._increaseDateTimeInterval(trendline.xPoints[0], -trendline.backwardForecast, axis._intervalType);
                    X1 = x1.getTime();
                    x2 = (trendline.xPoints[midPoint - 1]);
                    X2 = x2.getTime();
                    x3 = this._increaseDateTimeInterval(trendline.xPoints[count - 1], trendline.forwardForecast, axis._intervalType);
                    X3 = x3.getTime();
                } else {
                    x1 = X1 = (trendline.xPoints[0] - trendline.backwardForecast);
                    x2 = X2 = (trendline.xPoints[midPoint - 1]);
                    x3 = X3 = (trendline.xPoints[count - 1] + trendline.forwardForecast);
                }

                //trendline power segment  (Intercept * Math.Pow(xValue, Slope))
                var y1 = (trendline._intercept * Math.pow(1, trendline.slope)) - (1 - ((count - 1) * (trendline.backwardForecast) / (series.maxX - series.minX)));
                var y2 = (trendline._intercept * Math.pow(midPoint, trendline.slope));
                var y3 = (trendline._intercept * Math.pow((count + ((count - 1) * (trendline.forwardForecast) / (series.maxX - series.minX))), trendline.slope));
                trendline.points.push({ x: x1, xValue: X1, y: y1, YValues: [], visible: true });
                trendline.points.push({ x: x2, xValue: X2, y: y2, YValues: [], visible: true });
                trendline.points.push({ x: x3, xValue: X3, y: y3, YValues: [], visible: true });

                trendline.points[0].YValues[0] = trendline.points[0].y;
                trendline.points[1].YValues[0] = trendline.points[1].y;
                trendline.points[2].YValues[0] = trendline.points[2].y;
            }
            return false;
        }
    });
    BoldBIDashboard.trendlineTypes.power = BoldBIDashboard.Power;

    BoldBIDashboard.Polynomial = ejExtendClass(BoldBIDashboard.EjTrendLineRenderer, {

        //// Calculate Polynomial Trendline with order
        calculatePolynomialTrendline: function (series, trendline, axis) {
            var power = trendline.polynomialOrder;

            // Calculate sum of y datapoints 1 X power matrix
            trendline.polynomialSlopes = new Array(power + 1);
            var xLength = trendline.xValues.length;
            for (var index1 = 0; index1 < xLength; index1++)
            {
                var num2 = trendline.xValues[index1];
                var yval = trendline.yValues[index1];
                
                for (var index2 = 0; index2 <= power; ++index2) {
                    if (!trendline.polynomialSlopes[index2]) trendline.polynomialSlopes[index2] = 0;
                    trendline.polynomialSlopes[index2] += Math.pow(num2, index2) * yval;
                }
            }

            // Calculate sum matrix of x datapoints
            var numArray = new Array(1 + 2 * power);
            var matrixOfA = new Array(power + 1);
            for (var i = 0; i < (power + 1); i++)
                matrixOfA[i] = new Array(3);
            var num1 = 0;
            for (var index1 = 0; index1 < xLength; ++index1) {
                var num2 = 1.0;
                var d = trendline.xValues[index1];
                for (var index2 = 0; index2 < numArray.length; ++index2) {
                    if (!numArray[index2]) numArray[index2] = 0;
                    numArray[index2] += num2;
                    num2 *= d;
                    ++num1;
                }   
            }

            for (var index1 = 0; index1 <= power; ++index1) {
                for (var index2 = 0; index2 <= power; ++index2)
                    matrixOfA[index1][index2] = numArray[index1 + index2];
            }

            //Calculation Gauss jordan eliminiation value of a and b matrix
            if (!this.gaussJordanEliminiation(matrixOfA, trendline.polynomialSlopes))
                trendline.polynomialSlopes = null;

            //Create segments methods
            this.createPolynomialSegments(series, axis, trendline);
            return false;
        },
        createPolynomialSegments: function (series, axis, trendline) {
            var polynomialSlopes = trendline.polynomialSlopes;
            if (polynomialSlopes != null) {
                var count = trendline.xValues.length;
                var midPoint = Math.round((count / 2));
                var x1 = 1;
                var X;
                var length = polynomialSlopes.length;
                trendline.points = [];
                for (var i = 1; i <= length; i++) {                   
                    var x, y;
                    if (i == 1) {
                        if (axis._valueType == "datetime") {
                            x = this._increaseDateTimeInterval(trendline.xPoints[0], -trendline.backwardForecast, axis._intervalType);
                            X = x.getTime();
                        }
                        else
                            x = X = (trendline.xPoints[0] - trendline.backwardForecast);
                        var y = this.getPolynomialYValue(polynomialSlopes, (1 - ((count - 1) * (trendline.backwardForecast) / (series.maxX - series.minX))));
                    }
                    else if (i == polynomialSlopes.length) {
                        if (axis._valueType == "datetime") {
                            x = this._increaseDateTimeInterval(trendline.xPoints[count - 1], trendline.forwardForecast, axis._intervalType);
                            X = x.getTime();
                        }
                        else
                            x = X = (trendline.xPoints[count - 1] + trendline.forwardForecast);

                        var y = this.getPolynomialYValue(polynomialSlopes, (count + ((count - 1) * (trendline.forwardForecast) / (series.maxX - series.minX))));
                    } else {
                        x1 += (count + trendline.forwardForecast) / polynomialSlopes.length;
                        if (axis._valueType == "category") {
                            x = X = trendline.xPoints[0] + (x1 - 1);

                        }
                        else {
                            x = X = trendline.xPoints[parseInt(x1) - 1];
                            if (axis._valueType == "datetime" && count > x1)
                                X = x.getTime();
                        }                        
                        var y = this.getPolynomialYValue(polynomialSlopes, x1);
                    }
                    if (i == 1 || i == polynomialSlopes.length || axis._valueType == "category" || count > x1) {
                        trendline.points.push({ x: x, xValue: X, y: y, YValues: [], visible: true });
                        trendline.points[trendline.points.length - 1].YValues[0] = trendline.points[trendline.points.length - 1].y;
                    }
                }
            }
            return false;
        },

        getPolynomialYValue: function(slopes, x){
            var sum=0;
            for (var i = 0; i < slopes.length; i++) {
                sum += slopes[i] * Math.pow(x, i);
            }
            return sum;
        },        

        gaussJordanEliminiation: function (matrixOfA, polynomialSlopes) {
            var length = matrixOfA.length;
            var numArray1 = new Array(length);
            var numArray2 = new Array(length);
            var numArray3 = new Array(length);
            for (var index = 0; index < length; ++index)
                numArray3[index] = 0;
            for (var index1 = 0; index1 < length; ++index1)
            {
                var num1 = 0.0;
                var index2 = 0;
                var index3 = 0;
                for (var index4 = 0; index4 < length; ++index4)
                {
                    if (numArray3[index4] != 1)
                    {
                        for (var index5 = 0; index5 < length; ++index5)
                        {
                            if (numArray3[index5] == 0 && Math.abs(matrixOfA[index4][index5]) >= num1)
                            {
                                num1 = Math.abs(matrixOfA[index4][index5]);
                                index2 = index4;
                                index3 = index5;
                            }
                        }
                    }
                }
                ++numArray3[index3];
                if (index2 != index3)
                {
                    for (var index4 = 0; index4 < length; ++index4)
                    {
                        var num2 = matrixOfA[index2, index4];
                        matrixOfA[index2][index4] = matrixOfA[index3][index4];
                        matrixOfA[index3][index4] = num2;
                    }
                    var num3 = polynomialSlopes[index2];
                    polynomialSlopes[index2] = polynomialSlopes[index3];
                    polynomialSlopes[index3] = num3;
                }
                numArray2[index1] = index2;
                numArray1[index1] = index3;
                if (matrixOfA[index3][index3] == 0.0)
                    return false;
                var num4 = 1.0 / matrixOfA[index3][index3];
                matrixOfA[index3][index3] = 1.0;
               
                for (var index4 = 0; index4 < length; ++index4)
                    matrixOfA[index3][index4] *= num4;
                
                polynomialSlopes[index3] *= num4;
                
                for (var index4 = 0; index4 < length; ++index4)
                {
                    if (index4 != index3)
                    {
                        var num2 = matrixOfA[index4][index3];
                        matrixOfA[index4][index3] = 0.0;
                        for (var index5 = 0; index5 < length; ++index5)
                            matrixOfA[index4][index5] -= matrixOfA[index3][index5] * num2;
                        polynomialSlopes[index4] -= polynomialSlopes[index3] * num2;
                    }
                }
            }
            for (var index1 = length - 1; index1 >= 0; --index1)
            {
                if (numArray2[index1] != numArray1[index1])
                {
                    for (var index2 = 0; index2 < length; ++index2)
                    {
                        var num = matrixOfA[index2, numArray2[index1]];
                        matrixOfA[index2][numArray2[index1]] = matrixOfA[index2][numArray1[index1]];
                        matrixOfA[index2][numArray1[index1]] = num;
                    }
                }
            }
            return true;
        }
    });
    BoldBIDashboard.trendlineTypes.polynomial = BoldBIDashboard.Polynomial;

    BoldBIDashboard.MovingAverage = ejExtendClass(BoldBIDashboard.EjTrendLineRenderer, {

        updateMovingAverageTrendSource: function (points, trendline) {
            var len = points.length, i;
            trendline.xPoints = [];
            trendline.xValues = [];
            trendline.yValues = [];
            for (i = 0; i < len; i++) {
                if (!points[i].isEmpty) {
                    trendline.xPoints.push(points[i].xValue);
                    trendline.xValues.push(i + 1);
                    trendline.yValues.push(points[i].y);
                }
            }
            return false;
        },
        calculateMovingAverageTrendline: function (series, trendline, axis) {
            var pointsLength = trendline.xPoints.length,
            period = trendline.period >= pointsLength ? pointsLength - 1 : trendline.period,
			x1, i, j, yVal, count, nullCount, xVal, length;
            period = period < 2 ? 2 : period;
            trendline.points = [];

            for (i = 0; i < pointsLength-1; i++) {
                yVal = count = nullCount = 0;
                for (j = i; count < period ; j++) {
                    count++;
                    if (BoldBIDashboard.util.isNullOrUndefined(trendline.yValues[j])) nullCount++;
                    yVal += trendline.yValues[j];
                }
                yVal = period - nullCount <= 0 ? null : yVal / (period - nullCount);
                if (!BoldBIDashboard.util.isNullOrUndefined(yVal) && !isNaN(yVal)) {
				    xVal = trendline.xPoints[period - 1 + i];
                    trendline.points.push({ 
					        x: xVal, xValue: xVal, 
					        y: yVal, YValues: [], visible: true 
					});
                    length = trendline.points.length;
                    trendline.points[length - 1].YValues[0] = trendline.points[length - 1].y;
                }
            }
        }
    });
    BoldBIDashboard.trendlineTypes.movingaverage = BoldBIDashboard.MovingAverage;

    BoldBIDashboard.EjIndicatorRender.prototype = {

        draw: function (indicator, sender) {

            this.chartObj = sender;
            var translate = null;

            if (this.chartObj.model.AreaType == "cartesianaxes") {
                var transX = indicator.xAxis.x;
                var transY = indicator.yAxis.y;
                translate = 'translate(' + transX + ',' + transY + ')';
            }

            var indicatorIndex = bbdesigner$.inArray(indicator, this.chartObj.model.indicators);
            var indicatorOptions = { 'id': this.chartObj.svgObject.id + '_indicatorGroup' + '_' + indicatorIndex, 'transform': translate };
            this.gIndicatorGroupEle = this.chartObj.svgRenderer.createGroup(indicatorOptions);

            
            if (indicator._points.length > 0) {
                for (var i = 0; i < indicator.segment.length; i++) {
                    var segment = indicator.segment[i];
                    var style = { fill: segment.fill, width: segment.width, opacity: indicator.opacity };
                        segment.isIndicator = true;
                        segment.xAxis = indicator.xAxis;
                        segment.yAxis = indicator.yAxis;
                         if (segment.type == "line")
                            this.calculateDirection(segment, style, indicatorIndex);
                        else
                            this.drawColumn(segment, style, indicator);
                    }
                }

        },

        _drawLinePath: function (indicator, style, lDirection, indicatorIndex) {
            
          
          
           
            if (lDirection != "") {
                var options = {
				    'name': 'line',
                    'id': this.chartObj.svgObject.id + "_" + indicatorIndex + "_" + indicator.name,
                    'fill': 'none',
                    'stroke-dasharray': indicator.dashArray,
                    'stroke-width': style.width,
                    'stroke': style.fill,
                    'stroke-linecap': indicator.lineCap,
                    'stroke-linejoin': indicator.lineJoin,
                    'opacity': style.opacity,
                    'd': lDirection
                };

                this.chartObj.svgRenderer.drawPath(options, this.gIndicatorGroupEle);
            }

            this.chartObj.svgRenderer.append(this.gIndicatorGroupEle, this.chartObj.gIndicatorEle);
        },

        calculateDirection: function (currentseries, style, indicatorIndex) {
		    var canvasX = 0;
            var canvasY = 0;
		    var point;
            if (this.chartObj.model.enableCanvasRendering) {
                canvasX = currentseries.xAxis.x;
                canvasY = currentseries.yAxis.y;
            }
            currentseries.points = BoldBIDashboard.DataManager(currentseries.points, BoldBIDashboard.Query().sortBy("xValue")).executeLocal();

            var visiblePoints = BoldBIDashboard.EjSeriesRender.prototype._isVisiblePoints(currentseries);
            var lDirection;
            var sb = BoldBIDashboard.EjSvgRender.utils._getStringBuilder();

            // Dashed Line issue in Indicator is fixed.
            var firstPoint = false;
            var secondPoint;
            
            for (var i = 0; i < visiblePoints.length; i++) {
                secondPoint = visiblePoints[i];
                if (secondPoint.visible) {
                     point = BoldBIDashboard.EjSvgRender.utils._getPoint(secondPoint, currentseries);
                    if (firstPoint) {                                             
                        sb.append("L" + " " + (point.X + canvasX) + " " + ((point.Y + canvasY)) + " ");                    
                        }
                    else {                       
                        sb.append("M" + " " + (point.X + canvasX) + " " + ((point.Y + canvasY)) + " ");
                         firstPoint = true;
                       }         

                }
                else {
                    firstPoint = false;
                }

            }

            lDirection = sb.toString();

            this._drawLinePath(currentseries, style, lDirection, indicatorIndex);
        },

        drawColumn: function (option, style, indicator) {
            var series = option;
            var seriesIndex = bbdesigner$.inArray(indicator, this.chartObj.model.indicators);
            series.index = seriesIndex;
            var origin = Math.max(option.yAxis.visibleRange.min, 0);

            var sidebysideinfo = { Start: -0.35, End: 0.35 };
            var visiblePoints = BoldBIDashboard.EjSeriesRender.prototype._isVisiblePoints(series);

            var cSer = this;
			 var chart = cSer.chartObj;
            for (var i = 0; i < visiblePoints.length; i++) {
                var pointIndex = i;
                var point = visiblePoints[i];

                var y1 = point.YValues[0];
                var y2 = origin;
                if (point.visible) {
                    //calculate sides
                    var data = BoldBIDashboard.EjSeriesRender.prototype.calculateSides(point, sidebysideinfo);
                    var x1 = data.x1;
                    var x2 = data.x2;
                    var rect = BoldBIDashboard.EjSeriesRender.prototype.getRectangle(x1, y1, x2, y2, series, chart);

                    if (rect.X < 0) {
                        rect.Width = rect.Width + rect.X;
                        rect.X = 0;
                    }

                    rect.Width = ((rect.X + rect.Width) > cSer.chartObj.model.m_AreaBounds.Width) ? cSer.chartObj.model.m_AreaBounds.Width - rect.X : rect.Width;
                    //drawing part
                    var xr = Math.min(0, rect.Width);
                    var yr = Math.min(0, rect.Height);
                    if (rect.Width < 0.0001)// condition checked for IE width issue
                        rect.Width=0.0001;
                    var bounds;
                    if ((xr == 0 || yr == 0) && rect.Width > 0) {
                        options = {
                            'id': this.chartObj.svgObject.id + "_" + seriesIndex + "_" + series.name,
                            'x': rect.X + cSer.chartObj.canvasX,
                            'y': rect.Y + cSer.chartObj.canvasY,
                            'width': rect.Width,
                            'height': rect.Height,
                            'fill': (!visiblePoints[i].fill ) ? style.fill : visiblePoints[i].fill,
                            'stroke-width': series.border.width,
                            'plot': y1 < 0 ? "negative" : "positive",
                            'opacity': series.histogram.opacity,
                            'stroke': (!visiblePoints[i].fill ) ? series.border.color : visiblePoints[i].fill
                        };

                        this.chartObj.svgRenderer.drawRect(options, this.gIndicatorGroupEle);

                        var svgXy = BoldBIDashboard.EjSvgRender.utils._getSvgXY(rect.X, (rect.Y), series, cSer.chartObj);
                        bounds = { X: svgXy.X, Y: svgXy.Y, Width: rect.Width, Height: rect.Height };

                        this._addRegion(cSer.chartObj, bounds, series, point, pointIndex);
                    }
                }
            }

            this.chartObj.svgRenderer.append(this.gIndicatorGroupEle, this.chartObj.gIndicatorEle);
        },
        _addRegion: function (chart, bounds, series, point, pointIndex) {
            var type = series.type;
            if (series.index >= 0) {
                var regionItem = { SeriesIndex: series.index, Region: { PointIndex: pointIndex, Bounds: bounds }, type: type, isIndicator: true };
                chart.model.chartRegions.push(regionItem);
            }
        },

        calculateSegment: function (indicator, sender) {
            this.chartObj = sender;
              indicator.segment = [];
              indicator.xRange = {};
              indicator.yRange = {};
			  indicator.period = parseInt(indicator.period);   // to convert float value to integer
              if (indicator.period < indicator._points.length && indicator.period > 0) {
              //Upperband 
              var upperSeries = bbdesigner$.extend(true, {}, indicator);
              upperSeries.name = "upperseries";
              upperSeries.fill = indicator.upperLine.fill;
              upperSeries.width = indicator.upperLine.width;
              upperSeries.type = "line";

              for (var k = 0; k < indicator._points.length; k++) {
                  indicator._points[k].YValues.length = 1;
                  indicator._points[k].YValues[0] = indicator._points[k].y = 70;
              }
              
              upperSeries.points = bbdesigner$.extend(true, [], indicator._points);
              var xValues = sender._getXValues(upperSeries.points);
              var yValues = sender._getYValues(upperSeries.points);
              
              indicator.xRange.min = Math.min.apply(Math, xValues);
              indicator.xRange.max = Math.max.apply(Math, xValues);
              indicator.yRange.min = Math.min.apply(Math, yValues);
              indicator.yRange.max = Math.max.apply(Math, yValues);

              indicator.segment.push(upperSeries);

              //Lowerband
              var lowerSeries = bbdesigner$.extend(true, {}, indicator);
              lowerSeries.name = "lowerSeries";
              lowerSeries.width = indicator.lowerLine.width;
              lowerSeries.fill = indicator.lowerLine.fill;
              lowerSeries.type = "line";
           

              for (var n = 0; n < indicator._points.length; n++) {
                  indicator._points[n].YValues[0] = indicator._points[n].y = 30;
              }

               lowerSeries.points = bbdesigner$.extend(true, [], indicator._points);

              yValues = sender._getYValues(lowerSeries.points);

              indicator.yRange.min = Math.min(Math.min.apply(Math, yValues), indicator.yRange.min);
              indicator.yRange.max = Math.max(Math.max.apply(Math, yValues), indicator.yRange.max);

              indicator.segment.push(lowerSeries);
              
              // signalLine
              var trendSeries = bbdesigner$.extend(true, {}, indicator); 
              trendSeries.name = "signalSeries";
              trendSeries.width = indicator.width;
              trendSeries.fill = indicator.fill;
              trendSeries.type = "line";
              
              var c = 0, c1 = 0;
              var pmf = 0;
              var nmf = 0;
              var len = indicator.period;
              c1 = indicator._points[0].close;

              for (var i = 1; i <=len; ++i) {
                  c = indicator._points[i].close;
                  if (c > c1)
                      pmf += c - c1;
                  else if (c < c1)
                      nmf += c1 - c;
                  c1 = c;
                  indicator._points[i-1].YValues[0] = indicator._points[i-1].y = null;
              }
              pmf = pmf / len;
              nmf = nmf / len;
              
              indicator._points[len].YValues[0] = indicator._points[len].y = 100 - 100 / (1 + pmf / nmf);

              for (var j = len + 1; j < indicator._points.length; j++) {
                  c = indicator._points[j].close;
                  if (c > c1) {
                      pmf = (pmf * (len - 1) + (c - c1)) / len;
                      nmf = (nmf * (len - 1)) / len;
                  }
                  else if (c < c1) {
                      nmf = (nmf * (len - 1) + (c1 - c)) / len;
                      pmf = (pmf * (len - 1)) / len;
                  }
                  c1 = c;
                  indicator._points[j].YValues[0] = indicator._points[j].y = 100 - (100 / (1 + pmf / nmf));
              }
              trendSeries.points = bbdesigner$.extend(true, [], indicator._points);
              var trendPoints = [];
              for (var i = len, j = 0; i < trendSeries.points.length; i++, j++){
                  trendPoints[j] = trendSeries.points[i].y;
				  }

              indicator.yRange.min = Math.min(Math.min.apply(Math, trendPoints), indicator.yRange.min);
              indicator.yRange.max = Math.max(Math.max.apply(Math, trendPoints), indicator.yRange.max);

              indicator.segment.push(trendSeries);
              this.calculateIndicatorRange(sender, indicator);
           }
        },

        calculateIndicatorRange: function(sender, indicator){
            //Indicator X-Axis Calculation
            if (sender.model.indicatorRange[indicator.xAxisName] == undefined) {
                sender.model.indicatorRange[indicator.xAxisName] = {};
                sender.model.indicatorRange[indicator.xAxisName] = { min: indicator.xRange.min, max: indicator.xRange.max };
            } else {
                if (sender.model.indicatorRange[indicator.xAxisName].min > indicator.xRange.min)
                    sender.model.indicatorRange[indicator.xAxisName].min = indicator.xRange.min;
                if (sender.model.indicatorRange[indicator.xAxisName].max < indicator.xRange.max)
                    sender.model.indicatorRange[indicator.xAxisName].max = indicator.xRange.max;
            }
            //Indicator Y-Axis Calculation
            if (sender.model.indicatorRange[indicator.yAxisName] === undefined) {
                sender.model.indicatorRange[indicator.yAxisName] = {};
                sender.model.indicatorRange[indicator.yAxisName] = { min: indicator.yRange.min, max: indicator.yRange.max };
            } else {
                if (sender.model.indicatorRange[indicator.yAxisName].min > indicator.yRange.min)
                    sender.model.indicatorRange[indicator.yAxisName].min = indicator.yRange.min;
                if (sender.model.indicatorRange[indicator.yAxisName].max < indicator.yRange.max)
                    sender.model.indicatorRange[indicator.yAxisName].max = indicator.yRange.max;
            }
        }
    },
    BoldBIDashboard.ejRSI = ejExtendClass(BoldBIDashboard.EjIndicatorRender);

    BoldBIDashboard.indicatorTypes.rsi = BoldBIDashboard.ejRSI;
	BoldBIDashboard.ejMACD = ejExtendClass(BoldBIDashboard.EjIndicatorRender, {


        calculateSegment: function (indicator, sender) {
            this.chartObj = sender;
            indicator.segment = [];
            indicator.xRange = {};
            indicator.yRange = {};

            var pointsLength = indicator._points.length;
            var longPeriod = indicator.longPeriod;
            var shortPeriod = indicator.shortPeriod;
            var trigger = indicator.trigger;
            var diff = longPeriod-shortPeriod;
            var shortEMA = [];
            var longEMA = [];
            var macdPoints = [];
            var signalEMA = [];
            var histogramPoints = [];
            var length = longPeriod + trigger;
            if (length <= indicator._points.length && ((length-2) >= 0) && (shortPeriod <= longPeriod) && (shortPeriod > 0)) {
                shortEMA = this.calculateEMA(indicator._points, shortPeriod, true);
                longEMA = this.calculateEMA(indicator._points, longPeriod, true);

                //Calculte MACD Line points: MACD Line: (shortPeriod EMA - longPeriod EMA)  
                for (i = 0; i < longEMA.length; i++)
                    macdPoints.push((shortEMA[i + diff] - longEMA[i]));

                //MACD Line 
                var macdSeries = bbdesigner$.extend(true, {}, indicator);
                macdSeries.name = "macdSeries";
                macdSeries.fill = indicator.macdLine.fill;
                macdSeries.width = indicator.macdLine.width;
                macdSeries.type = "line";
                macdSeries.xAxis = indicator.xAxis;
                macdSeries.yAxis = indicator.yAxis;

                var l = longPeriod - 1;
                for (var t = 0, i = 0; t < pointsLength; t++) {
                    if (t < l)
                        indicator._points[t].YValues[0] = indicator._points[t].y = null;
                    else {
                        indicator._points[t].YValues[0] = indicator._points[t].y = macdPoints[i];
                        i += 1;
                    }
                }
                macdSeries.points = bbdesigner$.extend(true, [], indicator._points);
                //////////////////////////////////////////////

                //Signal Line: Trigger value(9-day default) EMA of MACD Line 
                signalEMA = this.calculateEMA(macdPoints, trigger, false);
                var trendSeries = bbdesigner$.extend(true, {}, indicator);
                trendSeries.name = "signalSeries";
                trendSeries.fill = indicator.fill;
                trendSeries.width = indicator.width;
                trendSeries.type = "line";
                trendSeries.xAxis = indicator.xAxis;
                trendSeries.yAxis = indicator.yAxis;

                var l = longPeriod + trigger - 2;
                for (var t = 0, i = 0; t < pointsLength; t++) {
                    if (t < l)
                        indicator._points[t].YValues[0] = indicator._points[t].y = null;
                    else {
                        indicator._points[t].YValues[0] = indicator._points[t].y = signalEMA[i];
                        i += 1;
                    }
                }
                trendSeries.points = bbdesigner$.extend(true, [], indicator._points);
                /////////////////////////////////////////

                //MACD Histogram: MACD Line - Signal Line
                var histogramSeries = bbdesigner$.extend(true, {}, indicator);
                histogramSeries.border = {};
                histogramSeries.name = "histogramSeries";
                histogramSeries.fill = indicator.histogram.fill;
                histogramSeries.opacity = indicator.histogram.opacity;
                histogramSeries.fill = indicator.histogram.fill;
                histogramSeries.border = indicator.histogram.border;
                histogramSeries.type = "column";
                histogramSeries.xAxis = indicator.xAxis;
                histogramSeries.yAxis = indicator.yAxis;

                for (var j = 0, k = l; k < pointsLength; j++, k++)
                    histogramPoints.push((macdPoints[j + (trigger - 1)]) - (signalEMA[j]));
                for (var j = 0, k = l; k < pointsLength; j++, k++) {
                    indicator._points[k].YValues[0] = indicator._points[k].y = histogramPoints[j];
                }
                histogramSeries.points = bbdesigner$.extend(true, [], indicator._points);
                xValues = sender._getXValues(macdSeries.points);
                indicator.xRange.min = Math.min.apply(Math, xValues);
                indicator.xRange.max = Math.max.apply(Math, xValues);

                switch (indicator.macdType) {
                    case "line":
                        {
                            //Push MACD Line
                            indicator.yRange.min = Math.min.apply(Math, macdPoints);
                            indicator.yRange.max = Math.max.apply(Math, macdPoints);
                            indicator.segment.push(macdSeries);

                            //Push Signal Line
                            var min = Math.min.apply(Math, signalEMA), max = Math.max.apply(Math, signalEMA);
                            indicator.yRange.min = indicator.yRange.min < min ? indicator.yRange.min : min;
                            indicator.yRange.max = indicator.yRange.max > max ? indicator.yRange.max : max;
                            indicator.segment.push(trendSeries);
                        }
                        break;
                    case "histogram":
                        {
                            //Push histogram Series
                            var min1 = Math.min.apply(Math, histogramPoints), max1 = Math.max.apply(Math, histogramPoints);
                            indicator.yRange.min = indicator.yRange.min < min1 ? indicator.yRange.min : min1;
                            indicator.yRange.max = indicator.yRange.max > max1 ? indicator.yRange.max : max1;
                            indicator.segment.push(histogramSeries);
                        }
                        break;
                    case "both":
                        {
                            //Push histogram Series
                            var min1 = Math.min.apply(Math, histogramPoints), max1 = Math.max.apply(Math, histogramPoints);
                            indicator.yRange.min = indicator.yRange.min < min1 ? indicator.yRange.min : min1;
                            indicator.yRange.max = indicator.yRange.max > max1 ? indicator.yRange.max : max1;
                            indicator.segment.push(histogramSeries);

                            //Push MACD Line 
                            indicator.yRange.min = Math.min.apply(Math, macdPoints);
                            indicator.yRange.max = Math.max.apply(Math, macdPoints);
                            indicator.segment.push(macdSeries);

                            //Push Signal Line
                            var min = Math.min.apply(Math, signalEMA), max = Math.max.apply(Math, signalEMA);
                            indicator.yRange.min = indicator.yRange.min < min ? indicator.yRange.min : min;
                            indicator.yRange.max = indicator.yRange.max > max ? indicator.yRange.max : max;
                            indicator.segment.push(trendSeries);
                        }
                        break;
                }
                this.calculateIndicatorRange(sender, indicator);
            }
        },
        calculateEMA: function (points, period, flag) {
            var sma = 0;
            var initialEMA = 0;
            var pointsLength = points.length;
            var getPoints = [];
            var getEma = [];
            var emaPercent = (2 / (period + 1));
            if (flag) { // calculating EMA for Indicators Points
                for (var i = 0; i < period; i++) {
                    getPoints.push(points[i].close);
                    sma = sma + getPoints[i];
                }

                initialEMA = (sma / period);
                getEma.push(initialEMA);
                var emaAvg = initialEMA;
                for (j = period; j < pointsLength; j++) {
                    emaAvg = (points[j].close - emaAvg) * emaPercent + emaAvg;
                    getEma.push(emaAvg);
                }
            } else { //Calculating EMA for Signal Points
                for (var i = 0; i < period; i++) {
                    getPoints.push(points[i]);
                    sma = sma + getPoints[i];
                }

                initialEMA = (sma / period);
                getEma.push(initialEMA);
                var emaAvg = initialEMA;
                for (j = period; j < pointsLength; j++) {
                    emaAvg = (points[j] - emaAvg) * emaPercent + emaAvg;
                    getEma.push(emaAvg);
                }
            }
            return getEma;
        }

    });

    BoldBIDashboard.indicatorTypes.macd = BoldBIDashboard.ejMACD;
	BoldBIDashboard.ejSMA = ejExtendClass(BoldBIDashboard.EjIndicatorRender, {

      
        calculateSegment: function (indicator, sender) {
            this.chartObj = sender;
            indicator.segment = [];
            indicator.xRange = {};
            indicator.yRange = {};


         
            // signalLine
            var trendSeries = bbdesigner$.extend(true, {}, indicator);
            trendSeries.name = "trendSeries";
            trendSeries.width = indicator.width;
            trendSeries.fill = indicator.fill;
            trendSeries.type = "line";

			//variable declaration
            var closevalues = [];
            var smavalues = [];
			var trendPoints = [];
            var sum;
            var length = indicator._points.length;
            var period = indicator.period;
			
			if (period <= 0 || length < period) return;
			
			//Push the Close values
            for (var i = 0; i < length; i++) {
               
                closevalues.push(indicator._points[i].close);

            }

            var close_length =closevalues.length;
			//calculation for SMA values
			
	     
            while (close_length >= period) {
                sum = 0;
                for (var j = 0; j < period; j++) {
                    sum = sum + closevalues[j];

                }
                sum = sum / period;
                smavalues.push(sum);
                closevalues.splice(0, 1);
                close_length = closevalues.length;
            }

	 
           //set the SMA values to Y-Axis
            for (var k = 0; k < length; k++) {
                if (k < period - 1) {
                    indicator._points[k].YValues[0] = indicator._points[k].y = null;

                }
                else {
                    indicator._points[k].YValues[0] = indicator._points[k].y =smavalues[k -(period - 1) ];
                }

            }

            
            trendSeries.points = bbdesigner$.extend(true, [], indicator._points);
            xValues = sender._getXValues(trendSeries.points);
            
            //Assign the Y-Axis values into trendPoints
            for (var i = period-1 , j = 0; i < trendSeries.points.length; i++, j++)
             {
                trendPoints[j] = trendSeries.points[i].y;
             }
                
			//X-Axis and Y-Axis range calculation
            indicator.xRange.min = Math.min.apply(Math, xValues);
            indicator.xRange.max = Math.max.apply(Math, xValues);
            indicator.yRange.min = Math.min.apply(Math, trendPoints);
            indicator.yRange.max = Math.max.apply(Math, trendPoints);
            
			//push trendSeries
            indicator.segment.push(trendSeries);
        	this.calculateIndicatorRange(sender, indicator);
            
          
        }

    });

    BoldBIDashboard.indicatorTypes.sma = BoldBIDashboard.ejSMA;
	
	 BoldBIDashboard.ejEMA = ejExtendClass(BoldBIDashboard.EjIndicatorRender, {


        calculateSegment: function (indicator, sender) {
            this.chartObj = sender;
            indicator.segment = [];
            indicator.xRange = {};
            indicator.yRange = {};



            // signalLine
            
            trendSeries = bbdesigner$.extend(true, {}, indicator);
            trendSeries.name = "trendSeries";
            trendSeries.type = "line";
            trendSeries.xAxis = indicator.xAxis;
            trendSeries.yAxis = indicator.yAxis;


            var getCloseValues = [];       
            var ema = [];
            var pointsLength = indicator._points.length;       
            var period = indicator.period;
            var sma = 0;
            if(pointsLength < period || period <=0) return ;
            // K=Smoothing Factor
            var k = (2 / (period + 1));

            //Get a close Values and push the previous Ema 
            for (var i = 0; i < period; i++) {
                getCloseValues.push(indicator._points[i].close);
                sma = sma + getCloseValues[i];            
            }
            ema.push(sma / period);

            //Find Remaining EMA by Adding smoothing factor K to the close values
            for (j = period; j < pointsLength; j++)
                  {              
                   ema.push((indicator._points[j].close - ema[j - period]) * k + ema[j - period]);                  
                   }        
            
            // Set Ema to the Indicator Points
           
            for (var t = 0; t < pointsLength; t++) {
                if (t < (period - 1)) {
                    indicator._points[t].YValues[0] = indicator._points[t].y = null;
                }
                else if (t >= (period - 1))
                {
                    indicator._points[t].YValues[0] = indicator._points[t].y = ema[t - (period - 1)];
                }
            }
             
            // Send the indicator Points for draw series.
            trendSeries.points = bbdesigner$.extend(true, [], indicator._points);
            xValues = sender._getXValues(trendSeries.points);
            var trendPoints = [];
            for (var i = period, j = 0; i < trendSeries.points.length; i++, j++)
                trendPoints[j] = trendSeries.points[i].y;

            indicator.xRange.min = Math.min.apply(Math, xValues);
            indicator.xRange.max = Math.max.apply(Math, xValues);
            indicator.yRange.min = Math.min.apply(Math, trendPoints);
            indicator.yRange.max = Math.max.apply(Math, trendPoints);

            indicator.segment.push(trendSeries);
        	this.calculateIndicatorRange(sender, indicator);
            
          
        }

    });

    BoldBIDashboard.indicatorTypes.ema = BoldBIDashboard.ejEMA;


    BoldBIDashboard.ejSTOCHASTIC = ejExtendClass(BoldBIDashboard.EjIndicatorRender, {

        calculateSegment: function (indicator, sender) {
            this.chartObj = sender;
            indicator.segment = [];
            indicator.xRange = {};
            indicator.yRange = {};
			var KPeriod = indicator.kPeriod;
            var DPeriod = indicator.dPeriod;
            var Period = indicator.period;
            if (Period < 1 || DPeriod < 1 || KPeriod < 1) return;
            if (Period > indicator._points.length || DPeriod > indicator._points.length || KPeriod > indicator._points.length) return;
			// Upper Line Calculation
            var upperSeries = bbdesigner$.extend(true, {}, indicator);
            upperSeries.name = "upperseries";
            upperSeries.type = "line";
            upperSeries.fill = indicator.upperLine.fill;
            upperSeries.width = indicator.upperLine.width;

            for (var k = 0; k < indicator._points.length; k++) {
                indicator._points[k].YValues.length = 1;
                indicator._points[k].YValues[0] = indicator._points[k].y = 80;
            }

            upperSeries.points = bbdesigner$.extend(true, [], indicator._points);
            var xValues = sender._getXValues(upperSeries.points);
            var yValues = sender._getYValues(upperSeries.points);

            indicator.xRange.min = Math.min.apply(Math, xValues);
            indicator.xRange.max = Math.max.apply(Math, xValues);
            indicator.yRange.min = Math.min.apply(Math, yValues);
            indicator.yRange.max = Math.max.apply(Math, yValues);

            indicator.segment.push(upperSeries);
            // End for Upper Line Calculation

            // Lower Line Calculation
            var lowerSeries = bbdesigner$.extend(true, {}, indicator);
            lowerSeries.name = "lowerSeries";
            lowerSeries.width = indicator.lowerLine.width;
            lowerSeries.fill = indicator.lowerLine.fill;
            lowerSeries.type = "line";


            for (var n = 0; n < indicator._points.length; n++) {
                indicator._points[n].YValues[0] = indicator._points[n].y = 20;
            }

            lowerSeries.points = bbdesigner$.extend(true, [], indicator._points);

            xValues = sender._getXValues(lowerSeries.points);
            yValues = sender._getYValues(lowerSeries.points);

            indicator.xRange.min = Math.min(Math.min.apply(Math, xValues), indicator.xRange.min);
            indicator.xRange.max = Math.max(Math.max.apply(Math, xValues), indicator.xRange.max);
            indicator.yRange.min = Math.min(Math.min.apply(Math, yValues), indicator.yRange.min);
            indicator.yRange.max = Math.max(Math.max.apply(Math, yValues), indicator.yRange.max);

            indicator.segment.push(lowerSeries);
            // End for Lower Line Calculation

            // Signal and Period Line Calculation

            var periodSeries = bbdesigner$.extend(true, {}, indicator);
            periodSeries.name = "periodSeries";
            periodSeries.width = indicator.periodLine.width;
            periodSeries.fill = indicator.periodLine.fill;
            periodSeries.type = "line";

            var HighValues = [];
            var LowValues = [];
            var CloseValues = [];
            var check = [];
            for (var i = 0; i < indicator._points.length; i++) {
                LowValues[i] = indicator._points[i].low;
                HighValues[i] = indicator._points[i].high;
                CloseValues[i] = indicator._points[i].close;
            }


            AddPoints(Period, KPeriod, indicator._points);
            check = indicator._points;
            SMA(Period, KPeriod, indicator._points);
            check = indicator._points;
            periodSeries.points = bbdesigner$.extend(true, [], indicator._points);

            xValues = sender._getXValues(periodSeries.points);
            yValues = sender._getYValues(periodSeries.points);

            indicator.xRange.min = Math.min(Math.min.apply(Math, xValues), indicator.xRange.min);
            indicator.xRange.max = Math.max(Math.max.apply(Math, xValues), indicator.xRange.max);
            indicator.yRange.min = Math.min(Math.min.apply(Math, yValues), indicator.yRange.min);
            indicator.yRange.max = Math.max(Math.max.apply(Math, yValues), indicator.yRange.max);

            indicator.segment.push(periodSeries);


            var trendSeries = bbdesigner$.extend(true, {}, indicator);
            trendSeries.name = "trendSeries";
            trendSeries.width = indicator.width;
            trendSeries.fill = indicator.fill;
            trendSeries.type = "line";

            SMA((Period+KPeriod-1), DPeriod, indicator._points);
            trendSeries.points = bbdesigner$.extend(true, [], indicator._points);

            indicator.segment.push(trendSeries);

            ///SMA Calculation(Signal Line and Period Line)

            function SMA(Period1, Period2, series) {
                if (indicator._points.length >= Period1 + Period2) {
                    SMACal(Period1, Period2, series);
                }
            }

            function SMACal(period1, period2, series) {
                var count = period1 + (period2-1);
                var temp = [];
                var values = [];
                var sum;
                for (var i = 0; i < indicator._points.length; i++) {
                    var val = check[i].y;
                    temp.push(val);
                }
                var length = temp.length;

                while (length >= count) {
                    sum = 0;
                    for (var j = period1-1; j < (period1 + period2-1); j++) {
                        sum = sum + temp[j];

                    }
                    sum = sum / period2;
                    values.push(sum.toFixed(2));
                    temp.splice(0, 1);
                    length = temp.length;
                }
                var len = count - 1;
                for (var k = 0; k < indicator._points.length; k++) {
                    if (k < len) {
                        series[k].YValues[0] = series[k].y = null;

                    }
                    else {
                        series[k].YValues[0] = series[k].y = Number((values[k - len]));
                    }

                }

            }

            // End for SMA Calculation

            // Period Line Calculation

            function AddPoints(Period1, Period2, series) {
                if (indicator._points.length > Period1) {
                    ComputeStochastics(Period1, Period2, series);
                }
            }
            function ComputeStochastics(len1, len2, series) {
                var len = len1 + len2;
                var mins = [];
                var maxs = [];
                var max;
                var min;
                var top = 0;
                var bottom = 0;
                for (var i = 0; i < len1 - 1; ++i) {
                    maxs.push(0);
                    mins.push(0);
                }

                for (var i = len1 - 1; i < indicator._points.length; ++i) {
                    min = Number.MAX_VALUE;
                    max = Number.MIN_VALUE;
                    for (var j = 0; j < len1; ++j) {
                        min = Math.min(min, LowValues[i - j]);
                        max = Math.max(max, HighValues[i - j]);
                    }
                    maxs.push(max);
                    mins.push(min);
                }

                for (var i = 0 ; i < len - 1; ++i) {
                    series[i].YValues.length = 1;
                    series[i].YValues[0] = series[i].y = null;
                }

                for (var i = len1 - 1; i < indicator._points.length; ++i) {
                    top = 0;
                    bottom = 0;
                    top += CloseValues[i] - mins[i];
                    bottom += maxs[i] - mins[i];
                    series[i].YValues.length = 1;
                    series[i].YValues[0] = series[i].y = (((top / bottom) * 100));
                }
            }

            // End for Period Line Calculation

            // Indicator Axis Range Calculation
            this.calculateIndicatorRange(sender, indicator);
        }


    });
    BoldBIDashboard.indicatorTypes.stochastic = BoldBIDashboard.ejSTOCHASTIC;
BoldBIDashboard.ejbollingerBand = ejExtendClass(BoldBIDashboard.EjIndicatorRender, {
        calculateSegment: function (indicator, sender) {
            this.chartObj = sender;
            indicator.segment = [];
            indicator.xRange = {};
            indicator.yRange = {};
            var sum = 0.0;
            var deviationSum = 0.0;
            var limit = indicator._points.length;
            var multiplier =indicator.standardDeviations;
            var movingavg =indicator.period;
            var length = Math.round(movingavg);
            var smaPoints = [];
            var deviations = [];
            var bbiPoints = [];
            //Calculating simple moving average
         if ((length < limit) && (length > 0))
{
            for (var i = 0; i < length; i++) {
                sum += indicator._points[i].close;

            }
            var sma = sum / movingavg;
            //Calculating smapoints using iteration
            for (var i = 0; i < limit; ++i) {
                if (i >= length - 1 && i < limit) {
                    if (i - movingavg >= 0) {
                        var diff = indicator._points[i].close - indicator._points[i - length].close;

                        sum = sum + diff;
                        sma = sum / (movingavg);
                        smaPoints[i] = sma;
                        deviations[i] = Math.pow(indicator._points[i].close - sma, 2);
                        deviationSum += deviations[i] - deviations[i - length];


                    }
                    else {

                        smaPoints[i] = sma;
                        deviations[i] = Math.pow(indicator._points[i].close - sma, 2);
                        deviationSum += deviations[i];
                    }


                    //calculation for standarddeviation for each period

                    var range = Math.sqrt(deviationSum / (movingavg));

                    //lower Band points for bollinger band
                    var lb = smaPoints[i] - (multiplier * range);
                    //upper Band points for bollinger band
                    var ub = smaPoints[i] + (multiplier * range);
                    //Binding the lowerband,upperband and middleband values to bollingerband array if the i value equal to period
                    if (i + 1 == length) {
                        for (var j = 0; j < length - 1; j++)
                            bbiPoints[j] = { "X": indicator._points[j].X, "mb": smaPoints[i], "lb": lb, "ub": ub, visible: true };



                    }
                    //binding the lb,ub,mb values to bollinger band array if i greather than period value.
                    bbiPoints[i] = { "X": indicator._points[i].X, "mb": smaPoints[i], "lb": lb, "ub": ub, visible: true };


                }


                else {
                    if (i < movingavg - 1) {

                        smaPoints[i] = sma;
                        deviations[i] = Math.pow(indicator._points[i].close - sma, 2);
                        deviationSum += deviations[i];
                    }


                }

            }


            var upperSeries = bbdesigner$.extend(true, {}, indicator);
            upperSeries.name = "upperseries";
            upperSeries.fill = indicator.upperLine.fill;
            upperSeries.width = indicator.upperLine.width;
            upperSeries.type = "line";

            //binding bollingerband array values to upper series and assigning null values 
            for (var k = 0; k < indicator._points.length; k++) {
                if (k >= (length - 1)) {
                    indicator._points[k].YValues.length = 1;
                    indicator._points[k].YValues[0] = indicator._points[k].y = bbiPoints[k].ub;
                }
                else {
                    indicator._points[k].YValues[0] = indicator._points[k].y = null;
                }
            }

            upperSeries.points = bbdesigner$.extend(true, [], indicator._points);
            var xValues = sender._getXValues(upperSeries.points);
            var values = [];
            //storing the y values from the period value
            for (var i = length; i < upperSeries.points.length; i++)
                values.push(upperSeries.points[i].y);
            var yValues = values;
            indicator.xRange.min = Math.min.apply(Math, xValues);
            indicator.xRange.max = Math.max.apply(Math, xValues);
            indicator.yRange.min = Math.min.apply(Math, yValues);
            indicator.yRange.max = Math.max.apply(Math, yValues);

            indicator.segment.push(upperSeries);


            var lowerSeries = bbdesigner$.extend(true, {}, indicator);
            lowerSeries.name = "lowerSeries";
            lowerSeries.width = indicator.lowerLine.width;
            lowerSeries.fill = indicator.lowerLine.fill;
            lowerSeries.type = "line";


            for (var n = 0; n < indicator._points.length; n++) {
                if (n >= (length - 1)) {
                    indicator._points[n].YValues.length = 1;
                    indicator._points[n].YValues[0] = indicator._points[n].y = bbiPoints[n].lb;
                }
                else {
                    indicator._points[n].YValues[0] = indicator._points[n].y = null;
                }
            }


            lowerSeries.points = bbdesigner$.extend(true, [], indicator._points);

            xValues = sender._getXValues(lowerSeries.points);

            var lowvalues = [];
            for (var i = length; i < lowerSeries.points.length; i++)
                lowvalues.push(lowerSeries.points[i].y);
            var yValues = lowvalues;

            indicator.xRange.min = Math.min(Math.min.apply(Math, xValues), indicator.xRange.min);
            indicator.xRange.max = Math.max(Math.max.apply(Math, xValues), indicator.xRange.max);
            indicator.yRange.min = Math.min(Math.min.apply(Math, yValues), indicator.yRange.min);
            indicator.yRange.max = Math.max(Math.max.apply(Math, yValues), indicator.yRange.max);

            indicator.segment.push(lowerSeries);



            var trendSeries = bbdesigner$.extend(true, {}, indicator);
            trendSeries.name = "trendSeries";
            trendSeries.width = indicator.width;
            trendSeries.fill = indicator.fill;
            trendSeries.type = "line";

            for (var m = 0; m < indicator._points.length; m++) {
                if (m >= (length - 1)) {
                    indicator._points[m].YValues.length = 1;
                    indicator._points[m].YValues[0] = indicator._points[m].y = bbiPoints[m].mb;
                }
                else {
                    indicator._points[m].YValues[0] = indicator._points[m].y = null;
                }
            }
            trendSeries.points = bbdesigner$.extend(true, [], indicator._points);
            xValues = sender._getXValues(trendSeries.points);
            var trendvalues = [];
            for (var i = length; i < trendSeries.points.length; i++)
                trendvalues.push(trendSeries.points[i].y);
            var yValues = trendvalues;

            indicator.xRange.min = Math.min(Math.min.apply(Math, xValues), indicator.xRange.min);
            indicator.xRange.max = Math.max(Math.max.apply(Math, xValues), indicator.xRange.max);
            indicator.yRange.min = Math.min(Math.min.apply(Math, yValues), indicator.yRange.min);
            indicator.yRange.max = Math.max(Math.max.apply(Math, yValues), indicator.yRange.max);
            indicator.segment.push(trendSeries);
            //calculating indicator range
            this.calculateIndicatorRange(sender, indicator);
           }
        }
     
        });
    BoldBIDashboard.indicatorTypes.bollingerband = BoldBIDashboard.ejbollingerBand;
  BoldBIDashboard.ejATR = ejExtendClass(BoldBIDashboard.EjIndicatorRender,{       
        calculateSegment:function(indicator,sender)
        {
            //calculation for atr
            this.chartObj = sender;
            indicator.segment = [];
            indicator.xRange = {};
            indicator.yRange = {};
            var atrPoints = [];
            var high_Low, high_ClosePrevious, low_ClosePrevious;
            high_Low = high_ClosePrevious = low_ClosePrevious = 0.0;
            var trueRange;
            var sumTruRange = 0.0;
            var firstFlag = false;
            var atr;
            var period =  indicator.period;
            if ((period <= 0) || (period > indicator._points.length))
                return;
            for (var i = 0; i < period; i++) {

                high_Low = indicator._points[i].high - indicator._points[i].low;
                if (i > 0) {
                    high_ClosePrevious = Math.abs(indicator._points[i].high - indicator._points[i - 1].close);
                    low_ClosePrevious = Math.abs(indicator._points[i].low - indicator._points[i - 1].close);
                 }
              
                trueRange = Math.max(high_Low, high_ClosePrevious, low_ClosePrevious);
               
                sumTruRange += trueRange;
                atr = (sumTruRange / period);
          
                    atrPoints[i] = { "X": indicator._points[i].X, "YValues": atr };

            }
       
             for (var i = period; i < indicator._points.length; ++i) {
                high_Low = indicator._points[i].high - indicator._points[i].low;
                high_ClosePrevious = Math.abs(indicator._points[i].high - indicator._points[i - 1].close);
                low_ClosePrevious = Math.abs(indicator._points[i].low - indicator._points[i-1].close);
                trueRange = Math.max(high_Low, high_ClosePrevious, low_ClosePrevious);
               
               atr = (atrPoints[i-1].YValues * (period - 1) + trueRange) / period;
             
                atrPoints[i] = {
                    "X": indicator._points[i].X, "YValues": atr
                };

               }
          


             var trendSeries = bbdesigner$.extend(true, {}, indicator);


            trendSeries.name = "trendSeries";
            trendSeries.width = indicator.width;
            trendSeries.fill = indicator.fill;
            trendSeries.type = "line";

         

            for (var k = 0; k < indicator._points.length; k++) {
                if (k >= (period - 1)) {
                    indicator._points[k].YValues.length = 1;
                    indicator._points[k].YValues[0] = indicator._points[k].y = atrPoints[k].YValues;
                }
                else {
                    indicator._points[k].YValues[0] = indicator._points[k].y = null;
                }
            }

           
       
            trendSeries.points = bbdesigner$.extend(true, [], indicator._points);
           
            var xValues = sender._getXValues(trendSeries.points);
           
            var values = [];
            for (var i = period; i < trendSeries.points.length; i++)
             values.push(trendSeries.points[i].y);
            
            indicator.xRange.min = Math.min.apply(Math, xValues);
            indicator.xRange.max = Math.max.apply(Math, xValues);
            indicator.yRange.min = Math.min.apply(Math, values);
            indicator.yRange.max = Math.max.apply(Math, values);

           indicator.segment.push(trendSeries);
        

            this.calculateIndicatorRange(sender, indicator);


            
        }

    });
    BoldBIDashboard.indicatorTypes.atr = BoldBIDashboard.ejATR;

 BoldBIDashboard.ejaccumulationDistribution = ejExtendClass(BoldBIDashboard.EjIndicatorRender, {
        calculateSegment: function (indicator, sender) {
            this.chartObj = sender;
            indicator.segment = [];
            indicator.xRange = {};
            indicator.yRange = {};
            var adlPoints = [];
            var sum = 0;
          //calculating accumulation distribution line points 
            for (var i = 0; i < indicator._points.length;i++) {
                var close = indicator._points[i].close;
                
                    var value=(((close - indicator._points[i].low) - (indicator._points[i].high - close)) / (indicator._points[i].high - indicator._points[i].low));
                    sum += value * indicator._points[i].volume;
                    adlPoints[i] = sum;
                
            }
            var trendSeries = bbdesigner$.extend(true, {}, indicator);
            trendSeries.name = "trendseries";
            trendSeries.fill = indicator.fill;
            trendSeries.width = indicator.width;
            trendSeries.type = "line";

            //Binding the accumulation distribution array values to indicator y values
            for (var k = 0; k < indicator._points.length; k++) {

                   indicator._points[k].YValues[0] = indicator._points[k].y = adlPoints[k];
                  }

            trendSeries.points = bbdesigner$.extend(true, [], indicator._points);
            var xValues = sender._getXValues(trendSeries.points);
           var yValues = sender._getYValues(trendSeries.points);
         
            indicator.xRange.min = Math.min.apply(Math, xValues);
            indicator.xRange.max = Math.max.apply(Math, xValues);
            indicator.yRange.min = Math.min.apply(Math, yValues);
            indicator.yRange.max = Math.max.apply(Math, yValues);

            indicator.segment.push(trendSeries);
            //calculating indicator range
            this.calculateIndicatorRange(sender, indicator);


        }

    });
    BoldBIDashboard.indicatorTypes.accumulationdistribution = BoldBIDashboard.ejaccumulationDistribution;
BoldBIDashboard.ejTMA = ejExtendClass(BoldBIDashboard.EjIndicatorRender, {
     calculateSegment: function (indicator, sender) {
         this.chartObj = sender;
         indicator.segment = [];
         indicator.xRange = {};
         indicator.yRange = {};

         // signalLine
         var trendSeries = bbdesigner$.extend(true, {}, indicator);
         trendSeries.name = "trendSeries";
         trendSeries.width = indicator.width;
         trendSeries.fill = indicator.fill;
         trendSeries.type = "line";

         //variable declaration
         var closevalues = [];
         var close_values = [];
         var smavalues = [];
         var tmavalues = [];
         var smaPoints = [];
         var trendPoints = [];
         var sum=0;
         var sum1;
         var length = indicator._points.length;
         var period = indicator.period;
        if (period < 1) return;
        
         if (period < length)
         {
                //Push the values to closevalues array
             for (var i = 0; i < length; i++) {
                 closevalues.push(indicator._points[i].close);
             }
             //find the closevalues length
             var close_length = closevalues.length;
         
             //calculation for SMA values

             while (close_length >= period) {
                 sum = 0;
                 for (var j = 0; j < period; j++) {
                     sum = sum + closevalues[j];

                 }
                 sum = sum / period;
                 smavalues.push( parseFloat(sum.toFixed(2)));
                 closevalues.splice(0, 1);
                 close_length = closevalues.length;
             }
             //calculating sma values depend on period
             for (var k = 0; k < length; k++) {
                 if (k < period - 1) {
                     sum = 0;
                     for (var j = 0; j < k+1; j++) {
                         sum = sum + indicator._points[j].close;

                     }
                     sum = sum / (k+1);
                     smaPoints[k] = parseFloat(sum.toFixed(2));
                 }
                 else {
                     smaPoints[k]= smavalues[k - (period - 1)];
                 }

             }
             //find the smavalues count
             var sma_count = smaPoints.length;
             //calculating TMA values
             while (sma_count >=period) {
                 sum1 = 0;
                 for (var j = 0; j < period; j++) {
                     sum1 = sum1 + smaPoints[j];

                 }
                 sum1 = sum1 / period;
                 tmavalues.push(sum1);
                 smaPoints.splice(0, 1);
                 sma_count = smaPoints.length;
                 }
            //set the TMA values to Y-Axis
             for (var k = 0; k < length; k++) {
                 if (k < period - 1) {
                     indicator._points[k].YValues[0] = indicator._points[k].y = null;

                 }
                 else {
                      indicator._points[k].YValues[0] = indicator._points[k].y = tmavalues[k - (period - 1)];
                    
                 }

             }
             trendSeries.points = bbdesigner$.extend(true, [], indicator._points);
             xValues = sender._getXValues(trendSeries.points);

             //Assign the Y-Axis values into trendPoints
             for (var i = period - 1, j = 0; i < trendSeries.points.length; i++, j++) {
                 trendPoints[j] = trendSeries.points[i].y;
             }

             //X-Axis and Y-Axis range calculation
             indicator.xRange.min = Math.min.apply(Math, xValues);
             indicator.xRange.max = Math.max.apply(Math, xValues);
             indicator.yRange.min = Math.min.apply(Math, trendPoints);
             indicator.yRange.max = Math.max.apply(Math, trendPoints);

             //push trendSeries
             indicator.segment.push(trendSeries);
             this.calculateIndicatorRange(sender, indicator);

            
         }
     }
 });
 BoldBIDashboard.indicatorTypes.tma = BoldBIDashboard.ejTMA;
	
	BoldBIDashboard.ejMomentum = ejExtendClass(BoldBIDashboard.EjIndicatorRender, {
	       calculateSegment: function (indicator, sender) {
            this.chartObj = sender;
              indicator.segment = [];
              indicator.xRange = {};
              indicator.yRange = {};

              //Upperband 
              var upperSeries = bbdesigner$.extend(true, {}, indicator);
              upperSeries.name = "upperseries";
              upperSeries.fill = indicator.upperLine.fill;
              upperSeries.width = indicator.upperLine.width;
              upperSeries.type = "line";

			  var period = indicator.period;
			  var pointsLength = indicator._points.length;
			  
          if(period > 0 && period < pointsLength -1){  // to check period value is greater than 0 and it is less than pointslength
              for (var k = 0; k < pointsLength; k++) {
                  indicator._points[k].YValues.length = 1;
                  indicator._points[k].YValues[0] = indicator._points[k].y = 100;
              }
              
              upperSeries.points = bbdesigner$.extend(true, [], indicator._points);
              var xValues = sender._getXValues(upperSeries.points);
              var yValues = sender._getYValues(upperSeries.points);
              
              indicator.xRange.min = Math.min.apply(Math, xValues);
              indicator.xRange.max = Math.max.apply(Math, xValues);
              indicator.yRange.min = Math.min.apply(Math, yValues);
              indicator.yRange.max = Math.max.apply(Math, yValues);

              indicator.segment.push(upperSeries);
              
              // signalLine
              var trendSeries = bbdesigner$.extend(true, {}, indicator); 
              trendSeries.name = "trendSeries";
              trendSeries.width = indicator.width;
              trendSeries.fill = indicator.fill;
              trendSeries.type = "line";
              
               var c = []; 
        var len = indicator.period;      // period value
            
        for (var i = 0; i < indicator._points.length; ++i)
        {
		   var points = indicator._points;
            if (!(i < len))                                       // calculate signal line points
                indicator._points[i].YValues[0] =indicator._points[i].y= (points[i].close / (points[i - len].close) *100);
        }

        for (var k = 0; k < len && k<indicator._points.length; k++) {
            indicator._points[k].YValues[0] = indicator._points[k].y = null;
        }
			  
              trendSeries.points = bbdesigner$.extend(true, [], indicator._points);
              xValues = sender._getXValues(trendSeries.points);
              var trendPoints = [];
              for (var i = len, j = 0; i < trendSeries.points.length; i++, j++){
                  trendPoints[j] = trendSeries.points[i].y;
			  }

              indicator.xRange.min = Math.min(Math.min.apply(Math, xValues), indicator.xRange.min);
              indicator.xRange.max = Math.max(Math.max.apply(Math, xValues), indicator.xRange.max);
              indicator.yRange.min = Math.min(Math.min.apply(Math, trendPoints), indicator.yRange.min);
              indicator.yRange.max = Math.max(Math.max.apply(Math, trendPoints), indicator.yRange.max);

              indicator.segment.push(trendSeries);
              this.calculateIndicatorRange(sender, indicator);
           }
        }
	});
	
	BoldBIDashboard.indicatorTypes.momentum = BoldBIDashboard.ejMomentum;
	
    BoldBIDashboard.EjSeriesRender.prototype = {

	    getOrigin: function (chart, options, params) {
	        if (params.axes[options.xAxis.name]._validCross) {
	            var crossAxis = chart.chartObj._getCrossAxis(chart.chartObj.model._axes, true, options.xAxis.crossesInAxis);
	            if ((chart.chartObj.model.requireInvertedAxes ? options.xAxis.name : options.yAxis.name === crossAxis.name))
	                return options.xAxis._crossValue;
	        }
			if (options.type.toLowerCase() == "splinerangearea")
                return Math.max(options.points[0].YValues[1], 0)
            else
	        return Math.max(options.yAxis.visibleRange.min, 0);
	    },

    setLineSeriesStyle: function (currentSeries) {

        var seriesIndex = bbdesigner$.inArray(currentSeries, this.chartObj.model._visibleSeries);
        var serColor = this.chartObj.model.seriesColors[seriesIndex];
        if (!serColor)
            serColor = this.chartObj.model.seriesBorderDefaultColors[0];
        var legendMode = this.chartObj.model.legend.mode;
        var seriesLength = this.chartObj.model._visibleSeries.length;
        if (this.chartObj.model.rangeColorMapping.length > 0 && legendMode !="series") {
            if (seriesLength > 1 && this.chartObj.model.pointColors.length == 0) {
                for (var i = 0; i < currentSeries.points.length; i++)
                    this.chartObj.model.pointColors[i] = currentSeries.points[i].fill ? currentSeries.points[i].fill : (currentSeries.points[i].rangeFill ? currentSeries.points[i].rangeFill : serColor );
            }
            serColor = this.chartObj.model.pointColors;
        }
        
        var seriesInterior = this.chartObj.model.enableCanvasRendering ? this.chartObj.svgRenderer.createGradientElement(this.getSeriesName(currentSeries) + seriesIndex, serColor, this.chartObj.model, this.chartObj.model.legend.position) : this.chartObj.svgRenderer.createGradientElement(this.getSeriesName(currentSeries) + seriesIndex, serColor, 0, 0, 0, bbdesigner$(this.chartObj.svgObject).height(), this.chartObj.gSeriesEle, this.chartObj.model);
        var seriesBorder = this.chartObj.model.seriesBorderColors[seriesIndex];
        return { SeriesInterior: seriesInterior, SeriesBorder: seriesBorder };

    },
    getSeriesName: function(series) {
        var serName;
        if (series.name)
            serName = series.name.replace(/\s/g, '');
        else
            serName = "series";
        
        return serName;
    },
    
    drawAreaPath: function (series, style, direction, canvasTranslate) {
	    var requireInvertedAxes = this.chartObj.model.requireInvertedAxes,
        seriesIndex = bbdesigner$.inArray(series, this.chartObj.model._visibleSeries),
        translate = null, areaType = this.chartObj.model.AreaType, seriesBorder = series.border;
        if (areaType == "cartesianaxes")
        {
            var trans = BoldBIDashboard.EjSvgRender.utils._getTransform(series.xAxis, series.yAxis, requireInvertedAxes);
            translate = 'translate(' + trans.x + ',' + trans.y + ')'
        }
        var serOptions = { 'id': this.chartObj.svgObject.id + '_SeriesGroup' + '_' + seriesIndex, 'transform': translate};

        this.gSeriesGroupEle = this.chartObj.svgRenderer.createGroup(serOptions);
        if (direction != "") {
            var options = {
                'id': this.chartObj.svgObject.id + "_Series" + seriesIndex,
                'fill': style.SeriesInterior,
                'fill-opacity': series.opacity,
                'stroke-width': seriesBorder.width,
                'stroke': seriesBorder.color,
                'stroke-dasharray': seriesBorder.dashArray,
                'stroke-linecap': series.lineCap,
                'stroke-linejoin': series.lineJoin,
                'd': direction
            };
            this.chartObj.svgRenderer.drawPath(options, this.gSeriesGroupEle, canvasTranslate);
        } 
    },

    setAreaSeriesStyle: function (series) {

        var seriesIndex = bbdesigner$.inArray(series, this.chartObj.model._visibleSeries);
        var maxY = Math.max.apply(0,bbdesigner$.map(series.points, function(v) {return v.YValues[0];
        }));
        var minY = Math.min.apply(0, bbdesigner$.map(series.points, function(v) {
            return v.YValues[0];
        }));
        var minX = Math.min.apply(0, bbdesigner$.map(series.points, function (v) {
            return v.xValue;
        }));

        var point1 = {xValue: minX, YValues : []};
        point1.YValues[0] = minY;
        var point2 = {xValue: minX, YValues : []};
        point2.YValues[0] = maxY;
        var point1Xy = BoldBIDashboard.EjSvgRender.utils._getPoint(point1, series);
        var point2Xy = BoldBIDashboard.EjSvgRender.utils._getPoint(point2, series);
        var serColor = this.chartObj.model.seriesColors[seriesIndex];
        if (!serColor)
            serColor = this.chartObj.model.seriesBorderDefaultColors[0];
        var legendMode = this.chartObj.model.legend.mode;
        var seriesLength = this.chartObj.model._visibleSeries.length;
        if (this.chartObj.model.rangeColorMapping.length > 0 && legendMode !="series") {
            if (this.chartObj.model.pointColors.length == 0) {
                for (var i = 0; i < series.points.length; i++)
                    this.chartObj.model.pointColors[i] = series.points[i].fill ? series.points[i].fill : (series.points[i].rangeFill ? series.points[i].rangeFill : serColor );
            }
            serColor = this.chartObj.model.pointColors;
        }
        var seriesInterior = this.chartObj.model.enableCanvasRendering ? this.chartObj.svgRenderer.createGradientElement(this.getSeriesName(series) + seriesIndex, serColor, this.chartObj.model, this.chartObj.model.legend.position) : this.chartObj.svgRenderer.createGradientElement(this.getSeriesName(series) + seriesIndex, serColor, point1Xy.X, point1Xy.Y, point2Xy.X, point2Xy.Y, this.chartObj.gSeriesEle, this.chartObj.model);

        return { SeriesInterior: seriesInterior };

    },





    naturalSpline: function (points, series, yIndex) {
        var count = points.length;
        //constant
        var yIndex = series.type.toLowerCase() == "splinerangearea" ? yIndex : 0, a = 6;
        var ySpline = [], ySplineDuplicate = [];
		
        // assigning the first and last value as zero
        ySpline[0] = ySplineDuplicate[0] = 0;
        ySpline[points.length - 1] = 0;

        for (var i = 1; i < count - 1; i++) {
            var d1 = points[i].xValue - points[i - 1].xValue;
            var d2 = points[i + 1].xValue - points[i - 1].xValue;
            var d3 = points[i + 1].xValue - points[i].xValue;
            var dy1 = points[i + 1].YValues[yIndex] - points[i].YValues[yIndex] || null;
            var dy2 = points[i].YValues[yIndex] - points[i - 1].YValues[yIndex] || null;
            if (d1 == 0 || d2 == 0 || d3 == 0) {
                ySpline[i] = 0;
                ySplineDuplicate[i] = 0;
            }
            else {
                var p = 1 / (d1 * ySpline[i - 1] + 2 * d2);

                ySpline[i] = -p * d3;
                ySplineDuplicate[i] = p * (a * (dy1 / d3 - dy2 / d1) - d1 * ySplineDuplicate[i - 1]);
            }
        }

        for (var k = count - 2; k >= 0; k--)
            ySpline[k] = ySpline[k] * ySpline[k + 1] + ySplineDuplicate[k];


        return ySpline;

    },
    getBezierControlPoints: function (point1, point2, ySpline1, ySpline2, yIndex) {
        var controlPoint1;
        var controlPoint2;
        var one3 = 1 / 3.0;
        var deltaX2 = (point2.xValue - point1.xValue);

        deltaX2 = deltaX2 * deltaX2;

         var dx1 = 2 * point1.xValue + point2.xValue;
         var dx2 = point1.xValue + 2 * point2.xValue;

        var dy1 = 2 * point1.YValues[yIndex] + point2.YValues[yIndex];
        var dy2 = point1.YValues[yIndex] + 2 * point2.YValues[yIndex];

        var y1 = one3 * (dy1 - one3 * deltaX2 * (ySpline1 + 0.5 * ySpline2));
        var y2 = one3 * (dy2 - one3 * deltaX2 * (0.5 * ySpline1 + ySpline2));

        controlPoint1 = { xValue: dx1 * one3, YValues: [y1] };
        controlPoint2 = { xValue: dx2 * one3, YValues: [y2] };

        return { controlPoint1: controlPoint1, controlPoint2: controlPoint2 };


    },

    improveChartPerformance: function(chartSeries) {
        var tempPoints = [],
            xVisibleRange = chartSeries.xAxis.visibleRange,
            yVisibleRange = chartSeries.yAxis.visibleRange,
            seriesPoints = chartSeries.points,
            AreaBounds = this.chartObj.model.m_AreaBounds,
            emptyPoints,
            xDelta = xVisibleRange.max - xVisibleRange.min,
            yDelta = yVisibleRange.max - yVisibleRange.min,
            xTolerance = Math.abs((xDelta * 1) / AreaBounds.Width),
            yTolerance = Math.abs((yDelta * 1) / AreaBounds.Height),
            prevXValue = (seriesPoints[0] && seriesPoints[0].X > xTolerance) ? 0 : xTolerance,
            prevYValue = (seriesPoints[0] && seriesPoints[0].y > yTolerance) ? 0 : yTolerance,
            xVal = 0, yVal = 0, isEmpty, currentPoint,
            currentPointsLenght = seriesPoints.length,
            count = 0;

        for (var k = 0; k < currentPointsLenght; k++) {
            currentPoint = seriesPoints[k];
            if (currentPoint.fill)
                chartSeries.pointFill = true;
            isEmpty = (currentPoint.isEmpty === null || currentPoint.isEmpty === undefined) ? false : currentPoint.isEmpty;
            if (currentPoint.xValue === null || currentPoint.xValue === undefined || isNaN(currentPoint.xValue)) {
                currentPoint.isEmpty = true;
                currentPoint.visible = false;
                currentPoint.xValue = xVisibleRange.min;
            } else
                currentPoint.isEmpty = isEmpty;
            if ((currentPoint.YValues[0] == null) || (currentPoint.YValues[0] == 'undefined') || isNaN(currentPoint.YValues[0]) || (currentPoint.YValues[0] === "")) {
                currentPoint.isEmpty = true;
                currentPoint.visible = false;
                currentPoint.YValues[0] = yVisibleRange.min;
            } else {
                currentPoint.isEmpty = currentPoint.isEmpty;
                currentPoint.visible = (currentPoint.isEmpty) ? !currentPoint.isEmpty : currentPoint.visible;
            }
            currentPoint.visible = !(currentPoint.isEmpty) ? true : (currentPoint.visible || false);
            xVal = currentPoint.xValue;
            yVal = currentPoint.YValues[0];
            if (Math.abs(prevXValue - xVal) >= xTolerance || Math.abs(prevYValue - yVal) >= yTolerance) {

                tempPoints[count]=currentPoint;
                prevXValue = xVal;
                prevYValue = yVal;
                count++;
            }
        }

        emptyPoints = this._calculateEmptyPoints(chartSeries, tempPoints);
        var chartModel = this.chartObj.model;
        var seriesVisiblePoints1 = [];
        var seriesVisiblePoints2 = [];
        if ((chartModel.legend.mode == "point" || chartModel.legend.mode == "range" )&& chartModel.AreaType == "cartesianaxes" ) {
            var emptyPointsLength = emptyPoints.length;
            for (var j = 0; j < emptyPointsLength; j++) {
                if (emptyPoints[j].visible) {
                    emptyPoints[j].visible = emptyPoints[j]._visibility == 'hidden' ? false : true;
                    if (emptyPoints[j].visible)
                        seriesVisiblePoints1.push(emptyPoints[j]);
                }
            }
            if (chartSeries._visiblePoints) {
                var visiblePoints = chartSeries._visiblePoints;
                var visiblePointsLength = visiblePoints.length;
                for (var j = 0; j < visiblePointsLength; j++) {
                    if (visiblePoints[j].visible)
                        visiblePoints[j].visible = visiblePoints[j]._visibility == 'hidden' ? false : true;
                    if (visiblePoints[j].visible)
                        seriesVisiblePoints2.push(visiblePoints[j]);
                }
            }
            chartSeries._visiblePoints = seriesVisiblePoints2? seriesVisiblePoints2 : seriesVisiblePoints1;
            return seriesVisiblePoints1;
        }
        else {
        chartSeries._visiblePoints = chartSeries._visiblePoints ? chartSeries._visiblePoints : emptyPoints;

        return emptyPoints;
        }

    },
    _isVisiblePoints: function(chartSeries, chartObj) {
        var points = chartSeries.points,
            emptyPoints,
            isEmpty,
            checkNull = BoldBIDashboard.util.isNullOrUndefined,
            length = points.length;
        for (var k = 0; k < length; k++) {
            isEmpty = (checkNull(points[k].isEmpty)) ? false : points[k].isEmpty;
            points[k].visible = (checkNull(points[k].visible)) ? true : points[k].visible;
            if (checkNull(points[k].xValue)) {
                points[k].isEmpty = true;
                points[k].visible = false;
                points[k].xValue = chartSeries.xAxis ? chartSeries.xAxis.visibleRange.min : null;
            } else
                points[k].isEmpty = isEmpty;

            if (isNaN(points[k].YValues[0]) || (points[k].YValues[0] == null || points[k].YValues[0] == 'undefined') || (chartSeries._hiloTypes && (points[k].YValues[1] == undefined || points[k].YValues[1] == null))) {
                points[k].isEmpty = true;
                points[k].visible = false;
            } else {
                points[k].isEmpty = points[k].isEmpty;
                points[k].visible = (points[k].isEmpty) ? !points[k].isEmpty : points[k].visible;
            }
            if (!checkNull(points[k].x)) {
                if (bbdesigner$.type(points[k].xValue) == "date")
                    points[k].xValue = (points[k].xValue).getTime();
            }
        }
        if (chartSeries.emptyPointSettings)
            emptyPoints = this._calculateEmptyPoints(chartSeries, points);
        else
            emptyPoints = points;

        if (chartSeries.type.toLowerCase() == "waterfall")
            this.chartObj.calculateWaterfallSeriesPoints(emptyPoints);

        var chartModel = chartObj ? chartObj.model : this.chartObj.model;
        var visiblePoints = [];
        var legendMode = chartModel.legend.mode;
        if ((legendMode == "point" || legendMode == "range") && chartModel.AreaType == "cartesianaxes" ) {
            var emptyPointsLength = emptyPoints.length;
            for (var j = 0; j < emptyPointsLength; j++) {
                if (emptyPoints[j].visible) {
                    emptyPoints[j].visible = emptyPoints[j]._visibility == 'hidden' ? false : true;
                    if (emptyPoints[j].visible)
                        visiblePoints.push(emptyPoints[j]);
                }
            }
            chartSeries._visiblePoints = visiblePoints;

            return visiblePoints;
        }
        else {

        chartSeries._visiblePoints = emptyPoints;

        return emptyPoints;
        }

    },

    _calculateEmptyPoints: function (series, points) {
        var currentPoints;
        var emptyPoints = series.emptyPointSettings,
            style = emptyPoints.style,
            fill = style.color,
            checkNull = BoldBIDashboard.util.isNullOrUndefined,
            borderColor = style.border.color,
            borderWidth = style.border.width,
            mode = emptyPoints.displayMode.toLowerCase(),
            emptyPointsVisible = emptyPoints.visible,
            length = points.length,
            point,
			seriesType = series.type,
            xPoints =[],
            visiblePoints = [];
            currentPoints = bbdesigner$.extend(true, {}, points, currentPoints);
            currentPoints.length = points.length;
        if (emptyPointsVisible) {
            if (mode != 'gap') {                
                for (var i = 0; i < length; i++) {
                    currentPoints[i].actualIndex = i;
                    point = currentPoints[i];
                    if ((point.isEmpty) && (!checkNull(point.x) || series._xAxisValueType == "string")) {
                        if (fill != '')
                            point.fill = fill;
                        if (borderColor != '') {
                            point.border = point.border ? point.border : {};
                            point.border.color = borderColor;
                            point.border.width = borderWidth;
                        }
                        switch (mode) {
                            case 'previous':
                                if (series._hiloTypes) {
                                    if (seriesType == "splinerangearea")
                                        this._setsraPoint(currentPoints[i]);
                                    bbdesigner$.each(point.YValues, function (index, value) {
                                        value = (currentPoints[i - 1] ? currentPoints[i - 1].YValues[index] : 0);
                                        point.YValues[index] = value;
                                        BoldBIDashboard.EjSeriesRender.prototype._sethlocPoint(index, point, value);
                                    })
                                } else {
                                    value = (currentPoints[i - 1] ? currentPoints[i - 1].y : 0);
                                    point.YValues[0] = value;
                                    point.y = value;
                                }
                                break;
                            case 'average':
                                if (series._hiloTypes) {
									if (seriesType == "splinerangearea")
                                        this._setsraPoint(currentPoints[i]);
                                    bbdesigner$.each(point.YValues, function (index, value) {
                                        value = ((currentPoints[i - 1] ? currentPoints[i - 1].YValues[index] : 0) + (currentPoints[i + 1] ? (currentPoints[i + 1].isEmpty ? 0 : currentPoints[i + 1].YValues[index] ) : 0)) / 2
                                            point.YValues[index] = value;
                                            BoldBIDashboard.EjSeriesRender.prototype._sethlocPoint(index, point, value);
                                    })
                                } else {
                                    value = ((currentPoints[i - 1] ? currentPoints[i - 1].y : 0) + (currentPoints[i + 1] ? ( currentPoints[i + 1].isEmpty ? 0 : currentPoints[i + 1].y ) : 0)) / 2;
                                    point.YValues[0] = value;
                                    point.y = value;
                                }
                                break;
                            case 'zero':
                                if (series._hiloTypes) {
									if (seriesType == "splinerangearea")
                                        this._setsraPoint(currentPoints[i]);
                                    bbdesigner$.each(point.YValues, function (index, value) {
                                            point.y = 0;
                                            point.YValues[index] = 0;
                                            BoldBIDashboard.EjSeriesRender.prototype._sethlocPoint(index, point, 0);
                                    })
                                } else {
                                    point.YValues[0] = 0;
                                    point.y = 0;
                                }
                                break;
                        }
                        point.isEmpty = false;
                        point.visible = true;
                        visiblePoints.push(point);
                    } else {
                        if (!checkNull(currentPoints[i].x) || series._xAxisValueType == "string")
                            visiblePoints.push(point);
                    }   
                }
            } else {
                for (var i = 0; i < length; i++) {
                    currentPoints[i].actualIndex = i;
					if (seriesType == "splinerangearea")
                        this._setsraPoint(currentPoints[i]);
                    visiblePoints[i]= (currentPoints[i]);
                }
            }
        } else {
            for (var i = 0; i < length; i++) {
                currentPoints[i].actualIndex = i;
                if (currentPoints[i].visible)
                    visiblePoints.push(currentPoints[i]);
            }
        }

        return visiblePoints;

    },
    _setsraPoint: function (currentPoint) {
        var checkNull = BoldBIDashboard.util.isNullOrUndefined;
        if (checkNull(currentPoint.YValues[0]))
            currentPoint.YValues[0] = 0;
        if (checkNull(currentPoint.YValues[1]))
            currentPoint.YValues[1] = 0;
    },	
    _sethlocPoint: function (index,point,value) {
        switch (index) {
            case 0:
                point.high = value;
                break;
            case 1:
                point.low = value;
                break;
            case 2:
                point.open = value;
                break;
            case 3:
                point.close = value;
                break;
        }
    },

    _calculatePolarAxesSegment: function (currentseries) {

        var points = currentseries._visiblePoints;
        var segment = BoldBIDashboard.EjSvgRender.utils._getStringBuilder();
        var SeriesIndex=bbdesigner$.inArray(currentseries, this.chartObj.model._visibleSeries)
        var size;
        var interval;
        var centerX = this.chartObj.model.centerX;
        var centerY = this.chartObj.model.centerY;
        // calculating side by side info.
        var sideInfo = this._getSeriesPosition(currentseries);

        size = bbdesigner$.extend(true, {}, currentseries.marker.size, size);
        if (size.width <= 10) {
            size.width = size.height = (1.5 * this.chartObj.model.elementSpacing);
        }
        if (currentseries.drawType.toLowerCase() == 'column') {
           
            var innerRadius = 0;
            var serOptions = { 'id': this.chartObj.svgObject.id + '_SeriesGroup' + '_' + SeriesIndex };
            this.gSeriesGroupEle = this.chartObj.svgRenderer.createGroup(serOptions);
            var interval = currentseries.xAxis.visibleRange.interval;
            currentseries.xAxis.labelPlacement = !(currentseries.xAxis.labelPlacement) ? "betweenticks" : currentseries.xAxis.labelPlacement;
            var ticks=0;
            if (currentseries.xAxis._valueType != "category" || (currentseries.xAxis._valueType == "category" && currentseries.xAxis.labelPlacement=="onticks"))
              ticks= interval / 2;
            var inversed = (currentseries.xAxis.isInversed) ? 0 : 1;
            interval = interval / sideInfo.all;
            var nextPoint = interval;
            var visiblePoints = currentseries._visiblePoints;
            var length = (currentseries.xAxis._valueType != "category" &&  visiblePoints.length != 1) ? visiblePoints.length - 1 : visiblePoints.length;
            // calculation for start and end angle for each positions.
            for (var l = 0; l < length; l++) {
                var itemCurrentXPos = temp = (visiblePoints[l].xValue - currentseries.xAxis.visibleRange.min) + ((interval) * sideInfo.pos - ticks);
                itemCurrentXPos = (itemCurrentXPos) / this.chartObj.model.sumofYValues;
                point = visiblePoints[l];
               
                var nextPoint = (currentseries.xAxis.visibleRange.interval) / sideInfo.all;
                point.startAngle = 2 * Math.PI * itemCurrentXPos;
                point.endAngle = 2 * Math.PI * (itemCurrentXPos + ((nextPoint) / this.chartObj.model.sumofYValues));
            }
            if (!visiblePoints[visiblePoints.length - 1].startAngle) {
                visiblePoints[visiblePoints.length - 1].startAngle = visiblePoints[0].startAngle;
                visiblePoints[visiblePoints.length - 1].endAngle = visiblePoints[0].endAngle;
            }
        }
        var gap = false;
        for (var i = 0; i < points.length; i++) {
            var point1;
            var point2;
            if (points[i].visible) {

            // drawType 'Line' calculation
            if (currentseries.drawType.toLowerCase() == 'line') {
                point1 = BoldBIDashboard.EjSvgRender.utils.TransformToVisible(currentseries, points[i].xValue, points[i].y, this.chartObj);

                if (i < points.length - 1 && points[i + 1].visible) {
                    point2 = BoldBIDashboard.EjSvgRender.utils.TransformToVisible(currentseries, points[i + 1].xValue, points[i + 1].y, this.chartObj);
                    segment.append("M" + " " + (point1.X) + " " + (point1.Y) + " " + "L" + " " + (point2.X) + " " + (point2.Y) + " ");
                }
                    // when isClosed is true
                else if(i == points.length - 1){
                    if (currentseries.isClosed) {
                        point2 = BoldBIDashboard.EjSvgRender.utils.TransformToVisible(currentseries, points[0].xValue, points[0].y, this.chartObj);
                        segment.append("M" + " " + (point1.X) + " " + (point1.Y) + " " + "L" + " " + (point2.X) + " " + (point2.Y) + " ");
                    }
                }            
            }

            else if (currentseries.drawType.toLowerCase() == 'column') {
                var interval = currentseries.xAxis.visibleRange.interval;
                var inversed= (currentseries.xAxis.isInversed) ? 0 : 1;
                var interval = interval / sideInfo.all;
                // radius for each point based on the y values.
                var radius = this.chartObj.model.Radius * BoldBIDashboard.EjSvgRender.utils._valueToCoefficient(currentseries.yAxis, points[i].y);
                
                var chartStartAngle = -.5 * Math.PI;
                var startAngle = points[i].startAngle + chartStartAngle;
                var endAngle = points[i].endAngle + chartStartAngle - 0.000001;

                var x1,y1, x2, y2;
           
                // calculating arc when the Stacking mode is enabled
               
                if (currentseries.isStacking) {
				     var startValue = currentseries.stackedValue.StartValues[i];
                    var endValue = currentseries.stackedValue.EndValues[i];
                    radius = ((startValue==endValue) ? 0 : (this.chartObj.model.Radius * BoldBIDashboard.EjSvgRender.utils._valueToCoefficient(currentseries.yAxis, endValue)));

                    x1 = centerX + radius * Math.cos(startAngle);
                    y1 = centerY + radius * Math.sin(startAngle);

                    x2 = centerX + radius * Math.cos(endAngle);
                    y2 = centerY + radius * Math.sin(endAngle);

                    innerRadius = this.chartObj.model.Radius * BoldBIDashboard.EjSvgRender.utils._valueToCoefficient(currentseries.yAxis, (startValue == 0 && currentseries.yAxis.visibleRange.min != 0) ? currentseries.yAxis.visibleRange.min : startValue);

                    var dStartX = centerX + innerRadius * Math.cos(startAngle);
                    var dStartY = centerY + innerRadius * Math.sin(startAngle);

                    var dEndX = centerX + innerRadius * Math.cos(endAngle);
                    var dEndY = centerY + innerRadius * Math.sin(endAngle);
                     if (this.chartObj.model.isPolar) 
                            direction = "M" + " " + x1 + " " + y1 + " " + "A" + " " + radius + " " + radius + " " + "0" + " " + "0" + " " + inversed + " " + x2 + " " + y2 + " " + "L" + " " + dEndX + " " + dEndY + " " + "A" + " " + innerRadius + " " + innerRadius + " " + "1" + " " + "0" + " " + "0" + " " + dStartX + " " + dStartY + " " + "z";
                       else
                            direction = "M" + " " + x1 + " " + y1 + " " + "L" + " " + x2 + " " + y2 + " " + "L" + " " + dEndX + " " + dEndY + " " + "L" + " " + dStartX + " " + dStartY + " " + "z";
                    }
                        // calculating arc for normal mode.
                    else {

                        x1 = centerX + radius * Math.cos(startAngle);
                        y1 = centerY + radius * Math.sin(startAngle);

                        x2 = centerX + radius * Math.cos(endAngle);
                        y2 = centerY + radius * Math.sin(endAngle);
                      if (this.chartObj.model.isPolar)
                            direction = "M" + " " + x1 + " " + y1 + " " + "A" + " " + radius + " " + radius + " " + "0" + " " + "0" + " " + inversed + " " + x2 + " " + y2 + " " + "L" + " " + centerX + " " + centerY + " " + "z";
                     else
                          direction = "M" + " " + x1 + " " + y1 + " " + "L" + " " + x2 + " " + y2 + " " + "L" + " " + centerX + " " + centerY + " " + "z";
                    }                   
        
                   // gradient creation
                var seriesInterior = this.chartObj.svgRenderer.createGradientElement(this.getSeriesName(currentseries) + "_" + SeriesIndex + i, this.chartObj.model.seriesColors[SeriesIndex], 0, 0, 0, 100, this.chartObj.gSeriesEle),
                    seriesBorder = currentseries.border;
                options = {
                     'id': this.chartObj.svgObject.id + "_Series" + SeriesIndex + "_Point" + i,
                     'fill': seriesInterior,
                     'stroke': seriesBorder.color,
                     'stroke-dasharray': seriesBorder.dashArray,
                     'stroke-width': seriesBorder.width,
                    'seriesIndex': SeriesIndex,
                    'opacity':currentseries.opacity,
                    'pointIndex': i,
                    'd': direction,
                    'start': points[i].startAngle - 1.57,
                    'end': points[i].endAngle - 1.57,
                    'radius': radius,
                    'innerR': innerRadius
                };
                if (this.chartObj.model.isPolar) {
                    options.x = centerX;
                    options.y = centerY;
					bounds = { PointIndex: i, StartAngle: points[i].startAngle, EndAngle: points[i].endAngle, CenterX: centerX, CenterY: centerY, Radius: radius, DRadius: innerRadius };
                }
				if (currentseries.type=="radar") {
                    var line1 = { x: centerX, y: centerY };
                    var line2 = { x: x1, y: y1 };
                    var line3 = { x: x2, y: y2 };
                    bounds = { PointIndex: i, Line1: line1, Line2: line2, Line3: line3 };
                }
                point = currentseries._visiblePoints[i];
                if ((!BoldBIDashboard.util.isNullOrUndefined(currentseries.marker) && currentseries.marker.visible) || (!BoldBIDashboard.util.isNullOrUndefined(currentseries.marker) && currentseries.marker.dataLabel.visible))
                    point.symbolLocation = { X: ((x1 + x2) / 2), Y: ((y1 + y2) / 2) };
                            
                this.chartObj.svgRenderer.drawPath(options, this.gSeriesGroupEle);

            }

                // drawType 'Area' calculation
            else {
                point1 = BoldBIDashboard.EjSvgRender.utils.TransformToVisible(currentseries, points[i].xValue, points[i].y, this.chartObj);
                if (i == 0 || gap) {
                    segment.append("M" + " " + (point1.X) + " " + (point1.Y) + " ");
                }
                    // when isClosed is enabled
                else if (i == points.length - 1) {
                    if(!currentseries.isClosed){
                        segment.append("L" + " " + (point1.X) + " " + (point1.Y) + " " + "L" + " " + (centerX) + " " + (centerY)  );
                    }
                    else {
                        point2 = BoldBIDashboard.EjSvgRender.utils.TransformToVisible(currentseries, points[0].xValue, points[0].y, this.chartObj);
                        segment.append("L" + " " + (point1.X) + " " + (point1.Y) + " " + "z");
                    }
                }
                    
                else {
                    if (points[i + 1].visible)
                        segment.append("L" + " " + (point1.X) + " " + (point1.Y) + " ");
                    else
                        segment.append("L" + " " + (point1.X) + " " + (point1.Y) + " " + "L" + " " + (centerX) + " " + (centerY) + " " + "z");
                }
                if (points[i + 1] && points[i + 1].visible)
                    gap = false;
                else
                    gap = true;
            }
            if (!currentseries.regionAdded && currentseries.drawType.toLowerCase() != 'column') {
                var bounds = { X: point1.X - size.width / 2, Y: point1.Y - size.height / 2, Width: size.width, Height: size.height };
                BoldBIDashboard.EjSvgRender.utils._addRegion(this.chartObj, bounds, currentseries, points[i], i);
            }
			if (!currentseries.regionAdded && currentseries.drawType.toLowerCase() == 'column' && this.chartObj.model.enableCanvasRendering)
                BoldBIDashboard.EjSvgRender.utils._addRegion(this.chartObj, bounds, currentseries, null, null); 
            }
        }

        if (!currentseries.regionAdded && currentseries.drawType.toLowerCase() == 'column' && !this.chartObj.model.enableCanvasRendering)
            BoldBIDashboard.EjSvgRender.utils._addRegion(this.chartObj, bounds, currentseries, null, null);
        return segment.toString();
    },
    _calculateVisiblePoints: function (currentseries, chart) {
        var visiblePoints = [],
            legendPoints = [],
            emptyPointsLength,
            checkNull = BoldBIDashboard.util.isNullOrUndefined,
            points = currentseries.points,currentPoints,
            length = points.length,
            point;
        var isAccumulation = currentseries.type.toLowerCase() == ("pie" || "funnel" || "pyramid" || "doughnut");

        // calculate visible points
        for (var i = 0; i < length; i++) {
            // for legend visibility
            point = points[i];
            if (checkNull(point._visibility))
                point._visibility = 'visible';
            point.actualIndex = i;
            point.visible = (point.isEmpty) ? false : point.visible;
            if (checkNull(point.visible))
                point.visible = true;
            if ((point.y < 0 && (isAccumulation)) || (checkNull(point.y) && !(chart && chart.model.AreaType == "cartesianaxes"))) {
                point.YValues[0] = Math.abs(point.YValues[0])
            }
            if (checkNull(point.x) && currentseries._xAxisValueType != "string") {
                point.visible = false;
                point.isEmpty = true;
            }
            if (checkNull(point.y)) {
                point.visible = false;
                point.isEmpty = true;
            }
        }
        currentPoints = bbdesigner$.extend(true, {}, currentseries.points, currentPoints);
        currentPoints.length = length;
        if (currentseries.emptyPointSettings.visible){
            emptyPoints = this._calculateEmptyPoints(currentseries, currentPoints, chart);
            emptyPointsLength = emptyPoints.length;
            for (var j = 0; j < emptyPointsLength; j++) {
                if (emptyPoints[j].visible) {
                    emptyPoints[j].visible = emptyPoints[j]._visibility == 'hidden' ? false : true;
                    legendPoints.push(emptyPoints[j]);
                    if (emptyPoints[j].visible)
                        visiblePoints.push(emptyPoints[j]);
                } else {
                    //calculating gap mode values
                    emptyPoints[j].y = ((emptyPoints[j - 1] ? emptyPoints[j - 1].y : 0) + (emptyPoints[j + 1] ? emptyPoints[j + 1].y : 0)) / 2;
                    if (isNaN(emptyPoints[j].y))
                        emptyPoints[j].y = ((emptyPoints[j - 2] ? emptyPoints[j - 2].y : 0) + (emptyPoints[j + 2] ? emptyPoints[j + 2].y : 0)) / 2;
                   
				   emptyPoints[j].YValues[0] = emptyPoints[j].y;
                    if (!checkNull(emptyPoints[j].x) || currentseries._xAxisValueType == "string") {
                        emptyPoints[j].gapMode = true;
                        visiblePoints.push(emptyPoints[j]);
                    }   
                }
            }
        }            
        else {
            for (var j = 0; j < length; j++) {
                if (currentPoints[j].visible) {
                    currentPoints[j].visible = currentPoints[j]._visibility == 'hidden' ? false : true;
                    legendPoints.push(currentPoints[j]);
                    if (currentPoints[j].visible)
                        visiblePoints.push(currentPoints[j]);
                }
            }
        }  
        if (currentseries.visibility == "hidden")
        {
            for(var i=0;i<legendPoints.length;i++)
            {
                legendPoints[i].visible = false;
            }
        }
        currentseries._visiblePoints = visiblePoints;
        currentseries.visiblePoints = legendPoints;

        return {
            'visiblePoints': visiblePoints,
            'legendPoints': legendPoints
        };
    },
    getMinMaxValue: function (point1, point2, degree) {
        var minX = Math.min(point1.x, point2.x);
        var minY = Math.min(point1.y, point2.y);
        var maxX = Math.max(point1.x, point2.x);
        var maxY = Math.max(point1.y, point2.y);
        var pointValue;
        switch (degree) {
            case 0:
            case 360:
                pointValue = maxY;
                break;
            case 90:
                pointValue = minX;
                break;
            case 180:
                pointValue = minY;
                break;
            case 270:
                pointValue = maxX;
                break;
        }
        return pointValue;
    },
    pieDoughnutCenter:function(currentseries)
    {
               var startAngle = currentseries.startAngle;
        var endAngle = currentseries.endAngle;
		 this.chartObj.model.centerCount ++;
		   var seriesIndex = bbdesigner$.inArray(currentseries, this.chartObj.model._visibleSeries);
        var regions = [-630,-540,-450,-360,-270,-180,-90,0, 90, 180, 270,360,450,540,630];
        var region = [];
         var oldCenterX = this.chartObj.model.circleCenterX[seriesIndex];
        var oldCenterY = this.chartObj.model.circleCenterY[seriesIndex];

        if (currentseries.startAngle < currentseries.endAngle) {
            for (i = 0; i < regions.length;i++) {
                if (regions[i] > startAngle && regions[i] < endAngle)
                    region[region.length] = (regions[i] % 360) < 0 ? (regions[i] % 360) + 360 : (regions[i] % 360);
            }
            }
        else {
            for (i = 0; i < regions.length; i++) {
                if (regions[i] < startAngle && regions[i] > endAngle)
                    region[region.length] = (regions[i] % 360) < 0 ? (regions[i] % 360) + 360 : (regions[i] % 360);
            }
        }
		 if (this.chartObj.model.centerCount == 1) {

                var radius = this.chartObj.model.circularRadius[seriesIndex];
                var startRadian = 2 * Math.PI * (startAngle - 90) / 360;
                var endRadian = 2 * Math.PI * (endAngle - 90) / 360;
                var centerPoint = { x: this.chartObj.model.circleCenterX[seriesIndex], y: this.chartObj.model.circleCenterY[seriesIndex] };
                var startPoint = { x: this.chartObj.model.circleCenterX[seriesIndex] + radius * Math.cos(startRadian), y: this.chartObj.model.circleCenterY[seriesIndex] + radius * Math.sin(startRadian) }
                var endPoint = { x: this.chartObj.model.circleCenterX[seriesIndex] + radius * Math.cos(endRadian), y: this.chartObj.model.circleCenterY[seriesIndex] + radius * Math.sin(endRadian) }
                switch (region.length) {
                    case 0:
                        var longX = Math.abs(centerPoint.x - startPoint.x) > Math.abs(centerPoint.x - endPoint.x) ? startPoint.x : endPoint.x;
                        var longY = Math.abs(centerPoint.y - startPoint.y) > Math.abs(centerPoint.y - endPoint.y) ? startPoint.y : endPoint.y;
                        var midPoint = { x: (centerPoint.x + longX) / 2, y: (centerPoint.y + longY) / 2 }
                        this.chartObj.model.circleCenterX[seriesIndex] = this.chartObj.model.circleCenterX[seriesIndex] + (this.chartObj.model.circleCenterX[seriesIndex] - midPoint.x);
                        this.chartObj.model.circleCenterY[seriesIndex] = this.chartObj.model.circleCenterY[seriesIndex] + (this.chartObj.model.circleCenterY[seriesIndex] - midPoint.y);
                        break;
                    case 1:
                        var maxRadian = 2 * Math.PI * (region[0] - 90) / 360;
                        var maxPoint = { x: this.chartObj.model.circleCenterX[seriesIndex] + radius * Math.cos(maxRadian), y: this.chartObj.model.circleCenterY[seriesIndex] + radius * Math.sin(maxRadian) }
                        switch (region[0]) {
                            case 0:
                            case 360:
                                point1 = { x: startPoint.x, y: maxPoint.y };
                                point2 = { x: endPoint.x, y: centerPoint.y };
                                break;
                            case 90:
                                point1 = { x: centerPoint.x, y: endPoint.y };
                                point2 = { x: maxPoint.x, y: startPoint.y };
                                break;
                            case 180:
                                point1 = { x: endPoint.x, y: centerPoint.y };
                                point2 = { x: startPoint.x, y: maxPoint.y };
                                break;
                            case 270:
                                point1 = { x: maxPoint.x, y: startPoint.y };
                                point2 = { x: centerPoint.x, y: endPoint.y };
                                break;
                        }
                        var midPoint = { x: (point1.x + point2.x) / 2, y: (point1.y + point2.y) / 2 }
                        this.chartObj.model.circleCenterX[seriesIndex] = this.chartObj.model.circleCenterX[seriesIndex] + ((this.chartObj.model.circleCenterX[seriesIndex] - midPoint.x) >= radius ? 0 : (this.chartObj.model.circleCenterX[seriesIndex] - midPoint.x));
                        this.chartObj.model.circleCenterY[seriesIndex] = this.chartObj.model.circleCenterY[seriesIndex] + ((this.chartObj.model.circleCenterY[seriesIndex] - midPoint.y) >= radius ? 0 : (this.chartObj.model.circleCenterY[seriesIndex] - midPoint.y));
                        break;
                    case 2:
                        var minRadian = 2 * Math.PI * (region[0] - 90) / 360;
                        var maxRadian = 2 * Math.PI * (region[1] - 90) / 360;
                        var maxPoint = { x: this.chartObj.model.circleCenterX[seriesIndex] + radius * Math.cos(maxRadian), y: this.chartObj.model.circleCenterY[seriesIndex] + radius * Math.sin(maxRadian) }
                        var minPoint = { x: this.chartObj.model.circleCenterX[seriesIndex] + radius * Math.cos(minRadian), y: this.chartObj.model.circleCenterY[seriesIndex] + radius * Math.sin(minRadian) }
                        var point1;
                        var point2
                        if (region[0] == 90 && region[1] == 180 || region[0] == 270 && region[1] == 0)
                            point1 = { x: minPoint.x, y: maxPoint.y }
                        else
                            point1 = { x: maxPoint.x, y: minPoint.y }
                        if (region[0] == 90 || region[0] == 270)
                            point2 = { x: this.getMinMaxValue(startPoint, endPoint, region[0]), y: this.getMinMaxValue(startPoint, endPoint, region[1]) }
                        else
                            point2 = { x: this.getMinMaxValue(startPoint, endPoint, region[1]), y: this.getMinMaxValue(startPoint, endPoint, region[0]) }
                        var midPoint = { x: Math.abs(point1.x - point2.x) / 2 >= radius ? 0 : (point1.x + point2.x) / 2, y: Math.abs(point1.y - point2.y) / 2 >= radius ? 0 : (point1.y + point2.y) / 2 }
                        this.chartObj.model.circleCenterX[seriesIndex] = this.chartObj.model.circleCenterX[seriesIndex] + (midPoint.x == 0 ? 0 : (this.chartObj.model.circleCenterX[seriesIndex] - midPoint.x) >= radius ? 0 : (this.chartObj.model.circleCenterX[seriesIndex] - midPoint.x));
                        this.chartObj.model.circleCenterY[seriesIndex] = this.chartObj.model.circleCenterY[seriesIndex] + (midPoint.y == 0 ? 0 : (this.chartObj.model.circleCenterY[seriesIndex] - midPoint.y) >= radius ? 0 : (this.chartObj.model.circleCenterY[seriesIndex] - midPoint.y));
                        break;
                }
            }
            for (var i = 0; i < currentseries.points.length; i++) {
                if (seriesIndex < this.chartObj.model._visibleSeries.length && this.chartObj.model.centerCount > 1) {
                    if (this.chartObj.model._visibleSeries[seriesIndex + 1].startAngle == startAngle && this.chartObj.model._visibleSeries[seriesIndex + 1].endAngle == endAngle) {
                        this.chartObj.model.circleCenterX[seriesIndex] = this.chartObj.model.circleCenterX[seriesIndex + 1];
                        this.chartObj.model.circleCenterY[seriesIndex] = this.chartObj.model.circleCenterY[seriesIndex + 1];
                    }
                }
                this.chartObj.model.startX[i] = this.chartObj.model.startX[i] - (oldCenterX - this.chartObj.model.circleCenterX[seriesIndex]);
                this.chartObj.model.startY[i] = this.chartObj.model.startY[i] - (oldCenterY - this.chartObj.model.circleCenterY[seriesIndex]);


            }

    },
    calculatingSliceAngle: function (currentseries) {
        var chart = this.chartObj,
            chartModel = chart.model,
            legend = chartModel.legend,
			 seriesIndex = bbdesigner$.inArray(currentseries, chartModel._visibleSeries),
            legendPosition = !BoldBIDashboard.util.isNullOrUndefined(legend.responsivePosition) ? legend.responsivePosition : legend.position.toLowerCase(),
            legendActualBounds = chartModel.LegendActualBounds,
            visiblePoints = currentseries._visiblePoints,
			visiblePointslength = visiblePoints.length,
            legXSpace = 0, totalDegree,
            legYSpace = 0,
            legendBorder = legend.border.width,
            border = chartModel.border.width,
            point, margin = chartModel.margin,
            elementSpacing = chartModel.elementSpacing,
            itemCurrentXPos = 0;
        chartModel.arcData = [];
        currentseries.rightsidePoints = [];
        currentseries.leftsidePoints = [];
        currentseries.labels = [];
        chartModel.sumofYValues = 0;
        chartModel.midPoint = 0;


        for (j = 0; j < visiblePoints.length; j++) {
            chartModel.sumofYValues += visiblePoints[j].YValues[0];
        }
        if (currentseries.endAngle != null)
            totalDegree = (currentseries.endAngle - currentseries.startAngle);
        else
            totalDegree = 360;
        totalDegree = (totalDegree != 360 && totalDegree != -360) ? totalDegree % 360 : totalDegree;
        if (currentseries.startAngle) {
            currentseries.startAngle = currentseries.startAngle % 360;
            currentseries.endAngle = currentseries.startAngle + totalDegree;
            itemCurrentXPos = (currentseries.startAngle) ? ((chartModel.sumofYValues / 360) * currentseries.startAngle) : 0;
            itemCurrentXPos = itemCurrentXPos / chartModel.sumofYValues;
            chartModel.itemCurrentXPos = itemCurrentXPos;
        }
        else
            currentseries.endAngle = totalDegree;
        if (legend.visible && legend.responsiveVisibility && legendPosition != "custom") {
            if (legendPosition == "right" || legendPosition == "left")
                legXSpace += legendActualBounds.Width + (legendBorder * 2) + elementSpacing;
            else
                legYSpace += legendActualBounds.Height + (legendBorder * 2) + elementSpacing;

        }

        var yOffset = ((chartModel.title.text && !BoldBIDashboard.util.isNullOrUndefined(chartModel._titleLocation)) ? chartModel._titleLocation.size.height + chartModel.elementSpacing : 0);

        var actualWidth = bbdesigner$(chart.svgObject).width() - (legXSpace + margin.left + margin.right + border * 2);
        var actualHeight = bbdesigner$(chart.svgObject).height() - (legYSpace + yOffset + margin.top + margin.bottom + border * 2);
       
        chartModel.circleCenterX[seriesIndex] = (actualWidth * 0.5) + margin.left + ((legend.visible && legendPosition === "left") ? legXSpace : 0);
        chartModel.circleCenterY[seriesIndex] = (actualHeight * 0.5) + margin.top + yOffset + ((legend.visible && legendPosition === "top") ? legYSpace : 0);
     
		var endAngle;
        totalDegree = currentseries.endAngle - currentseries.startAngle;
        var pieFactor = totalDegree / 180;
        for (var l = 0; l < visiblePointslength; l++) {
            point = currentseries._visiblePoints[l];
            if (point.visible || point.gapMode) {
                var pointIndex = l;
                if (l == 0){
                    point.startAngle = 2 * Math.PI * itemCurrentXPos;
					 currentseries.start = point.startAngle;
				}
                else
                    point.startAngle = endAngle;
                endAngle = point.endAngle = pieFactor * Math.PI * (point.YValues[0] / chartModel.sumofYValues) + point.startAngle;
                    endAngle = point.endAngle = (isNaN(endAngle)) ? point.startAngle : endAngle;
                    point.start = point.startAngle;
                    point.end = point.endAngle;
            point.midAngle = (point.endAngle + point.startAngle) / 2;
            point.pointIndex = pointIndex;
            var chartStartingAngle = -.5 * Math.PI;

                point.radian = (point.midAngle) % (2 * Math.PI)

                if (currentseries.labelPosition.toLowerCase() == "outsideextended") {

                    if (point.radian < Math.PI)
                        currentseries.rightsidePoints.push(point);
                    else
                        currentseries.leftsidePoints.push(point);
                }
                itemCurrentXPos += point.YValues[0] / chartModel.sumofYValues;

                var midAngle = point.midAngle + chartStartingAngle;

                if ((point.actualIndex == currentseries.explodeIndex || currentseries.explodeAll) && !chart.vmlRendering) {

                    chartModel.startX[pointIndex] = chartModel.circleCenterX[seriesIndex] + Math.cos(midAngle) * currentseries.explodeOffset;
                    chartModel.startY[pointIndex] = chartModel.circleCenterY[seriesIndex]+ Math.sin(midAngle) * currentseries.explodeOffset;
                }
                else {
                    chartModel.startX[pointIndex] = chartModel.circleCenterX[seriesIndex];
                    chartModel.startY[pointIndex] = chartModel.circleCenterY[seriesIndex];
                }
            }

        }

        if (currentseries.labelPosition.toLowerCase() == "outsideextended") {
            currentseries.rightsidePoints = BoldBIDashboard.DataManager(currentseries.rightsidePoints, BoldBIDashboard.Query().sortBy("radian")).executeLocal();
            currentseries.leftsidePoints = BoldBIDashboard.DataManager(currentseries.leftsidePoints, BoldBIDashboard.Query().sortBy("radian")).executeLocal();
        }
        if (currentseries.marker.dataLabel.template) {
            if (currentseries.labelPosition.toLowerCase() == "outsideextended") {
                for (var i = 0; i < currentseries.rightsidePoints.length; i++) {
                    BoldBIDashboard.EjSvgRender.utils._getSeriesTemplateSize(currentseries.rightsidePoints[i], currentseries.rightsidePoints[i].pointIndex, currentseries, false, chart);
                }
                for (var k = 0; k < currentseries.leftsidePoints.length; k++) {
                    BoldBIDashboard.EjSvgRender.utils._getSeriesTemplateSize(currentseries.leftsidePoints[k], currentseries.leftsidePoints[k].pointIndex, currentseries, true, chart);
                }

            }
            else {
                for (var j = 0; j < currentseries._visiblePoints.length; j++) {
                    BoldBIDashboard.EjSvgRender.utils._getSeriesTemplateSize(currentseries._visiblePoints[j], currentseries._visiblePoints[j].actualIndex, currentseries, true, chart);
                }
            }
            
        }
        else {
            BoldBIDashboard.EjSvgRender.utils._getSeriesMaxLabel(currentseries);
        }

      
        currentseries.finalSize= { width: actualWidth, height: actualHeight };
        return currentseries.finalSize;
    },
	 _drawHiloPath: function (series, style, interior, direction, i, pointbounds) {

	     var seriesIndex = bbdesigner$.inArray(series, this.chartObj.model._visibleSeries);

        var options = {
            'name': series.type,
            'id': this.chartObj.svgObject.id + "_Series" + seriesIndex + "_Point" + i,
            'fill': "none",
            'stroke-dasharray': series.dashArray,
            'stroke-width': style.borderWidth,
            'stroke': interior,
            'stroke-linecap': series.lineCap,
            'stroke-linejoin': series.lineJoin,
            'opacity': series.opacity,
            'd': direction
        };
        this.chartObj.svgRenderer.drawPath(options, this.gSeriesGroupEle);
        var valWidth, valHeight;
        var trans = BoldBIDashboard.EjSvgRender.utils._getTransform(series.xAxis, series.yAxis, this.chartObj.model.requireInvertedAxes);
        x = (Math.min(pointbounds.point2.X, pointbounds.point1.X) +trans.x) - (style.borderWidth);
        y = (Math.min(pointbounds.point2.Y, pointbounds.point1.Y) +trans.y);
        if (pointbounds.point1.Y != pointbounds.point2.Y) {
            valWidth = style.borderWidth + (style.borderWidth / 2);
              valHeight = Math.abs(pointbounds.point1.Y - pointbounds.point2.Y);
        }
	     else {
            valWidth = Math.abs(pointbounds.point2.X - pointbounds.point1.X);
            valHeight = style.borderWidth + (style.borderWidth / 2); 
        }
        var bounds = { X: x, Y: y, Width: valWidth, Height: valHeight };
        BoldBIDashboard.EjSvgRender.utils._addRegion(this.chartObj, bounds, series, null, i);
      
	 },
	 isIntersec: function (other, currBounds) {
	     if (currBounds.Bottom < other.Top || currBounds.Right < other.Left
               || currBounds.Top > other.Bottom || currBounds.Left > other.Right) {
	         return false;
	     }
	      return true;
	 },
	 IntersectWith: function (sender, point, currBounds, labelPosition, seriesIndex) {
	     var chartObj = this,intersect = false,
	      smartIndex;
	     if (BoldBIDashboard.util.isNullOrUndefined(sender.model.rightsidebounds[seriesIndex]) || BoldBIDashboard.util.isNullOrUndefined(sender.model.leftsidebounds[seriesIndex])) {
	         sender.model.leftsidebounds[seriesIndex] = [];
	         sender.model.rightsidebounds[seriesIndex] = [];
	         sender.model.leftsidebounds[seriesIndex].points = [];
	         sender.model.rightsidebounds[seriesIndex].points = [];
	     }
	     if (labelPosition == "outsideExtended") {
                for (i = seriesIndex; i < sender.model.bounds.length ; i++) {
                    if (sender.model._visibleSeries[i].labelPosition.toLowerCase() == "outsideextended") {
                        if ((!BoldBIDashboard.util.isNullOrUndefined(sender.model.bounds[i].points["left"])) && (sender.model.bounds[i].points["left"].length > 0)) {
                            var pointsLength = sender.model.bounds[i].points["left"].length;
                            for (j = pointsLength - 1; j >= 0 && !(BoldBIDashboard.util.isNullOrUndefined(sender.model.bounds[i].points["left"][j])) ; j--) {
                                sender.model.leftsidebounds[i].points[j] = sender.model.bounds[i].points["left"][j];

                            }
                        }
                        else if ((!BoldBIDashboard.util.isNullOrUndefined(sender.model.bounds[i].points["right"])) && (sender.model.bounds[i].points["right"].length > 0)) {
                            var pointsLength = sender.model.bounds[i].points["right"].length;
                            for (k = 0; k < pointsLength && !(BoldBIDashboard.util.isNullOrUndefined(sender.model.bounds[i].points["right"][k])) ; k++) {
                                sender.model.rightsidebounds[i].points[k] = sender.model.bounds[i].points["right"][k];
                            }
                        }

                    }
                }
            }
            else {

                if (sender.model.bounds[seriesIndex].points.length > 0 || seriesIndex >= 0) {
                    for (i = seriesIndex; i < sender.model.bounds.length && (!BoldBIDashboard.util.isNullOrUndefined(sender.model.bounds[i])) ; i++) {
                        if (sender.model._visibleSeries[i].labelPosition.toLowerCase() != "outsideextended") {
                            var pointsLength = sender.model.bounds[i].points.length;
                            for (j = 0; j < pointsLength && !(BoldBIDashboard.util.isNullOrUndefined(sender.model.bounds[i].points[j])) ; j++) {
                                if (sender.model.bounds[i].points[j].X < sender.model.circleCenterX[seriesIndex]) {
                                    if ((bbdesigner$.inArray(sender.model.bounds[i].points[j], sender.model.leftsidebounds[i].points)) == -1)
                                        sender.model.leftsidebounds[i].points[j] = sender.model.bounds[i].points[j];
                                }
                                else if ((bbdesigner$.inArray(sender.model.bounds[i].points[j], sender.model.rightsidebounds[i].points)) == -1)
                                    sender.model.rightsidebounds[i].points[j] = (sender.model.bounds[i].points[j]);

                            }
                        }
                    }
                }

            }
            for (i = seriesIndex; i < sender.model.bounds.length && (!BoldBIDashboard.util.isNullOrUndefined(sender.model.bounds[i])) ; i++) {
                if (sender.model.leftsidebounds[i].points.length > 0) {
                    bounds = sender.model.leftsidebounds[i].points;
                    if (bounds.length > 0) {
                        for (var j = bounds.length - 1  ; j >= 0 ; j--) {
                            var other = bounds[j];
                          
                                if (!(BoldBIDashboard.util.isNullOrUndefined(other) && other != currBounds)) {
                                if (other.SeriesIndex == currBounds.SeriesIndex && other.PointIndex == currBounds.PointIndex) {
                                    if (point.smartLabelPosition == "outside")
                                        continue;
                                    else
                                        break;
                                }
                                else if (this.isIntersec(other, currBounds))
                                    return true;
                            }
                        }
                    }

                }
            }
            for (i = seriesIndex; i < sender.model.bounds.length && (!BoldBIDashboard.util.isNullOrUndefined(sender.model.bounds[i])) ; i++) {
                bounds = sender.model.rightsidebounds[i].points;
                if (bounds.length > 0) {
                    for (var j = bounds.length - 1 ; j >= 0; j--) {
                        var other = bounds[j];
                        if (!(BoldBIDashboard.util.isNullOrUndefined(other) && other != currBounds)) {
                                if (other.SeriesIndex == currBounds.SeriesIndex && other.PointIndex == currBounds.PointIndex) {
                                    if (point.smartLabelPosition == "outside")
                                        continue;
                                    else
                                        break;
                                }
                                else if (this.isIntersec(other, currBounds))
                                    return true;
                            }
                    }

                }
            }
	     return intersect;
	     
	 },
   
   
	 _calculateArcData: function (sender, pointIndex, point, series, seriesIndex) {
	     var visiblePoints = series._visiblePoints;
	     var index = point.actualIndex;
	     var chartObj = sender;
	     var chartStartAngle = -.5 * Math.PI;
	     var currBounds;
	     var startAngle = point.startAngle + chartStartAngle;
	     var endAngle = point.endAngle + chartStartAngle - 0.000001;
	     var totalDegree = series.endAngle - series.startAngle;
	     var longArc = endAngle - startAngle < Math.PI ? 0 : 1;
	     var midAngle = (startAngle + endAngle) / 2;
		  if (BoldBIDashboard.util.isNullOrUndefined(point.currentMidAngle)) {
	         point.currentMidAngle = (startAngle + endAngle) / 2;
	     }
	     var direction;
	     var startX;
	     var startY
	     var clockWise=totalDegree > 0?1:0;
	     var longArc = clockWise ? endAngle - startAngle < Math.PI ? 0 : 1 : endAngle - startAngle > -1 * Math.PI ? 0 : 1;
	     var radius = chartObj.model.circularRadius[seriesIndex] ;
		 var innerRadius = chartObj.model.innerRadius[seriesIndex] ;
	     if ((index == series.explodeIndex || series.explodeAll) && !chartObj.vmlRendering) {
           
	         startX = chartObj.model.circleCenterX[seriesIndex] + Math.cos(midAngle) * series.explodeOffset;
	         startY = chartObj.model.circleCenterY[seriesIndex] + Math.sin(midAngle) * series.explodeOffset;
	     }
	     else {
	         startX = chartObj.model.circleCenterX[seriesIndex];
	         startY = chartObj.model.circleCenterY[seriesIndex];
	     }


	     var x1 = startX + radius* Math.cos(startAngle);
	     var y1 = startY + radius * Math.sin(startAngle);

	     var x2 = startX + radius * Math.cos(endAngle);
	     var y2 = startY + radius * Math.sin(endAngle);
	    
	     if (series.type.toLowerCase() == "doughnut") {
	         var dStartX = startX + innerRadius * Math.cos(startAngle);
	         var dStartY = startY + innerRadius * Math.sin(startAngle);

	         var dEndX = startX + innerRadius * Math.cos(endAngle);
	         var dEndY = startY + innerRadius * Math.sin(endAngle);
	         var dClockWise = clockWise ? 0 : 1;
	         if ((startAngle < 0) && Math.round(point.endAngle - point.startAngle) == 6)
	         {
	             dEndX = dEndX - 0.01;
	             x2 = x2 - 0.01;
	         }
	         direction = "M" + " " + x1 + " " + y1 + " " + "A" + " " + radius + " " + radius + " " + "0" + " " + longArc + " " + clockWise + " " + x2 + " " + y2 + " " + "L" + " " + dEndX + " " + dEndY + " " + "A" + " " +innerRadius+ " " + innerRadius + " " + "1" + " " + longArc + " " + dClockWise + " " + dStartX + " " + dStartY + " " + "z";
	     }

	     else{
	         if ((point.endAngle-point.startAngle).toFixed(4) == (2*Math.PI).toFixed(4)){
				 var centerx = startX;
	             var centery = startY;
	             direction = "M" + " " + x1 + " " + y1 + " " + "A" + " " + radius + " " + radius + " " + "0" + " " + longArc + " " + clockWise + " " + x2 + " " + y2;
            }
			else
	             direction = "M" + " " + x1 + " " + y1 + " " + "A" + " " + radius + " " + radius + " " + "0" + " " + longArc + " " + clockWise + " " + x2 + " " + y2 + " " + "L" + " " + startX + " " + startY + " " + "z";
	     }

        // display label for pie and doughnut chart
	     

        return { Direction: direction, centerX: centerx, centerY: centery };

    },

    getXCordinate: function (x, radius, angle) {
        var x1 = x + radius * (Math.cos(angle));
        return x1;
    },

    getYCordinate: function (y, radius, angle) {
        var y1 = y + radius * (Math.sin(angle));
        return y1;
    },
 getDoubleRange: function (start, end) {
        var mstart;
        var mend;
        if (start > end) {
            mstart = end;
            mend = start;
        }
        else {
            mstart = start;
            mend = end;
        }

        var mdelta = mend - mstart;
        var mmedian = (mstart + mend) / 2;
        var misEmpty = isNaN(mstart) || isNaN(mend);

        return { Start: mstart, End: mend, Delta: mdelta, Median: mmedian, IsEmpty: misEmpty };

    },
    isDependentSeries: function (series) {
        var type = series.type.toLowerCase();
        var requireInvertedAxes = this.chartObj.model.requireInvertedAxes;
       if((!requireInvertedAxes) || (requireInvertedAxes && series.isTransposed))
           return ((type.indexOf("bar") != -1 && !series._isTransposed) || (type.indexOf("column") != -1) || (type.indexOf("waterfall") != -1) || (type.indexOf("hilo") != -1) || (type.indexOf("candle") != -1)) ? true : false;
        else
            return (type.indexOf("bar") != -1) ? true : false;
    },

    getPointXYOrgin: function (x, y, series, sender) {
	     var requireInvertedAxes = sender.model.requireInvertedAxes;
		 var xvalue;
		 var yvalue;
        if ((series.isTransposed && requireInvertedAxes) || series._isTransposed) {
            xvalue = (1 - BoldBIDashboard.EjSvgRender.utils._valueToCoefficient(series.xAxis, x)) * (series.xAxis.height);
            yvalue = (BoldBIDashboard.EjSvgRender.utils._valueToCoefficient(series.yAxis, y)) * (series.yAxis.width);
            return { X: yvalue, Y: xvalue };
        }
        else {
             xvalue = BoldBIDashboard.EjSvgRender.utils._valueToCoefficient(series.xAxis, x) * (series.xAxis.width);
             yvalue = (1 - BoldBIDashboard.EjSvgRender.utils._valueToCoefficient(series.yAxis, y)) * (series.yAxis.height);
            return { X: xvalue, Y: yvalue };
        }
    },
    getRectangle: function (x1, y1, x2, y2, series, sender) {
        var pt1 = this.getPointXYOrgin(x1, y1, series, sender);
        var pt2 = this.getPointXYOrgin(x2, y2, series, sender);
        return BoldBIDashboard.EjSvgRender.utils._correctRect(pt1.X, pt1.Y, pt2.X, pt2.Y);
    },
    calculateSides: function (point, sidebysideinfo) {
        var x1 = point.xValue + sidebysideinfo.Start;
        var x2 = point.xValue + sidebysideinfo.End;
        return { x1: x1, x2: x2 };
    },
    _getSeriesPosition: function (currentSeries) {
     // calculation for position of series in radar and polar.
        if (BoldBIDashboard.util.isNullOrUndefined(currentSeries.position) || this.chartObj.model.legendCollapsed) {
            var stacked;
            var stackingposition
            var all=0;
            var seriesCollection=[];
            for (var i = 0; i < this.chartObj.model._visibleSeries.length; i++) {
                var series=this.chartObj.model._visibleSeries[i];
                if (series.visibility.toLowerCase() === 'visible' && series.drawType.toLowerCase() == 'column') {
                    seriesCollection.push(series);
                }
            }
            for (var j = 0; j < seriesCollection.length; j++) {
                var series = seriesCollection[j];
			    if (series._xAxisName == this.chartObj.model._axes[0].name && series._yAxisName == this.chartObj.model._axes[1].name) {
                    if (series.isStacking) {
                        if (!stacked) {
                            stackingposition = all;
                            all++;
                            stacked = true;
                        }
                        series.position = stackingposition;
                    }
                    else {
                        series.position = all;
                        all++;
                      }
				}	  
            }
            for (var k = 0; k < seriesCollection.length; k++) 
                seriesCollection[k].all = all;
            
        }
        return { all: currentSeries.all, pos: currentSeries.position };
    },
     getSideBySidePositions: function (currentSeries, params) {

         var chart = this, 
            stackingGroup = [],
            model = chart.chartObj.model,
            vAxeseries,
            i = j = k = 0,
            visibleSeriesLength=model._visibleSeries.length;
         if (BoldBIDashboard.util.isNullOrUndefined(currentSeries.position) || model.legendCollapsed) {
             var hAxes = (model.requireInvertedAxes) ? model.vAxes : model.hAxes;
             var vAxes = (model.requireInvertedAxes) ? model.hAxes : model.vAxes;

             bbdesigner$.each(hAxes, function (index, hAxis) {
                 var all = 0, seriesCollection = [];
				 vAxeseries=[];
                 for (j = 0; j <visibleSeriesLength; j++) {
                     var series = model._visibleSeries[j];
                     if (series.visibility.toLowerCase() === 'visible') {
                         if (chart.isDependentSeries(series)) {
                             if (hAxis.name == series._xAxisName) {
                                 seriesCollection.push(series);
                             }
                         }
                     }
                 }
				  var seriesCollectionLength=seriesCollection.length;                 
                 for (j = 0; j < seriesCollectionLength; j++) {
                     var index = (model.requireInvertedAxes) ? seriesCollection[j].yAxis.columnIndex : seriesCollection[j].yAxis.rowIndex;
                     if (!vAxeseries[index]) {
                         vAxeseries[index] = [];                         
                     }
					 seriesCollection[j].yAxis.position = null;
                     vAxeseries[index].push(seriesCollection[j]);
                 }

                 for (i = 0; i < vAxeseries.length; i++) {
                     if (!BoldBIDashboard.util.isNullOrUndefined(vAxeseries[i])) {
                         vAxeseries[i].all = 0;
                         for (j = 0; j < vAxeseries[i].length; j++) {
                             series = vAxeseries[i][j];
                             if (series.type.toLowerCase().indexOf("stacking") != -1) {
                                 if (series.stackingGroup) {
                                     if (BoldBIDashboard.util.isNullOrUndefined(stackingGroup[series.stackingGroup])) {
                                         vAxeseries[i].all++;
                                         series.position = vAxeseries[i].all;
                                         stackingGroup[series.stackingGroup] = vAxeseries[i].all;
                                     }
                                     else
                                         series.position = stackingGroup[series.stackingGroup];
                                 }
                                 else {
                                     if (BoldBIDashboard.util.isNullOrUndefined(series.yAxis.position) || model.legendCollapsed) {
                                         vAxeseries[i].all++;
                                         series.position = vAxeseries[i].all;
                                         series.yAxis.position = vAxeseries[i].all;
										 model.legendCollapsed=false;
                                     }
                                     else
                                         series.position = series.yAxis.position;
                                 }
                             }
                             else {
                                 vAxeseries[i].all++;
                                 series.position = vAxeseries[i].all;
                             }
                         }
                     }
                 }
                 var columnWidth = seriesCollectionLength > 0 && seriesCollection[0].columnWidth;
                 for (k = 0; k < seriesCollectionLength; k++) {
                     var index = (model.requireInvertedAxes) ? seriesCollection[k].yAxis.columnIndex : seriesCollection[k].yAxis.rowIndex;
                     seriesCollection[k].all = vAxeseries[index].all;
                     params.needSpace = params.needSpace || columnWidth != seriesCollection[k].columnWidth
                 }

             });
             if (params.needSpace && this.chartObj.model._sideBySideSeriesPlacement)
                 this._getColumnSpacing(vAxeseries, params);
         }
         return { all: currentSeries.all, pos: currentSeries.position };
     },
	
     getSideBySideInfo: function (series, params) {
		 series.xAxis.m_minPointsDelta = BoldBIDashboard.EjSvgRender.utils.getMinPointsDelta(series.xAxis, this.chartObj);
         var spacing = series.columnSpacing,
             columnWidth = series.columnWidth,
             data = this.getSideBySidePositions(series, params),
             pos = data.pos,
             all = data.all,
             needSpace = params.needSpace && this.chartObj.model._sideBySideSeriesPlacement,
             width = series.xAxis.m_minPointsDelta * (needSpace ? 1 : columnWidth),
             loc = needSpace ? params[series.name || series._name].loc : (pos - 1) / all - 0.5,
             range = this.getDoubleRange(loc, loc + (needSpace ? columnWidth : 1) / all);        
        if (!this.chartObj.model._sideBySideSeriesPlacement)
            return this.getDoubleRange(-width / 2, width / 2);


         // multiplying with width  and scaling
         if (!range.IsEmpty) {
             range = this.getDoubleRange(range.Start * width, range.End * width);
             var radius = spacing * range.Delta;
             range = this.getDoubleRange(range.Start + radius / 2, range.End - radius / 2);
         }
         return range;
    },

     _getColumnSpacing: function (axesSeries, params) {
         var i = j = 0, length, len, series, name;
         for (len = axesSeries.length; i < len; i++) {
             var width = 0, stackingSeries = [], group = {};
             for (length = axesSeries[i].length; j < length; j++)
                 if ((series = axesSeries[i][j]).type.toLowerCase().indexOf("stacking") == -1)
                     width += series.columnWidth / series.all;
                 else
                     group[name = series.stackingGroup] = { width: Math.max(series.columnWidth, group[name] ? group[name].width : 0), all: series.all }
             for (var key in group)
                 width += group[key].width / group[key].all;

             var start = (1 - width) / 2 - .5;
             for (j = 0, length = axesSeries[i].length; j < length; j++) {
                 if ((series = axesSeries[i][j]).type.toLowerCase().indexOf("stacking") == -1) {
                     params[series.name || (series._name="series"+i+j)] = { loc: start };
                     start += series.columnWidth / series.all;
                 }
                 else {
                     if (group[name = series.stackingGroup].loc == null) {
                         params[series.name || (series._name="series"+i+j)] = { loc: start + (group[name].width - series.columnWidth) / 2 / series.all };
                         group[name].loc = params[series.name || series._name].loc + series.columnWidth / 2 / series.all;
                         start += group[name].width / series.all;
                     }
                     else
                         params[series.name || series._name] = { loc: group[name].loc - series.columnWidth / 2 / series.all };
                 }
             }
         }
     },

    draw: function (chart, options) {

        this.chartObj = chart;
        
        //DrawLineGraph
        var lDirection;
        var sb = BoldBIDashboard.EjSvgRender.utils._getStringBuilder();
		options.animationType = "path";
        var currentseries = options;
		var legendMode = chart.model.legend.mode.toLowerCase();
        var style = this.setLineSeriesStyle(currentseries);
        if (currentseries.sorting)
            currentseries.points = BoldBIDashboard.DataManager(currentseries.points, BoldBIDashboard.Query().sortBy("xValue")).executeLocal();
        var visiblePoints = this.improveChartPerformance(currentseries);

        if (!currentseries.pointFill || legendMode =="series") {

            var firstPoint = null;
            var secondPoint;
            var firstIndex = -1;
            var startDirection = "M ";
            for (var i = 0; i < visiblePoints.length; i++) {
                secondPoint = visiblePoints[i];
                if (secondPoint.visible) {
                    if (firstPoint != null) {
                        if (visiblePoints.length > firstIndex + 1) {
                            var nextpoint = visiblePoints[firstIndex + 1];
                            var point1 = BoldBIDashboard.EjSvgRender.utils._getPoint(firstPoint, currentseries);
                            var point2 = BoldBIDashboard.EjSvgRender.utils._getPoint(nextpoint, currentseries);
                            var chartObj = this.chartObj;
                            sb.append(startDirection + (point1.X + chartObj.canvasX) + " " + ((point1.Y + chartObj.canvasY)) + " " + "L" + " " + (point2.X + chartObj.canvasX) + " " + ((point2.Y + chartObj.canvasY)) + " ");
                            startDirection = "L ";
                        }

                    }
                    firstPoint = secondPoint;
                    firstIndex = i;

                }
                else {
					startDirection = "M ";
                    firstPoint = null;
                }

            }

            lDirection = sb.toString();

            this._drawLinePath(currentseries, style, lDirection);
        }

        else {
            var seriesIndex = bbdesigner$.inArray(currentseries, this.chartObj.model._visibleSeries),
            previousStyle, styleOptions, currentPoint,
            nextPoint, point1, point2,
            requireInvertedAxes = this.chartObj.model.requireInvertedAxes,
            count=0,
            chartObj = this.chartObj;

            var visiblePoints = currentseries._visiblePoints,
           length = currentseries._visiblePoints.length - 1;

            var trans = BoldBIDashboard.EjSvgRender.utils._getTransform(currentseries.xAxis, currentseries.yAxis, requireInvertedAxes);

            var serOptions = { 'id': this.chartObj.svgObject.id + '_SeriesGroup' + '_' + seriesIndex, 'transform': 'translate(' + trans.x + ',' + trans.y + ')' };

            this.gSeriesGroupEle = this.chartObj.svgRenderer.createGroup(serOptions);

            for (var i = 0; i < length; i++) {
                currentPoint = visiblePoints[i];             
                nextpoint = visiblePoints[i + 1];               
                
                 if (!previousStyle) 
                     previousStyle = this.chartObj.setStyle(this, currentseries, seriesIndex, i);

                 if (nextpoint.visible && currentPoint.visible) {
                     point1 = BoldBIDashboard.EjSvgRender.utils._getPoint(currentPoint, currentseries);

                     point2 = BoldBIDashboard.EjSvgRender.utils._getPoint(nextpoint, currentseries);

                     sb.append("M" + " " + (point1.X + chartObj.canvasX) + " " + ((point1.Y + chartObj.canvasY)) + " " + "L" + " " + (point2.X + chartObj.canvasX) + " " + ((point2.Y + chartObj.canvasY)) + " ");
                  }
                   
                    styleOptions = this.chartObj.setStyle(this, currentseries, seriesIndex, i + 1);

                    if (styleOptions.interior == previousStyle.interior && (i != length - 1) && nextpoint.visible)
                        continue;                 
                    
                  
                    var options = {
                        'name': currentseries.type,
                        'id': this.chartObj.svgObject.id + '_Series' + seriesIndex + '_Point' + count,
                        'stroke-dasharray': previousStyle.dashArray,
                        'fill': "none",
                        'stroke-width': previousStyle.width,
                        'stroke-linecap': currentseries.lineCap,
                        'stroke-linejoin': currentseries.lineJoin,
                        'stroke': previousStyle.interior,
                        'opacity': previousStyle.opacity,
                        'd': sb.toString()
                    };

                    this.chartObj.svgRenderer.drawPath(options, this.gSeriesGroupEle);

                    count++;

                    sb = BoldBIDashboard.EjSvgRender.utils._getStringBuilder();

                    previousStyle = styleOptions;

                 
                
            }
        }
        
        this.chartObj.svgRenderer.append(this.gSeriesGroupEle, this.chartObj.gSeriesEle);

        //assigned calculated visible points for series.
        if (options.marker && options.marker.dataLabel.visible == true && options.enableSmartLabels) {
            options._visiblePoints = this._isVisiblePoints(options);
        } else {
            options._visiblePoints = visiblePoints;
        }
    },
	
	doCircularAnimation: function (chartObj, series, seriesType, seriesIndex) {
	  var type = series.type.toLowerCase();
	  if (type == "pie" || type == "doughnut"){
         var seriesRender = this, startAngle, endAngle,
         angle = (series.points[0]) ? series.points[0].startAngle : 0,
		 visiblePoints = series._visiblePoints;
         bbdesigner$.each(visiblePoints, function (pointIndex, point) {
             startAngle = point.startAngle;
             endAngle = point.endAngle;
             chartObj.model._radius = chartObj.model.circularRadius[seriesIndex];
             point.startAngle = 0;
             point.endAngle =point.startAngle;
             chartObj.model.Radius = 0;
             var piePath = bbdesigner$(chartObj.gSeriesEle).find("#" + chartObj.svgObject.id + '_SeriesGroup' + '_' + seriesIndex)[0].childNodes[pointIndex];
			 if (type == "pie"){
               bbdesigner$(piePath).each(function () { this.StartAngle = angle, this.EndAngle = angle; }).animate(
                 { StartAngle: startAngle, EndAngle: endAngle, pieRadius: chartObj.model._radius },
                 {
                     duration: 1200, queue: false, step: function (now, fx) {
                         if (fx.prop.toString() === "StartAngle") {
                             point.startAngle = now;
                             point.endAngle = point.startAngle;
                         }
                         else if (fx.prop.toString() == "pieRadius" && chartObj.model) 
                             chartObj.model.Radius = now;
                         else  
                             point.endAngle = now;
                         if (chartObj.model) {
                             var result = seriesRender._calculateArcData(chartObj, pointIndex, point, series, seriesIndex);
                             chartObj.svgRenderer._setAttr(bbdesigner$(piePath), { "d": result.Direction });
                             chartObj.model.Radius = chartObj.model._radius;
                         }
                     },
                     complete: function () {
                         seriesRender.circularAnimationComplete(pointIndex, chartObj, series);
                     }
                 });
			   } 
			   else{ 
			      bbdesigner$(piePath).each(function () { this.StartAngle = angle, this.EndAngle = angle; }).animate(
                 { StartAngle: startAngle, EndAngle: endAngle },
                 {
                     duration: 1200, queue: false, step: function (now, fx) {
                         if (fx.prop.toString() === "StartAngle") {
                             point.startAngle = now;
                             point.endAngle = point.startAngle;
                         }
                         else  
                             point.endAngle = now;
                         if (chartObj.model) {
                             var result = seriesRender._calculateArcData(chartObj, pointIndex, point, series, seriesIndex);
                             chartObj.svgRenderer._setAttr(bbdesigner$(piePath), { "d": result.Direction });
                             chartObj.model.Radius = chartObj.model._radius;
                         }
                     },
                     complete: function () {
                         seriesRender.circularAnimationComplete(pointIndex, chartObj, series);
                     }
                 });
			   }
			 point.startAngle = startAngle;
			 point.endAngle = endAngle;
           });
	    }
     },
	 circularAnimationComplete: function(pointIndex, chartObj, series){
		if (!BoldBIDashboard.util.isNullOrUndefined(chartObj.model)) {
		 var commonEventArgs, i,seriesIndex= bbdesigner$.inArray(series,chartObj.model._visibleSeries), elements;
		     if(seriesIndex >= 0){
			 chartObj.svgRenderer._setAttr(bbdesigner$(chartObj.gSeriesEle).find("#" + chartObj.gSeriesTextEle[seriesIndex].id), { "visibility": "visible" });
		     if (chartObj.gSymbolGroupEle)
		         chartObj.svgRenderer._setAttr(bbdesigner$(chartObj.gSeriesEle).find("#" + chartObj.gSymbolGroupEle[seriesIndex].id), { "visibility": "visible" });
		     if (chartObj.gDataLabelEle)
		         chartObj.svgRenderer._setAttr(bbdesigner$(chartObj.gSeriesEle).find("#" + chartObj.gDataLabelEle[seriesIndex].id), { "visibility": "visible" });
		     if (series.marker.dataLabel.template) {
		         elements = bbdesigner$(chartObj.element[0].childNodes[0].childNodes);
		         for (i = 0; i < elements.length; i++)
		             bbdesigner$(elements[i]).css('display', 'block');
		     }
		     if (chartObj.gConnectorEle)
		         chartObj.svgRenderer._setAttr(bbdesigner$(chartObj.gSeriesEle).find("#" + chartObj.gConnectorEle[seriesIndex].id), { "visibility": "visible" });
		     }
			 chartObj.model.AnimationComplete = true;
		     series.AnimationComplete = true;
		     commonEventArgs = bbdesigner$.extend({}, BoldBIDashboard.EjSvgRender.commonChartEventArgs);
		     commonEventArgs.data = { series: series };
		     chartObj._trigger("animationComplete", commonEventArgs);
		}
	 },
	 
    _doLineSymbol: function(element, sec, val, series, invertedAxes, chartobj) {
	  if (element.tagName != "defs") {
        var beginTime = parseInt(val * sec),
        chartObj = (this.chartObj == undefined) ? chartobj : this.chartObj,
        box = BoldBIDashboard.EjSvgRender.utils._getBoundingClientRect(element, chartObj, series, invertedAxes),
        centerX = box.x + (box.width / 2),
        centerY = box.y + (box.height / 2),
        scaleVal, bbdesigner$ele = bbdesigner$(element),
        rotate = chartObj.svgRenderer._getAttrVal(bbdesigner$ele, "transform");
        rotate = !BoldBIDashboard.util.isNullOrUndefined(rotate) ? rotate : " " ;
        chartObj.svgRenderer._setAttr(bbdesigner$ele, { "transform": "scale(0)" });
        bbdesigner$ele.delay(beginTime).animate(
            {
                scale: 1
            },
            {
                duration: 200,
                step: function(now) {
                    scaleVal = now;
                    chartObj.svgRenderer._setAttr(bbdesigner$ele, { "transform": "translate(" + centerX + " " + centerY + ") scale(" + scaleVal + ") translate(" + (-centerX) + " " + (-centerY) + ")" + rotate });

                }
            }
        );
	  }
    },
    animateSymbol: function(element,delayInterval,series,invertedAxes,chartobj) {
	  if (element.tagName != "defs") {
        var chartObj = (this.chartObj == undefined) ? chartobj : this.chartObj,
        box = BoldBIDashboard.EjSvgRender.utils._getBoundingClientRect(element, chartObj, series, invertedAxes),
        centerX = box.x + (box.width / 2),
        centerY = box.y + (box.height / 2),
        scaleVal, bbdesigner$ele = bbdesigner$(element),
        rotate = chartObj.svgRenderer._getAttrVal(bbdesigner$ele, "transform");
        rotate = !BoldBIDashboard.util.isNullOrUndefined(rotate) ? rotate : " ";
        bbdesigner$ele.delay(delayInterval).each(function () {this.scale = 0.5; }).animate(
            {
                scale: 1
            },
            {
                duration: 500,
                step: function(now) {
                    scaleVal = now;
                    chartObj.svgRenderer._setAttr(bbdesigner$ele, { "transform": "translate(" + centerX + " " + centerY + ") scale(" + scaleVal + ") translate(" + (-centerX) + " " + (-centerY) + ")" + (rotate) });
                }
            }
        );
	  }
    },
    animateRect: function (element,series,invertedAxes, chartObj) {       
        var box = BoldBIDashboard.EjSvgRender.utils._getBoundingClientRect(element, chartObj, series, invertedAxes),
        centerX, centerY,scale1, scale2, scaleVal,
        bbdesigner$element = bbdesigner$(element);
        if ((series.isTransposed && invertedAxes) || invertedAxes) {
            if (chartObj.svgRenderer._getAttrVal(bbdesigner$element, "plot") === "negative") {
                centerX = box.x + box.width;
                centerY = box.y + box.height;
            } else {               
                centerX = box.x;
                centerY = box.y;
			}
            scale1 = ") scale(";
            scale2 = ",1) translate(";
        }
        else {
            if (chartObj.svgRenderer._getAttrVal(bbdesigner$element, "plot") === "negative") {
                centerX = box.x;
                centerY = box.y;
			}
			else {
                 centerX = (box.x +box.width);
                 centerY = (box.y + box.height);
             }
            scale1 = ") scale(1,";
            scale2 = ") translate(";   
        }
        bbdesigner$element.animate(
            {
                scale: 1
            },
            {
                duration: 1000,
                complete: function () {
                    if (series.type.toLowerCase() == "waterfall")
                        bbdesigner$("#" + chartObj.svgObject.id + '_SeriesGroup' + '_waterfallLine_' + series.index).attr("visibility", "visible");
                },
                step: function (now) {
                    scaleVal = now; 
                    chartObj.svgRenderer._setAttr(bbdesigner$element, { "transform": "translate(" + centerX + " " + centerY + scale1 + scaleVal + scale2 + (-centerX) + " " + (-centerY) + ")" });
                }
            });
    },
    animateStackingRect: function (element, series, invertedAxes, chartObj) {
       var centerX, centerY, scale1, scale2, bbdesigner$element = bbdesigner$(element), boxX, boxY, scaleVal,
       box = BoldBIDashboard.EjSvgRender.utils._getBoundingClientRect(element, chartObj, series, invertedAxes);
        if ((series.isTransposed && invertedAxes) || invertedAxes) {
            boxX = (BoldBIDashboard.EjSvgRender.utils._valueToCoefficient(series.yAxis, 0)) * (series.yAxis.width);
            centerX = boxX;
            centerY = box.y;
			scale1 = ") scale(";
            scale2 = ",1) translate(";
        }
        else {
            boxY = (1 - BoldBIDashboard.EjSvgRender.utils._valueToCoefficient(series.yAxis, 0)) * (series.yAxis.height);
            centerX = box.x;
            centerY = boxY;
            scale1 = ") scale(1,";
            scale2 = ") translate(";
        }
        bbdesigner$element.animate(
            {
                scale: 1
            },
            {
                duration: 1000,

                step: function (now) {
                    scaleVal = now;
                    chartObj.svgRenderer._setAttr(bbdesigner$element, { "transform": "translate(" + centerX + " " + centerY + scale1 + scaleVal + scale2 + (-centerX) + " " + (-centerY) + ")" });
                }
            });
    },
    _doLineAnimation: function (chartObj, clipRect) {
		if (chartObj.model.requireInvertedAxes) {
            var height = parseFloat(chartObj.svgRenderer._getAttrVal(clipRect, "height"));
            //chartObj.svgRenderer._setAttr(bbdesigner$(clipRect), { "y": height });
            bbdesigner$(clipRect).animate(
                {
                    y: parseFloat(chartObj.svgRenderer._getAttrVal(clipRect, "y")),
                    clipRectHeight:parseFloat(chartObj.svgRenderer._getAttrVal(clipRect, "height")) 
                },
                {
                    duration: 2000,
                    step: function (now) {
                        chartObj.svgRenderer._setAttr(bbdesigner$(clipRect), { "y": height - now });
                        chartObj.svgRenderer._setAttr(bbdesigner$(clipRect), { "height": now});
                    }
                });
        }
		else
		{
          bbdesigner$(clipRect).animate(
            { 
			  clipRectWidth: parseFloat(chartObj.svgRenderer._getAttrVal(clipRect, "width")) 
			},
            {
                duration: 2000,
                step: function (now) {
                    chartObj.svgRenderer._setAttr(bbdesigner$(clipRect), { "width": now });
                }
            });
		} 
    },
    
    _drawLinePath: function (series, style, direction) {
        var requireInvertedAxes = this.chartObj.model.requireInvertedAxes;
		var trans;
        var seriesIndex = bbdesigner$.inArray(series, this.chartObj.model._visibleSeries);
        var translate = null;
        if (this.chartObj.model.AreaType == "cartesianaxes") {
            trans = BoldBIDashboard.EjSvgRender.utils._getTransform(series.xAxis, series.yAxis, requireInvertedAxes);
            translate = 'translate(' + trans.x + ',' + trans.y + ')'
        }
        
        var serOptions = { 'id': this.chartObj.svgObject.id + '_SeriesGroup' + '_' + seriesIndex, 'transform': translate };
        this.chartObj.gSeriesGroupEle =  this.gSeriesGroupEle = this.chartObj.svgRenderer.createGroup(serOptions);
        if (direction != "" && direction.indexOf("NaN") == -1) {
            var options = {
                'name': series.type,
                'id': this.chartObj.svgObject.id + "_Series" + seriesIndex,
                'fill': 'none',
                'stroke-dasharray': series.dashArray,
                'stroke-width': series.width,
                'stroke': style.SeriesInterior,
                'stroke-linecap': series.lineCap,
                'stroke-linejoin': series.lineJoin,
                'opacity': series.opacity,
                'd': direction
            };

            this.chartObj.svgRenderer.drawPath(options, this.gSeriesGroupEle);
        }

            
        },
        accumulationLayout: function (chartObj){
		  var radius = chartObj.model.totalRadius;
		
		  for (var i = 0; i < chartObj.model.series.length; i++) {
		      var currentseries = chartObj.model.series[i],
                seriesType = currentseries.type.toLowerCase(),
                svgWidth = bbdesigner$(chartObj.svgObject).width(),
                svgHeight = bbdesigner$(chartObj.svgObject).height();

            if (svgWidth <= 250 && svgHeight <= 200)
                currentseries.responsiveLabelPosition = "inside";
            else
                currentseries.responsiveLabelPosition = currentseries.labelPosition.toLowerCase();
				
            if (svgWidth <= 100 || svgHeight <= 100) {
			   currentseries.marker.dataLabel.responsiveVisibility = false;
			   chartObj.model.elementSpacing = 0;
			   chartObj.model.legend.responsiveVisibility = false;
			   chartObj.responsiveFlag = true;
			   this.responsiveAccLayout(1, currentseries, null, null, chartObj);
			}	
		  }
		  
           if (chartObj.responsiveFlag){
              if (((seriesType == "pie" || seriesType == "doughnut") && chartObj.model.Radius == radius)||
			        (seriesType == "pyramid" || seriesType == "funnel") && this.yOffset == radius){
			    chartObj.model.legend.responsiveVisibility = true;
				chartObj.model._titleLocation = !BoldBIDashboard.util.isNullOrUndefined(chartObj.model._tempTitleLocation) ? 
				                                chartObj.model._tempTitleLocation : chartObj.model._titleLocation;
			  }else {
			        chartObj.model.title.trimmedText = "";
                    var length = chartObj.svgObject.getElementsByTagName("g").length;
                    for (var i = 0; i < length; i++) {
                        var currentNode = chartObj.svgObject.getElementsByTagName("g")[i];
                        var id = currentNode.id;
                        if (id.indexOf("_ChartTitle") != -1){
                            bbdesigner$(currentNode).remove();
							break;
						}
                    }
				   chartObj.model.title.responsiveVisibility = false;
				   chartObj.model.title.subTitle.responsiveVisibility = false; 
                   chartObj.model._titleLocation = null;
                   chartObj.model.chartTitleRegion = null;
				   chartObj.model.chartSubTitleRegion = null;
			   }
			 }
		},
		
        responsiveAccLayout: function (count, currentseries, coefficient, doughnutSize, chartObj) {
            var chartObj = !BoldBIDashboard.util.isNullOrUndefined(chartObj) ? chartObj : this.chartObj;
            var model = chartObj.model, legend = model.legend, margin = model.margin, title = model.title,
                        type = !currentseries ? "" : currentseries.type.toLowerCase(),
                        legend = model.legend,
                        legendPosition =!BoldBIDashboard.util.isNullOrUndefined(legend.responsivePosition) ? legend.responsivePosition : legend.position.toLowerCase();
            switch (count) {
			    case 3:
					model.elementSpacing = 0;
			    case 2 || 3:
				    legend.responsiveVisibility = false;
                case 1 || 2 || 3:
				    model._titleLocation = BoldBIDashboard.util.isNullOrUndefined(model._titleLocation) ? null : model._titleLocation;
                    model._tempTitleLocation = !BoldBIDashboard.util.isNullOrUndefined(model._tempTitleLocation) ? model._tempTitleLocation : model._titleLocation;
                    model._titleLocation = null;
					model.title.responsiveVisibility = false;
					model.title.subTitle.responsiveVisibility = false;
					break;
                default:
                    chartObj.flag = true
            }

            if (model.AreaType == "polaraxes") {
                BoldBIDashboard.EjAxisRenderer.prototype._polarRadius();
            }
            else if (type == "doughnut") {
                size = this.calculatingSliceAngle(currentseries);
                this.getCompleteRadius(chartObj, size);
            }
            else if (type == "pie") {
                size = this.calculatingSliceAngle(currentseries);
                this.getCompleteRadius(chartObj, size);
            }
            else if (type == "pyramid" || type == "funnel") {
                var legendWidth = model.legend.border.width;
                var measureTitle = (model.title.text && model.title.responsiveVisibility && model.title.visible) ? BoldBIDashboard.EjSvgRender.utils._measureText(title.text, bbdesigner$(this.svgObject).width() - margin.left - margin.right, title.font) : 0;
                this.xOffset = (margin.left + model.elementSpacing + margin.right + model.elementSpacing);
                this.yOffset = (((title.text && !BoldBIDashboard.util.isNullOrUndefined(model._titleLocation)) ? (model._titleLocation.Y + measureTitle.height) : model.elementSpacing) + margin.top + model.elementSpacing + margin.bottom + model.elementSpacing);
                if (legend.visible && legend.responsiveVisibility){
				   this.xOffset += ((legendPosition === "right" || legendPosition === "left") ? model.LegendActualBounds.Width + (2 * legendWidth) : 0);
				   this.yOffset += ((legendPosition === "top" || legendPosition === "bottom") ? model.LegendActualBounds.Height + (2 * legendWidth) : 0);
				}
			  }
            },
    
    getRadius: function (chartObj, seriesIndex, size){
		var currentSeries = chartObj.model._visibleSeries[seriesIndex];
		var value = currentSeries.type.toLowerCase() == "pie" ? currentSeries.pieCoefficient: currentSeries.doughnutSize;
		currentSeries._pieCoefficient =  currentSeries.pieCoefficient;
		currentSeries._doughnutSize = currentSeries.doughnutSize;
		currentSeries._doughnutCoefficient =  currentSeries.doughnutCoefficient;
		if(chartObj.model.circularRadius.length>1){
			for (i = seriesIndex;!BoldBIDashboard.util.isNullOrUndefined(currentSeries.zOrder) ? i >= 0 : i < chartObj.model.circularRadius.length; !BoldBIDashboard.util.isNullOrUndefined(currentSeries.zOrder) ? i-- : i++) {
            if (!BoldBIDashboard.util.isNullOrUndefined(chartObj.model.circularRadius[i])) {
                chartObj.model.circularRadius[seriesIndex] = chartObj.model.circularRadius[i] * value;
                break;
            }
          }
       }
        else
			chartObj.model.circularRadius[seriesIndex] = 0.5 * value * Math.min(size.width, size.height); 	
    },
	
	getCompleteRadius: function (chartObj, size){
       for(var j= chartObj.model._visibleSeries.length-1; j>=0 ; j-- ){
        var currentSeries = chartObj.model._visibleSeries[j];
        var value = currentSeries.type.toLowerCase() == "pie" ? currentSeries.pieCoefficient: currentSeries.doughnutSize;
        currentSeries._pieCoefficient =  currentSeries.pieCoefficient;
        currentSeries._doughnutSize = currentSeries.doughnutSize;
        currentSeries._doughnutCoefficient =  currentSeries.doughnutCoefficient;
        if(chartObj.model._circularRadius.length>1){
            for (i = j;!BoldBIDashboard.util.isNullOrUndefined(currentSeries.zOrder) ? i >= 0 : i < chartObj.model._circularRadius.length; !BoldBIDashboard.util.isNullOrUndefined(currentSeries.zOrder) ? i-- : i++) {
                if (!BoldBIDashboard.util.isNullOrUndefined(chartObj.model._circularRadius[i])) {
                    chartObj.model._circularRadius[j] = chartObj.model._circularRadius[i] * value;
                    break;
                }
            }
        }
        else
            chartObj.model._circularRadius[j] = 0.5 * value * Math.min(size.width, size.height);
      }
					
        for(i=0; i< chartObj.model._circularRadius.length; i++)
            chartObj.model.totalRadius += chartObj.model._circularRadius[i];
    },

    drawDataLabel: function (series, index, point, x, y, chartRegionIndex, params) {
	       // method for data label symbols - cartesianaxes
        point.marker = point.marker ? point.marker : {};
		var labelFormat = series.yAxis.labelFormat,
        value = (series.type.toLowerCase() == "waterfall" && (point.showIntermediateSum || point.showTotalSum)) ? point.waterfallSum : point.y,
        pointText = (point.text) ? point.text : ((labelFormat) ? (labelFormat.indexOf("{value}") > -1 ? labelFormat.replace("{value}", value) : BoldBIDashboard.format(value,labelFormat)) : value);
       
        
		var	chart = this.chartObj,
			chartModel = chart.model,
			seriesIndex = bbdesigner$.inArray(series, chartModel._visibleSeries),
			textAlign, element,
			textBaseline, symbolName,
			marker = bbdesigner$.extend(true, {}, series.marker, point.marker),
			dataLabel = marker.dataLabel,
			dataLabelFont = dataLabel.font,
			textPosition = dataLabel.textPosition.toLowerCase(),
			textAnchor = dataLabel.textAnchor.toLowerCase(),
			type = series.type.toLowerCase(),
			size = BoldBIDashboard.util.isNullOrUndefined(dataLabelFont.size) ? "11px" : dataLabelFont.size,
			fontStyle = BoldBIDashboard.util.isNullOrUndefined(dataLabelFont.fontStyle) ? "Normal" : dataLabelFont.fontStyle,
			fontFamily = BoldBIDashboard.util.isNullOrUndefined(dataLabelFont.fontFamily) ? "Segoe UI" : dataLabelFont.fontFamily,
			labelfont = { size: size, fontStyle: fontStyle, fontFamily: fontFamily },
			textOffset = BoldBIDashboard.EjSvgRender.utils._measureText(pointText, null, labelfont),
			position = this.textPosition(series, seriesIndex, point, textOffset, type, x, y, chartRegionIndex, index, params),
			commonEventArgs = bbdesigner$.extend({}, BoldBIDashboard.EjSvgRender.commonChartEventArgs);
        commonEventArgs.data = { text: pointText, location: { x: position.x + chart.canvasX, y: position.y + chart.canvasY }, seriesIndex: seriesIndex, pointIndex: index };
        chart._trigger("displayTextRendering", commonEventArgs);
        var dataLabelOffset = (marker.dataLabel.offset.y==undefined) ? marker.dataLabel.offset : marker.dataLabel.offset.y;
        var xval = marker.dataLabel.offset.x;
		var textOffset = BoldBIDashboard.EjSvgRender.utils._measureText(commonEventArgs.data.text, null, labelfont);
        if (textPosition == 'bottom')
              commonEventArgs.data.location.y = commonEventArgs.data.location.y + dataLabelOffset;
        else
              commonEventArgs.data.location.y = commonEventArgs.data.location.y - dataLabelOffset;
        if (xval)                           
              commonEventArgs.data.location.x = commonEventArgs.data.location.x + xval;
                          
        if (!commonEventArgs.cancel)
        {
            var options = {
                'id': chart.svgObject.id + '_SeriesText' + index + seriesIndex,
                'x': commonEventArgs.data.location.x,
                'y': commonEventArgs.data.location.y,
                'fill': dataLabelFont.color,
                'font-size': dataLabelFont.size,
                'font-family': dataLabelFont.fontFamily,
                'font-style': dataLabelFont.fontStyle,
                'font-weight': dataLabelFont.fontWeight,
                'opacity': dataLabelFont.opacity,
                'text-anchor': textAnchor
            };
            var margin = dataLabel.margin,
                width = textOffset.width + margin.left + margin.right,
                height = textOffset.height + margin.top + margin.bottom,
                location = { X: commonEventArgs.data.location.x, Y: commonEventArgs.data.location.y };

            if (BoldBIDashboard.util.isNullOrUndefined(dataLabel.template)) {
				if (dataLabel.shape)
                    element = dataLabel.shape;
                else
                    element = "None";
                bbdesigner$.each(chartModel.symbolShape, function (name) {
                    if (element.toLowerCase() == name.toLowerCase())
                        symbolName = name;
                });
							
				var xXalue = commonEventArgs.data.location.x - (margin.left) / 2 + (margin.right) / 2,
                    yValue = commonEventArgs.data.location.y - (margin.top) / 2 - (height / margin.top) + (margin.bottom) / 2,
                    degree = isNaN(parseInt(dataLabel.angle)) ? 0 : parseInt(dataLabel.angle),
                    angle = (degree > 360) ? degree - 360 : (degree < -360) ? degree + 360 : degree;
							
 
							

                //For accurate placement of rotated data labels in canvas
				if (chartModel.enableCanvasRendering && (degree % 360 != 0)) {
				    options.y -= textOffset.height / 4;
				    options.baseline = 'middle';
				}

				if (series._enableSmartLabels) {
				    point.dataLabel = { textX: options.x, textY: options.y, x: xXalue, y: yValue, width: width, height: height }
				    point.margin = {top: margin.top, bottom: margin.bottom}
				}

				if (point.y == point.low && !(point.y === undefined && point.low === undefined)) //undefined condition checked for waterfall series sum value display
							    {
							        point.xPosLow = xXalue;
							        point.yPosLow = yValue;
							        point.widthLow = (symbolName == "None") ? textOffset.width : width;
							        point.heightLow = (symbolName == "None") ? textOffset.height : height;
							        point.textOptionsLow = options;
							        point.textOptionsLow.angle = angle;
							        point.drawTextLow = commonEventArgs.data.text;
							    }
							
							    else {
							        // storing the values in point
							    point.textOptions = options;
								if (angle != 0)
							    point.textOptions.angle = angle;
							    point.drawText = commonEventArgs.data.text;
							    point.index = index;
							    point.xPos = xXalue;
							    point.yPos = yValue;
							    point.seriesIndex = seriesIndex;
							    point.width = (symbolName == "None") ? textOffset.width : width;
							    point.height = (symbolName == "None") ? textOffset.height : height;
								if (angle == 90 || angle == -90) //Swapping datalabel text height and width value
							    point.width = [point.height, point.height = point.width][0];
							    point.symbolName = symbolName;
							   }
						}
            else {
					location.X -= chart.canvasX;
					location.Y -= chart.canvasY;
					this.drawLabelTemplate(series, point, index, location, chart);
                }                             
        }
    },

    //smart labels for pie and doughnut

    updateSmartLabelPosition: function (currentseries, point, pointIndex, bounds, midAngle, startPoint, textOffset, size, sender, seriesIndex) {
        var renderingPoints = [],
            chartObj = sender,
            chartModel = chartObj.model,
            legend = chartModel.legend,
            legendActualBounds = chartModel.LegendActualBounds,
            legendPosition = !BoldBIDashboard.util.isNullOrUndefined(legend.responsivePosition) ? legend.responsivePosition : legend.position.toLowerCase(),
            labelPosition = chartModel.adaptiveRendering ? currentseries.responsiveLabelPosition : currentseries.labelPosition.toLowerCase(),
            seriesType = new BoldBIDashboard.seriesTypes[currentseries.type.toLowerCase()](),
            connectorDirection = "",
			bezierPoints="",
            connectorX = bounds.connector.connectorX,
            connectorY = bounds.connector.connectorY,
            midX = bounds.midPoint.midX,
            midY = bounds.midPoint.midY,
            dMidX = bounds.doughnutMidPoint.dMidX,
            dMidY = bounds.doughnutMidPoint.dMidY,
            startX = startPoint.startX,
            startY = startPoint.startY,
            marker = bbdesigner$.extend(true, {}, currentseries.marker, point.marker),
            textGap = (marker.dataLabel.template) ? 0 : 4,
            outerX,
            radius,
            isIntersectedLabel,
            angle = midAngle,
            smartAngle = (currentseries.startAngle > currentseries.endAngle) ? -0.01 : 0.01,
            connectorType = marker.dataLabel.connectorLine.type.toLowerCase(),
            previousLeft, type = currentseries.type.toLowerCase(),
            radius = chartModel.circularRadius[seriesIndex]; 
      
        if (BoldBIDashboard.util.isNullOrUndefined(chartModel.bounds[seriesIndex])){
            chartModel.bounds[seriesIndex] = [];
            chartModel.bounds[seriesIndex].points = [];
            if (labelPosition == 'outsideextended') {
                chartModel.bounds[seriesIndex].points["left"] = [];
                chartModel.bounds[seriesIndex].points["right"] = [];
            }
        }

        //calculation for inside labels
        if (labelPosition == 'inside' && BoldBIDashboard.util.isNullOrUndefined(point.smartLabelPosition)) {
            positionX = (midX + startX) / 2;
            positionY = (midY + startY) / 2;

            positionX = (midX + positionX) / 2;
            positionY = (midY + positionY) / 2;

			point.hide = false;
            if (point.isIntersected && chartModel.bounds[seriesIndex].points[point.index]) {
                currBounds = chartModel.bounds[seriesIndex].points[point.index];
            }
            else {
                if (midX > startX)
                    currBounds = { X: positionX, Y: positionY, Left: positionX, Top: positionY, Right: positionX + size.width, Bottom: positionY + size.height,SeriesIndex:seriesIndex,PointIndex:pointIndex };
                else
                    currBounds = { X: positionX, Y: positionY, Left: positionX - size.width, Top: positionY, Right: positionX, Bottom: positionY + size.height,SeriesIndex:seriesIndex,PointIndex:pointIndex };
             }

            do {
                isIntersectedLabel = false;
                if (!this.IntersectWith(chartObj, point, currBounds, "inside", seriesIndex)) continue;
                previousLeft = currBounds.Left;
                angle += smartAngle;
                point.isIntersected = true;
                currBounds.Angle = angle;
                if (midX > startX) {
                    currBounds.X = currBounds.Left = seriesType.getXCordinate(startX, (radius) + textOffset, angle);
                    currBounds.Right = currBounds.X + size.width;
                }
                else {
                    currBounds.X = currBounds.Right = seriesType.getXCordinate(startX, (radius) + textOffset, angle);
                    currBounds.Left = currBounds.Right - size.width;
                }
                currBounds.Y = currBounds.Top = seriesType.getYCordinate(startY, (radius) + textOffset, angle);
                currBounds.Bottom = currBounds.Y + size.height;
                isIntersectedLabel = true;

                var pointStartAngle = -.5 * Math.PI;
                //chart start the angle from -90. So it will break the loop if angle > endAngle of series
                if (angle > ((currentseries.endAngle * Math.PI / 180) + pointStartAngle)) {
                    point.hide = true;
                    isIntersectedLabel = false;
                }

            } while (isIntersectedLabel)
            if (midX > startX && currBounds.X < startX) {
                currBounds.Right = previousLeft;
                currBounds.Left = previousLeft - size.width;
            }
            
            if (point.isIntersected && currBounds.Angle) {

                positionX = seriesType.getXCordinate(startX, (radius) + textOffset, currBounds.Angle);
                positionY = seriesType.getYCordinate(startY, (radius) + textOffset, currBounds.Angle);

                var connectorMidX = seriesType.getXCordinate(startX, (radius) + textOffset / 3, midAngle);
                var connectorMidY = seriesType.getYCordinate(startY, (radius) + textOffset / 3, midAngle);
                renderingPoints.push({ X: midX, Y: midY });
                renderingPoints.push({ X: connectorMidX, Y: connectorMidY });
                renderingPoints.push({ X: positionX, Y: positionY });
                if (point.isIntersected && connectorType == 'bezier' && !chartObj.vmlRendering) {
                    bezierPoints = seriesType.drawBezierSegment(renderingPoints, currentseries, pointIndex, chartObj, seriesIndex);
                }
                connectorDirection = "M" + " " + midX + " " + midY + " " + "L" + " " + connectorMidX + " " + connectorMidY + " " + "M" + " " + connectorMidX + " " + connectorMidY + " " + "L" + " " + positionX + " " + positionY;

            }			
			
            if (!point.hide && point.isIntersected) {
                var lineColl = [], l1, l2, centerXY, paddingR = 5, pathLength = 2;

                lineColl.push({ x: (radius + paddingR) * Math.cos(midAngle) + startPoint.startX, y: (radius + paddingR) * Math.sin(midAngle) + startPoint.startY });
                lineColl.push({ x: connectorMidX, y: connectorMidY });
                lineColl.push({ x: positionX, y: positionY });
                centerXY = { x: startPoint.startX, y: startPoint.startY };

                for (var j = 0; j < pathLength; j++) {
                    l1 = lineColl[j];
                    l2 = lineColl[j + 1];
                    //Check whether connector line intersect with pie segment
                    if (this.collision_circle_line(centerXY, radius, l1, l2)) {
                        point.hide = true;
                        midX = midY = connectorMidX = connectorMidY = outerX = 0;
                        currBounds = {
                            X: 0, Y: 0, Left: 0, Right: 0, Bottom: 0, Top: 0, Angle: currBounds.Angle,
                            PointIndex: currBounds.PointIndex, SeriesIndex: currBounds.SeriesIndex
                        };
                        break;
                    }
                }
            }
            //Remove interseted connector line start here
            var contrBnds = [], length;
            contrBnds.push({ x: midX, y: midY });
            contrBnds.push({ x: connectorMidX, y: connectorMidY });
            contrBnds.push({ x: currBounds.X, y: currBounds.Y });
            contrBnds.push({ x: outerX, y: currBounds.Y });
            if (!chartModel.connectorBounds)
                chartModel.connectorBounds = [];
            length = chartModel.connectorBounds.length;

            if (length == 0) {
                chartModel.connectorBounds.push(contrBnds);
            }
            else {
                var crntBnds, p1x, p1y, p2x, p2y, p3x, p3y, p4x, p4y, lineIntersect = false, connectorLength = 3;
                for (var l = 0; l < length; l++) {
                    crntBnds = chartModel.connectorBounds[l];
                    for (var m = 0; m < connectorLength; m++) {
                        p1x = contrBnds[m].x, p1y = contrBnds[m].y, p2x = contrBnds[m + 1].x, p2y = contrBnds[m + 1].y;
                        for (var n = 0; n < connectorLength; n++) {
                            p3x = crntBnds[n].x, p3y = crntBnds[n].y, p4x = crntBnds[n + 1].x, p4y = crntBnds[n + 1].y;
                            if (this.lineSegmentsIntersect(p1x, p1y, p2x, p2y, p3x, p3y, p4x, p4y)) {
                                lineIntersect = true;
                                break;
                            }
                        }
                        if (lineIntersect) {
                            break;
                        }
                    }
                    if (lineIntersect) {
                        var emptyXY = { x: 0, y: 0 }, bndsLength = 4;
                        contrBnds = [];
                        for (var t = 0; t < bndsLength; t++) contrBnds.push(emptyXY);
                        point.hide = true;
                        currBounds = {
                            X: 0, Y: 0, Left: 0, Right: 0, Bottom: 0, Top: 0,
                            PointIndex: currBounds.PointIndex, SeriesIndex: currBounds.SeriesIndex
                        };
                        break;
                    }
                }
                chartModel.connectorBounds[pointIndex] = contrBnds;
            }
            // End here

            chartModel.bounds[seriesIndex].points[pointIndex] = currBounds;
        }

       //calculation for outside labels
        else if (labelPosition == 'outside' || point.smartLabelPosition =="outside") {
           
		    point.hide = false;
            if (midX >= startX) 
                currBounds = { X: connectorX, Y: connectorY, Left: connectorX, Top: connectorY, Right: connectorX + size.width, Bottom: connectorY + size.height, SeriesIndex: seriesIndex, PointIndex: pointIndex };
           else
                currBounds = { X: connectorX, Y: connectorY, Left: connectorX - size.width, Top: connectorY, Right: connectorX, Bottom: connectorY + size.height, SeriesIndex: seriesIndex, PointIndex: pointIndex };
            var textPos;
            do {
                isIntersectedLabel = false;
               if (!this.IntersectWith(chartObj, point, currBounds, "outside", seriesIndex)) continue;
				 previousLeft = currBounds.Left;
                angle += smartAngle;
				 textPos = seriesType.getXCordinate(startX, (radius) + textOffset, angle);
                point.isIntersected = true;
                if (textPos > startX) {
                    currBounds.X = currBounds.Left = textPos
                    currBounds.Right = currBounds.X + size.width;
                }
                else {
                    currBounds.X = currBounds.Right = textPos;
                    currBounds.Left =  currBounds.Right - size.width;
                }

                currBounds.Y = currBounds.Top = seriesType.getYCordinate(startY, (radius) + textOffset, angle);              
                currBounds.Bottom = currBounds.Y + size.height;
                isIntersectedLabel = true;
				if (angle > 5.18 + currentseries.start){
					point.hide = true;
					isIntersectedLabel = false;
				}
            } while (isIntersectedLabel)
			 if (midX > startX && currBounds.X < startX) {
                currBounds.Right = previousLeft;
                currBounds.Left = previousLeft - size.width;
			 }
         	 
            var connectorMidX = seriesType.getXCordinate(startX, (radius) + textOffset / 3, midAngle);
            var connectorMidY = seriesType.getYCordinate(startY, (radius) + textOffset / 3, midAngle);

            renderingPoints.push({ X: midX, Y: midY });
            renderingPoints.push({ X: connectorMidX, Y: connectorMidY });
            renderingPoints.push({ X: currBounds.X, Y: currBounds.Y });
            positionX = currBounds.X;
            positionY = currBounds.Y;
            if (textOffset > 0) {
                if (currBounds.X < startX) {
                    outerX = currBounds.X - chartModel.elementSpacing;
                    positionX = outerX - textGap;
                }
                else {
						outerX = currBounds.X + chartModel.elementSpacing;
						positionX = outerX + textGap;
                }
                renderingPoints.push({ X: outerX, Y: currBounds.Y });
            }
			
            //Check whether connector line intersect with pie segment
            if (!point.hide && !chartModel.explode) {
			    var lineColl = [], l1, l2, centerXY, paddingR = 5, pathLength = 3;

                lineColl.push({ x: (radius + paddingR) * Math.cos(midAngle) + startPoint.startX, y: (radius + paddingR) * Math.sin(midAngle) + startPoint.startY });
                lineColl.push({ x: connectorMidX, y: connectorMidY });
                lineColl.push({ x: currBounds.X, y: currBounds.Y });
                lineColl.push({ x: outerX, y: currBounds.Y });
                centerXY = { x: startPoint.startX, y: startPoint.startY };

                for (var j = 0; j < pathLength; j++) {
                    l1 = lineColl[j];
                    l2 = lineColl[j + 1];                   
                    if (this.collision_circle_line(centerXY, radius, l1, l2)) {
                        point.hide = true;
                        midX = midY = connectorMidX = connectorMidY = outerX = 0;
                        currBounds = {
                            X: 0, Y: 0, Left: 0, Right: 0, Bottom: 0, Top: 0,
                            PointIndex: currBounds.PointIndex, SeriesIndex: currBounds.SeriesIndex
                        };
                        break;
                    }
                }
            }
            //End

            //Remove interseted connector line start here
                var contrBnds = [], length;
                contrBnds.push({ x: midX, y: midY });
                contrBnds.push({ x: connectorMidX, y: connectorMidY });
                contrBnds.push({ x: currBounds.X, y: currBounds.Y });
                contrBnds.push({ x: outerX, y: currBounds.Y });
                if (!chartModel.connectorBounds)
                    chartModel.connectorBounds = [];
                length = chartModel.connectorBounds.length;

                if (length == 0) {
                    chartModel.connectorBounds.push(contrBnds);
                }
                else if (!chartModel.explode) {
                    var crntBnds, p1x, p1y, p2x, p2y, p3x, p3y, p4x, p4y, lineIntersect = false, connectorLength = 3;
                    for (var l = 0; l < length; l++) {
                        crntBnds = chartModel.connectorBounds[l];
                        for (var m = 0; m < connectorLength; m++) {
                            p1x = contrBnds[m].x, p1y = contrBnds[m].y, p2x = contrBnds[m + 1].x, p2y = contrBnds[m + 1].y;
                            for (var n = 0; n < connectorLength; n++) {
                                p3x = crntBnds[n].x, p3y = crntBnds[n].y, p4x = crntBnds[n + 1].x, p4y = crntBnds[n + 1].y;
                                if (this.lineSegmentsIntersect(p1x, p1y, p2x, p2y, p3x, p3y, p4x, p4y)) {
                                    lineIntersect = true;
                                    break;
                                }
                            }
                            if (lineIntersect) {
                                break;
                            }
                        }
                        if (lineIntersect) {
                            var emptyXY = { x: 0, y: 0 }, bndsLength = 4;
                            contrBnds = [];
                            for (var t = 0; t < bndsLength; t++) contrBnds.push(emptyXY);
                            point.hide = true;
                            currBounds = {
                                X: 0, Y: 0, Left: 0, Right: 0, Bottom: 0, Top: 0,
                                PointIndex: currBounds.PointIndex, SeriesIndex: currBounds.SeriesIndex
                            };
                            break;
                        }
                    }                    
                    chartModel.connectorBounds[pointIndex] = contrBnds;
                }
                // End intersectConnectorline 
                currBounds.positionX = positionX;
                chartModel.bounds[seriesIndex].points[pointIndex] = currBounds;

               //Check the connector line intersect with other segment text
                if (chartModel.bounds[seriesIndex].points.length > 1 && !point.hide && !chartModel.explode) {
                    var textRegions = chartModel.bounds[seriesIndex].points, connectorLength = 3, lineIntersect;
                    var conctrLineBnds = chartModel.connectorBounds[pointIndex],
                        p1x, p1y, p2x, p2y, rect, emptyXY, textAnchor, textPadding = 1.5;
                    
                    for (var t = 0; t < textRegions.length - 1; t++) {
                        textAnchor = (textRegions[t].positionX < startX) ? 'end' : 'start';
                        rect = {
                            x1: textAnchor == 'start' ? textRegions[t].positionX : textRegions[t].positionX - size.width, //minX
                            y1: textRegions[t].Y - size.height + (size.height / 4) - textPadding, //minY
                            x2: textAnchor == 'start' ? textRegions[t].positionX + size.width : textRegions[t].positionX, //maxX 
                            y2: textRegions[t].Y + (size.height / 4) + textPadding //maxY                                                     
                        };
                        for (var m = 0; m < connectorLength; m++) {
                            p1x = contrBnds[m].x, p1y = contrBnds[m].y, p2x = contrBnds[m + 1].x, p2y = contrBnds[m + 1].y;
                            lineIntersect = this.lineTextIntersect(p1x, p1y, p2x, p2y, rect.x1, rect.y1, rect.x2, rect.y2);
                            if (lineIntersect) {
                                emptyXY = { x: 0, y: 0 }, bndsLength = 4;
                                conctrLineBnds = [];
                                for (var l = 0; l < bndsLength; l++) conctrLineBnds.push(emptyXY);
                                point.hide = true;
                                currBounds = {
                                    X: 0, Y: 0, Left: 0, Right: 0, Bottom: 0, Top: 0,
                                    PointIndex: currBounds.PointIndex, SeriesIndex: currBounds.SeriesIndex,
                                    positionX : positionX
                                };
                                chartModel.bounds[seriesIndex].points[pointIndex] = currBounds;
                                break;
                            }
                        }
                        if (lineIntersect) break;
                    }
                }
                //End

            if (connectorType == 'bezier' && !chartObj.vmlRendering) {
                bezierPoints = seriesType.drawBezierSegment(renderingPoints, currentseries, pointIndex, chartObj, seriesIndex);
            }
            else {
                connectorDirection = "M" + " " + contrBnds[0].x + " " + contrBnds[0].y + " " + "L" + " " + contrBnds[1].x + " " + contrBnds[1].y + " " + "M" + " " + contrBnds[1].x + " " + contrBnds[1].y + " " + "L" + " " + contrBnds[2].x + " " + contrBnds[2].y + " " + "M" + " " + contrBnds[2].x + " " + contrBnds[2].y + " " + "L" + " " + contrBnds[3].x + " " + contrBnds[3].y;
            }
            if (BoldBIDashboard.util.isNullOrUndefined(chartModel.dataLabelSeries[seriesIndex])) {
                chartModel.dataLabelSeries[seriesIndex] = [];
                chartModel.dataLabelSeries[seriesIndex].dataLabelInfo = [];
            }
            var dataLabelInfo = { positionX: positionX, positionY: positionY, connectorDirection: connectorDirection, isInterSected: point.isIntersected, bezierPath: bezierPoints, textBounds: currBounds, connecterLinePath: contrBnds, visible: point.hide };

            if (!chartModel.explode && !chartModel.explodeOut)
                chartModel.dataLabelSeries[seriesIndex].dataLabelInfo[pointIndex] = dataLabelInfo;
            if (chartModel.explodeOut) { 
                dataLabelInfo = chartModel.dataLabelSeries[seriesIndex].dataLabelInfo[pointIndex];
                point.hide = dataLabelInfo.visible;
                chartModel.connectorBounds[pointIndex] = dataLabelInfo.connecterLinePath;
                chartModel.bounds[seriesIndex].points[pointIndex] = dataLabelInfo.textBounds;
            }
            return dataLabelInfo;
        }


         //calculation for outsideExtended labels
        else {
            var labelX = midX;
            var labelY = midY;

            midX = midX + (Math.cos((midAngle)) * (-(radius / 10)));
            midY = midY + (Math.sin((midAngle)) * (-(radius / 10)));

            var connectorHeight = radius / 4;

            renderingPoints.push({ X: midX, Y: midY });
            midX = midX + (Math.cos((midAngle)) * connectorHeight);
            midY = midY + (Math.sin((midAngle)) * connectorHeight);

            renderingPoints.push({ X: midX, Y: midY });

            var legendWidth = (legend.visible && legend.responsiveVisibility && legendPosition == "left") ? (chartModel.margin.left + legendActualBounds.Width) : 0;
            var centerX = chartModel.circleCenterX[seriesIndex];
            var labelEdge;

            if (midX < startX) {

                midX = ((centerX - radius - (connectorHeight * 2) - currentseries.LeftLabelMaxWidth > 0)
                                 ? centerX - radius - (connectorHeight * 2) + legendWidth
                                 : (currentseries.LeftLabelMaxWidth > labelX) ? labelX : currentseries.LeftLabelMaxWidth + legendWidth) - size.width / 2;

                labelEdge = renderingPoints[1].X - currentseries.LeftLabelMaxWidth;

                var height = (centerX - radius - (connectorHeight * 2) - currentseries.LeftLabelMaxWidth > 0) ? connectorHeight
                             : (currentseries.LeftLabelMaxWidth > labelX) ? 0
                             : (labelEdge > 3 * (connectorHeight / 2)) ? connectorHeight : labelEdge / 2;

                connectorLineEdge = +size.width / 2;

            }
            else {
                var legendRight = (legend.visible && legend.responsiveVisibility && legendPosition == "right") ? (chartModel.margin.right + legendActualBounds.Width) : 0;
                midX = ((centerX + radius + (connectorHeight * 2) + currentseries.RightLabelMaxWidth < bbdesigner$(chartObj.svgObject).width() - legendRight)
               ? centerX + radius + (connectorHeight * 2) - legendWidth
               : ((centerX + radius + currentseries.RightLabelMaxWidth) > bbdesigner$(chartObj.svgObject).width()) ? labelX : bbdesigner$(chartObj.svgObject).width() - currentseries.RightLabelMaxWidth - legendRight) + size.width / 2;


                labelEdge = (bbdesigner$(chartObj.svgObject).width() - currentseries.RightLabelMaxWidth) - renderingPoints[1].X;

                var height = (centerX + radius + (connectorHeight * 2) + currentseries.RightLabelMaxWidth < bbdesigner$(chartObj.svgObject).width()) ? connectorHeight
                            : ((centerX + radius + currentseries.RightLabelMaxWidth) > bbdesigner$(chartObj.svgObject).width()) ? 0
                            : (labelEdge > 3 * (connectorHeight / 2)) ? connectorHeight : labelEdge / 2;
                connectorLineEdge = -size.width / 2;
            }

            var distanceFromOrigin = (Math.sqrt(Math.pow(labelX - midX, 2) + Math.pow(labelY - midY, 2))) / 10;

            var isLeft = (midX < startX) ? true : false;
            midX = isLeft ? midX + distanceFromOrigin : midX - distanceFromOrigin;
            var index = isLeft ? 1 : -1;

            var bounds = isLeft ? chartModel.bounds[seriesIndex].points["left"] : chartModel.bounds[seriesIndex].points["right"];
            var currBounds = { X: midX, Y: midY, Left: midX, Top: midY, Right: midX + size.width, Bottom: midY + size.height, index: pointIndex, SeriesIndex: seriesIndex, PointIndex: pointIndex };
            if (this.IntersectWith(chartObj, point, currBounds, "outsideExtended", seriesIndex)) {
                renderingPoints.push(midX < startX
                       ? { X: midX + height + connectorLineEdge, Y: midY }
                       : { X: midX - height + connectorLineEdge, Y: midY });
                midY = (BoldBIDashboard.util.isNullOrUndefined(bounds[point.index + index])) ? currBounds.Bottom + 2 : bounds[point.index + index].Bottom + 2;

                currBounds.Y = midY;
                currBounds.Top = midY;
                currBounds.Bottom = midY + size.height;
            }
            renderingPoints.push({ X: midX + connectorLineEdge, Y: midY });
            if (centerX < renderingPoints[0].X && (renderingPoints[1].X > renderingPoints[2].X))
                renderingPoints[2].X = renderingPoints[1].X;
            if (centerX > renderingPoints[0].X && (renderingPoints[1].X < renderingPoints[2].X))
                renderingPoints[2].X = renderingPoints[1].X;
            if (!isLeft) {
                chartModel.bounds[seriesIndex].points["right"][point.index] = (currBounds);
                if (renderingPoints[renderingPoints.length - 1].X < renderingPoints[renderingPoints.length - 2].X)
                    renderingPoints[renderingPoints.length - 2].X = renderingPoints[renderingPoints.length - 1].X;
               
            }
            else {
                chartModel.bounds[seriesIndex].points["left"][point.index] = (currBounds);
                if (renderingPoints[renderingPoints.length - 1].X > renderingPoints[renderingPoints.length - 2].X)
                    renderingPoints[renderingPoints.length - 2].X = renderingPoints[renderingPoints.length - 1].X;
            }


            connectorDirection = BoldBIDashboard.EjSvgRender.utils._getStringBuilder();
            if (connectorType == 'bezier' && !chartObj.vmlRendering) {
                bezierPoints=seriesType.drawBezierSegment(renderingPoints, currentseries, pointIndex, chartObj,seriesIndex);
            }
            else {
                for (k = 0; k < renderingPoints.length; k++) {
                    if (k == renderingPoints.length - 1)
                        connectorDirection.append(" ");
                    else
                        connectorDirection.append("M" + " " + (renderingPoints[k].X) + " " + (renderingPoints[k].Y) + " " + "L" + " " + (renderingPoints[k + 1].X) + " " + (renderingPoints[k + 1].Y) + " ");
                }
                connectorDirection = connectorDirection.toString();
            }
            positionX = renderingPoints[renderingPoints.length - 1].X + ((midX < startX) ? -textGap : textGap);
            positionY = renderingPoints[renderingPoints.length - 1].Y;
        }
        
        return { positionX: positionX, positionY: positionY, connectorDirection: connectorDirection, isInterSected:point.isIntersected,bezierPath:bezierPoints };
    },

    //Check line intersect with circle 
    collision_circle_line: function (cXY, r, line1, line2) {
        var x1 = line1.x, y1 = line1.y, x2 = line2.x, y2 = line2.y, cX = cXY.x, cY = cXY.y,
        dx = x2 - x1, dy = y2 - y1,
        sx = x1 - cX, sy = y1 - cY,
        tx = x2 - cX,
        ty = y2 - cY;

        if (tx * tx + ty * ty < r * r) return true;

        var c = sx * sx + sy * sy - r * r;
        if (c < 0) return true;

        var b = 2 * (dx * sx + dy * sy);
        var a = dx * dx + dy * dy;

        if (Math.abs(a) < 1.0e-12) return false;

        var discr = b * b - 4 * a * c;
        if (discr < 0) return false;
        discr = Math.sqrt(discr);

        var k1 = (-b - discr) / (2 * a);
        if (k1 >= 0 && k1 <= 1) return true;

        var k2 = (-b + discr) / (2 * a);
        if (k2 >= 0 && k2 <= 1) return true;

        return false;
    },
	
	//Check whether two connetor lines are intersected
    lineSegmentsIntersect: function (x1, y1, x2, y2, x3, y3, x4, y4) {
        var p1_dx = x2 - x1;
        var p1_dy = y2 - y1;
        var p2_dx = x4 - x3;
        var p2_dy = y4 - y3;
        var s = (-p1_dy * (x1 - x3) + p1_dx * (y1 - y3)) / (-p2_dx * p1_dy + p1_dx * p2_dy);
        var t = (+p2_dx * (y1 - y3) - p2_dy * (x1 - x3)) / (-p2_dx * p1_dy + p1_dx * p2_dy);
        return (s >= 0 && s <= 1 && t >= 0 && t <= 1);
    },

    //Check connectorline intersect with text
    lineTextIntersect: function (x1, y1, x2, y2, minX, minY, maxX, maxY) {  
        // Completely outside.
        if ((x1 <= minX && x2 <= minX) || (y1 <= minY && y2 <= minY) || (x1 >= maxX && x2 >= maxX) || (y1 >= maxY && y2 >= maxY))
            return false;

        var m = (y2 - y1) / (x2 - x1);

        var y = m * (minX - x1) + y1;
        if (y > minY && y < maxY) return true;

        y = m * (maxX - x1) + y1;
        if (y > minY && y < maxY) return true;

        var x = (minY - y1) / m + x1;
        if (x > minX && x < maxX) return true;

        x = (maxY - y1) / m + x1;
        if (x > minX && x < maxX) return true;

        return false;
    },
	
    updateLabelPosition: function (currentseries, point, pointIndex, bounds, midAngle, startPoint, textOffset, size, sender, seriesIndex){

        var renderingPoints=[];
        var chartObj=sender; 
        var seriesType = new BoldBIDashboard.seriesTypes[currentseries.type.toLowerCase()]();
        var connectorDirection = "";

        var connectorX = bounds.connector.connectorX;
        var connectorY = bounds.connector.connectorY;
        var midX = bounds.midPoint.midX;
        var midY = bounds.midPoint.midY;
        var dMidX = bounds.doughnutMidPoint.dMidX;
        var dMidY = bounds.doughnutMidPoint.dMidY;
        var startX = startPoint.startX;
        var startY = startPoint.startY;
        var marker = bbdesigner$.extend(true, {}, currentseries.marker, point.marker);
        var textGap = (marker.dataLabel.template) ? 0 :4;
		var legend = chartObj.model.legend;
        var position = !BoldBIDashboard.util.isNullOrUndefined(legend.responsivePosition) ? legend.responsivePosition : legend.position.toLowerCase();
        var labelPosition = chartObj.model.adaptiveRendering ? currentseries.responsiveLabelPosition : currentseries.labelPosition.toLowerCase();
        var outerX;
        var radius = chartObj.model.circularRadius[seriesIndex];

        //calculation for outside labels

        renderingPoints.push({ X: midX, Y: midY });
        renderingPoints.push({ X: connectorX, Y: connectorY });
        positionX = connectorX;
        positionY = connectorY;

        if (labelPosition == 'outside') {
            if (textOffset > 0) {
                if (connectorX < startX) {
                    outerX = connectorX - chartObj.model.elementSpacing;
                    positionX = outerX - textGap;
                }
                else {
                    outerX = connectorX + chartObj.model.elementSpacing;
                    positionX = outerX + textGap;
                }
                renderingPoints.push({ X: outerX, Y: connectorY });
            } 
           
            if (marker.dataLabel.connectorLine.type.toLowerCase() == 'bezier' && !chartObj.vmlRendering) {
                seriesType.drawBezierSegment(renderingPoints, currentseries, pointIndex, chartObj,seriesIndex);
            }
            else {
                connectorDirection = "M" + " " + midX + " " + midY + " " + "L" + " " + connectorX + " " + connectorY + " " + "M" + " " + connectorX + " " + connectorY +" "+ "L" + " " + outerX + " " + connectorY;
            }
          
        }


            //calculation for outsideextended labels
        else if (labelPosition == 'outsideextended') {

            labelX=midX;
            labelY=midY;

            midX = midX + (Math.cos((midAngle)) * (-(radius / 10)));
            midY = midY + (Math.sin((midAngle)) * (-(radius / 10)));


            var renderingPoints = [];

            var connectorHeight = radius / 4;

            renderingPoints.push({ X: midX, Y: midY });
            connectorX = midX + (Math.cos((midAngle)) * connectorHeight);
            connectorY = midY + (Math.sin((midAngle)) * connectorHeight);

            renderingPoints.push({ X: connectorX, Y: connectorY });

            var legendWidth = (chartObj.model.legend.visible && chartObj.model.legend.responsiveVisibility && (position == "left" || position == "right")) ? (chartObj.model.elementSpacing) : 0;

            if (midX < startX) {
                connectorX = (chartObj.model.centerX - radius - (connectorHeight * 2) - currentseries.LeftLabelMaxWidth > 0)
                                     ? chartObj.model.centerX - radius - (connectorHeight * 2) + legendWidth
                                     : (currentseries.LeftLabelMaxWidth > labelX) ? labelX : currentseries.LeftLabelMaxWidth;
            }
            else {
                connectorX = (chartObj.model.centerX + radius + (connectorHeight * 2) + currentseries.RightLabelMaxWidth < bbdesigner$(chartObj.svgObject).width())
                     ? chartObj.model.centerX + radius + (connectorHeight * 2) - legendWidth
                     : ((chartObj.model.centerX + radius + currentseries.RightLabelMaxWidth) > bbdesigner$(chartObj.svgObject).width()) ? labelX : bbdesigner$(chartObj.svgObject).width() - currentseries.RightLabelMaxWidth;
                      
            }

            renderingPoints.push({ X: connectorX, Y: connectorY });

            connectorDirection = BoldBIDashboard.EjSvgRender.utils._getStringBuilder();
            if (marker.dataLabel.connectorLine.type.toLowerCase() == 'bezier' && !chartObj.vmlRendering) {
                seriesType.drawBezierSegment(renderingPoints, currentseries, pointIndex, chartObj, seriesIndex);
            }
            else {
                for (k = 0; k < renderingPoints.length; k++) {
                    if (k == renderingPoints.length - 1)
                        connectorDirection.append(" ");
                    else
                        connectorDirection.append("M" + " " + (renderingPoints[k].X) + " " + (renderingPoints[k].Y) + " " + "L" + " " + (renderingPoints[k + 1].X) + " " + (renderingPoints[k + 1].Y) + " ");
                }
                connectorDirection = connectorDirection.toString();
            }
            positionX = renderingPoints[renderingPoints.length - 1].X + ((midX < startX) ? -textGap : textGap);;
            positionY = renderingPoints[renderingPoints.length - 1].Y;
        }

       //calculation for inside labels

        else {
            if (currentseries.type.toLowerCase() == "doughnut") {
                positionX = (midX + dMidX) / 2;
                positionY = (midY + dMidY) / 2;
            }
            else {
                positionX = (midX + startX) / 2;
                positionY = (midY + startY) / 2;

                positionX = (midX + positionX) / 2;
                positionY = (midY + positionY) / 2;
            }
        }

        return { positionX: positionX, positionY: positionY, connectorDirection: connectorDirection };
    },
    // method to update the position of the data labels in pyramid chart
        updateSmartLabel: function (chartObj, currentseries, pointIndex, point) {
            // declaration
        var datalabelTemplateVisiblity = true,
            connectorDirection = "",
            labelPosition = chartObj.model.adaptiveRendering ? currentseries.responsiveLabelPosition : currentseries.labelPosition.toLowerCase(),
            marker = bbdesigner$.extend(true, {}, currentseries.marker, point.marker),
            dataLabel = marker.dataLabel,
            areaBounds = chartObj.model.m_AreaBounds,
			svgHeight = chartObj.model.svgHeight,
            type = currentseries.type.toLowerCase(),
            pyrX, pyrY, ele, xPos, yPos;
            point._labelPlacement = "";
            if (labelPosition == "inside" || labelPosition == "outsideextended")
                this.calculateInsideConnectorLines(pointIndex, point, currentseries, chartObj);
            else
                this.compareDataLabels(point, pointIndex, chartObj.model.outsideDataRegionPoints, currentseries, chartObj);

            pyrX = (chartObj.model.enableCanvasRendering && !dataLabel.template) ? chartObj.pyrX : 0;
            pyrY = (chartObj.model.enableCanvasRendering && !dataLabel.template) ? chartObj.pyrY : 0;
            if (type == "pyramid") {
                if ((chartObj.model.actualHeight< point.yPos - pyrY) || (point.xPos - pyrX > areaBounds.Width && point._labelPlacement == "insideoverlap") || (chartObj.model.legend.position == "right" && dataLabel.template && (point.xPos + point.width) > areaBounds.Width + chartObj.model.LegendActualBounds.Width)) {
                    datalabelTemplateVisiblity = false;
                    point.drawTextacc = "";
                }
            }
            else {
                if ((point.yPos - pyrY < 0) || (point.xPos - pyrX > areaBounds.Width && point._labelPlacement == "insideoverlap") || (chartObj.model.legend.position == "right" && dataLabel.template && (point.xPos + point.width) > areaBounds.Width + chartObj.model.LegendActualBounds.Width)) {
                    datalabelTemplateVisiblity = false;
                    point.drawTextacc = "";

                }
            }
            if ((labelPosition == "outside" || point._labelPlacement == "insideoverlap") && datalabelTemplateVisiblity)
                connectorDirection = this.drawConnectorLines(pointIndex, point, currentseries, chartObj);

            if (dataLabel.template) {
                ele = bbdesigner$("#" + point.id);
                if (!datalabelTemplateVisiblity) {
                    ele.css("display", "none");
                }
                else {
                    xPos = (point._labelPlacement == "insidenooverlap") ? point.textOptionsacc.x + chartObj.pyrX - point.width / 2 : point.textOptionsacc.x + chartObj.pyrX;
                    yPos = (point._labelPlacement == "insidenooverlap") ? point.textOptionsacc.y + chartObj.pyrY : point.textOptionsacc.y + chartObj.pyrY - chartObj.model.elementSpacing;
                    ele.css("left", xPos).css("top", yPos);
                    ele.css("height", point.height).css("overflow", "hidden");
                }
            }


            return { xPos: point.xPos, yPos: point.yPos, textOptionsacc: point.textOptionsacc, connectorDirection: connectorDirection.connectorDirection,bezierPath:connectorDirection.bezierdir, drawTextacc: point.drawTextacc };
        },
        // method to compare the data labels in chart for intersection
        compareDataLabels: function (point, pointIndex, outsideDataRegionPoints, currentseries, chartObj) {

            var marker = bbdesigner$.extend(true, {}, currentseries.marker, point.marker),
                dataLabel = marker.dataLabel,
                angle = isNaN(parseInt(dataLabel.angle)) ? 0 : parseInt(dataLabel.angle),
                prevLabel, collide, regionPoint, degree, angle, rotate,
                elementSpacing = chartObj.model.elementSpacing,
                margin = marker.dataLabel.margin,
				visiblePointslength = currentseries._visiblePoints.length,
				labelPosition = chartObj.model.adaptiveRendering ? currentseries.responsiveLabelPosition : currentseries.labelPosition.toLowerCase(),
                pyrX = (chartObj.model.enableCanvasRendering) ? chartObj.pyrX : 0,
                pyrY = (chartObj.model.enableCanvasRendering) ? chartObj.pyrY : 0;
            for (var j = 0, length = outsideDataRegionPoints.length; j < length ; j++) {
                prevLabel = outsideDataRegionPoints[j];
                collide = this.isCollide(prevLabel, point, currentseries);
                if (collide.state) {
                    if (labelPosition == "inside" || labelPosition == "outsideextended") {
                        point.textOptionsacc.y = point.yPos = point.textOptionsacc.y + collide.height;
                        positionPoint = (dataLabel.template) ? { x: point.xPos, y: point.yPos } : { x: point.xPos - pyrX, y: point.yPos - pyrY };
                        for (var k = 0, visibleLength = visiblePointslength ; k < visibleLength ; k++) {
                            regionPoint = (chartObj.isPointInPolygon(chartObj.model.chartRegions[0].Region[k].Polygon, positionPoint));
                            if (regionPoint) {
                                point.textOptionsacc.x = point.xPos = point.textOptionsacc.x + point.width;
                                positionPoint = (dataLabel.template) ? { x: point.xPos, y: point.yPos } : { x: point.xPos - pyrX, y: point.yPos - pyrY };
                            }
                        }
                    }
                    else {
                        point._labelPlacement = "outside";
                        point.textOptionsacc.y = point.yPos = (currentseries.type.toLowerCase() == "pyramid") ? point.yPos + collide.height + elementSpacing / 2 : point.yPos + collide.height - elementSpacing / 2;
                        point.textOptionsacc.y = point.textOptionsacc.y + point.height / 4 - elementSpacing / 2 + margin.top / 2 - margin.bottom / 2;
                    }
                }
            }
            degree = angle;
            angle = (degree > 360) ? degree - 360 : (degree < -360) ? degree + 360 : degree;
            rotate = 'rotate(' + angle + ',' + (point.textOptionsacc.x) + ',' + (point.textOptionsacc.y) + ')';
            bbdesigner$(point.textOptionsacc).attr('transform', rotate);
            bbdesigner$(point.textOptionsacc).attr('labelRotation', degree);//for canvas label rotation
            bbdesigner$(point.textOptionsacc).attr({
                'transform': rotate
            });
            if (labelPosition == "inside" || labelPosition == "outsideextended") {
                point.yPos = point.yPos + elementSpacing / 4;
                point.textOptionsacc.y = point.textOptionsacc.y + point.height / 4 + margin.top / 2 - margin.bottom / 2;
            }
            outsideDataRegionPoints[outsideDataRegionPoints.length] = point;
        },

        //Inside region checking and smartlabels
        calculateInsideConnectorLines: function (pointIndex, point, currentseries, chartObj) {

            var polygon = point.Polygon,
                marker = bbdesigner$.extend(true, {}, currentseries.marker, point.marker),
                dataLabel = marker.dataLabel,
                font = dataLabel.font, connectorHeight,
                pyrX = (chartObj.model.enableCanvasRendering) ? chartObj.pyrX : 0,
                pyrY = (chartObj.model.enableCanvasRendering) ? chartObj.pyrY : 0,
                //inside connector line height
                connectorLength = 70,
                datalabelWidth = BoldBIDashboard.EjSvgRender.utils._measureText(point.drawTextacc, null, font),
                positionPoint = (dataLabel.template) ? { x: point.xPos, y: point.yPos } : { x: point.xPos + (datalabelWidth.width / 2) - pyrX, y: point.yPos - (point.height / 2) - pyrY },
                regionPoint = chartObj.isPointInPolygon(polygon, positionPoint);
            if (!regionPoint) {
                point._labelPlacement = "insideoverlap";
                point.textOptionsacc['text-anchor'] = 'start';
                if (point.startX + connectorLength < chartObj.model.m_AreaBounds.Width)
                    connectorHeight = connectorLength;
                else
                    connectorHeight = chartObj.model.m_AreaBounds.Width - (point.startX);

                point.textOptionsacc.x = point.xPos = point.startX + connectorHeight;
                point.textOptionsacc.y = point.yPos = point.yLocation;
                if (chartObj.model.enableCanvasRendering && !dataLabel.template) {
                    point.textOptionsacc.x += chartObj.pyrX;
                    point.textOptionsacc.y += chartObj.pyrY;
                    point.xPos += chartObj.pyrX;
                    point.yPos += chartObj.pyrY;
                }
                this.compareDataLabels(point, pointIndex, chartObj.model.outsideDataRegionPoints, currentseries, chartObj);

            }

            else {
                point._labelPlacement = "insidenooverlap";
            }
        },
        //smartLabels connector Lines
        drawConnectorLines: function (index, currentPoint, currentseries, chartObj) {
            var bezierdir = "";
            var seriesType = new BoldBIDashboard.seriesTypes[currentseries.type.toLowerCase()](),
                startx = currentseries._visiblePoints[index].startX,
                starty = currentseries._visiblePoints[index].startY,
                connectorDirection = "",
				seriesIndex = bbdesigner$.inArray(currentseries, chartObj.model._visibleSeries),
                marker = bbdesigner$.extend(true, {}, currentseries.marker, currentPoint.marker),
                dataLabel = marker.dataLabel,
                endy = currentPoint.textOptionsacc.y - chartObj.model.elementSpacing / 2,
                pyrX = (chartObj.model.enableCanvasRendering) ? chartObj.pyrX : 0,
                pyrY = (chartObj.model.enableCanvasRendering) ? chartObj.pyrY : 0,
                renderingPoints = [{ X: startx + pyrX, Y: starty + pyrY },//bezier curve control points
                                   { X: currentPoint.textOptionsacc.x, Y: endy }];
            if (dataLabel.connectorLine.type.toLowerCase() == 'bezier' && !chartObj.vmlRendering)
                bezierdir =  seriesType.drawBezierSegment(renderingPoints, currentseries, index, chartObj, seriesIndex);
            else {
                connectorDirection = "M" + " " + (startx) + " " + (starty) + " " + "L" + " " + (currentPoint.textOptionsacc.x) + " " + (endy);
                if (chartObj.model.enableCanvasRendering && !dataLabel.template)
                    connectorDirection = "M" + " " + (startx) + " " + (starty) + " " + "L" + " " + (currentPoint.textOptionsacc.x - pyrX) + " " + (endy - pyrY);
            }
            return { connectorDirection: connectorDirection, bezierdir: bezierdir };
        },

        //method to detect collision between data labels
        isCollide: function (prevlabel, currentlabel, currentseries) {
            var width = 0,
                height = 0,
                type = currentseries.type.toLowerCase(),
                state;
            state = !(
           ((prevlabel.yPos + prevlabel.height) < (currentlabel.yPos)) ||
           (prevlabel.yPos > (currentlabel.yPos + currentlabel.height)) ||
           ((prevlabel.xPos + prevlabel.width / 2) < currentlabel.xPos - currentlabel.width / 2) ||
           ((prevlabel.xPos - prevlabel.width) > (currentlabel.xPos + currentlabel.width)));

            if (state && type == "pyramid") {
                height = ((prevlabel.yPos + prevlabel.height) - (currentlabel.yPos));
                width = (prevlabel.xPos + prevlabel.width) - currentlabel.xPos;
            }
            else if (state && type == "funnel") {
                height = ((prevlabel.yPos) - (currentlabel.yPos + currentlabel.height));
                width = (prevlabel.xPos + prevlabel.width) - currentlabel.xPos;
            }
            return { state: state, height: height, width: width };
        },
        // trimming the text when it exceeds chart area
        trimText: function (text, maxLength, ellipsis) {
            maxLength--;
            var length = maxLength - ellipsis.length;
            trimmedText = text.substr(0, length);
            return trimmedText + ellipsis;
        },

        //calculate a length of a text for datalabel trimming
        trimfunction: function (datalabelText, remainingWidth, datalabelLength, elipsis, axisWidth, font) {
            var datalabelText, datalabelLength;
            while (remainingWidth < datalabelLength) {
                datalabelText = this.trimText(datalabelText, datalabelText.length, elipsis);
                datalabelLength = BoldBIDashboard.EjSvgRender.utils._measureText(datalabelText, axisWidth, font).width;
                if (datalabelText == elipsis) {
                    datalabelText = "";
                    break;
                }
            }
            return datalabelText;
        },

        //To calculate start and end point of a text inside a pie and doughnut region
        calculatePosition: function (chartObj, textOptions, datalabelLength, startX, startY) {
            var rightEndX, rightEndY, leftEndX, leftEndY;            
            rightEndX = (textOptions.x + (datalabelLength / 2)) - startX;
            rightEndY = (textOptions.y) - (startY);
            leftEndX = (textOptions.x - (datalabelLength / 2)) - startX;
            leftEndY = textOptions.y - startY;
            return { rightEndX: rightEndX, rightEndY: rightEndY, leftEndX: leftEndX, leftEndY: leftEndY };
                        
        },

        //To caluculate textoptions
        textOption: function (currentseries, chartObj, textsize, pyrX, pyrY, pointIndex, textAnchor, positionX, positionY, seriesIndex, dataLabelFont) {
            var marker = bbdesigner$.extend(true, {}, currentseries.marker, currentseries._visiblePoints[pointIndex].marker), font, angle;
            if (!marker.dataLabel.template) {
                bbdesigner$("#" + chartObj.svgObject.id + 'series' + seriesIndex + '_PointText' + pointIndex).remove();
                font = dataLabelFont || marker.dataLabel.font;
                angle = isNaN(parseInt(marker.dataLabel.angle)) ? 0 : parseInt(marker.dataLabel.angle);
                var textOptions = {
                    'id': chartObj.svgObject.id + 'series' + seriesIndex + '_PointText' + pointIndex,
                    'x': positionX + pyrX,
                    'y': positionY + textsize.height / 4 + pyrY,
                    'fill': marker.dataLabel.font.color,
                    'font-size': marker.dataLabel.font.size,
                    'font-family': font.fontFamily,
                    'font-style': font.fontStyle,
                    'font-weight': font.fontWeight,
                    'opacity': font.opacity,
                    'text-anchor': textAnchor,
                    'cursor': 'default',
                    'degree':angle
                };
                //To rotate datalabels
                var degree = angle;
                var angle = (degree > 360) ? degree - 360 : (degree < -360) ? degree + 360 : degree;
                var rotate = 'rotate(' + angle + ',' + (positionX) + ',' + (positionY) + ')';
                bbdesigner$(textOptions).attr('transform', rotate);
                bbdesigner$(textOptions).attr('labelRotation', degree);//for canvas label rotation
                bbdesigner$(textOptions).attr({
                    'transform': rotate
                });
            }
            return textOptions;
        },

        //To trim  datalabel when it exceed a particular pie and doughnut region
        labelTrim: function (chartObj, textOptions, datalabelLength, datalabelText, startX, startY, point, font,seriesIndex) {
            var chartStartAngle = -.5 * Math.PI;
            var chartEndAngle = .5 * Math.PI;
            var position = this.calculatePosition(chartObj, textOptions, datalabelLength, startX, startY);
            var startAngle = chartObj.model.series[seriesIndex].startAngle;
            var endAngle = chartObj.model.series[seriesIndex].endAngle;
            var regionData = (chartObj.model.chartRegions.length <chartObj.model._visibleSeries.length) ? chartObj.model.chartRegions[0].Region : chartObj.model.chartRegions[seriesIndex].Region;
            var pointStartAngle, pointEndAngle;
            var distanceFromCenter;
            var textinRegion;
            var trimPosition, datalabelWidth;
            var ellipsis = "...";
            var firstStartAngle = [];
            var totalDegree = endAngle - startAngle;
            if (totalDegree < 0) {
                endAngle = endAngle / 360;
                var arcAngle = (endAngle) ? 2 * Math.PI * (endAngle < 0 ? 1 + endAngle : endAngle) : 0;
            }
            else
                var arcAngle = startAngle ? 2 * Math.PI * (chartObj.model.itemCurrentXPos < 0 ? 1 + chartObj.model.itemCurrentXPos : chartObj.model.itemCurrentXPos) : 0;            
            startAngle = (Math.atan2(position.rightEndY, position.rightEndX) - chartStartAngle - arcAngle) % (2 * Math.PI);
            if (startAngle < 0) startAngle = 2 * Math.PI + startAngle;
            endAngle = (Math.atan2(position.leftEndY, position.leftEndX) - chartStartAngle - arcAngle) % (2 * Math.PI);
            if (endAngle < 0) endAngle = 2 * Math.PI + endAngle;            
            pointStartAngle = parseFloat(point.start.toFixed(14));
            pointEndAngle = parseFloat(point.end.toFixed(14));
            if (totalDegree > 0) {
                if (BoldBIDashboard.util.isNullOrUndefined(chartObj.firstStartAngle[0])) {
                    chartObj.firstStartAngle.push(pointStartAngle);
                }
                pointStartAngle = (chartObj.firstStartAngle[0] < 0) ? 2 * Math.PI + pointStartAngle : pointStartAngle;
                pointEndAngle = (chartObj.firstStartAngle[0] < 0) ? 2 * Math.PI + pointEndAngle : pointEndAngle;
            }
            else {
                pointStartAngle = pointStartAngle < 0 ? 2 * Math.PI + pointStartAngle : pointStartAngle;
                pointEndAngle = pointEndAngle < 0 ? 2 * Math.PI + pointEndAngle : pointEndAngle;
            }
            pointStartAngle -= arcAngle;
            pointEndAngle -= arcAngle;
            if (startAngle < 0 && (endAngle > 0 || endAngle == null)) {
                pointStartAngle = pointStartAngle < 0 ? 2 * Math.PI + pointStartAngle : pointStartAngle;
                pointEndAngle = pointEndAngle <= 0 ? 2 * Math.PI + pointEndAngle : pointEndAngle;
            }
            if (chartObj.model.circleCenterX[seriesIndex] < textOptions.x) {
                distanceFromCenter = Math.sqrt(Math.pow(Math.abs(position.rightEndX), 2) + Math.pow(Math.abs(position.rightEndY), 2));
            }
            else
                distanceFromCenter = Math.sqrt(Math.pow(Math.abs(position.leftEndX), 2) + Math.pow(Math.abs(position.leftEndY), 2));            
            if (totalDegree < 0) {               
                pointEndAngle = [pointStartAngle, pointStartAngle = pointEndAngle][0];
            }            
            if ((endAngle >= pointStartAngle && endAngle <= pointEndAngle) && (startAngle >= pointStartAngle && startAngle <= pointEndAngle) && (distanceFromCenter <= chartObj.model.circularRadius[seriesIndex] && distanceFromCenter > 0)) {
                textinRegion = true;
            }
            else {
                textinRegion = false;
                while (!textinRegion) {
                   datalabelText = this.trimText(datalabelText, datalabelText.length, ellipsis);
                   if (datalabelText == ellipsis) {
                       datalabelText = "";
                       break;
                   }  
                   datalabeltWidth = BoldBIDashboard.EjSvgRender.utils._measureText(datalabelText, null, font);
                   trimPosition = this.calculatePosition(chartObj, textOptions, datalabeltWidth.width, startX, startY);
                   startangle = (Math.atan2(trimPosition.rightEndY, trimPosition.rightEndX) - chartStartAngle - arcAngle) % (2 * Math.PI);
                   if (startangle < 0) startangle = 2 * Math.PI + startangle;
                   var endAngle = (Math.atan2(trimPosition.leftEndY, trimPosition.leftEndX) - chartStartAngle - arcAngle) % (2 * Math.PI);
                   if (endAngle < 0) endAngle = 2 * Math.PI + endAngle;
                   if (chartObj.model.circleCenterX[seriesIndex]< textOptions.x) {
                      distanceFromCenter = Math.sqrt(Math.pow(Math.abs(trimPosition.rightEndX), 2) + Math.pow(Math.abs(trimPosition.rightEndY), 2));
                   }
                   else
                      distanceFromCenter = Math.sqrt(Math.pow(Math.abs(trimPosition.leftEndX), 2) + Math.pow(Math.abs(trimPosition.leftEndY), 2));
                   if ((endAngle >= pointStartAngle && endAngle <= pointEndAngle) && (startangle >= pointStartAngle && startangle <= pointEndAngle) && (distanceFromCenter <= chartObj.model.circularRadius[seriesIndex] && distanceFromCenter > 0)) {
                      textinRegion = true;
                   }
                 }
            }
                        
         return datalabelText;
        },
    
    
        drawDataLabelAcc: function (sender, currentseries, pointIndex, point, seriesIndex) {
            // method for data label symbols - accumulation series	
            var pointMarker = point.marker;
            if (point.visible && ((pointMarker && pointMarker.dataLabel && pointMarker.dataLabel.visible) || (!pointMarker || !pointMarker.dataLabel) && currentseries.marker.dataLabel.visible && currentseries.marker.dataLabel.responsiveVisibility)) {
                var chartObj = sender,
                    type = currentseries.type.toLowerCase(),
                    seriesType = new BoldBIDashboard.seriesTypes[type](),
                    isNull = BoldBIDashboard.util.isNullOrUndefined,
                    _labelPosition = chartObj.model.adaptiveRendering ? currentseries.responsiveLabelPosition : currentseries.labelPosition.toLowerCase(),
                    chartModel = chartObj.model,
					chartTitle = chartModel.title,
                    measureText = BoldBIDashboard.EjSvgRender.utils._measureText,
                    elementSpacing = chartModel.elementSpacing,
                    seriesMarker = currentseries.marker,
                    dataLabel = seriesMarker.dataLabel,
                    margin = dataLabel.margin,
                    dataLabelFont = bbdesigner$.extend({},dataLabel.font),                        
                    datalabelText, datalabelLength, remainingWidth,
                    axisWidth = chartModel.m_AreaBounds.Width + chartModel.m_AreaBounds.X + chartModel.margin.left,
                    connectorLine = dataLabel.connectorLine,
                    connectorType = connectorLine.type.toLowerCase(),
                    legend = chartModel.legend,
                    legendPosition = !BoldBIDashboard.util.isNullOrUndefined(legend.responsivePosition) ? legend.responsivePosition : legend.position.toLowerCase(),
                    legendActualBounds = chartModel.LegendActualBounds,
                    text = isNull(point.text) ? point.y : point.text
                var connectorDirection, labelfont,
                    commonEventArgs, textsize,
                    positionX = 0, textWidth, textHeight,
                    positionY = 0,
                    pointColor;

                if ((type == "pyramid" || type == "funnel") && _labelPosition == 'outsideextended')
                    _labelPosition = 'inside';

                commonEventArgs = bbdesigner$.extend({}, BoldBIDashboard.EjSvgRender.commonChartEventArgs);
                commonEventArgs.data = { text: text, series: currentseries, pointIndex: pointIndex };
                chartObj._trigger("displayTextRendering", commonEventArgs);

                labelfont = { size: dataLabelFont.size, fontStyle: dataLabelFont.fontStyle, fontFamily: dataLabelFont.fontFamily };
                textsize = measureText(commonEventArgs.data.text, null, labelfont);
                textWidth = textsize.width + margin.left + margin.right;
                textHeight = textsize.height + margin.top + margin.bottom;

                if (type == "pyramid" || type == "funnel") {
                    var measureTitle = (chartModel.title.text) ? measureText(chartModel.title.text, bbdesigner$(this.svgObject).width() - chartModel.margin.left - chartModel.margin.right, chartModel.title.font) : 0;
                    var mesureSubTitle = (chartObj.model.title.subTitle.text) ? BoldBIDashboard.EjSvgRender.utils._measureText(chartObj.model.title.subTitle.text, bbdesigner$(this.svgObject).width() - chartObj.model.margin.left - chartObj.model.margin.right, chartObj.model.title.subTitle.font) : 0;
                    var subtitleHeight = (chartObj.model.title.subTitle.text === '') ? 0 : mesureSubTitle.height;
                    var pyrX = elementSpacing + chartModel.margin.left + (legendPosition === "left") ? (legendActualBounds.Width) : 0;
                    var pyrY = ((legendPosition === "top") ? (legendActualBounds.Height) : 0) + ((chartModel.title.text && !BoldBIDashboard.util.isNullOrUndefined(chartModel._titleLocation)) ? (chartModel._titleLocation.Y + measureTitle.height + subtitleHeight) : (chartModel.margin.top + elementSpacing));
                    textWidth = textWidth + 10;
                    var Location = { X: point.xLocation + chartObj.pyrX, Y: point.yLocation + chartObj.pyrY };
                    positionX = point.xLocation;
                    positionY = point.yLocation;
                    var marker = point.marker ? point.marker : seriesMarker;
                    marker = bbdesigner$.extend(true, {}, seriesMarker, marker);
                    connectorDirection = point.connectorLine;
                    symbolPos = { positionX: positionX, positionY: positionY };
                }

                if (type != "pyramid" && type != "funnel") {
                    var chartStartingAngle = -.5 * Math.PI,
                        midAngle = point.midAngle + chartStartingAngle,
                        midPoint, doughnutMidPoint, connector, bounds,
                        startPoint,
                        measureTitle = (chartModel.title.text) ? measureText(chartModel.title.text, bbdesigner$(this.svgObject).width() - chartModel.margin.left - chartModel.margin.right, chartModel.title.font) : 0,
                        mesureSubTitle = (chartObj.model.title.subTitle.text) ? BoldBIDashboard.EjSvgRender.utils._measureText(chartObj.model.title.subTitle.text, bbdesigner$(this.svgObject).width() - chartObj.model.margin.left - chartObj.model.margin.right, chartObj.model.title.subTitle.font) : 0,
                        subtitleHeight = (chartObj.model.title.subTitle.text === '') ? 0 : mesureSubTitle.height,
                        textOffset, startX, startY, midX, midY, dMidX, dMidY, connectorX, connectorY,
                        renderingPoints = [],
                        radius = chartModel.circularRadius[seriesIndex],
                        svgWidth = bbdesigner$(chartObj.svgObject).width(),
                        svgHeight = bbdesigner$(chartObj.svgObject).height();

                    // This condition is removed due to datalabel crop issue (JS-63856)
                     if (currentseries._enableSmartLabels && (svgWidth < 250 || svgHeight < 250)) {
                         dataLabelFont.size = "9px"; //Change pie/doughnut text size dynamically
                         size = measureText(commonEventArgs.data.text, svgWidth, dataLabelFont);
                         textOffset = 10;
                     }
                    if (isNull(connectorLine.height))
                        textOffset = textOffset || measureText(commonEventArgs.data.text, null, dataLabelFont).height;
                    else
                        textOffset = connectorLine.height;

                    if ((currentseries._visiblePoints[point.index].actualIndex == currentseries.explodeIndex || currentseries.explodeAll) && !chartObj.vmlRendering) {
                        startX = chartModel.circleCenterX[seriesIndex] + Math.cos(midAngle) * currentseries.explodeOffset;
                        startY = chartModel.circleCenterY[seriesIndex] + Math.sin(midAngle) * currentseries.explodeOffset;
                    }
                    else {
                        startX = chartModel.circleCenterX[seriesIndex];
                        startY = chartModel.circleCenterY[seriesIndex];
                    }
                    midX = seriesType.getXCordinate(startX, (radius), midAngle);
                    midY = seriesType.getYCordinate(startY, (radius), midAngle);

                    dMidX = seriesType.getXCordinate(startX, (chartModel.innerRadius[seriesIndex]), midAngle);
                    dMidY = seriesType.getYCordinate(startY, (chartModel.innerRadius[seriesIndex]), midAngle);

                    connectorX = this.getXCordinate(startX, (radius) + textOffset, midAngle);
                    connectorY = this.getYCordinate(startY, (radius) + textOffset, midAngle);

                    if (dataLabel.template)
                        size = point.size;
                    else {
                        var marker = point.marker ? point.marker : seriesMarker,
                            marker = bbdesigner$.extend(true, {}, seriesMarker, marker);
                        shape = marker.dataLabel.shape;
                        size = measureText(commonEventArgs.data.text, svgWidth, dataLabelFont);
                        
                        if (shape.toLowerCase() != "none") {
                            size.height = size.height + margin.top + margin.bottom;
                            size.width = size.width + margin.left + margin.right;
                        }
                    }

                    midPoint = { midX: midX, midY: midY };
                    doughnutMidPoint = { dMidX: dMidX, dMidY: dMidY };
                    connector = { connectorX: connectorX, connectorY: connectorY };
                    bounds = { midPoint: midPoint, doughnutMidPoint: doughnutMidPoint, connector: connector };
                    startPoint = { startX: startX, startY: startY };

                    if (!currentseries._enableSmartLabels) {
                        position = seriesType.updateLabelPosition(currentseries, point, point.index, bounds, midAngle, startPoint, textOffset, size, sender, seriesIndex);
                        positionX = position.positionX;
                        positionY = position.positionY;
                        connectorDirection = position.connectorDirection;
                    }
                        // smart labels

                    else {
                        position = seriesType.updateSmartLabelPosition(currentseries, point, point.index, bounds, midAngle, startPoint, textOffset, size, sender, seriesIndex);
                        positionX = position.positionX;
                        positionY = position.positionY;
                        if (_labelPosition == "outside" || _labelPosition == "outsideextended") {
                            var centerX = chartModel.circleCenterX[seriesIndex], centerY = chartModel.circleCenterY[seriesIndex],
                                borderWidth = chartObj.model.border.width;
                            if (centerX < positionX)
                                remainingWidth = axisWidth - positionX;
                            else
                                remainingWidth = legendPosition == "left" ? (positionX - (legendActualBounds.Width + borderWidth + elementSpacing * 2)) : (positionX - elementSpacing);

                            datalabelText = (typeof commonEventArgs.data.text == "string") ? commonEventArgs.data.text : commonEventArgs.data.text.toString();
                            datalabelText = point.hide ? "" : datalabelText;
                            datalabelLength = measureText(datalabelText, datalabelText.length, dataLabelFont).width;
                            if (datalabelLength > remainingWidth) {

                                if ((positionX > centerX && positionY > centerY) || (positionX < centerX && positionY < centerY))//rightBottom, topLeft
                                    midAngle = point.startAngle + ((point.endAngle - point.startAngle) * 0.75) + chartStartingAngle; // 0.75 is point midAngle moved to 3/4'th of the segment 
                                else //rightTop, bottomLeft point midAngle moved to 1/4'th position of the segment
                                    midAngle = point.startAngle + ((point.endAngle - point.startAngle) / 4) + chartStartingAngle;

                                connectorX = this.getXCordinate(startX, (radius) + textOffset, midAngle);
                                connectorY = this.getYCordinate(startY, (radius) + textOffset, midAngle);
                                dMidX = seriesType.getXCordinate(startX, (chartModel.innerRadius[seriesIndex]), midAngle);
                                dMidY = seriesType.getYCordinate(startY, (chartModel.innerRadius[seriesIndex]), midAngle);
                                midX = seriesType.getXCordinate(startX, (radius), midAngle);
                                midY = seriesType.getYCordinate(startY, (radius), midAngle);
                                midPoint = { midX: midX, midY: midY };
                                connector = { connectorX: connectorX, connectorY: connectorY };
                                doughnutMidPoint = { dMidX: dMidX, dMidY: dMidY };
                                bounds = { midPoint: midPoint, doughnutMidPoint: doughnutMidPoint, connector: connector }; 
                                chartObj.model.bounds[seriesIndex].points.splice(point.index, 1); // Remove the existing stored region for the point text
                                chartObj.model.connectorBounds.splice(point.index, 1); // Remove the existing stored region for the connectorLine
                                position = seriesType.updateSmartLabelPosition(currentseries, point, point.index, bounds, midAngle, startPoint, textOffset, size, sender, seriesIndex);

                                positionX = position.positionX;
                                positionY = position.positionY;
                            }
                        }
                        symbolPos = { positionX: positionX, positionY: positionY, isInterSected: position.isInterSected };
                        connectorDirection = position.connectorDirection;
                    }
                }
                var textAnchor = ((_labelPosition != 'inside' && _labelPosition != 'insidenooverlap') || ((type == "pyramid" || type == "funnel") && _labelPosition == 'outside')) ? ((positionX < chartModel.circleCenterX[seriesIndex]) ? 'end' : 'start') : 'middle',
                    width = (_labelPosition == 'inside' || _labelPosition == 'insidenooverlap') ? 0 : (positionX < chartModel.circleCenterX[seriesIndex]) ? -textsize.width : textsize.width,
                    pyrX = 0, pyrY = 0, textOptions;

                if ((type == "pie" || type == "doughnut") && _labelPosition == "inside")
                    textAnchor = (position.connectorDirection != "") ? ((positionX < chartModel.circleCenterX[seriesIndex]) ? 'end' : 'start') : 'middle';
                if ((type == "pyramid" || type == "funnel") && _labelPosition == "outside")
                    textAnchor = 'start';

                var subtitleHeight = (chartObj.model.title.subTitle.text === '') ? 0 : mesureSubTitle.height;
                if ((this.chartObj && chartModel.enableCanvasRendering) && (type == "pyramid" || type == "funnel")) {
                    pyrX = ((legendPosition === "left") ? (legendActualBounds.Width) : 0) + elementSpacing + chartModel.margin.left;
                    pyrY = ((legendPosition === "top") ? (legendActualBounds.Height) : 0) + ((chartTitle.text) ? (chartModel._titleLocation.Y + measureTitle.height + subtitleHeight) : (chartModel.margin.top + elementSpacing));
                }
                textOptions = this.textOption(currentseries, chartObj, textsize, pyrX, pyrY, point.index, textAnchor, positionX, positionY, seriesIndex, dataLabelFont);
                if (dataLabel.template) {
                    Location = isNull(Location) ? { X: positionX, Y: positionY } : Location;
                    var pointindex = point.actualIndex;
                    seriesType.drawLabelTemplate(currentseries, point, pointindex, Location, sender);
                    if (connectorType == "bezier" && (position.bezierPath) != "")
                        sender.svgRenderer.drawPolyline(position.bezierPath, sender.gConnectorEle[seriesIndex]);
                }
                else {
                    bbdesigner$.each(chartModel.symbolShape, function (name) {
                        marker = point.marker ? point.marker : seriesMarker;
                        marker = bbdesigner$.extend(true, {}, seriesMarker, marker);
                        shape = marker.dataLabel.shape;
                        if (shape.toLowerCase() == name.toLowerCase())
                            symbolName = name;
                    });

                    positionX = pyrX + positionX - (margin.left) / 2 + (margin.right) / 2 + width / 2;
                    positionY = pyrY + positionY - (margin.top) / 2 + (margin.bottom) / 2;
                    //SmartLabels value storing for pyramid and funnel
                    if (type == "pyramid" || type == "funnel") {
                        point.xPos = symbolPos.positionX + pyrX;
                        point.yPos = symbolPos.positionY + pyrY;
                        point.width = (symbolName == "None") ? textsize.width : textWidth;
                        point.height = (symbolName == "None") ? textsize.height : textHeight;
                        point.symbolName = (dataLabel.template) ? "none" : symbolName;
                        point.textOptionsacc = textOptions;
                        point.drawTextacc = commonEventArgs.data.text;
                    }
                    //For accurate placement of rotated data labels in canvas
                    if (chartModel.enableCanvasRendering && (textOptions.degree % 360 != 0)) {
                        textOptions.y -= (textsize.height / 4);
                        textOptions.baseline = 'middle';
                    } if (currentseries._enableSmartLabels) {
                        var labelPosition = (chartObj.model.adaptiveRendering) ? currentseries.responsiveLabelPosition : currentseries.labelPosition.toLowerCase(),
                            enableCanvasRendering = chartModel.enableCanvasRendering,
                            legendBounds,
                            legendWidth = 0, legendHeight = 0;
                        datalabelText = (typeof commonEventArgs.data.text == "string") ? commonEventArgs.data.text : commonEventArgs.data.text.toString(),
                            datalabelText = point.hide ? "" : datalabelText,
                           datalabelLength = measureText(datalabelText, datalabelText.length, dataLabelFont).width;
                        if (legend.visible && legend.responsiveVisibility) {
                            if (legendPosition == "left" || legendPosition == "right")
                                legendBounds = legendActualBounds;
                        }
                        else
                            legendBounds = { Width: 0 };

                        if (type == "pie" || type == "doughnut") {
                            var legendViewerBounds = currentseries._legendBounds;
                            if (labelPosition == "outside" || labelPosition == "outsideextended" || position.connectorDirection != "") {
                               
                                if (chartModel.circleCenterX[seriesIndex] < textOptions.x) {
                                    remainingWidth = legendPosition == "right" ? (axisWidth - textOptions.x) : (axisWidth - textOptions.x);
                                    if (legendPosition == "right") {
                                        if (textOptions.y < legendViewerBounds.y || textOptions.y > legendViewerBounds.y + legendViewerBounds.height)
                                            remainingWidth += legendViewerBounds.width;
                                    }
                                }
                                else {
                                    remainingWidth = legendPosition == "left" ? (textOptions.x - (legendBounds.Width + legendViewerBounds.x)) : (textOptions.x - elementSpacing);
                                    if (legendPosition == "left") {
                                        if (textOptions.y < legendViewerBounds.y || textOptions.y > legendViewerBounds.y + legendViewerBounds.height)
                                            remainingWidth += legendViewerBounds.width;
                                    }
                                }
                                datalabelText = this.trimfunction(datalabelText, remainingWidth, datalabelLength, "...", axisWidth, dataLabelFont);

                                if (legend.visible && (legendPosition == 'top' || legendPosition == 'bottom')) {
                                    datalabelText = this._overlapLegend(textOptions, datalabelText, sender, seriesIndex, legendPosition);
                                }
                            }
                            if (labelPosition == "inside" && (position.connectorDirection == "")) {
                                datalabelText = this.labelTrim(chartObj, textOptions, datalabelLength, datalabelText, startX, startY, point, dataLabelFont, seriesIndex);
                                if (datalabelText == "") {
                                    point.smartLabelPosition = "outside";
                                    position = seriesType.updateSmartLabelPosition(currentseries, point, point.index, bounds, midAngle, startPoint, textOffset, size, sender, seriesIndex);
                                    symbolPos = { positionX: position.positionX, positionY: position.positionY, isInterSected: position.isInterSected };
                                    datalabelText = commonEventArgs.data.text;
                                    connectorDirection = position.connectorDirection;
                                    textAnchor = (chartModel.circleCenterX[seriesIndex]< position.positionX) ? "start" : "end";
                                    textOptions = this.textOption(currentseries, chartObj, textsize, pyrX, pyrY, point.index, textAnchor, position.positionX, position.positionY, seriesIndex, dataLabelFont);
                                    if (chartModel.circleCenterX[seriesIndex]< position.positionX){
                                        remainingWidth = legendPosition == "right" ? (axisWidth - textOptions.x) : (axisWidth - textOptions.x);
                                        if (legendPosition == "right") {
                                            if (textOptions.y < legendViewerBounds.y || textOptions.y > legendViewerBounds.y + legendViewerBounds.height)
                                                remainingWidth += legendViewerBounds.width;
                                        }
                                    }
                                    else {
                                        remainingWidth = legendPosition == "left" ? (textOptions.x - (legendBounds.Width + legendViewerBounds.x)) : (textOptions.x - elementSpacing);
                                        if (legendPosition == "left") {
                                            if (textOptions.y < legendViewerBounds.y || textOptions.y > legendViewerBounds.y + legendViewerBounds.height)
                                                remainingWidth += legendViewerBounds.width;
                                        }
                                    }
                                    datalabelText = this.trimfunction(datalabelText, remainingWidth, datalabelLength, "...", axisWidth, dataLabelFont);
                                    delete point.smartLabelPosition;
                                }
                            }
                        }
                        else if ((type == "pyramid" || type == "funnel")) {
                            position = seriesType.updateSmartLabel(sender, currentseries, point.index, point);
                            positionX = position.xPos;
                            positionY = position.yPos;
                            connectorDirection = position.connectorDirection;
                            textOptions = position.textOptionsacc;
                            datalabelText = point.drawTextacc;

                            if ((connectorDirection != "" || connectorType == "bezier") && datalabelText != "") {

                                if (legendPosition == "right")
                                    remainingWidth = (enableCanvasRendering) ? (axisWidth - textOptions.x) : (axisWidth - textOptions.x - chartObj.pyrX);
                                else if (legendPosition == "left")
                                    remainingWidth = enableCanvasRendering ? (axisWidth - textOptions.x) : (axisWidth - textOptions.x - chartObj.pyrX);
                                else if (legendPosition == "top")
                                    remainingWidth = (enableCanvasRendering) ? (axisWidth - textOptions.x) : axisWidth - textOptions.x - chartObj.pyrX;
                                else
                                    remainingWidth = (enableCanvasRendering) ? (axisWidth - textOptions.x) : axisWidth - textOptions.x - chartObj.pyrX;
                                if (remainingWidth < datalabelLength)
                                    datalabelText = this.trimfunction(datalabelText, remainingWidth, datalabelLength, "...", axisWidth, dataLabelFont);
                            }
                        }

                        var datalabelShape = measureText(datalabelText, null, dataLabelFont);
                        if (type == "pie" || type == "doughnut")
                            var width = ((_labelPosition == 'inside' || _labelPosition == 'insidenooverlap') && !symbolPos.isInterSected && connectorDirection == "") ? 0 : (positionX < chartModel.circleCenterX[seriesIndex]) ? -datalabelShape.width : datalabelShape.width;
                        else if (type == "pyramid" || type == "funnel")
                            var width = (point._labelPlacement == "insidenooverlap") ? 0 : datalabelShape.width;
                        if (type == "pie" || type == "doughnut") {
                            positionX = pyrX + symbolPos.positionX - (margin.left) / 2 + (margin.right) / 2 + (width / 2);
                            positionY = pyrY + symbolPos.positionY - (margin.top) / 2 + (margin.bottom) / 2;
                        }
                        else {
                            positionX = positionX - (margin.left) / 2 + (margin.right) / 2 + (width / 2);
                            positionY = positionY - (margin.top) / 2 + (margin.bottom) / 2;
                        }
                        var dataLabelEle = bbdesigner$('#' + chartObj.svgObject.id + '_dataLabel_series' + seriesIndex+ "_point_"+ pointIndex);
						var conEle = bbdesigner$('#' + chartObj.svgObject.id + "_connectorLine_series"+ seriesIndex+"_point_" + pointIndex);
						if(datalabelText!== ""){
						dataLabelEle.show();
						conEle.show();
							seriesType.dataLabelSymbol(seriesIndex, currentseries, point.index, positionX, positionY, textWidth, textHeight, symbolName, chartObj);
							if (connectorType == "bezier" && (position.bezierPath) != "" && !(BoldBIDashboard.util.isNullOrUndefined(position.bezierPath)))
									sender.svgRenderer.drawPolyline(position.bezierPath, sender.gConnectorEle[seriesIndex]);
						}
						else{
							dataLabelEle.hide();
							conEle.hide();
							connectorDirection = "";
                        }
                        // To check the datalabel overlaps with chart bounds - (Start)
                       // var textWidthD = datalabelShape.width;
                       // var textHeightD = datalabelShape.height;
                       // var x = textOptions.x; var y = textOptions.y;
                      //  const topPadding = 5; // 5 for datalabel bounds top value correction
                      //  const bottomPadding = 10; //10 for datalabel bounds bottom value correction
                      //  if (textOptions["text-anchor"] === "start") {
                      //      y -= textHeightD;
                      //  } else if (textOptions["text-anchor"] === "end") {
                      //      x -= textWidthD;
                      //      y -= textHeightD;
                      //  } else {
                      //      x -= (textWidthD / 2);
                      //      y -= textHeightD;
                      //  }
                      //  y += topPadding;
                      //  var chartBound = {
                      //      x: chartObj.model.border.width / 2,
                      //      y: chartObj.model.border.width / 2,
                      //      width: chartObj.model.svgWidth - (2 * chartObj.model.border.width),
                      //      height: chartObj.model.svgHeight - (2 * chartObj.model.border.width)
                      //  }
                      //  if (y < chartBound.y || (y + textHeight - bottomPadding) > (chartBound.y + chartBound.height)) {
                      //      point.hide = true;
                      //  }
                        // To check the datalabel overlaps with chart bounds - (End)
						if (!point.hide) chartObj.svgRenderer.drawText(textOptions, datalabelText, chartObj.gSeriesTextEle[seriesIndex]);

                        var datalabelSize = measureText(datalabelText, datalabelText.length, dataLabelFont);
                        var untrimmedSize = measureText(commonEventArgs.data.text, null, dataLabelFont);
                        var bounds;
                        var minX, minY, maxX, maxY;
                        if (type == "pie" || type == "doughnut") {
                            if (labelPosition == "inside" && position.connectorDirection == "") {
                                minX = textOptions.x - datalabelShape.width / 2;
                                maxX = textOptions.x + datalabelShape.width / 2;
                                minY = textOptions.y - datalabelShape.height / 2;
                                maxY = textOptions.y + datalabelShape.height / 2;
                            }
                            else {
                                if (chartModel.circleCenterX[seriesIndex] < textOptions.x) {
                                    minX = textOptions.x;
                                    maxX = textOptions.x + datalabelShape.width;
                                }
                                else {
                                    minX = textOptions.x - datalabelShape.width;
                                    maxX = textOptions.x;
                                }
                                minY = textOptions.y - datalabelShape.height / 2;
                                maxY = textOptions.y + datalabelShape.height / 3;
                            }
                            bounds = { centerX: chartModel.circleCenterX[seriesIndex], minX: minX, minY: minY, maxX: maxX, maxY: maxY, width: datalabelSize.width, height: datalabelSize.height, labelPosition: labelPosition };
                        }

                        if ((type == "funnel" || type == "pyramid")) {
                            legendWidth = legendPosition == "left" ? legendWidth : 0;
                            var legendHeight = 0;
                            if (connectorDirection != "" || connectorType == "bezier") {
                                minX = textOptions.x - legendWidth;
                                maxX = textOptions.x + datalabelShape.width - legendWidth;
                                minY = textOptions.y - datalabelShape.height;
                                maxY = textOptions.y;
                            }
                            if (!enableCanvasRendering)
                                bounds = { minX: minX + chartObj.pyrX + legendWidth, maxX: maxX + chartObj.pyrX + legendWidth, minY: minY + chartObj.pyrY + legendHeight, maxY: maxY + chartObj.pyrY + legendHeight, width: datalabelSize.width, height: datalabelSize.height, labelPosition: labelPosition };
                            else
                                bounds = { minX: minX + legendWidth, maxX: maxX + legendWidth, minY: minY + legendHeight, maxY: maxY + legendHeight, width: datalabelSize.width, height: datalabelSize.height, labelPosition: labelPosition };
                        }
                        accDataLabelRegion = { bounds: bounds, trimmedText: datalabelText, text: commonEventArgs.data.text, type: type, font: dataLabelFont };
                        chartObj.accDataLabelRegion.type = type;
                        chartObj.accDataLabelRegion.connectorDirection = connectorDirection;
                        if (BoldBIDashboard.util.isNullOrUndefined(chartObj.accDataLabelRegion[seriesIndex])) {
                            chartObj.accDataLabelRegion[seriesIndex] = [];
                        }
                        if (chartObj.accDataLabelRegion[seriesIndex].length < currentseries._visiblePoints.length)
                            chartObj.accDataLabelRegion[seriesIndex].push(accDataLabelRegion);
                        if (((!isNull(point.index) && currentseries.explode) && (!enableCanvasRendering)))
                            chartObj.accDataLabelRegion[seriesIndex].splice(point.index, 1, accDataLabelRegion);
                    }
                    else {
                        seriesType.dataLabelSymbol(seriesIndex, currentseries, point.index, positionX, positionY, textWidth, textHeight, symbolName, chartObj);
                        chartObj.svgRenderer.drawText(textOptions, commonEventArgs.data.text, chartObj.gSeriesTextEle[seriesIndex]);
                    }
                }
                if ((type == "pyramid" || type == "funnel") && dataLabel.template && currentseries._enableSmartLabels) {
                    position = seriesType.updateSmartLabel(sender, currentseries, point.index, point);
                    positionX = position.xPos;
                    positionY = position.yPos;
                    connectorDirection = position.connectorDirection;

                }
                pointColor = bbdesigner$.type(chartModel.pointColors[point.actualIndex]) == "array" ? chartModel.pointColors[point.actualIndex][0].color : chartModel.pointColors[point.actualIndex];
                // To set the point color when set the color in empty point
                pointColor = point.fill ? bbdesigner$.type(point.fill) == "array" ? point.fill[0].color : point.fill : pointColor;

                var translate = [];
                translate[0] = pyrX;
                translate[1] = pyrY;
                if ((connectorType != 'bezier' || chartObj.vmlRendering || (type == "pyramid" || type == "funnel")) && (connectorDirection != '')) {
                    if (connectorDirection && !point.hide) {
                        var connectorOptions = {
                            'id': chartObj.svgObject.id + "_connectorLine_series"+seriesIndex+"_point_" + pointIndex,
                            'stroke': (connectorLine.color) ? connectorLine.color : pointColor,
                            'stroke-width': connectorLine.width,
                            'd': connectorDirection
                        };
                        chartObj.svgRenderer.drawPath(connectorOptions, chartObj.gConnectorEle[seriesIndex], translate);
                    }
                }
            }
        },

	_overlapLegend: function (textOptions, datalabelText, chart,seriesIndex, legendPos) {

	    var svgHeight = bbdesigner$(chart.svgObject).height(),
            svgWidth = bbdesigner$(chart.svgObject).width(),
	        legendBounds = chart.model.LegendActualBounds,
	        elementSpacing = chart.model.elementSpacing,
            margin = chart.model.series[seriesIndex].marker.dataLabel.margin,
            shape = chart.model.series[seriesIndex].marker.dataLabel.shape,
            top = shape != 'none' ? margin.top : 0,
            bottom = shape != 'none' ? margin.bottom : 0,
            textHeight = BoldBIDashboard.EjSvgRender.utils._measureText(datalabelText, null, textOptions, '', true).height,
	        dataLabelEndPos = textOptions.y + textHeight + bottom,
	        dataLabelTopPos = textOptions.y - top,
	        legendPosition = legendPos,
            title = chart.model.title,
            subTitle = title.subTitle,
            margin = chart.model.margin,
            borderSize = chart.model.border.width,
            modelsubTitleHeight = subTitle.text == "" ? 0 : BoldBIDashboard.EjSvgRender.utils._measureText(subTitle.text, svgWidth - margin.left - margin.right, subTitle.font).height + elementSpacing,
            titleLocation = chart.model._titleLocation ? chart.model._titleLocation.Y : 0 + modelsubTitleHeight,
	        text = datalabelText, legendPosY;
	        
        
	    if (legendPosition == 'bottom') {
	        legendPosY = svgHeight - chart.model.LegendActualBounds.Height - elementSpacing;
            text = dataLabelEndPos > legendPosY ? '' : text;
	    } else {
	        legendPosY = titleLocation == 0 ? borderSize + elementSpacing : titleLocation + elementSpacing;
            text = dataLabelTopPos < (legendPosY + legendBounds.Height) ? '' : text;
        }
	    if (dataLabelEndPos > svgHeight)
	        text = '';
	    return text;

	},

	_getLegendBounds: function () {
	    var chartModel = this.chartObj.model,
            legend = chartModel.legend,
            legendViewerBounds = chartModel.LegendViewerBounds,
            actualBounds = chartModel.LegendActualBounds,
            legendPosition = !BoldBIDashboard.util.isNullOrUndefined(legend.responsivePosition) ? legend.responsivePosition : legend.position.toLowerCase(),
            alignment = legend.alignment.toLowerCase(),
            elementSpacing = chartModel.elementSpacing,
            legendTitle = legend.title,
            legendBorder = legend.border.width,
            measureText = BoldBIDashboard.EjSvgRender.utils._measureText,
            borderSize = chartModel.border.width,
            legendCollection = chartModel.legendCollection,
            collectionLength = legendCollection.length,
            svgWidth = chartModel.svgWidth - ((borderSize * 2)),
            svgHeight = chartModel.svgHeight - ((borderSize * 2)),
            itemPadding = legend.itemPadding > 0 ? legend.itemPadding : 0,
            legendTitleHeight = measureText(legendTitle.text, null, legendTitle.font).height,
            areaBounds = chartModel.m_AreaBounds,
            isScroll = legend.enableScrollbar,
	        X, Y, Height = legendViewerBounds.Height + legendTitleHeight;

	    if (legend.visible) {
	        switch (legendPosition) {
	            case "right":
	                X = svgWidth - actualBounds.Width - (elementSpacing * 2);
	                break;
	            case "left":
	                X = borderSize + (elementSpacing * 2);
	                break;
	        }
	        if (isScroll) {
	            switch (alignment) {
	                case "center":
	                    Y = areaBounds.Height / 2 - (actualBounds.Height / 2) + areaBounds.Y - legendBorder;
	                    break;
	                case "near":
	                    Y = areaBounds.Y;
	                    break;
	                case "far":
	                    Y = areaBounds.Y + areaBounds.Height - actualBounds.Height - (legendBorder * 2);
	                    break;
	            }
	        } else {
	            switch (alignment) {
	                case "center":
	                    Y = (svgHeight / 2) - ((actualBounds.Height + legendBorder * 2) / 2) + (elementSpacing / 2);
	                    break;
	                case "near":
	                    Y = borderSize + (elementSpacing * 2);
	                    break;
	                case "far":
	                    Y = svgHeight - (actualBounds.Height + (legendBorder)) - (elementSpacing * 2);
	                    break;
	            }
	        }
	        if (isScroll) {
	            var scrollbarHeight = 13;
	            Height += scrollbarHeight;
	            if (Y < areaBounds.Y || actualBounds.Height + (legendBorder * 2) >= areaBounds.Height) {
	                var legendHeight = (legendBorder * 2);
	                for (var k = 0; k < collectionLength; k++) {
	                    legendHeight += legendCollection[k].Bounds.Height + itemPadding;
	                    if (legendHeight > areaBounds.Height) {
	                        Y = areaBounds.Y;
	                        break;
	                    }
	                }
	            }
	        }
	        return { x: X, y: Y, height: Height, width: legendViewerBounds.Width };
	    }
	    return { x: 0, y: 0, height: 0, width: 0 };
	},

    drawBezierSegment: function (controlpoints, currentseries, pointIndex, sender, seriesIndex) {
	    //currentseries.points[pointIndex].marker = currentseries.points[pointIndex].marker ? currentseries.points[pointIndex].marker : {};
	    //var marker = bbdesigner$.extend(true, {}, currentseries.marker, currentseries.points[pointIndex].marker);
	    var polyLine = BoldBIDashboard.EjSvgRender.utils._getStringBuilder();
	    var seriesType = new BoldBIDashboard.seriesTypes[currentseries.type.toLowerCase()]();
	    for (var i = 0; i <= 16; i++) {
	        var t = i / 16;
	        var points = seriesType.GetBezierPoint(t, controlpoints, 0, controlpoints.length, currentseries);
	        polyLine.append(points.X + "," + points.Y + " ");
	    }
	    var connectorOptions = {
	        'id': sender.svgObject.id + "_bezierLine_series"+ seriesIndex + "_point" + pointIndex,
	        'stroke': (currentseries.marker.dataLabel.connectorLine.color) ? currentseries.marker.dataLabel.connectorLine.color : sender.model.pointColors[pointIndex],
	        'stroke-width': currentseries.marker.dataLabel.connectorLine.width,
            'fill':'none',
	        'points': polyLine.toString()
	    };
		if (!currentseries._enableSmartLabels)
	       sender.svgRenderer.drawPolyline(connectorOptions, sender.gConnectorEle);
		else
	       return connectorOptions;
	},
	GetBezierPoint:function(t, controlPoints, index, count, currentseries)
	{
	    var seriesType = new BoldBIDashboard.seriesTypes[currentseries.type.toLowerCase()]();
	    if (count == 1)
	        return controlPoints[index];
	    var p0 = seriesType.GetBezierPoint(t, controlPoints, index, count - 1, currentseries);
	    var p1 = seriesType.GetBezierPoint(t, controlPoints, index + 1, count - 1, currentseries);
	    var x = (p0.X) ? p0.X : p0.x;
	    var y = (p0.Y) ? p0.Y : p0.y;
	    var x1 = (p1.X) ? p1.X : p1.x;
	    var y1 = (p1.Y) ? p1.Y : p1.y;
	    var X = (1 - t) * x+ t * x1;
	    var Y = (1 - t) * y + t * y1;
	    if (p0.x)
	        return { x: X, y: Y }
	    else
	        return { X: X, Y: Y };;
	    


       // return new Point((1 - t) * p0.X + t * p1.X, (1 - t) * p0.Y + t * p1.Y);
    },
	
    drawLabelTemplate: function (series, point, pointIndex, location, sender) {
        // method for data label template
        if(sender)
            this.chartObj = sender;
	    var seriesIndex = bbdesigner$.inArray(series, this.chartObj.model._visibleSeries);
        var areaType = this.chartObj.model.AreaType;
        var currentSeries = this.chartObj.model.series[seriesIndex];
		var xPosition = 0, yPosition = 0;
        var chartContainer = this.chartObj._id;
        var marker = bbdesigner$.extend(true, {}, series.marker, point.marker);
        var style = { 'interior': marker.dataLabel.fill, 'opacity': marker.dataLabel.opacity, 'borderColor': marker.dataLabel.border.color, 'borderWidth': marker.dataLabel.border.width };
        var color, width, height;
		var type = this.chartObj.model.chartRegions[pointIndex] ? this.chartObj.model.chartRegions[pointIndex].type : "";
		if (areaType != "none" || this.chartObj.model.enable3D) {

            if (bbdesigner$('#template_group_' + chartContainer).length != 0)
                var templateContainer = bbdesigner$('#template_group_' + chartContainer);
            else
                templateContainer = bbdesigner$("<div></div>").attr('id', "template_group_" + chartContainer);

            templateContainer.css('position', 'relative').css('z-index', 1000);
			if (bbdesigner$("#" + marker.dataLabel.template).length == 0) // To check the specified div is in DOM
                return;
            else
            var cloneNode = bbdesigner$("#" + marker.dataLabel.template).clone();
            bbdesigner$(cloneNode).attr("id", marker.dataLabel.template + '_' + seriesIndex + '_' + pointIndex + '_' + chartContainer);
            var bbdesigner$cloneNode = bbdesigner$(cloneNode);
            bbdesigner$cloneNode.css("position", "absolute");

            var pointX = point.x; 
            point.dataLabeltemplate = true;	
            point.id = marker.dataLabel.template + '_' + seriesIndex + '_' + pointIndex + '_' + chartContainer;			
            if (series.xAxis._valueType.toLowerCase() == "datetime")
                point.x = (BoldBIDashboard.format(new Date(point.xValue), ((BoldBIDashboard.util.isNullOrUndefined(series.xAxis.labelFormat)) ? BoldBIDashboard.EjSvgRender.utils._dateTimeLabelFormat(series.xAxis._intervalType) : series.xAxis.labelFormat)));
            if (series.xAxis._valueType.toLowerCase() == "category")
                point.x = BoldBIDashboard.EjSvgRender.utils._getLabelContent(pointIndex, series.xAxis);

            point.count = 1;
            var data = { series: series, point: point };
            bbdesigner$cloneNode.html(bbdesigner$cloneNode.html().parseTemplate(data));

            point.x = pointX;
            var display = (areaType == "cartesianaxes" || !series.enableAnimation || (series.type.toLowerCase() == "pyramid" || series.type.toLowerCase() == "funnel")) ? "block" : "none";
            bbdesigner$cloneNode.css("display", display).appendTo(bbdesigner$(templateContainer));
			//template_group_container Div appended in chartcontainer_container Div 
            bbdesigner$(templateContainer).appendTo('#' + 'chartContainer_' + chartContainer);
            var areaBound = this.chartObj.model.m_AreaBounds;
            if (areaType == "cartesianaxes" && !this.chartObj.model.enable3D) {
                xPosition = areaBound.X + (this.chartObj.model.requireInvertedAxes ? currentSeries.yAxis.plotOffset : currentSeries.xAxis.plotOffset);
                yPosition = currentSeries.yAxis.y;
            }
            width = bbdesigner$cloneNode.width() / 2;
            height = bbdesigner$cloneNode.height();
            if (BoldBIDashboard.util.isNullOrUndefined(style) && style.interior)
                color = style.interior;
            else
                color = (areaType == "none") ? this.chartObj.model.pointColors[pointIndex] : this.chartObj.model.seriesColors[seriesIndex];
        }
        else {
            if (BoldBIDashboard.util.isNullOrUndefined(style) && style.interior)
                color = style.interior;
            else
                color = this.chartObj.model.pointColors[pointIndex];
             width = this.chartObj.model.circleCenterX[seriesIndex]> location.X ? point.size.width : 0;
            bbdesigner$cloneNode = bbdesigner$('#template_group_' + chartContainer).find("#" + marker.dataLabel.template + '_' + seriesIndex + '_' + pointIndex + '_' + chartContainer);
            point.id = marker.dataLabel.template + '_' + seriesIndex + '_' + pointIndex + '_' + chartContainer;
            height = (!this.chartObj.model.enable3D) ? point.size.height / 2 : 0;
        }
        
        if (currentSeries.type == 'hilo' || currentSeries.type == 'hiloopenclose' || currentSeries.type == 'candle')
            color = currentSeries._visiblePoints[pointIndex]._hiloFill;
            color = bbdesigner$.type(color) == "array" ? color[0].color : color;
			
           
        if (currentSeries.type.indexOf("bar") != -1) {
            var left = location.X + xPosition - width;
            var top = location.Y + ((!this.chartObj.model.enable3D) ? areaBound.Y : 0) - height + currentSeries.xAxis.plotOffset;
        } else {
        var left =location.X + xPosition - width;
        var top = yPosition + location.Y - height;
       }
       var backgroundColor = bbdesigner$cloneNode[0].style.backgroundColor;
       bbdesigner$cloneNode.css("left", left).css("top", top).css("background-color", (backgroundColor != '' ? backgroundColor : color)).css("display", "block").css("cursor", "default");
	    
		if(this.chartObj.model.AreaType !="cartesianaxes"){
          point.xPos = left - this.chartObj.pyrX;
          point.yPos = top - this.chartObj.pyrY;
		  point.textOptionsacc = { x: left - this.chartObj.pyrX, y: top - this.chartObj.pyrY };
		}
		else{
		    if (point.y == point.low) {
		        point.xPosLow = left;
		        point.yPosLow = top;
		        point.textOptionsLow = { x: left, y: top };
		        point.dataLabelLow = { textX: left, textY: top, x: left, y: top };
		    }
		    else {
		        point.xPos = left;
		        point.yPos = top;
		        point.seriesIndex = seriesIndex;
		        point.textOptions = { x: left, y: top };
		        point.dataLabel = { textX: left, textY: top, x: left, y: top };
		        point.margin = { top: 0, bottom: 0, left: 0, right: 0 };
		    }
		}
        point.height = bbdesigner$cloneNode.outerHeight();
        point.width = bbdesigner$cloneNode.outerWidth();
        if (areaType == "cartesianaxes") {
            if ((left > xPosition + areaBound.Width || top + height > areaBound.Y + areaBound.Height) || (this.chartObj.zoomed && (left < xPosition || top < yPosition || left > xPosition + areaBound.Width || top > yPosition + areaBound.Height)))
                bbdesigner$cloneNode.remove();
        }
    },
	
	animateLabelTemplate : function(options) {
	// method to animate data label template
        var seriesIndex = bbdesigner$.inArray(options, this.chartObj.model._visibleSeries);
        var length = options._visiblePoints.length;
        var secondsPerPoint = 1000;
        
        for (var i = 0; i < length; i++) {            
            var ele = options.marker.dataLabel.template + '_' + seriesIndex + '_' + i + '_' + this.chartObj._id;
            ele = bbdesigner$('#' + ele);
            ele.css("display", "none");
            ele.delay(secondsPerPoint).fadeIn(300);
			}
    },
	
	textPosition: function (series, seriesIndex, point, textOffset, type, x, y, chartRegionIndex, index, params) {
	    var marker = bbdesigner$.extend(true, {}, series.marker, point.marker),
            dataLabel = marker.dataLabel,
            anchor = dataLabel.textAnchor.toLowerCase(),
            angle = isNaN(parseInt(dataLabel.angle)) ? 0 : parseInt(dataLabel.angle),
            isRTL = dataLabel.isReversed,
            horizontalTextAlignment = dataLabel.horizontalTextAlignment.toLowerCase(),
            verticalTextAlignment = dataLabel.verticalTextAlignment.toLowerCase(),
            textPosition = dataLabel.textPosition.toLowerCase(),
            visiblePointLength = series._visiblePoints.length,
            seriesPointIndex = chartRegionIndex,
            lineHeight = 10,
			padding = 3,
            margin = dataLabel.margin,
			isYInversed = series.yAxis.isInversed,
			xOrigin = this.chartObj._getXCrossValue(series, series.xAxis, params);

	    var seriesType = (type.indexOf("bar") != -1 || (type.indexOf("column") != -1 && type!="rangecolumn")) ? (this.chartObj.model.requireInvertedAxes) ? "bar" : "column" : type;
	    if (seriesType == 'column' || seriesType == 'stackingcolumn' || seriesType == 'stackingcolumn100') {
			var bounds = this.chartObj.model.chartRegions[seriesPointIndex].Region.Bounds,
				originChanged = params.axes[series.xAxis.name]._validCross||false;
                pointHeight = bounds.Height,
                pointWidth = bounds.Width;

			if(!originChanged){				
                if (textPosition == "bottom") {
                    if ((point.y >= xOrigin && !series.yAxis.isInversed) || (point.y < xOrigin && series.yAxis.isInversed)) {
                        y = (point.symbolLocation.Y + pointHeight) - (textOffset.width / 2) - margin.bottom;
                    }
                    else
                        y = textOffset.height + margin.bottom;
                } else if (textPosition == "middle") {
                    if ((point.y > xOrigin && !series.yAxis.isInversed) || (point.y < xOrigin && series.yAxis.isInversed))
                        y += pointHeight / 2 + (textOffset.height) / 4;
                    else
                        y -= pointHeight / 2;
                }
                else {
                    if ((point.y > xOrigin && series.yAxis.isInversed) || (point.y < xOrigin && !series.yAxis.isInversed))
                        y += lineHeight + ((textOffset.height) / 2);
                    else {
                        y += type == 'column' ? ((angle ? -textOffset.width / 2 : -lineHeight)) : (lineHeight * 2);
                    }
                }				
           }
			else{
				var origin = Math.abs((isYInversed ? series.yAxis.visibleRange.min : series.yAxis.visibleRange.max) - xOrigin) / series.yAxis.visibleRange.delta * series.yAxis.height;
				if (textPosition == "bottom") {
					if (y <= origin)
						y = y + pointHeight - margin.bottom;
					else 
						y = y - pointHeight + textOffset.height - margin.bottom;
				} else if (textPosition == "middle") {
					if (y < origin)
						y += pointHeight / 2 + (textOffset.height) / 4;
					else  
						y -= pointHeight / 2;
				}
				else {
					if ((y < origin && isYInversed) || (y < origin && !isYInversed))
						y -= (lineHeight + (2 * textOffset.height) / 2);
					else
						y += (lineHeight + (2 * textOffset.height) / 2);
				}			
			}

           if (horizontalTextAlignment && horizontalTextAlignment == "far")
               x = isRTL ? x - pointWidth/2 : x + pointWidth / 2;
            else if (horizontalTextAlignment && horizontalTextAlignment == "near")
               x = isRTL ? x + pointWidth/2 : x - pointWidth / 2;

           if (verticalTextAlignment && verticalTextAlignment == "near") {
               if (textPosition == "bottom")
                   y += lineHeight;
               else
                   y += lineHeight - padding;
           }
           else if (verticalTextAlignment && verticalTextAlignment == "far") {
               if (textPosition == "bottom")
                   y -= lineHeight;
               else
                   y -= lineHeight;
           }
        }

	    else if (seriesType.indexOf("bar") != -1) {
	        var bounds = this.chartObj.model.chartRegions[seriesPointIndex].Region.Bounds,
                pointWidth = bounds.Width,
			    originChanged = params.axes[series.xAxis.name]._validCross||false,
	            pointHeight = bounds.Height;
			y = y+ textOffset.height / 4;
			if(!originChanged)
			{				
				if (textPosition == "bottom") {
		  	    if ((point.y >= 0 && !series.yAxis.isInversed) || (point.y < 0 && series.yAxis.isInversed))
                    x -= (pointWidth - margin.left - textOffset.width / 4);
		  	    else
		  	        x += (pointWidth - textOffset.height - margin.right);
		  	} else if (textPosition == "middle") {
			      if ((point.y > 0 && !series.yAxis.isInversed) || (point.y < 0 && series.yAxis.isInversed))
			          x -= pointWidth / 2 + textOffset.width / 2;
			      else
			          x += pointWidth / 2;
		  	} else {
		  	    if ((point.y >= 0 && !series.yAxis.isInversed) || (point.y < 0 && series.yAxis.isInversed))
                      x = anchor == "middle" ? (x + (type == "bar" ? textOffset.width : -textOffset.width)) : (anchor == "start" ? (x + textOffset.width/2 + lineHeight) : (x + lineHeight)) ;
                else
                      x = anchor == "middle" ? (x - textOffset.width / 4 + lineHeight) : (anchor == "start" ? (x - textOffset.width / 2 + lineHeight) : (x + lineHeight));
           }
			}
			else
			{
				var yOrigin = series.xAxis._crossValue||0,
				origin = Math.abs(isYInversed ? series.yAxis.visibleRange.max : series.yAxis.visibleRange.min - yOrigin) / series.yAxis.visibleRange.delta * series.yAxis.width;
				if (textPosition == "bottom") {
				    if ((x < origin && !isYInversed)||(x >= origin && isYInversed))
						x = x + pointWidth - textOffset.width;
					else
						x = x - pointWidth + margin.left;
				} else if (textPosition == "middle") {
				    if ((x < origin && !isYInversed) || (x >= origin && isYInversed))
				        x = x + pointWidth / 2 - textOffset.width / 2;
				    else
				        x = x - pointWidth / 2 - textOffset.width / 2;
				}
				else {
				    if ((x < origin && !isYInversed) || (x >= origin && isYInversed))
				        x -= (lineHeight + (2 * textOffset.width) / 2);
				    else
				        x += (lineHeight + (2 * textOffset.width) / 2);
				}
			}

		  	if (horizontalTextAlignment && horizontalTextAlignment == "far") {
		  	    if (textPosition == "bottom")
		  	        x += textOffset.width - textOffset.width / 4;
		  	    else
		  	        x += textOffset.width/4 + lineHeight;
		  	}
		  	else if (horizontalTextAlignment && horizontalTextAlignment == "near") {
		  	    if (textPosition == "bottom")
		  	        x -= textOffset.width / 4;
		  	    else
		  	        x -= lineHeight - textOffset.width/4 - padding ;
		  	}
		  	else // for center
				x  = anchor == "middle" ? (x + (point.y < 0 ? -textOffset.width/2 - lineHeight : textOffset.width/4)) : (anchor == "start" ? (x + textOffset.width/2 ) : x) ;
				
            if (verticalTextAlignment && verticalTextAlignment == "near")
                y += pointHeight / 2;
            else if (verticalTextAlignment && verticalTextAlignment == "far")
                y -= pointHeight / 2;
	    }
	    else if (seriesType == "rangecolumn" ) {
	         var bounds = this.chartObj.model.chartRegions[seriesPointIndex].Region.Bounds;
	         var height = 0;
	         var width = 0;
	         if (point.high != point.y) {
	            height = bounds.Height;
	     	 	width = bounds.Width;
	          }
	       	 if (this.chartObj.model.requireInvertedAxes) {
	             if (textPosition == "top")
                     x = x - width + (lineHeight + (2 * textOffset.width) / 2);
                 else if (textPosition == "bottom")
                     x = x - width - (2 * textOffset.width + lineHeight);
	             else if (textPosition == "middle")
                     x = x - width;
             }
	         else{
                 if(textPosition == "top")
                     y += height - lineHeight;
	        
                 else if(textPosition == "bottom")
                     y = y + height + (2 * textOffset.height + lineHeight);
	             else if (textPosition == "middle")
                     y = y + height;
	         }
	         if (horizontalTextAlignment && horizontalTextAlignment.toLowerCase() == "far")
                  x += bounds.Width / 2;
	         else if (horizontalTextAlignment && horizontalTextAlignment.toLowerCase() == "near")
                  x -= bounds.Width / 2;	    
            if (verticalTextAlignment && verticalTextAlignment.toLowerCase() == "near")
                  y += lineHeight - padding;
	         else if (verticalTextAlignment && verticalTextAlignment.toLowerCase() == "far")
                  y -= lineHeight;
	    
        }
	    else if (type == "waterfall") {
	        var bounds = this.chartObj.model.chartRegions[seriesPointIndex].Region.Bounds,
                pointHeight = bounds.Height,
                pointWidth = bounds.Width;

	        var isNegativePoint = point.waterfallSum < 0 || (!point.showIntermediateSum && !point.showTotalSum && point.y < 0);
	       
	        switch (textPosition) {
	            case "bottom":
	                if (!series.isTransposed) {
	                    if (!series.yAxis.isInversed)
	                        y = y + pointHeight - margin.bottom - (isNegativePoint ? pointHeight : 0);
	                    else
	                        y = y - textOffset.height + margin.bottom + (isNegativePoint ? pointHeight : 0);
	                } else {
	                    if (!series.yAxis.isInversed)
	                        x = x - pointWidth + (lineHeight + (2 * textOffset.height) / 2) + (isNegativePoint ? pointWidth : 0);
	                    else
	                        x = x + pointWidth - (lineHeight + (2 * textOffset.height) / 2) - (isNegativePoint ? pointWidth : 0);
	                }
	                break;

	            case "middle":
	                if (!series.isTransposed) {
	                    if (!series.yAxis.isInversed)
	                        y = y + (pointHeight / 2 + (textOffset.height) / 4) - (isNegativePoint ? pointHeight : 0);
	                    else
	                        y = y - (pointHeight / 2) + (isNegativePoint ? pointHeight : 0);
	                } else {
	                    if (!series.yAxis.isInversed)
	                        x = x - (pointWidth / 2 + (textOffset.width) / 4) + (isNegativePoint ? pointWidth : 0);
	                    else
	                        x = x + (pointWidth / 2) - (isNegativePoint ? pointWidth : 0);
	                }
	                break;

	            default:
	                if (!series.isTransposed) {
	                    if (!series.yAxis.isInversed)
	                        y = y - (lineHeight + (2 * textOffset.height) / 2) - (isNegativePoint ? pointHeight : 0);
	                    else
	                        y = y + (lineHeight + (2 * textOffset.height) / 2) + (isNegativePoint ? pointHeight : 0);
	                } else {
	                    if (!series.yAxis.isInversed)
	                        x = x + (lineHeight + (2 * textOffset.height) / 2) + (isNegativePoint ? pointWidth : 0);
	                    else
	                        x = x - (lineHeight + (2 * textOffset.height) / 2) - (isNegativePoint ? pointWidth : 0);
	                }
	        }

	        if (horizontalTextAlignment && horizontalTextAlignment == "far")
	            x += pointWidth / 2;
	        else if (horizontalTextAlignment && horizontalTextAlignment == "near")
	            x -= pointWidth / 2;

	        if (verticalTextAlignment && verticalTextAlignment == "near") {
	            if (textPosition == "bottom")
	                y += textOffset.height / 3;
	            else
	                y += (textOffset.height + lineHeight);
	        }
	        else if (verticalTextAlignment && verticalTextAlignment == "far") {
	            if (textPosition == "bottom")
	                y -= textOffset.height / 3;
	            else
	                y -= (lineHeight + (textOffset.height) / 2);
	        }

	    }
        else if (type == "polar" || type == "radar") {
                y += textOffset.height / 4;
            if (textPosition == "bottom")
                y += (textOffset.height);
            else if (textPosition == "top")
                y -=  (textOffset.height);

            if (horizontalTextAlignment && horizontalTextAlignment == "far")
                x += textOffset.width;
            else if (horizontalTextAlignment && horizontalTextAlignment == "near")
                x -= (textOffset.width);

            if (verticalTextAlignment && verticalTextAlignment == "near")
                y += (textOffset.height)/2;
            else if (verticalTextAlignment && verticalTextAlignment == "far")
                y -= ((textOffset.height)/2);
        }
        else {
            if ((seriesType == "rangearea" || seriesType == "splinerangearea") && (point.high != point.y)) {
                  var length = this.chartObj.model.chartRegions[seriesPointIndex].Region.Bounds.region.length;
                    y = this.chartObj.model.chartRegions[seriesPointIndex].Region.Bounds.region[length - 1].Y;
                    x = this.chartObj.model.chartRegions[seriesPointIndex].Region.Bounds.region[length - 1].X;
            }    
            if (this.chartObj.model.requireInvertedAxes) {
                if (textPosition == "top")
                    x += lineHeight;
                else if (textPosition == "bottom")
                    x -= (lineHeight + (2 * textOffset.width) / 2);
            }
            else {
                if (textPosition == "bottom")
                    y += (2 * textOffset.height + lineHeight);
                else if (textPosition == "top")
                    y -= lineHeight;
            }
            if (horizontalTextAlignment && horizontalTextAlignment == "far")
                x += textOffset.width + lineHeight;
            else if (horizontalTextAlignment && horizontalTextAlignment == "near")
                x -= ((textOffset.width) + lineHeight);

            if (verticalTextAlignment && verticalTextAlignment == "near")
                y += lineHeight - padding;
            else if (verticalTextAlignment && verticalTextAlignment == "far")
                y -= lineHeight;
        }
        var location = { x: x, y: y };
        return location;
    },
	



    changeCrossHairSymbol: function(element, track, ptIndex, serIndex, series) {
        if (!BoldBIDashboard.util.isNullOrUndefined(track)) {
            var trackMarker = {};
            element = bbdesigner$.extend(true, {}, series.marker, element);
            trackMarker = bbdesigner$.extend(true, {}, this.chartObj.model.crosshair.marker, trackMarker);
            var point = series.points[ptIndex], seriesType = series.type.toLowerCase();
            if (BoldBIDashboard.util.isNullOrUndefined(trackMarker.shape)) {
                trackMarker.shape = element.shape;
                if (seriesType == 'bubble') {
                    trackMarker.border.color = ((point.border) && point.border.color) ? point.border.color : series.border.color;
                    trackMarker.border.width = ((point.border) && point.border.width) ? point.border.width : series.border.width;
                }
            }
            
            if ((!this.chartObj.model.crosshair.visible || BoldBIDashboard.util.isNullOrUndefined(trackMarker.fill)) && series.type.toLowerCase() != "bubble" && series.type.toLowerCase() != "scatter") {
                if(trackMarker.shape.toLowerCase()=="cross" ||trackMarker.shape.toLowerCase()=="horizline"||trackMarker.shape.toLowerCase()=="vertline" )   
                    trackMarker.fill = bbdesigner$.type(this.chartObj.model.seriesColors[serIndex]) == "array" ? this.chartObj.model.seriesColors[serIndex][0].color : this.chartObj.model.seriesColors[serIndex];         
                else
                    trackMarker.fill = element.border.color;
            }
            if (series.type.toLowerCase() == "bubble" && !this.chartObj.model.enableCanvasRendering) {
                var box = bbdesigner$(this.chartObj.gSeriesEle).find("#" + this.chartObj.svgObject.id + '_Series' + serIndex + '_Point' + ptIndex)[0].getBoundingClientRect();
                trackMarker.size.width = (box.right - box.left) / 2 + 15;
                trackMarker.size.height = (box.bottom - box.top) / 2 + 15;
            } else {
                if (trackMarker.size.width <= element.size.width)
                    trackMarker.size.width = element.size.width + 2;
                if (trackMarker.size.height <= element.size.height)
                    trackMarker.size.height = element.size.height + 2;
               
                if (BoldBIDashboard.util.isNullOrUndefined(trackMarker.border.color) || !this.chartObj.model.crosshair.visible){              
                 if (!BoldBIDashboard.util.isNullOrUndefined(element.fill))
                    trackMarker.border.color = bbdesigner$.type(element.fill) == "array" ? element.fill._gradientStop[0].color : element.fill;
                 else if (seriesType == 'scatter') {
                     trackMarker.border.color = ((point.border) && point.border.color) ? point.border.color : series.border.color;
                     trackMarker.border.width = ((point.border) && point.border.width) ? point.border.width : series.border.width;
                 }
                else
                  trackMarker.border.color = (point.fill) ? point.fill : (bbdesigner$.type(this.chartObj.model.seriesColors[serIndex]) == "array" ? this.chartObj.model.seriesColors[serIndex][0].color : this.chartObj.model.seriesColors[serIndex]);
                }
            }
        }
        series._trackMarker = trackMarker;
        return trackMarker;


    },
	
    dataLabelSymbol: function (seriesIndex, series, pointIndex, x, y, width, height, symbolName, sender, group) {
        var chartObj = sender;
        if (symbolName == 'None')
            return;
            var point = series._visiblePoints[pointIndex];
            var location = { startX: x, startY: y };
            if(!sender.model.enable3D)
                var symbolEle = group ? group : chartObj.gDataLabelEle[seriesIndex];
				symbolEle = chartObj.model.enableCanvasRendering ? null : symbolEle;
            var element = bbdesigner$.extend(true, {}, series.marker, point.marker);
            var gradientName = "symbol";
            var style = { 'interior': element.dataLabel.fill, 'opacity': element.dataLabel.opacity, 'borderColor': element.dataLabel.border.color, 'borderWidth': element.dataLabel.border.width };
            var options = {
                'style': style,
                'gradientName': gradientName,
                'symbolEle': symbolEle,
                'width': width,
                'height': height,
                'point': point,
                'location': location,
                'seriesIndex': seriesIndex,
                'pointIndex': pointIndex,
                'element': element,
                'symbolName': symbolName,
                'id': chartObj.svgObject.id + '_dataLabel_series'+ seriesIndex + "_" + pointIndex
            };
            this.drawSymbolStyle(options, chartObj);
    },

    drawSymbolStyle: function (options, sender) {
        var chartObj = sender;
        var borderColor, borderWidth, opacity;
        var style = options.style, gradientName = options.gradientName, symbolEle = options.symbolEle,
            width = options.width, dashArray = options.dashArray;
        var height = options.height, point = options.point, location = options.location,
            seriesIndex = options.seriesIndex, visibility = options.visibility;
        var pointIndex = options.pointIndex, element = options.element, symbolName = options.symbolName;
        var trackSymbol = options.trackSymbol;
        var isCanvas = chartObj.model.enableCanvasRendering;
        var isPolar = chartObj.model.AreaType == 'polaraxes';
        var series = chartObj.model.series[seriesIndex];
		var mode = chartObj.model.legend.mode.toLowerCase();
        if (style != null) {
            if (style.borderColor != "")
                borderColor = style.borderColor ? style.borderColor: "transparent";

            opacity = style.opacity;
            borderWidth = style.borderWidth < 0 ? 0 : style.borderWidth;
        }
        var colors = null;
        if (style.interior) {
            colors = BoldBIDashboard.util.isNullOrUndefined(style.interior._gradientStop) ? style.interior : style.interior._gradientStop;
        }
        else {       
            if (point.fill)
                colors = bbdesigner$.type(point.fill) == "array" ? (point.fill[0] ? point.fill[0] : point.fill[0].color) : point.fill;
            else {
                var pointColors = chartObj.model.pointColors;
                colors = (chartObj.model.AreaType != "none") ? ((series.type.toLowerCase() == "waterfall" && series.positiveFill && (point.y > 0 || point.waterfallSum > 0)) ? series.positiveFill :
                    chartObj.model.seriesColors[seriesIndex]) : bbdesigner$.type(pointColors[pointIndex]) == "array" ? pointColors[pointIndex][0].color : pointColors[pointIndex];
            }
        }
       chartObj.symbolColorName = chartObj.svgRenderer.createGradientElement(gradientName + seriesIndex, colors, 0, 0, 0, bbdesigner$(chartObj.svgObject).height(), symbolEle, chartObj.model);

       var symbolStyle = {
		   Shape: options.element.shape,
           dashArray: options.dashArray,
           ShapeSize: {
               width: width,
               height: height
           },
           Style: {
               BorderColor: borderColor,
               BorderWidth: borderWidth,
               Opacity: opacity,
               Visibility: visibility,
               Color: chartObj.symbolColorName
           },
           PointIndex: pointIndex,
           SeriesIndex: seriesIndex,
           Imageurl: element.imageUrl,
           Image: element.image,
           ID: options.id
       };

        var commonEventArgs = bbdesigner$.extend({}, BoldBIDashboard.EjSvgRender.commonChartEventArgs);
        commonEventArgs.data = { location: location, style: symbolStyle };
        chartObj._trigger("symbolRendering", commonEventArgs);
		bbdesigner$.each(chartObj.model.symbolShape, function (name) {
            if (commonEventArgs.data.style.Shape.toLowerCase() == name.toLowerCase())
                symbolName = name;
        });
        if (!commonEventArgs.cancel) {
            if (isCanvas){
				//Added for Marker location while setting plotoffset value to axis
                  location.startY = (!chartObj.model.requireInvertedAxes) ? (location.startY + (series.yAxis.y ? (series.yAxis.y - chartObj.canvasY) : 0)) : location.startY;
              
                commonEventArgs.data.location.startY = location.startY;
                if (BoldBIDashboard.util.isNullOrUndefined(trackSymbol)) { // to draw marker/datalabel
				    if (chartObj.model.AreaType == "cartesianaxes") {
					    symbolEle = chartObj.svgRenderer.ctx;
					    chartObj.svgRenderer.ctx.save();
				        chartObj.svgRenderer.ctx.beginPath();
                        if (!chartObj.model.requireInvertedAxes)
                            chartObj.svgRenderer.ctx.rect(series.xAxis.x, series.yAxis.y, series.xAxis.width, series.yAxis.height);
					    else
                            chartObj.svgRenderer.ctx.rect(series.yAxis.x, series.xAxis.y, series.yAxis.width, series.xAxis.height);
                        chartObj.svgRenderer.ctx.clip();
					    BoldBIDashboard.EjSvgRender.chartSymbol["_draw" + symbolName](commonEventArgs.data.location, commonEventArgs.data.style, chartObj, symbolEle);
					    chartObj.svgRenderer.ctx.restore();
				    }
				    else{
				        if (isCanvas && isPolar) {
				            chartObj.svgRenderer.ctx.save();
				            chartObj.svgRenderer.ctx.beginPath();
				            chartObj.svgRenderer.ctx.arc(chartObj.model.centerX, chartObj.model.centerY, chartObj.model.Radius, 0, 2 * Math.PI, false);
				            chartObj.svgRenderer.ctx.clip();
				        }
				        BoldBIDashboard.EjSvgRender.chartSymbol["_draw" + symbolName](commonEventArgs.data.location, commonEventArgs.data.style, chartObj, symbolEle);
				        if (isCanvas && isPolar)
				            chartObj.svgRenderer.ctx.restore();
                    }
                   
                }
                else {
                        var ptIndex = commonEventArgs.data.style.PointIndex;
                        var serIndex = commonEventArgs.data.style.SeriesIndex;
                        if (!chartObj.model.series[serIndex].highlightSettings.enable) {
                            if (bbdesigner$('#' +chartObj._id+'_selection_'+serIndex+'_'+ptIndex+'_canvas').length == 0)
                                chartObj.svgRenderer.trackSymbol(commonEventArgs.data.style, commonEventArgs.data.location, symbolName, trackSymbol, chartObj);
                        }
                    }
                }
                else {
                    var ptIndex = commonEventArgs.data.style.PointIndex;
                    var serIndex = commonEventArgs.data.style.SeriesIndex;
                    var type = series.type;
                    var className;
                    if (series.highlightSettings.enable && trackSymbol && !chartObj.model.crosshair.visible) {
                        var style = bbdesigner$.extend(true, commonEventArgs.data.style);
                        var highlight =series.highlightSettings;
                        style.Style.Color = (highlight.pattern.toLowerCase() == "none" || highlight.pattern == "") ? (highlight.color != "" ? highlight.color : style.Style.Color) : "url(#" + highlight.pattern.toLowerCase() + '_Highlight_2D_' + serIndex + ")";
                        style.Style.Opacity = highlight.opacity;
                        style.Style.BorderColor = highlight.border.color;
                        style.Style.BorderWidth = highlight.border.width;
                        // checked condition for is already selected or not
                        if(type == 'bubble')
                            className = bbdesigner$('#' + this.chartObj.svgObject.id + '_Series' + serIndex + '_Point' + ptIndex).attr('class');
                        else
                            className = bbdesigner$('#' + this.chartObj.svgObject.id + '_Series' + serIndex + '_Point' + ptIndex+'_symbol').attr('class');
                        if (className != "SelectionStyleseries" + serIndex)
                            BoldBIDashboard.EjSvgRender.chartSymbol["_draw" + symbolName](commonEventArgs.data.location, style, chartObj, (chartObj.model.enable3D) ? sender.chart3D : symbolEle);
                    }
                    else {
                        if (type == 'scatter')
                            className = bbdesigner$('#' + chartObj.svgObject.id + '_Series' + serIndex + '_Point' + ptIndex + '_symbol').attr('class');
                        else
                            className = bbdesigner$('#' + chartObj.svgObject.id + '_Series' + serIndex + '_Point' + ptIndex).attr('class');
                        if (className != "SelectionStyleseries" + serIndex)
                            BoldBIDashboard.EjSvgRender.chartSymbol["_draw" + symbolName](commonEventArgs.data.location, commonEventArgs.data.style, chartObj, (chartObj.model.enable3D) ? sender.chart3D : symbolEle);
                    }
                }
            }

        if (!sender.chart3D && chartObj.model.AreaType == "none" && bbdesigner$(symbolEle).children().not("defs").length > chartObj.model._visibleSeries[seriesIndex]._visiblePoints.length) {
            bbdesigner$(symbolEle.childNodes[options.pointIndex]).replaceWith(bbdesigner$(symbolEle.childNodes[bbdesigner$(symbolEle.childNodes).length - 1]));
        }

    },
	
    drawSymbol: function (seriesIndex,series, pointIndex, x, y,chart,trackSymbol) {

        if (BoldBIDashboard.util.isNullOrUndefined(this.chartObj)) this.chartObj = chart;

        var legendMode = this.chartObj.model.legend.mode;
        var point = series._visiblePoints[pointIndex], seriesType = series.type.toLowerCase(),
        dashArray = (seriesType == 'bubble' || seriesType == 'scatter') ? series.border.dashArray : "";
             var symbolName = "None";
             var tracker = this.changeCrossHairSymbol(point.marker ? point.marker : series.marker, trackSymbol, pointIndex, seriesIndex, series);
             var element = tracker ? tracker : bbdesigner$.extend(true, {}, series.marker, point.marker);

             bbdesigner$.each(this.chartObj.model.symbolShape, function(name) {
                 if (element.shape.toLowerCase() == name.toLowerCase())
                     symbolName = name;
             });
                if (symbolName == "None")
                    return;
                var location = this.chartObj.model.AreaType == "cartesianaxes" ? { startX: x + this.chartObj.canvasX, startY: y + this.chartObj.canvasY } : { startX: x, startY: y };
                if (seriesType == 'scatter') {
                    var borderColor = ((point.border) && point.border.color) ? point.border.color : series.border.color;
                    var borderWidth = ((point.border) && point.border.width) ? point.border.width : series.border.width;
                    var style = { 'interior': element.fill, 'opacity': element.opacity, 'borderColor': borderColor, 'borderWidth': borderWidth };
                }
                else {
                    var style = { 'interior': element.fill, 'opacity': element.opacity, 'borderColor': element.border.color, 'borderWidth': element.border.width };
                }
                var symbolEle = (trackSymbol) ? this.chartObj.gTrackerEle : this.chartObj.gSymbolGroupEle[seriesIndex];
                pointIndex = legendMode == "point" ? point.actualIndex : pointIndex;
                var id = (trackSymbol) ? (this.chartObj.svgObject.id + '_trackSymbol_' + seriesIndex + "_" + pointIndex) : (this.chartObj.svgObject.id + '_Series' + seriesIndex + '_Point' + pointIndex + '_symbol');
                var gradientName = trackSymbol ? "TrackSymbol" : "symbol";
                var width = element.size.width;
                var height = element.size.height;
                var options = {
                    'style': style,
                    'gradientName': gradientName,
                    'symbolEle': symbolEle,
                    'width': width,
                    'height': height,
                    'point': point,
                    'location': location,
                    'seriesIndex': seriesIndex,
                    'pointIndex': pointIndex,
                    'element': element,
                    'visibility': (point.visible) ? 'visible' : 'hidden',
                    'symbolName': symbolName,
                    'trackSymbol' : trackSymbol,
                    'id': id,
                    'dashArray':dashArray
                };
                this.drawSymbolStyle(options, this.chartObj, trackSymbol);

                if (series.type.toLowerCase() == "scatter") {
                    var areaBoundsX = series.xAxis.x;
                    var areaBoundsY = series.yAxis.y;
                    if (this.chartObj.model.enableCanvasRendering) {
                        areaBoundsX = 0;
                        areaBoundsY = 0;
                    }
                    var bounds = { X: areaBoundsX + location.startX - (height / 2), Y: areaBoundsY + location.startY - (width / 2), Height: height, Width: width };
                    BoldBIDashboard.EjSvgRender.utils._addRegion(this.chartObj, bounds, series, null, pointIndex);
                }
    },

    chartAreaType: "cartesianAxes",
    requireInvertedAxes: false,
    stackingSeries: false,
    hiloTypes:false
    
};


function ejExtendClass(parent, members) {
    var object = function () { };
    object.prototype = new parent();
    bbdesigner$.extend(object.prototype, members);
    return object;
}

BoldBIDashboard.ejLineSeries = ejExtendClass(BoldBIDashboard.EjSeriesRender);

BoldBIDashboard.seriesTypes.line = BoldBIDashboard.ejLineSeries;


BoldBIDashboard.ejStepLineSeries = ejExtendClass(BoldBIDashboard.EjSeriesRender, {

    draw: function (chart, options) {
        var chartObj = this.chartObj = chart;
        var lDirection;
		options.animationType = "path";
        var sb = BoldBIDashboard.EjSvgRender.utils._getStringBuilder();
        var currentseries = options;
        var style = this.setLineSeriesStyle(currentseries);
        if (currentseries.sorting)
            currentseries.points = BoldBIDashboard.DataManager(currentseries.points, BoldBIDashboard.Query().sortBy("xValue")).executeLocal();
        var visiblePoints = this.improveChartPerformance(currentseries);
        var firstPoint = null;
        var startPath = "M";
        var secondPoint,nextpoint,point1,point2,point3;
        var firstIndex = -1;
        for (var i = 0; i < visiblePoints.length; i++) {
            secondPoint = visiblePoints[i];
            if (secondPoint.visible) {
                if (firstPoint != null) {
                    if (visiblePoints.length > firstIndex + 1) {
                        nextpoint = { xValue: visiblePoints[firstIndex + 1].xValue, YValues: [firstPoint.YValues[0]] };
                        point1 = BoldBIDashboard.EjSvgRender.utils._getPoint(firstPoint, currentseries);
                        point2 = BoldBIDashboard.EjSvgRender.utils._getPoint(nextpoint, currentseries);
                        point3 = BoldBIDashboard.EjSvgRender.utils._getPoint(visiblePoints[firstIndex + 1], currentseries);
                        chartObj = this.chartObj;
                        sb.append(startPath + " " + (point1.X + chartObj.canvasX) + " " + ((point1.Y + chartObj.canvasY)) + " " +
						"L" + " " + (point2.X + chartObj.canvasX) + " " + ((point2.Y + chartObj.canvasY)) + " " +
						"L" + " " + (point3.X + chartObj.canvasX) + " " + ((point3.Y + chartObj.canvasY)) + " ");
                    }
                    startPath = "L";
                }
                firstPoint = secondPoint;
                firstIndex = i;
            }
            else {
                firstPoint = null;
                startPath = "M";
            }
        }
        lDirection = sb.toString();

        this._drawLinePath(currentseries, style, lDirection);

        this.chartObj.svgRenderer.append(this.gSeriesGroupEle, this.chartObj.gSeriesEle); 
    }

});

BoldBIDashboard.ejStepAreaSeries = ejExtendClass(BoldBIDashboard.EjSeriesRender, {

    draw: function (chart, options, params) {
        this.chartObj = chart;
		options.animationType = "path";
		var requireInvertedAxes = this.chartObj.model.requireInvertedAxes;
        var aDirection;
        var sb = BoldBIDashboard.EjSvgRender.utils._getStringBuilder();
        var currentseries = options;
        var style = this.setAreaSeriesStyle(currentseries);
        if (currentseries.sorting)
            currentseries.points = BoldBIDashboard.DataManager(currentseries.points, BoldBIDashboard.Query().sortBy("xValue")).executeLocal();
        var visiblePoints = this.improveChartPerformance(currentseries);
        var xOffset = 0;
        var firstPoint = null;
        var secondPoint;
        if (currentseries.xAxis._valueType.toLowerCase() == "category" && currentseries.xAxis.labelPlacement.toLowerCase() != "onticks")
            xOffset = 0.5;
        var origin = BoldBIDashboard.EjSeriesRender.prototype.getOrigin(this, currentseries, params);
        var startPoint = null;
        var start = true;
        var chartObj = this.chartObj;
        for (var i = 0; i <= visiblePoints.length; i++) {

            if (i < visiblePoints.length) {
                if (visiblePoints[i].visible) {

                    secondPoint = { xValue: visiblePoints[i].xValue - xOffset, YValues: [visiblePoints[i].y] };
                    point1 = BoldBIDashboard.EjSvgRender.utils._getPoint(secondPoint, currentseries);
                    if (!startPoint) {
                        startPoint = { xValue: visiblePoints[i].xValue - xOffset, YValues: [origin] }
                        var startLoc = BoldBIDashboard.EjSvgRender.utils._getPoint(startPoint, currentseries);
                        sb.append("M" + " " + (startLoc.X + chartObj.canvasX) + " " + (startLoc.Y + chartObj.canvasY) + " ");
                    }
                    if (firstPoint != null) {
                        var step = { xValue: secondPoint.xValue, YValues: [firstPoint.YValues[0]] };
                        var stepPoint = BoldBIDashboard.EjSvgRender.utils._getPoint(step, currentseries);
                        if (start) {
                            sb.append("L" + " " + (point2.X + chartObj.canvasX) + " " + (point2.Y + chartObj.canvasY) + " ");
                            start = false;
                        }
                        sb.append("L" + " " + (stepPoint.X + chartObj.canvasX) + " " + ((stepPoint.Y + chartObj.canvasY)) + " " + "L" + " " + (point1.X + chartObj.canvasX) + " " + (point1.Y + chartObj.canvasY) + " ");
                        if ((xOffset == 0 && i == visiblePoints.length - 1) || (i < (visiblePoints.length - 1) && !visiblePoints[i + 1].visible)) {
                            if (xOffset > 0) {
                                secondPoint = { xValue: visiblePoints[i].xValue + xOffset, YValues: [visiblePoints[i].y] };
                                var point1 = BoldBIDashboard.EjSvgRender.utils._getPoint(secondPoint, currentseries);
                                 if (requireInvertedAxes)
                                    sb.append("L" + " " + (point1.X + chartObj.canvasX) + " " + (point1.Y + chartObj.canvasY) + " " + "L" + " " + (point1.Y + chartObj.canvasX) + " " + (startLoc.X + chartObj.canvasY) + " ");
                                 else
                                    sb.append("L" + " " + (point1.X + chartObj.canvasX) + " " + (point1.Y + chartObj.canvasY) + " " + "L" + " " + (point1.X + chartObj.canvasX) + " " + (startLoc.Y + chartObj.canvasY) + " ");
                            }
                            else
                               if (requireInvertedAxes)
                                    sb.append("L" + " " + (point1.Y + chartObj.canvasX)+ " " + (startLoc.X + chartObj.canvasY) + " ");
                                else
                                    sb.append("L" + " " + (point1.X + chartObj.canvasX)+ " " + (startLoc.Y + chartObj.canvasY) + " ");
                            startPoint = null;
                            firstPoint = null;
                            start = true;
                        }
                    }
                    if (startPoint) {
                        point2 = point1;
                        firstPoint = secondPoint;
                    }
                }
                else {
                    startPoint = null;
                    firstPoint = null;
                    start = true;
                }

              }
             else {
                if (visiblePoints.length > 0 && visiblePoints[i - 1].visible && xOffset > 0) {
                                secondPoint = { xValue: visiblePoints[i - 1].xValue + xOffset, YValues: [visiblePoints[i - 1].y] };
                                var point1 = BoldBIDashboard.EjSvgRender.utils._getPoint(secondPoint, currentseries);
                               if (requireInvertedAxes)
                                    sb.append("L" + " " + (point1.X + chartObj.canvasX) + " " + (point1.Y + chartObj.canvasY) + " " + "L" + " " + (point1.Y + chartObj.canvasX) + " " + (startLoc.X + chartObj.canvasY) + " ");
                                else
                                    sb.append("L" + " " + (point1.X + chartObj.canvasX) + " " + (point1.Y + chartObj.canvasY) + " " + "L" + " " + (point1.X + chartObj.canvasX) + " " + (startLoc.Y + chartObj.canvasY) + " ");
                       }                           
                }
            
         }
        aDirection = sb.toString();

        this.drawAreaPath(currentseries, style, aDirection);

        this.chartObj.svgRenderer.append(this.gSeriesGroupEle, this.chartObj.gSeriesEle);

    }
});
BoldBIDashboard.seriesTypes.steparea = BoldBIDashboard.ejStepAreaSeries;


BoldBIDashboard.seriesTypes.stepline = BoldBIDashboard.ejStepLineSeries;


 BoldBIDashboard.ejColumnSeries = ejExtendClass(BoldBIDashboard.EjSeriesRender, {
   
  
      
     draw: function (chart,options, params)
      { 
         this.chartObj=chart;
		 var requireInvertedAxes = this.chartObj.model.requireInvertedAxes;
		 options.animationType = "rect";
         var series = options;
         var seriesIndex = bbdesigner$.inArray(series, this.chartObj.model._visibleSeries);         
         var origin = BoldBIDashboard.EjSeriesRender.prototype.getOrigin(this, series, params);
        
         var sidebysideinfo = this.getSideBySideInfo(series, params);    
         var visiblePoints = this._isVisiblePoints(series);
         var legendMode = chart.model.legend.mode;
         var trans = BoldBIDashboard.EjSvgRender.utils._getTransform(series.xAxis, series.yAxis, requireInvertedAxes);

         var pointMarker;
         
         var serOptions = { 'id': this.chartObj.svgObject.id + '_SeriesGroup' + '_' + seriesIndex, 'transform': 'translate(' + trans.x + ',' + trans.y + ')' };

         this.gSeriesGroupEle = this.chartObj.svgRenderer.createGroup(serOptions);
         
         var cSer = this;
         for (var i = 0; i < visiblePoints.length; i++) {
             var pointIndex =  i;
             var point = visiblePoints[i];
             pointMarker = visiblePoints[i].marker;
           
             var y1 = point.YValues[0];
             var y2 = origin;
             if (point.visible) {
             //calculate sides
             var data = cSer.calculateSides(point, sidebysideinfo);
             var x1 = data.x1;
             var x2 = data.x2;
             
			 var styleOptions= this.chartObj.setStyle(cSer, series, seriesIndex, pointIndex);

			 var rect = cSer.getRectangle(x1, y1, x2, y2, series, chart);

             if (rect.X < 0) {
                 rect.Width = rect.Width + rect.X;
                 rect.X = 0;
             }
			 
             rect.Width = ((rect.X + rect.Width) > cSer.chartObj.model.m_AreaBounds.Width) ? cSer.chartObj.model.m_AreaBounds.Width - rect.X : rect.Width;
             //drawing part
             var xr = Math.min(0, rect.Width);
             var yr = Math.min(0, rect.Height);

             var  bounds;        
             if ((xr == 0 || yr == 0) && rect.Width > 0) {
                 pointIndex = legendMode == "point" || legendMode =="range" ? visiblePoints[i].actualIndex : pointIndex;
                 options = {
                     'id': cSer.chartObj.svgObject.id + '_Series' + seriesIndex + '_Point' + pointIndex,
                     'x': rect.X + cSer.chartObj.canvasX,
                     'y': rect.Y + cSer.chartObj.canvasY,
                     'width': rect.Width,
                     'height': rect.Height,
                     'fill': styleOptions.interior,
                     'stroke-width': styleOptions.borderWidth,
                     'plot': y1 < 0 ? "negative" : "positive",
                     'opacity': styleOptions.opacity,
                     'stroke': styleOptions.borderColor,
                     'stroke-dasharray': styleOptions.dashArray,
                 };

                         cSer.chartObj.svgRenderer.drawRect(options, cSer.gSeriesGroupEle);

                         var svgXy = BoldBIDashboard.EjSvgRender.utils._getSvgXY(rect.X, (rect.Y), series, cSer.chartObj);
                        bounds = { X: svgXy.X, Y: svgXy.Y, Width: rect.Width, Height: rect.Height };
                        BoldBIDashboard.EjSvgRender.utils._addRegion(cSer.chartObj, bounds, series, point, pointIndex);
                 }
            
                  if (requireInvertedAxes)
                      point.symbolLocation = { X: ((y1 < (series.xAxis._crossValue || 0) && !series.yAxis.isInversed) || (series.yAxis.isInversed && y1 > (series.xAxis._crossValue || 0))) ? (rect.X) : (rect.X + rect.Width), Y: ((rect.Y) + (rect.Height / 2)) };
                  else
                      point.symbolLocation = { X: rect.X + (rect.Width / 2), Y: ((y1 < (series.xAxis._crossValue || 0) && !series.yAxis.isInversed) || (series.yAxis.isInversed && y1 > (series.xAxis._crossValue ||0))) ? ((rect.Y) + (rect.Height)) : (rect.Y) };
                 
             }
         }

         this.chartObj.svgRenderer.append(this.gSeriesGroupEle, this.chartObj.gSeriesEle);

        
     },
   
   isRegion:true

 });
 BoldBIDashboard.seriesTypes.column = BoldBIDashboard.ejColumnSeries;

 BoldBIDashboard.ejStackingColumnSeries = ejExtendClass(BoldBIDashboard.EjSeriesRender, {

     draw: function (chart, options, params) {
         this.chartObj = chart;
		 options.animationType = "rect";
		 var requireInvertedAxes = this.chartObj.model.requireInvertedAxes;
         var series = options;
         var seriesIndex = bbdesigner$.inArray(series, this.chartObj.model._visibleSeries);
         //var origin = Math.max(options.yAxis.visibleRange.min, 0);
         var legendMode = this.chartObj.model.legend.mode;
         var sidebysideinfo = this.getSideBySideInfo(series, params);
         var visiblePoints = this._isVisiblePoints(series);

         var trans = BoldBIDashboard.EjSvgRender.utils._getTransform(series.xAxis, series.yAxis, requireInvertedAxes);

         var serOptions = { 'id': this.chartObj.svgObject.id + '_SeriesGroup' + '_' + seriesIndex, 'transform': 'translate(' + trans.x + ',' + trans.y + ')' };

         this.gSeriesGroupEle = this.chartObj.svgRenderer.createGroup(serOptions);
         var cSer = this;
         for (var i = 0; i < visiblePoints.length; i++) {
             var pointIndex = i;
             var point = series._visiblePoints[i];

             var y2 = series.stackedValue.StartValues[i];
             var y1= series.stackedValue.EndValues[i];
             if (point.visible) {
                 //calculate sides
                 var data = cSer.calculateSides(point, sidebysideinfo);
                 var x1 = data.x1;
                 var x2 = data.x2;
                 
				 var styleOptions= this.chartObj.setStyle(cSer, series, seriesIndex, pointIndex);

                 var rect = cSer.getRectangle(x1, y1, x2, y2, series, chart);
                 if (rect.X < 0) {
                     rect.Width = rect.Width + rect.X;
                     rect.X = 0;
                 }

                 rect.Width = ((rect.X + rect.Width) > cSer.chartObj.model.m_AreaBounds.Width) ? cSer.chartObj.model.m_AreaBounds.Width - rect.X : rect.Width;
                 //drawing part
                 var xr = Math.min(0, rect.Width);
                 var yr = Math.min(0, rect.Height);

                 var bounds;
                 if ((xr == 0 || yr == 0) && rect.Width > 0) {
                     pointIndex = legendMode == "point" || legendMode == "range" ? visiblePoints[i].actualIndex : pointIndex;
                     options = {
                         'id': cSer.chartObj.svgObject.id + '_Series' + seriesIndex + '_Point' + pointIndex,
                         'x': rect.X + cSer.chartObj.canvasX,
                         'y': rect.Y + cSer.chartObj.canvasY,
                         'width': rect.Width,
                         'height': rect.Height,
                         'fill': styleOptions.interior,
                         'stroke-width': styleOptions.borderWidth,
                         'plot': y1 < 0 ? "negative" : "positive",
                         'opacity': styleOptions.opacity,
                         'stroke': styleOptions.borderColor,
                         'stroke-dasharray': styleOptions.dashArray,
                     };

                     cSer.chartObj.svgRenderer.drawRect(options, cSer.gSeriesGroupEle);

                     var svgXy = BoldBIDashboard.EjSvgRender.utils._getSvgXY(rect.X, (rect.Y), series, cSer.chartObj);
                     bounds = { X: svgXy.X, Y: svgXy.Y, Width: rect.Width, Height: rect.Height };
                     BoldBIDashboard.EjSvgRender.utils._addRegion(cSer.chartObj, bounds, series, point, pointIndex);
                 }
                
                 if (requireInvertedAxes)
                     point.symbolLocation = { X: ((y1 < (series.xAxis._crossValue || 0) && !series.yAxis.isInversed) || (series.yAxis.isInversed && y1 > (series.xAxis._crossValue || 0))) ? (rect.X) : (rect.X + rect.Width), Y: ((rect.Y) + (rect.Height / 2)) };
                 else
                     point.symbolLocation = { X: rect.X + (rect.Width / 2), Y: ((y1 < (series.xAxis._crossValue || 0) && !series.yAxis.isInversed) || (series.yAxis.isInversed && y1 > (series.xAxis._crossValue || 0))) ? ((rect.Y) + (rect.Height)) : (rect.Y) };
                 
             }
         }

         this.chartObj.svgRenderer.append(this.gSeriesGroupEle, this.chartObj.gSeriesEle);

        

     },

     stackingSeries: true,
	  isRegion:true

 });
 BoldBIDashboard.seriesTypes.stackingcolumn = BoldBIDashboard.ejStackingColumnSeries;
 
 BoldBIDashboard.seriesTypes.stackingcolumn100 = BoldBIDashboard.ejStackingColumnSeries;

 BoldBIDashboard.seriesTypes.rangecolumn = BoldBIDashboard.ejRangeColumnSeries;

 BoldBIDashboard.ejRangeColumnSeries = ejExtendClass(BoldBIDashboard.EjSeriesRender, {
   
     draw: function (chart, options, params) {
         this.chartObj = chart;
		 options.animationType = "rect";
		 var requireInvertedAxes = this.chartObj.model.requireInvertedAxes;
         var series = options;
         var seriesIndex = bbdesigner$.inArray(series, this.chartObj.model._visibleSeries);
         var legendMode = this.chartObj.model.legend.mode;
         var sidebysideinfo = this.getSideBySideInfo(series, params);
         var visiblePoints = this._isVisiblePoints(series);

         var trans = BoldBIDashboard.EjSvgRender.utils._getTransform(series.xAxis, series.yAxis, requireInvertedAxes);

         var serOptions = { 'id': this.chartObj.svgObject.id + '_SeriesGroup' + '_' + seriesIndex, 'transform': 'translate(' + trans.x + ',' + trans.y + ')' };

         this.gSeriesGroupEle = this.chartObj.svgRenderer.createGroup(serOptions);
         var cSer = this;
         for (var i = 0; i < visiblePoints.length; i++) {
             var pointIndex = i;
             var point = visiblePoints[i];

             var y1 = point.YValues[0];
             var y2 = point.YValues[1];
             if (point.visible) {
                 //calculate sides
                 var data = cSer.calculateSides(point, sidebysideinfo);
                 var x1 = data.x1;
                 var x2 = data.x2;
                  
				 var styleOptions = this.chartObj.setStyle(cSer, series, seriesIndex, pointIndex);
				  
                 var rect = cSer.getRectangle(x1, y1, x2, y2, series, chart);
                 if (rect.X < 0) {
                     rect.Width = rect.Width + rect.X;
                     rect.X = 0;
                 }
                 var width=cSer.chartObj.model.m_AreaBounds.Width;
                 rect.Width = ((rect.X + rect.Width) > width) ? width - rect.X : rect.Width;
                 //drawing part
                 var xr = Math.min(0, rect.Width);
                 var yr = Math.min(0, rect.Height);

                 var bounds;
                 if (xr == 0 || yr == 0) {
                     pointIndex = legendMode == "point" || legendMode == "range" ? visiblePoints[i].actualIndex : pointIndex;
                     options = {
                         'id': cSer.chartObj.svgObject.id + '_Series' + seriesIndex + '_Point' + pointIndex,
                         'x': rect.X + cSer.chartObj.canvasX,
                         'y': rect.Y + cSer.chartObj.canvasY,
                         'width': rect.Width,
                         'height': rect.Height,
                         'fill': styleOptions.interior,
                         'stroke-width': styleOptions.borderWidth,
                         'opacity': styleOptions.opacity,
                         'stroke': styleOptions.borderColor,
                         'stroke-dasharray': styleOptions.dashArray,
                     };

                     cSer.chartObj.svgRenderer.drawRect(options, cSer.gSeriesGroupEle, trans.y);

                     //Add region for each rect
                     var svgXy = BoldBIDashboard.EjSvgRender.utils._getSvgXY(rect.X, (rect.Y), series, cSer.chartObj);
                     bounds = { X: svgXy.X, Y: svgXy.Y, Width: rect.Width, Height: rect.Height };
                     BoldBIDashboard.EjSvgRender.utils._addRegion(cSer.chartObj, bounds, series, point, pointIndex);
                 }
                 //Add rect location details for symbol                
                 if (series.type.toLowerCase() == "waterfall")
                     y1 = point.waterfallSum ? point.waterfallSum : point.y;              
                 if (requireInvertedAxes)
                     point.symbolLocation = { X: ((y1 < 0 && !series.yAxis.isInversed) || (series.yAxis.isInversed && y1 > 0)) ? (rect.X) : (rect.X + rect.Width), Y: ((rect.Y) + (rect.Height / 2)) };
                 else
                     point.symbolLocation = { X: rect.X + (rect.Width / 2), Y: ((y1 < 0 && !series.yAxis.isInversed) || (series.yAxis.isInversed && y1 > 0)) ? ((rect.Y) + (rect.Height)) : (rect.Y) };
                 
             }
         }

         this.chartObj.svgRenderer.append(this.gSeriesGroupEle, this.chartObj.gSeriesEle);

      

     },
	 
     hiloTypes: true,
	  isRegion:true

 });
 BoldBIDashboard.seriesTypes.rangecolumn = BoldBIDashboard.ejRangeColumnSeries;

 BoldBIDashboard.ejWaterfallSeries = ejExtendClass(BoldBIDashboard.EjSeriesRender, {

     draw: function (chart, options, params) {

         BoldBIDashboard.ejRangeColumnSeries.prototype.draw.call(this, chart, options, params);
         options.animationType = "rect";
         var chartRegions = this.chartObj.model.chartRegions;
         var seriesRegions = [];
         var areaBounds = this.chartObj.model.m_AreaBounds;
         var seriesIndex = bbdesigner$.inArray(options, this.chartObj.model._visibleSeries);
         options.index = seriesIndex;

         for (var j = 0, i = 0; j < chartRegions.length; j++) {
             if (seriesIndex == chartRegions[j].SeriesIndex) {
                 seriesRegions[i] = chartRegions[j];
                 i += 1;
             }
         }
         var serOptions1 = { 'id': this.chartObj.svgObject.id + '_SeriesGroup' + '_waterfallLine_' + seriesIndex };

         this.connectorLineGroup = this.chartObj.svgRenderer.createGroup(serOptions1);

         var sb, point1, point2, y, y1, t1, t2, lineOptions;
         for (var k = 0; k < seriesRegions.length - 1; k++) {
             sb = BoldBIDashboard.EjSvgRender.utils._getStringBuilder();
             point1 = seriesRegions[k].Region.Bounds;
             point2 = seriesRegions[k + 1].Region.Bounds;

             if (!options.isTransposed) {
                 y1 = Math.ceil(point1.Y), h1 = Math.ceil(point1.Height), y2 = Math.ceil(point2.Y), h2 = Math.ceil(point2.Height);
                 t1 = Math.ceil(point1.Y + point1.Height);
                 y = ((y1 == y2) ? point1.Y : (t1 == y2 ? point2.Y : (point2.Y + point2.Height)));
                 sb.append("M " + (point1.X) + " " + (y) + " L " + (point2.X + point2.Width )+ " " + y);
             } else {
                 x1 = Math.ceil(point1.X), w1 = Math.ceil(point1.Width), x2 = Math.ceil(point2.X), w2 = Math.ceil(point2.Width);
                 t1 = Math.ceil(point1.X + point1.Width);
                 t2 = Math.ceil(point2.X + point2.Width);
                 x = ((t1 == t2) ? (point1.X + point1.Width) : (x1 == x2 ? point1.X : (x1 == t2 ? point1.X: (point1.X + point1.Width))));
                 sb.append("M " + (x) + " " + (point1.Y + point1.Height) + " L " + x + " " + (point2.Y));
             }

             
             lDirection = sb.toString();
             if (lDirection != "" && point1.Height >= 0) {
                 lineOptions = {
                     'id': this.chartObj.svgObject.id + "_waterFall_" + seriesIndex + "_connectorLine_" + k,
                     'fill': 'none',
                     'stroke-dasharray': options.connectorLine.dashArray,
                     'stroke-width': options.connectorLine.width,
                     'stroke': options.connectorLine.color,
                     'opacity': options.connectorLine.opacity,
                     'd': lDirection
                 };
                 this.chartObj.svgRenderer.drawPath(lineOptions, this.connectorLineGroup);
             }
         }
         this.chartObj.svgRenderer.append(this.connectorLineGroup, this.chartObj.gSeriesEle);

         if (options.enableAnimation && !options._animatedSeries)
             this.chartObj.svgRenderer._setAttr(this.connectorLineGroup, { "visibility": "hidden" });
     },

     hiloTypes: false,
     isRegion: true
 });
 BoldBIDashboard.seriesTypes.waterfall = BoldBIDashboard.ejWaterfallSeries;

 BoldBIDashboard.ejStackingBarSeries = ejExtendClass(BoldBIDashboard.EjSeriesRender, {
     
     draw: function (chart, options, params) {
         this.chartObj = chart;
		 options.animationType = "rect";
		 var requireInvertedAxes = this.chartObj.model.requireInvertedAxes;
         var series = options;
         var seriesIndex = bbdesigner$.inArray(series, this.chartObj.model._visibleSeries);
         //var origin = Math.max(options.yAxis.visibleRange.min, 0);
         var sidebysideinfo = this.getSideBySideInfo(series, params);
         var visiblePoints = this._isVisiblePoints(series);
         var trans = BoldBIDashboard.EjSvgRender.utils._getTransform(series.xAxis, series.yAxis, requireInvertedAxes);
         var legendMode = this.chartObj.model.legend.mode;
         var serOptions = { 'id': this.chartObj.svgObject.id + '_SeriesGroup' + '_' + seriesIndex, 'transform': 'translate(' + trans.x + ',' + trans.y + ')' };

         this.gSeriesGroupEle = this.chartObj.svgRenderer.createGroup(serOptions);
         var cSer = this;
         for (var i = 0; i < visiblePoints.length; i++) {
             var pointIndex = i;
             var point = visiblePoints[i];
             var y1 = series.stackedValue.EndValues[i];
             var y2 =series.stackedValue.StartValues[i];
             if (point.visible) {
                 //calculate sides
                 var data = cSer.calculateSides(point, sidebysideinfo);
                 var x1 = data.x1;
                 var x2 = data.x2;
                 
				 var styleOptions = this.chartObj.setStyle(cSer, series, seriesIndex, pointIndex);

                 var rect = cSer.getRectangle(x1, y1, x2, y2, series, chart);
				 if (!requireInvertedAxes) {
				     if (rect.X < 0) {
				         rect.Width = rect.Width + rect.X;
				         rect.X = 0;
				     }
				     rect.Width = ((rect.X + rect.Width) > cSer.chartObj.model.m_AreaBounds.Width) ? cSer.chartObj.model.m_AreaBounds.Width - rect.X : rect.Width;
				 }
                 var xr = Math.min(0, rect.Width);
                 var yr = Math.min(0, rect.Height);

                 if (xr == 0 || yr == 0) {
                     var bounds;
                     pointIndex = legendMode == "point" || legendMode == "range" ? visiblePoints[i].actualIndex : pointIndex;
                     options = {
                         'id': cSer.chartObj.svgObject.id + '_Series' + seriesIndex + '_Point' + pointIndex,
                         'x': rect.X + cSer.chartObj.canvasX,
                         'y': rect.Y + cSer.chartObj.canvasY,
                         'width': rect.Width,
                         'height': rect.Height,
                         'fill': styleOptions.interior,
                         'stroke-width': styleOptions.borderWidth,
						 'opacity': styleOptions.opacity,
						 'stroke': styleOptions.borderColor,
						 'stroke-dasharray': styleOptions.dashArray,
                     };

                     cSer.chartObj.svgRenderer.drawRect(options, cSer.gSeriesGroupEle);

                     var svgXy = BoldBIDashboard.EjSvgRender.utils._getSvgXY((rect.X), (rect.Y), series, cSer.chartObj);
                     bounds = { X: svgXy.X, Y: svgXy.Y, Width: rect.Width, Height: rect.Height };

                     BoldBIDashboard.EjSvgRender.utils._addRegion(cSer.chartObj, bounds, series, point, pointIndex);
                 }

               
                 if (!requireInvertedAxes)
                     point.symbolLocation = { X: rect.X + (rect.Width / 2), Y: ((y1 < (series.yAxis._crossValue || 0) && !series.yAxis.isInversed) || (series.yAxis.isInversed && y1 > (series.yAxis._crossValue || 0))) ? ((rect.Y) + (rect.Height)) : (rect.Y) };
                 else
                     point.symbolLocation = { X: ((y1 < (series.yAxis._crossValue || 0) && !series.yAxis.isInversed) || (series.yAxis.isInversed && y1 > (series.yAxis._crossValue || 0))) ? (rect.X) : (rect.X + rect.Width), Y: ((rect.Y) + (rect.Height / 2)) };
               
             }
         }

         this.chartObj.svgRenderer.append(this.gSeriesGroupEle, this.chartObj.gSeriesEle);
 

     },
	 
     stackingSeries: true,
     requireInvertedAxes: true,
	  isRegion:true

 });
 BoldBIDashboard.seriesTypes.stackingbar = BoldBIDashboard.ejStackingBarSeries;

 BoldBIDashboard.seriesTypes.stackingbar100 = BoldBIDashboard.ejStackingBarSeries;

 BoldBIDashboard.ejBarSeries = ejExtendClass(BoldBIDashboard.EjSeriesRender, {
    
     draw: function (chart, options, params) {
         this.chartObj = chart;
		 options.animationType = "rect";
		 var requireInvertedAxes = this.chartObj.model.requireInvertedAxes;
         var series = options;
         var seriesIndex = bbdesigner$.inArray(series, this.chartObj.model._visibleSeries);
         var origin = BoldBIDashboard.EjSeriesRender.prototype.getOrigin(this, series, params);
         var style = bbdesigner$.extend(true, {}, this.chartObj.model.seriesStyle, series.style);
         var sidebysideinfo = this.getSideBySideInfo(series, params);
         var visiblePoints = this._isVisiblePoints(series);
         var colors;
         var legendMode = this.chartObj.model.legend.mode;
         var trans = BoldBIDashboard.EjSvgRender.utils._getTransform(series.xAxis, series.yAxis, requireInvertedAxes);
         
         var serOptions = { 'id': this.chartObj.svgObject.id + '_SeriesGroup' + '_' + seriesIndex, 'transform': 'translate(' + trans.x + ',' + trans.y + ')' };

         this.gSeriesGroupEle = this.chartObj.svgRenderer.createGroup(serOptions);
         var cSer = this;
         for (var i = 0; i < visiblePoints.length; i++) {
             var pointIndex = i;
             var point = visiblePoints[i];           
             var y1 = point.YValues[0];
             var y2 = origin;
             if (point.visible) {
                 //calculate sides
                 var data = cSer.calculateSides(point, sidebysideinfo);
                 var x1 = data.x1;
                 var x2 = data.x2;
                 
				 var styleOptions = this.chartObj.setStyle(cSer, series, seriesIndex, pointIndex);

                 var rect = cSer.getRectangle(x1, y1, x2, y2, series, chart);
				 if (!requireInvertedAxes) {
				     if (rect.X < 0)
				     {
				         rect.Width = rect.Width + rect.X;
				         rect.X = 0;
				     }
				     rect.Width = ((rect.X + rect.Width) > cSer.chartObj.model.m_AreaBounds.Width) ? cSer.chartObj.model.m_AreaBounds.Width - rect.X : rect.Width;
				 }
                
                 var xr = Math.min(0, rect.Width);
                 var yr = Math.min(0, rect.Height);

                if (xr == 0 || yr == 0) {
                    var bounds;
                    pointIndex = legendMode == "point" || legendMode == "range" ? visiblePoints[i].actualIndex : pointIndex;
                         options = {
                             'id': cSer.chartObj.svgObject.id + '_Series' + seriesIndex+ '_Point' + pointIndex,
                             'x': rect.X + cSer.chartObj.canvasX,
                             'y': rect.Y + cSer.chartObj.canvasY,
                             'width': rect.Width,
                             'height': rect.Height,
                             'fill': styleOptions.interior,
                             'stroke-width': styleOptions.borderWidth,
                             'plot': y1 < 0 ? "negative" : "positive",
                             'opacity': styleOptions.opacity,
                             'stroke': styleOptions.borderColor,
                             'stroke-dasharray': styleOptions.dashArray,
                         };

                         cSer.chartObj.svgRenderer.drawRect(options, cSer.gSeriesGroupEle);

                         var svgXy = BoldBIDashboard.EjSvgRender.utils._getSvgXY((rect.X), (rect.Y), series, cSer.chartObj);
                        bounds = { X: svgXy.X, Y: svgXy.Y, Width: rect.Width, Height: rect.Height };
                     
                        BoldBIDashboard.EjSvgRender.utils._addRegion(cSer.chartObj, bounds, series, point, pointIndex);
                 }


                 
                  if (!requireInvertedAxes)
                      point.symbolLocation = { X: rect.X + (rect.Width / 2), Y: ((y1 < (series.xAxis._crossValue || 0) && !series.yAxis.isInversed) || (series.yAxis.isInversed && y1 > (series.xAxis._crossValue || 0))) ? ((rect.Y) + (rect.Height)) : (rect.Y) };
                else
                    point.symbolLocation = { X: ((y1 < (series.xAxis._crossValue || 0) && !series.yAxis.isInversed) || (series.yAxis.isInversed && y1 > (series.xAxis._crossValue || 0))) ? (rect.X) : (rect.X + rect.Width), Y: ((rect.Y) + (rect.Height / 2)) };
                
             }
         }

         this.chartObj.svgRenderer.append(this.gSeriesGroupEle, this.chartObj.gSeriesEle);

        
     },
	 
     requireInvertedAxes: true,
	  isRegion:true
 });
 BoldBIDashboard.seriesTypes.bar = BoldBIDashboard.ejBarSeries;


 BoldBIDashboard.ejStackingAreaSeries = ejExtendClass(BoldBIDashboard.EjSeriesRender, {

     draw: function (chart, options) {
         this.chartObj = chart;
         options._animationType = "path";
         var aDirection, currentPoint, point1;
         var areasb = BoldBIDashboard.EjSvgRender.utils._getStringBuilder();
         var currentSeries = options;
         var style = this.setAreaSeriesStyle(currentSeries);
         var visiblePoints = this._isVisiblePoints(currentSeries);
         var origin = Math.max(options.yAxis.visibleRange.min, currentSeries.stackedValue.StartValues[0]);
         var canvasX = this.chartObj.canvasX;
         var canvasY = this.chartObj.canvasY;
         var startPoint = { xValue: visiblePoints[0].xValue, YValues: [origin] };
         var startLoc = BoldBIDashboard.EjSvgRender.utils._getPoint(startPoint, currentSeries), startValue = 0, endLength = currentSeries.stackedValue.EndValues.length;
         areasb.append("M" + " " + (startLoc.X + canvasX) + " " + (startLoc.Y + canvasY) + " ");
         //var index = bbdesigner$.inArray(currentSeries, this.chartObj.model._visibleSeries);
         for (var j = 0; j <= endLength; j++) {
             if (j != endLength && visiblePoints[j].visible) {
                 currentPoint = { xValue: visiblePoints[j].xValue, YValues: [currentSeries.stackedValue.EndValues[j]] };
                 if (visiblePoints[j].visible) {
                     point1 = visiblePoints[j].location = BoldBIDashboard.EjSvgRender.utils._getPoint(currentPoint, currentSeries);
                     areasb.append("L" + " " + (point1.X + canvasX) + " " + ((point1.Y + canvasY)) + " ");
                     visiblePoints[j].YValues[0] = currentPoint.YValues[0];
                 }
             }
             else {
                 origin = currentSeries.stackedValue.StartValues[j + 1];
                 for (var i = j - 1; i >= startValue; i--) {
                     currentPoint = { xValue: visiblePoints[i].xValue, YValues: [currentSeries.stackedValue.StartValues[i]] };
                     point1 = BoldBIDashboard.EjSvgRender.utils._getPoint(currentPoint, currentSeries);
                     areasb.append("L" + " " + (point1.X + canvasX) + " " + ((point1.Y + canvasY)) + " ");
                 }
                 if (visiblePoints[j + 1] && visiblePoints[j + 1].visible) {
                     var startPoint = { xValue: visiblePoints[j + 1].xValue, YValues: [currentSeries.stackedValue.StartValues[j + 1]] };
                     var startLoc = BoldBIDashboard.EjSvgRender.utils._getPoint(startPoint, currentSeries);
                     areasb.append("M" + " " + (startLoc.X + canvasX) + " " + (startLoc.Y + canvasY) + " ");
                 }
                 startValue = j + 1;
             }
         }
         aDirection = areasb.toString();
         this.drawAreaPath(currentSeries, style, aDirection);
         this.chartObj.svgRenderer.append(this.gSeriesGroupEle, this.chartObj.gSeriesEle);
     },
     stackingSeries: true
 });
 
 BoldBIDashboard.seriesTypes.stackingarea = BoldBIDashboard.ejStackingAreaSeries;

 BoldBIDashboard.seriesTypes.stackingarea100 = BoldBIDashboard.ejStackingAreaSeries;

 BoldBIDashboard.ejAreaSeries = ejExtendClass(BoldBIDashboard.EjSeriesRender, {

  
     draw: function (chart,options, params) {
         this.chartObj = chart;
         var aDirection;
		 options.animationType = "path";
         var areasb = BoldBIDashboard.EjSvgRender.utils._getStringBuilder();
         var currentSeries = options;
         var style = this.setAreaSeriesStyle(currentSeries);
         var chartObj = this.chartObj;
         if (currentSeries.sorting)
         	currentSeries.points = BoldBIDashboard.DataManager(currentSeries.points, BoldBIDashboard.Query().sortBy("xValue")).executeLocal();
      
         var visiblePoints = this._isVisiblePoints(currentSeries);
         var origin = BoldBIDashboard.EjSeriesRender.prototype.getOrigin(this, currentSeries, params);
         
         var startPoint;
         var translate = [];
         translate[0] = chartObj.canvasX;
         translate[1] = chartObj.canvasY;
        
         for (var i = 0; i < visiblePoints.length; i++) {
             if (visiblePoints[i].visible) {
                 if (visiblePoints.length > i + 1) {
                     if (!startPoint) {
                         startPoint = { xValue: visiblePoints[i].xValue, YValues: [origin] }
                         var point1 = BoldBIDashboard.EjSvgRender.utils._getPoint(startPoint, currentSeries);
                         areasb.append("M" + " " + (point1.X) + " " + ((point1.Y)) + " ");
                     }


                     var point1 = BoldBIDashboard.EjSvgRender.utils._getPoint(visiblePoints[i], currentSeries);

                     areasb.append("L" + " " + (point1.X) + " " + ((point1.Y)) + " ");

                     if (!visiblePoints[i + 1].visible) {
                         point = { xValue: visiblePoints[i].xValue, YValues: [origin] }
                         var point2 = BoldBIDashboard.EjSvgRender.utils._getPoint(point, currentSeries);
                         var point3 = BoldBIDashboard.EjSvgRender.utils._getPoint(startPoint, currentSeries);
                         areasb.append("L" + " " + (point2.X) + " " + ((point2.Y)) + " " + "L" + " " + (point3.X) + " " + ((point3.Y)) + " ");
                         startPoint = null;
                     }
                 }
                 else {
                     if (visiblePoints[i - 1] && visiblePoints[i - 1].visible) {
                         var point1 = BoldBIDashboard.EjSvgRender.utils._getPoint(visiblePoints[i], currentSeries);
                         areasb.append("L" + " " + (point1.X) + " " + ((point1.Y)) + " ");
                     }
                 }
             }         
         }

         if (visiblePoints.length > 0) {
         var endPoint = { xValue: visiblePoints[visiblePoints.length - 1].xValue, YValues: [origin] };
         var endLoc = BoldBIDashboard.EjSvgRender.utils._getPoint(endPoint, currentSeries);
         }
         if (visiblePoints.length > 1)
             areasb.append("L" + " " + (endLoc.X) + " " + ((endLoc.Y)) + " ");
         
         aDirection = areasb.toString();

         this.drawAreaPath(currentSeries, style, aDirection, translate);

         this.chartObj.svgRenderer.append(this.gSeriesGroupEle, this.chartObj.gSeriesEle);

     
       

     }

 });

 BoldBIDashboard.seriesTypes.area = BoldBIDashboard.ejAreaSeries;

 BoldBIDashboard.ejRangeAreaSeries = ejExtendClass(BoldBIDashboard.EjSeriesRender, {


     draw: function (chart, options) {
         this.chartObj = chart;
         var aDirection;
		 options.animationType = "path";
         var areasb = BoldBIDashboard.EjSvgRender.utils._getStringBuilder();
         var currentSeries = options;
         var style = this.setAreaSeriesStyle(currentSeries);
         var seriesIndex = bbdesigner$.inArray(currentSeries, this.chartObj.model._visibleSeries);
         currentSeries.points = BoldBIDashboard.DataManager(currentSeries.points, BoldBIDashboard.Query().sortBy("xValue")).executeLocal();

         var visiblePoints = this._isVisiblePoints(currentSeries);        
         var translate = [];
         translate[0] = this.chartObj.canvasX;
         translate[1] = this.chartObj.canvasY;
         var startPoint;
         var internalRegion=[]
         for (var i = 0; i < visiblePoints.length; i++) {
             internalRegion[i] = {Region:{PointIndex:i}, SeriesIndex:seriesIndex, region:[]};
             if (visiblePoints[i].visible) {     
                     if (!startPoint) {
                         var origin = visiblePoints[i].low;
                         startPoint = { xValue: visiblePoints[i].xValue, YValues: [origin] }
                         var point1 = BoldBIDashboard.EjSvgRender.utils._getPoint(startPoint, currentSeries);
                         areasb.append("M" + " " + (point1.X) + " " + ((point1.Y)) + " ");
                     }
                 var point1 = BoldBIDashboard.EjSvgRender.utils._getPoint(visiblePoints[i], currentSeries);
                 areasb.append("L" + " " + (point1.X) + " " + ((point1.Y)) + " ");
                 internalRegion[i].region.push({ X: point1.X, Y: point1.Y });
                 if (i != 0)
                     internalRegion[i - 1].region.push({ X: point1.X, Y: point1.Y });
                 
                 if( (i +1 ) < visiblePoints.length &&  !visiblePoints[i+1].visible)
                 {
                     for (var j = i; j >=0; j--)
                     {
                         if (visiblePoints[j].visible) {
                             origin = visiblePoints[j].low;
                             var point = { xValue: visiblePoints[j].xValue, YValues: [origin] };
                             var point2 = BoldBIDashboard.EjSvgRender.utils._getPoint(point, currentSeries);
                             areasb.append("L" + " " + (point2.X) + " " + ((point2.Y)) + " ");
                             internalRegion[j].region.push({ X: point2.X, Y: point2.Y });
                             if(j!=0)
                                 internalRegion[j - 1].region.push({ X: point2.X, Y: point2.Y });
                         }
                         else
                             break;
                     }
                     startPoint = null;
                 }

              
             }
         }
         for (var i = visiblePoints.length-1; i >= 0; i--)
         {
             if (visiblePoints[i].visible)
             {
                 origin = visiblePoints[i].low;
                 var point = { xValue: visiblePoints[i].xValue, YValues: [origin] };
                 var point2 = BoldBIDashboard.EjSvgRender.utils._getPoint(point, currentSeries);
                 areasb.append("L" + " " + (point2.X) + " " + ((point2.Y)) + " ");
                 internalRegion[i].region.push({ X: point2.X, Y: point2.Y });
                 if(i!=0)
                     internalRegion[i - 1].region.push({ X: point2.X, Y: point2.Y });

             }
             else if (visiblePoints.length>i && visiblePoints[i].visible)
             {
                 var point2 = BoldBIDashboard.EjSvgRender.utils._getPoint(visiblePoints[i], currentSeries);
                 areasb.append("L" + " " + (point2.X) + " " + ((point2.Y)) + " ");
                 break;
             }                       
             else if (i != (visiblePoints.length - 1))
			  {
                 var count=0;
                 for(k=i-1;k>=0;k--)
                 {
                     if (visiblePoints[k].visible)
                        count++;
                     else if (!visiblePoints[k].visible)
                        break;
                 }
                 i = i - count;
             }
         }     
         aDirection = areasb.toString();
         for (var i = 0; i < visiblePoints.length; i++) {
             BoldBIDashboard.EjSvgRender.utils._addRegion(this.chartObj, internalRegion[i], currentSeries, point, i);

         }

         this.drawAreaPath(currentSeries, style, aDirection, translate);
         this.chartObj.svgRenderer.append(this.gSeriesGroupEle, this.chartObj.gSeriesEle);
     },

     hiloTypes:true,
	 isRegion :true

 });

 BoldBIDashboard.seriesTypes.rangearea = BoldBIDashboard.ejRangeAreaSeries;

 BoldBIDashboard.ejSplineRangeAreaSeries = ejExtendClass(BoldBIDashboard.EjSeriesRender, {
    draw: function (chart, options, params) {
        this.chartObj = chart;
        var series = new BoldBIDashboard.seriesTypes["splinearea"]();
        series.draw(chart, options, params);
    },
    chartAreaType: "cartesianAxes",
    hiloTypes: true,
	isRegion: true
 });
 BoldBIDashboard.seriesTypes.splinerangearea = BoldBIDashboard.ejSplineRangeAreaSeries;

 BoldBIDashboard.ejSplineSeries = ejExtendClass(BoldBIDashboard.EjSeriesRender, {
    
     draw: function (chart,options, params) {
		 if(!params.seriesCollection)
		 {			
			params.seriesCollection = {  };
			options._name = options._name || options.name;
			params.seriesCollection[options._name] = {};
         }
         this.chartObj = chart;
		 options.animationType = "path";
         var series = options,
			spDirection = "",
            splinesb = BoldBIDashboard.EjSvgRender.utils._getStringBuilder(),
            style = this.setLineSeriesStyle(series),
            yIndex = 0,
            visiblePoints = this._isVisiblePoints(series),
            ySpline = this.naturalSpline(visiblePoints, series, yIndex) || params.seriesCollection[series._name].naturalSpline,
            firstPoint = null,
            secondPoint = null,
            firstIndex = -1, controlPointsCount = 0,
			controlPoints = [] || params.seriesCollection[series._name].controlPoints;
			
		 //Removed spline sorting behavior based on the 'X' points.
         //series.points = BoldBIDashboard.DataManager(series.points, BoldBIDashboard.Query().sortBy("X")).executeLocal();
         
         for (var i = 0; i < visiblePoints.length; i++) {
             var pointIndex = i;
             secondPoint = visiblePoints[i];             
             if (secondPoint.visible) {
                 if (firstPoint != null) {
                     var controlPoint1 = null;
                     var controlPoint2 = null;
                     var data = controlPoints[controlPointsCount++] || this.getBezierControlPoints(firstPoint, secondPoint, ySpline[firstIndex], ySpline[pointIndex], yIndex);
                     controlPoint1 = data["controlPoint1"];
                     controlPoint2 = data["controlPoint2"];
                     var pt1 = BoldBIDashboard.EjSvgRender.utils._getPoint(firstPoint, series);
                     var pt2 = BoldBIDashboard.EjSvgRender.utils._getPoint(secondPoint, series);
                     var bpt1 = BoldBIDashboard.EjSvgRender.utils._getPoint(controlPoint1, series);
                     var bpt2 = BoldBIDashboard.EjSvgRender.utils._getPoint(controlPoint2, series);
                     var chartObj = this.chartObj;
                     splinesb.append("M" + " " + (pt1.X + chartObj.canvasX) + " " + (pt1.Y + chartObj.canvasY) + " " + "C" + " " + (bpt1.X + chartObj.canvasX) + " " + (bpt1.Y + chartObj.canvasY) + " " + (bpt2.X + chartObj.canvasX) + " " + (bpt2.Y + chartObj.canvasY) + " " + (pt2.X + chartObj.canvasX) + " " + (pt2.Y + chartObj.canvasY) + " ");

                 }
                 firstPoint = secondPoint;
                 firstIndex = pointIndex;
             } else {
                 firstPoint = null;
             }
         }
         
        spDirection = splinesb.toString();
        this._drawLinePath(series, style, spDirection);

         this.chartObj.svgRenderer.append(this.gSeriesGroupEle, this.chartObj.gSeriesEle);

     }

 });

 BoldBIDashboard.seriesTypes.spline = BoldBIDashboard.ejSplineSeries;

 BoldBIDashboard.ejSplineAreaSeries = ejExtendClass(BoldBIDashboard.EjSeriesRender, {


     draw: function (chart, options, params) {
		 if(!params.seriesCollection)
		 {
			params.seriesCollection = {  };
			options._name = options._name || options.name;
			params.seriesCollection[options._name] = {};
         }
         this.chartObj = chart;
		 options.animationType = "path";
		 var requireInvertedAxes = this.chartObj.model.requireInvertedAxes;
         var series = options;
         var spDirection = "";
         var splinesb = BoldBIDashboard.EjSvgRender.utils._getStringBuilder();
         var style = this.setAreaSeriesStyle(series);
         var yIndex = 0, yIndex1 = 1;
         //Removed splineArea sorting behavior based on the 'X' points.
         if (series.sorting)
         	series.points = BoldBIDashboard.DataManager(series.points, BoldBIDashboard.Query().sortBy("xValue")).executeLocal();
         var visiblePoints = this._isVisiblePoints(series);
         var ySpline = this.naturalSpline(visiblePoints, series, yIndex) || params.seriesCollection[series._name].naturalSpline;
		 var ySpline1 =  this.naturalSpline(visiblePoints, series, yIndex1) || params.seriesCollection[series._name].naturalSpline1;
         var firstPoint = null;
         var secondPoint = null;
		 var previousSeriesPoints = null;
         var firstIndex = -1;
		 var internalRegion = [], stackingsplinepath = [];
         var origin = BoldBIDashboard.EjSeriesRender.prototype.getOrigin(this, series, params);
         var startPoint = null;
         var start = true;
         var chartObj = this.chartObj;
		 var seriesIndex = series._seriesIndex;
		 var seriesType = series.type.toLowerCase();
         var translate = [], controlPointsCount = 0, controlPoints = [] || params.seriesCollection[series._name].controlPoints;
         translate[0] = chartObj.canvasX;
         translate[1] = chartObj.canvasY;
         var count = 0;
         for (var i = 0; i < visiblePoints.length; i++) {
			 internalRegion[i] = { Region: { PointIndex: i }, SeriesIndex: seriesIndex, region: [] };
             var pointIndex = i;
             secondPoint = visiblePoints[i];
             if (secondPoint.visible) {
               if (!startPoint) {
                        if (seriesIndex == 0 || seriesType.indexOf('stackingsplinearea') == -1)
                            startPoint = { xValue: visiblePoints[i].xValue, YValues: [origin] };
                        else {
                            var actualIndex = bbdesigner$.inArray(options, chartObj.model._visibleSeries);
                            for (var m = actualIndex; m > 0; m--) {
                                var ser = chartObj.model.series[m - 1];
                                if (ser.visibility != "hidden") {
                                    previousSeriesPoints = ser.points;
                                    break;
                                }
                            }
                            startPoint = { xValue: visiblePoints[i].xValue, YValues: [previousSeriesPoints[i].YValues[0]] };
                        }
                        var startLoc = BoldBIDashboard.EjSvgRender.utils._getPoint(startPoint, series);
                    }
				 if (seriesType == "splinerangearea")
                    {
                        var point1 = BoldBIDashboard.EjSvgRender.utils._getPoint(visiblePoints[i], series);
                        internalRegion[i].region.push({ X: point1.X, Y: point1.Y });
                        if (i != 0)
                            internalRegion[i - 1].region.push({ X: point1.X, Y: point1.Y });
                    }
                 if (firstPoint != null) {
                     var controlPoint1 = null;
                     var controlPoint2 = null;
					 if (seriesType == "splinerangearea")
                        var data = controlPoints[pointIndex - 1] || this.getBezierControlPoints(firstPoint, secondPoint, ySpline[firstIndex], ySpline[pointIndex], yIndex, series, this);
				     else
						var data = controlPoints[controlPointsCount++] || this.getBezierControlPoints(firstPoint, secondPoint, ySpline[firstIndex], ySpline[pointIndex], yIndex);
                     controlPoint1 = data["controlPoint1"];
                     controlPoint2 = data["controlPoint2"];
                     var pt1 = BoldBIDashboard.EjSvgRender.utils._getPoint(firstPoint, series);
                     var pt2 = BoldBIDashboard.EjSvgRender.utils._getPoint(secondPoint, series);
                     var bpt1 = BoldBIDashboard.EjSvgRender.utils._getPoint(controlPoint1, series);
                     var bpt2 = BoldBIDashboard.EjSvgRender.utils._getPoint(controlPoint2, series);
                     if (start) {
                         if (requireInvertedAxes)
                             splinesb.append("M" + " " + (startLoc.X) + " " + (pt1.Y) + " " + "L" + " " + (pt1.X) + " " + ((pt1.Y)) + " ");
                         else
                             splinesb.append("M" + " " + (pt1.X) + " " + (startLoc.Y) + " " + "L" + " " + (pt1.X) + " " + ((pt1.Y)) + " ");
                         start = false;
                     }
                     splinesb.append("C" + " " + (bpt1.X) + " " + (bpt1.Y) + " " + (bpt2.X) + " " + (bpt2.Y) + " " + (pt2.X) + " " + (pt2.Y) + " ");
                     if (seriesType == "splinerangearea") {
                            if (requireInvertedAxes)
                                stackingsplinepath[pointIndex] = ("C" + " " + (bpt2.low) + " " + (bpt2.Y) + " " + (bpt1.low) + " " + (bpt1.Y) + " " + (pt1.low) + " " + (pt1.Y) + " ");
                            else
                                stackingsplinepath[pointIndex] = ("C" + " " + (bpt2.X) + " " + (bpt2.low) + " " + (bpt1.X) + " " + (bpt1.low) + " " + (pt1.X) + " " + (pt1.low) + " ");
                    }
					 if (pointIndex == visiblePoints.length - 1 || (pointIndex < visiblePoints.length - 1 && !visiblePoints[i + 1].visible)) {
                        if ((seriesIndex != 0 && seriesType.indexOf("stackingsplinearea") != -1) || seriesType == "splinerangearea") {
                                startPoint = { xValue: visiblePoints[i].xValue, YValues: seriesType == "splinerangearea" ? visiblePoints[i].YValues : [previousSeriesPoints[i].YValues[0]] };
                                startLoc = BoldBIDashboard.EjSvgRender.utils._getPoint(startPoint, series);
                            }
						if (requireInvertedAxes)
                            splinesb.append("L" + " " + (seriesType == "splinerangearea" ? pt2.low :startLoc.X) + " " + (pt2.Y) + " ");
                         else
                            splinesb.append("L" + " " + (pt2.X) + " " + (seriesType == "splinerangearea" ? startLoc.low : startLoc.Y) + " ");
                         startPoint = null;
                         start = true;
                     }
                 }
				 else if (seriesType.indexOf("splinerangearea") != -1) {
                        if (pointIndex > 0 && emptyPointSettings.displayMode == "gap")
                            this.drawbackCurve(controlPoints, series, stackingsplinepath, pointIndex, secondPoint);
                    }
                 firstPoint = secondPoint;
                 firstIndex = pointIndex;
             } else {
                 firstPoint = null;
				 if ((seriesType.indexOf("splinerangearea") != -1) && pointIndex > 0 && emptyPointSettings.displayMode == "gap")
                        this.drawbackCurve(controlPoints, series, stackingsplinepath, pointIndex, secondPoint);                    
             }
         }
		 if (chartObj.model.series[seriesIndex].type.toLowerCase() == "splinerangearea") {
                for (var i = visiblePoints.length - 1; i >= 0; i--) {
                    origin = visiblePoints[i].low;
                    var point = { xValue: visiblePoints[i].xValue, YValues: [origin] };
                    var point2 = BoldBIDashboard.EjSvgRender.utils._getPoint(point, series);
                    internalRegion[i].region.push({ X: point2.X, Y: point2.Y });
                    if (i != 0)
                        internalRegion[i - 1].region.push({ X: point2.X, Y: point2.Y });
                }
            }
         spDirection = splinesb.toString();
		 if (seriesType == "splinerangearea") {
                rangeDirection = this._getReversePath(series, stackingsplinepath);
                spDirection = spDirection + rangeDirection + "Z";
				for (var i = 0; i < visiblePoints.length; i++)
					BoldBIDashboard.EjSvgRender.utils._addRegion(chartObj, internalRegion[i], series, point, i);         
				//this.chartObj.model.chartRegions.push(internalRegion);
         }
         this.drawAreaPath(series, style, spDirection, translate);

         this.chartObj.svgRenderer.append(this.gSeriesGroupEle, this.chartObj.gSeriesEle);
		 
		 this.chartObj.gSeriesGroupEle = this.gSeriesGroupEle;

     },
	 _getReversePath: function (series, reversePath) {
            var emptyPointSettings = series.emptyPointSettings,
                path = "", points = series.points;
            if (!BoldBIDashboard.util.isNullOrUndefined(reversePath)) {
                for (var i = 0; i < points.length; i++) {
                    var pointIndex = i;
                    if (!points[pointIndex].visible) {
                        if (!points[pointIndex].isEmpty || emptyPointSettings.displayMode == "gap") {
                            if (pointIndex == 0) {
                                if (reversePath[pointIndex + 1])
                                    reversePath[pointIndex + 1] = "";
                            }
                            else if (pointIndex == points.length - 1) {
                                if (reversePath[pointIndex])
                                    reversePath[pointIndex] = "";
                            }
                            else {
                                if (reversePath[pointIndex])
                                    reversePath[pointIndex] = "";
                                if (reversePath[pointIndex + 1])
                                    reversePath[pointIndex + 1] = "";
                            }
                        }

                    }
                }
                for (var j = reversePath.length - 1; j > 0; j--) {
                    path = path + reversePath[j];
                }
            }
            return path;
        },

        drawbackCurve: function (controlPoints, series, stackingsplinepath, pointIndex, secondPoint) {
            var data = controlPoints[pointIndex - 1];
            controlPoint1 = data["controlPoint1"];
            controlPoint2 = data["controlPoint2"];
            var pt1 = BoldBIDashboard.EjSvgRender.utils._getPoint(series.points[pointIndex - 1], series);
            var pt2 = BoldBIDashboard.EjSvgRender.utils._getPoint(secondPoint, series);
            var bpt1 = BoldBIDashboard.EjSvgRender.utils._getPoint(controlPoint1, series);
            var bpt2 = BoldBIDashboard.EjSvgRender.utils._getPoint(controlPoint2, series);
            stackingsplinepath[pointIndex] = ("C" + " " + (bpt2.X) + " " + (bpt2.Y) + " " + (bpt1.X) + " " + (bpt1.Y) + " " + (pt1.X) + " " + (pt1.Y) + " ");
        }
 });

 BoldBIDashboard.seriesTypes.splinearea = BoldBIDashboard.ejSplineAreaSeries;



 BoldBIDashboard.ejScatterSeries = ejExtendClass(BoldBIDashboard.EjSeriesRender, {

        
    
     draw: function (chart,options) {
         this.chartObj = chart;
         var series = options;
		 options.animationType = "scatter";
		 var seriesIndex = bbdesigner$.inArray(options, this.chartObj.model._visibleSeries);
        var visiblePoints = this._isVisiblePoints(series);
		 var visiblePointsLength=visiblePoints.length;
		 var point,point1;
        for (var i = 0; i < visiblePointsLength; i++)
        {
            point = visiblePoints[i];
            var pointIndex = i;
            point1 = BoldBIDashboard.EjSvgRender.utils._getPoint(point, options);
            this.drawSymbol(seriesIndex, options, pointIndex, point1.X, point1.Y);
        }

     }
 });

 BoldBIDashboard.seriesTypes.scatter = BoldBIDashboard.ejScatterSeries;

 
 BoldBIDashboard.ejBubbleSeries = ejExtendClass(BoldBIDashboard.EjSeriesRender, {

     createBubbleGroup: function(series) {

         var seriesIndex = bbdesigner$.inArray(series, this.chartObj.model.series);
         var transX = series.xAxis.x;

         var transY = series.yAxis.y;
         var serOptions = { 'id': this.chartObj.svgObject.id + '_SeriesGroup' + '_' + seriesIndex, 'transform': 'translate(' + transX + ',' + transY + ')' };

         this.gSeriesGroupEle = this.chartObj.svgRenderer.createGroup(serOptions);

     },
     draw: function (chart,options) {
         this.chartObj = chart;
		 options.animationType = "bubble";
         var series = options;    
         series.points = BoldBIDashboard.DataManager(series.points, BoldBIDashboard.Query().sortBy("xValue")).executeLocal();
         var seriesIndex = bbdesigner$.inArray(series, this.chartObj.model._visibleSeries); 
         var visiblePoints = this._isVisiblePoints(series);
         var sizeValueIndex = 1;
         var legendMode = this.chartObj.model.legend.mode;
		 //bubble responsive
         var bubbleOptions = options.bubbleOptions;
         var temp = 100;
         var areaBounds = chart.model.m_AreaBounds;
         var value = Math.max(areaBounds.Height, areaBounds.Width);
         var minRadius = (bubbleOptions && bubbleOptions.minRadius) ? bubbleOptions.minRadius : 1;
         var maxRadius = (bubbleOptions && bubbleOptions.maxRadius) ? bubbleOptions.maxRadius : 3;
         var percentChange=value/temp;
         var minRadius = minRadius * percentChange;
         var maxRadius = maxRadius * percentChange;
         var radius = maxRadius - minRadius;
         var segmentRadius;
         var maximumSize = Math.max.apply(0,bbdesigner$.map(visiblePoints,function (v) { if(v.YValues[sizeValueIndex]!=0) return v.YValues[sizeValueIndex]; }));
		 var minimumSize = Math.min.apply(0, bbdesigner$.map(visiblePoints, function (v) { if(v.YValues[sizeValueIndex]!=0) return v.YValues[sizeValueIndex]; }));
         this.createBubbleGroup(series);
         for (var i = 0; i < visiblePoints.length; i++) {
             var point = visiblePoints[i];
             var pointIndex= i;
             if (point.visible) {
				if (maximumSize < 0)
                    segmentRadius = minRadius + radius * Math.abs(maximumSize / point.YValues[sizeValueIndex]);                            
                else if (minimumSize < 0)
                    segmentRadius = point.YValues[sizeValueIndex] < 0 && -point.YValues[sizeValueIndex] > maximumSize ? Math.abs(minRadius + radius * (point.YValues[sizeValueIndex]/maximumSize)): minRadius + radius * Math.abs(point.YValues[sizeValueIndex]/maximumSize);
                else
					segmentRadius = minRadius + radius * Math.abs(point.YValues[sizeValueIndex] / maximumSize);
                 var location = BoldBIDashboard.EjSvgRender.utils._getPoint(point, series);
                 
				 var styleOptions = this.chartObj.setStyle(this, series, seriesIndex, pointIndex);
				 pointIndex = legendMode == "point" || legendMode == "range" ? visiblePoints[i].actualIndex : pointIndex;
                 var options = {
                     'id': this.chartObj.svgObject.id + '_Series' + seriesIndex + '_Point' + pointIndex,
                     'cx': location.X + this.chartObj.canvasX,
                     'cy': (location.Y) + this.chartObj.canvasY,
                     'r': point.YValues[sizeValueIndex] !=0 ? segmentRadius : 0,
                     'fill': styleOptions.interior,
                     'stroke-width': styleOptions.borderWidth,
                     'stroke-dasharray': styleOptions.dashArray,
                     'opacity': styleOptions.opacity,
                     'stroke': styleOptions.borderColor
                 };

                 point.radius = segmentRadius; // radius is stored to draw tracksymbol for bubble in canvas
                 
                 this.chartObj.svgRenderer.drawCircle(options, this.gSeriesGroupEle);
				 
			 

                 var cx = location.X;
                 var cy = location.Y;
                 var r = segmentRadius;


                 var valwidth, x, y, valheight;
                 x = ((cx - r) + series.xAxis.x);
                 y = ((cy - r) + series.yAxis.y);

                 valheight = 2 * r;
                 valwidth = 2 * r;

                 var bounds = { X: x, Y: y, Width: valwidth, Height: valheight };
                 BoldBIDashboard.EjSvgRender.utils._addRegion(this.chartObj, bounds, series, null, i);
             }
         }
         this.chartObj.svgRenderer.append(this.gSeriesGroupEle, this.chartObj.gSeriesEle);

     }
 });

BoldBIDashboard.seriesTypes.bubble = BoldBIDashboard.ejBubbleSeries;
 BoldBIDashboard.ejhiloSeries = ejExtendClass(BoldBIDashboard.EjSeriesRender, {
     draw: function (chart, options, params) {

         this.chartObj = chart;
		 options.animationType = "hilo";
         var requireInvertedAxes = this.chartObj.model.requireInvertedAxes;
         //DrawHiloGraph      
        
         var currentseries = options;
          currentseries.points = BoldBIDashboard.DataManager(currentseries.points, BoldBIDashboard.Query().sortBy("xValue")).executeLocal();
         var visiblePoints = this._isVisiblePoints(currentseries);
         var sidebysideinfo = this.getSideBySideInfo(currentseries, params);
         var point = null;
         
         var seriesIndex = bbdesigner$.inArray(currentseries, this.chartObj.model._visibleSeries);
         var trans = BoldBIDashboard.EjSvgRender.utils._getTransform(currentseries.xAxis, currentseries.yAxis, requireInvertedAxes);
         var serOptions = { 'id': this.chartObj.svgObject.id + '_SeriesGroup' + '_' + seriesIndex, 'transform': 'translate(' + trans.x + ',' + trans.y + ')' };
         this.gSeriesGroupEle = this.chartObj.svgRenderer.createGroup(serOptions);
       

         for (var i = 0; i < visiblePoints.length; i++) {
             point = visiblePoints[i];
			 var pointIndex= i;
             if (point.visible) {
                
                 var lDirection = "";
                    if (BoldBIDashboard.util.isNullOrUndefined(point.YValues[0]) || BoldBIDashboard.util.isNullOrUndefined(point.YValues[1]))
                     continue;
					 
                    var styleOptions = this.chartObj.setStyle(this, currentseries, seriesIndex, pointIndex);

                    var pathInterior = this.chartObj.setHiloStyle(currentseries, pointIndex, seriesIndex);
              
				 
                 var lowvalue = {}, highvalue = {};
                 if (point.YValues[0] < point.YValues[1]) {
                     lowvalue = { xValue: point.xValue + sidebysideinfo.Median, YValues: [point.YValues[0]] };
                     highvalue = { xValue: point.xValue + sidebysideinfo.Median, YValues: [point.YValues[1]] };
                 } else {
                     lowvalue = { xValue: point.xValue + sidebysideinfo.Median, YValues: [point.YValues[1]] };
                     highvalue = { xValue: point.xValue + sidebysideinfo.Median, YValues: [point.YValues[0]] };
                 }
                 var point1 = BoldBIDashboard.EjSvgRender.utils._getPoint(lowvalue   , currentseries);
                 var point2 = BoldBIDashboard.EjSvgRender.utils._getPoint(highvalue, currentseries);
                 lDirection = "M" + " " + (point1.X + this.chartObj.canvasX) + " " + ((point1.Y + this.chartObj.canvasY)) + " " + "L" + " " + (point2.X + this.chartObj.canvasX) + " " + ((point2.Y + this.chartObj.canvasY)) + " ";
                 var pointbounds = { point1:point1, point2:point2 };
                 this._drawHiloPath(currentseries, styleOptions, pathInterior, lDirection, i, pointbounds);
             }
         }
        
         this.chartObj.svgRenderer.append(this.gSeriesGroupEle, this.chartObj.gSeriesEle);
     },
     
     hiloTypes: true
 });

 BoldBIDashboard.seriesTypes.hilo = BoldBIDashboard.ejhiloSeries;
 
 //Draw HiloOpenClose
 BoldBIDashboard.ejhiloopencloseSeries = ejExtendClass(BoldBIDashboard.EjSeriesRender, {
     draw: function (chart, options, params) {

         this.chartObj = chart;
         var requireInvertedAxes = this.chartObj.model.requireInvertedAxes;
         //DrawHiloGraph      
         options.animationType = "hilo";
         var currentseries = options;
         currentseries.points = BoldBIDashboard.DataManager(currentseries.points, BoldBIDashboard.Query().sortBy("xValue")).executeLocal();
         var visiblePoints = this._isVisiblePoints(currentseries);
         var sidebysideinfo = this.getSideBySideInfo(currentseries, params);
         var point = null;

         var seriesIndex = bbdesigner$.inArray(currentseries, this.chartObj.model._visibleSeries);
         var trans = BoldBIDashboard.EjSvgRender.utils._getTransform(currentseries.xAxis, currentseries.yAxis, requireInvertedAxes);
         var serOptions = { 'id': this.chartObj.svgObject.id + '_SeriesGroup' + '_' + seriesIndex, 'transform': 'translate(' + trans.x + ',' + trans.y + ')' };
         this.gSeriesGroupEle = this.chartObj.svgRenderer.createGroup(serOptions);
         
         var interior;

     


         for (var i = 0; i < visiblePoints.length; i++) {
		    var pointIndex = i;
             point = visiblePoints[i];
             if (point.visible) {

                 var lDirection = "";
                 var drawOpenWing = (BoldBIDashboard.util.isNullOrUndefined(currentseries.drawMode) ? true : (currentseries.drawMode.toLowerCase() == "both" || currentseries.drawMode.toLowerCase() == "open") ? true : false);
                 var drawCloseWing = (BoldBIDashboard.util.isNullOrUndefined(currentseries.drawMode) ? true : (currentseries.drawMode.toLowerCase() == "both" || currentseries.drawMode.toLowerCase() == "close") ? true : false);

                
                 var lowvalue = {}, highvalue = {}, openvalue = {}, closevalue = {};
                  
                    
                 if (point.YValues[0] < point.YValues[1]) {
                     lowvalue = { xValue: point.xValue + sidebysideinfo.Median, YValues: [point.YValues[0]] };
                     highvalue = { xValue: point.xValue + sidebysideinfo.Median, YValues: [point.YValues[1]] };
                     openvalue = { xValue: point.xValue, YValues: [point.YValues[2]] };
                     closevalue = { xValue: point.xValue, YValues: [point.YValues[3]] };
                     
                 } else {
                     lowvalue = { xValue: point.xValue + sidebysideinfo.Median, YValues: [point.YValues[1]] };
                     highvalue = { xValue: point.xValue + sidebysideinfo.Median, YValues: [point.YValues[0]] };
                     openvalue = { xValue: point.xValue, YValues: [point.YValues[2]] };
                     closevalue = { xValue: point.xValue, YValues: [point.YValues[3]] };
                    
                 }
				 currentseries.fill = currentseries.isFill ? currentseries.fill : null;
                 if (point.YValues[2] < point.YValues[3]) 
                     currentseries.bearFillColor = interior = (BoldBIDashboard.util.isNullOrUndefined(currentseries.bearFillColor)) ? ((currentseries.fill) ? currentseries.fill : "#339933") : currentseries.bearFillColor;
                 
                 else 
                     currentseries.bullFillColor = interior = (BoldBIDashboard.util.isNullOrUndefined(currentseries.bullFillColor)) ? ((currentseries.fill) ? currentseries.fill : "#E51400") : currentseries.bullFillColor;
                    
				 
                 var styleOptions = this.chartObj.setStyle(this, currentseries, seriesIndex, pointIndex, interior);

                 var pathInterior = this.chartObj.setHiloStyle(currentseries, pointIndex,seriesIndex, interior);
                 

				 if (point.fill) {
                     interior = bbdesigner$.type(point.interior) == "array" ? point.fill[0] : point.fill;
                 }
                 else {
                      point._hiloFill = interior;
                 }
				 var canvasX = this.chartObj.canvasX;
				 var canvasY = this.chartObj.canvasY;
                 
                 //Draw open points
                 if (drawOpenWing) {

                     var startOpenValue = { xValue: openvalue.xValue + sidebysideinfo.Median, YValues: openvalue.YValues };
                     var pto1 = BoldBIDashboard.EjSvgRender.utils._getPoint(startOpenValue, currentseries);
                     var endOpenValue = { xValue: openvalue.xValue + sidebysideinfo.Start, YValues: openvalue.YValues };
                     var pto2 = BoldBIDashboard.EjSvgRender.utils._getPoint(endOpenValue, currentseries);
                      lDirection = "M" + " " + (pto1.X + canvasX) + " " + ((pto1.Y + canvasY)) + " " + "L" + " " + (pto2.X + canvasX) + " " + ((pto2.Y + canvasY)) + " ";
                     var openbounds = { point1: pto1, point2: pto2 };
                     this._drawHiloPath(currentseries, styleOptions,pathInterior,  lDirection, i, openbounds);
                     lDirection = "";

                 }
                 //Draw close points
                 if (drawCloseWing) {
                     var startCloseValue = { xValue: closevalue.xValue + sidebysideinfo.Median, YValues: closevalue.YValues };
                     var ptc1 = BoldBIDashboard.EjSvgRender.utils._getPoint(startCloseValue, currentseries);
                     var endCloseValue = { xValue: closevalue.xValue + sidebysideinfo.End, YValues: closevalue.YValues };
                     var ptc2 = BoldBIDashboard.EjSvgRender.utils._getPoint(endCloseValue, currentseries);
                     lDirection = "M" + " " + (ptc1.X + canvasX) + " " + ((ptc1.Y + canvasY)) + " " + "L" + " " + (ptc2.X + canvasX) + " " + ((ptc2.Y + canvasY)) + " ";
                     var pointbounds = { point1: ptc1, point2: ptc2 };
                     this._drawHiloPath(currentseries, styleOptions, pathInterior, lDirection, i, pointbounds);
                     lDirection = "";

                 }
                 // Draw High low points
                 var point1 = BoldBIDashboard.EjSvgRender.utils._getPoint(lowvalue, currentseries);
                 var point2 = BoldBIDashboard.EjSvgRender.utils._getPoint(highvalue, currentseries);
                 lDirection = "M" + " " + (point1.X + canvasX) + " " + ((point1.Y + canvasY)) + " " + "L" + " " + (point2.X + canvasX) + " " + ((point2.Y + canvasY)) + " ";
                 var bounds = { point1: point1, point2: point2 };
                 this._drawHiloPath(currentseries, styleOptions, pathInterior, lDirection, i, bounds);
             }

         }
         this.chartObj.svgRenderer.append(this.gSeriesGroupEle, this.chartObj.gSeriesEle);
     
     },

     hiloTypes: true

 });

 BoldBIDashboard.seriesTypes.hiloopenclose = BoldBIDashboard.ejhiloopencloseSeries;
 
 //Draw candle
BoldBIDashboard.ejCandleSeries = ejExtendClass(BoldBIDashboard.EjSeriesRender, {
     draw: function (chart, options, params) {

         this.chartObj = chart;
		 options.animationType = "hilo";
         var requireInvertedAxes = this.chartObj.model.requireInvertedAxes;
         //DrawCandleGraph      

         var currentseries = options;
         currentseries.points = BoldBIDashboard.DataManager(currentseries.points, BoldBIDashboard.Query().sortBy("xValue")).executeLocal();
         var visiblePoints = this._isVisiblePoints(currentseries);
         var sidebysideinfo = this.getSideBySideInfo(currentseries, params);
         var point = null;

         var seriesIndex = bbdesigner$.inArray(currentseries, this.chartObj.model._visibleSeries);
         var trans = BoldBIDashboard.EjSvgRender.utils._getTransform(currentseries.xAxis, currentseries.yAxis, requireInvertedAxes);
         var serOptions = { 'id': this.chartObj.svgObject.id + '_SeriesGroup' + '_' + seriesIndex, 'transform': 'translate(' + trans.x + ',' + trans.y + ')' };
         this.gSeriesGroupEle = this.chartObj.svgRenderer.createGroup(serOptions);
         var interior;

         for (var i = 0; i < visiblePoints.length; i++) {
             point = visiblePoints[i];
			  var pointIndex= i;
             if (point.visible) {

                 var lDirection = "";
               
                 var lowvalue = {}, highvalue = {}, openvalue = {}, closevalue = {};
                 
                
                 if (point.YValues[0] < point.YValues[1]) {
                     lowvalue = { xValue: point.xValue + sidebysideinfo.Median, YValues: [point.YValues[0]] };
                     highvalue = { xValue: point.xValue + sidebysideinfo.Median, YValues: [point.YValues[1]] };
                     openvalue = { xValue: point.xValue, YValues: [point.YValues[2]] };
                     closevalue = { xValue: point.xValue, YValues: [point.YValues[3]] };
                     
                 } else {
                     lowvalue = { xValue: point.xValue + sidebysideinfo.Median, YValues: [point.YValues[1]] };
                     highvalue = { xValue: point.xValue + sidebysideinfo.Median, YValues: [point.YValues[0]] };
                     openvalue = { xValue: point.xValue, YValues: [point.YValues[2]] };
                     closevalue = { xValue: point.xValue, YValues: [point.YValues[3]] };
                     
                 }      
                 if (point.YValues[2] < point.YValues[3]) {
                     
                     openvalue = { xValue: point.xValue, YValues: [point.YValues[2]] };
                     closevalue = { xValue: point.xValue, YValues: [point.YValues[3]] };
                     currentseries.bearFillColor = interior = (BoldBIDashboard.util.isNullOrUndefined(currentseries.bearFillColor)) ? "#339933" : currentseries.bearFillColor;
                     
                 } else {
                    
                     openvalue = { xValue: point.xValue, YValues: [point.YValues[3]] };
                     closevalue = { xValue: point.xValue, YValues: [point.YValues[2]] };
                     currentseries.bullFillColor = interior = (BoldBIDashboard.util.isNullOrUndefined(currentseries.bullFillColor)) ? "#E51400" : currentseries.bullFillColor;
                    
                 }
                 
                 var styleOptions = this.chartObj.setStyle(this, currentseries, seriesIndex, pointIndex, interior);

                 var pathInterior = this.chartObj.setHiloStyle(currentseries, pointIndex,seriesIndex, interior);
				 
				 if (point.style && point.style.interior) {
                     interior = bbdesigner$.type(point.style.interior) == "array" ? point.style.interior[0] : point.style.interior;
                 }
               
                 else {
                     point._hiloFill = pathInterior;
                 }

                 //Draw High low points
                 var point1 = BoldBIDashboard.EjSvgRender.utils._getPoint(lowvalue, currentseries);
                 var point2 = BoldBIDashboard.EjSvgRender.utils._getPoint(highvalue, currentseries);
                 var canvasX = this.chartObj.canvasX;
                 var canvasY = this.chartObj.canvasY;
                 lDirection = "M" + " " + (point1.X + canvasX) + " " + ((point1.Y + canvasY)) + " " + "L" + " " + (point2.X + canvasX) + " " + ((point2.Y + canvasY)) + " ";
                 var pointbounds = { point1: point1, point2: point2 };
                 this._drawHiloPath(currentseries, styleOptions, pathInterior, lDirection, i, pointbounds);
                 //Draw open and close points
              
                 var startRect = { xValue: closevalue.xValue + sidebysideinfo.Start, YValues: closevalue.YValues };
                     var orginRect = BoldBIDashboard.EjSvgRender.utils._getPoint(startRect, currentseries);

                     var rectSize = { xValue: openvalue.xValue + sidebysideinfo.End, YValues: openvalue.YValues };
                     var sizeRect = BoldBIDashboard.EjSvgRender.utils._getPoint(rectSize, currentseries);
                     var rect = BoldBIDashboard.EjSvgRender.utils._correctRect(orginRect.X, orginRect.Y, sizeRect.X, sizeRect.Y);
                  
                     var candleOptions = {
                        'id': this.chartObj.svgObject.id + '_Series' + seriesIndex+ '_Point' + i,
                        'x': rect.X + this.chartObj.canvasX,
                        'y': rect.Y + this.chartObj.canvasY,
                        'width': rect.Width,
                        'height': rect.Height,
                        'fill': styleOptions.interior,
                        'stroke-width': styleOptions.borderWidth,
                        'stroke-dasharray': styleOptions.dashArray,
                         'stroke': styleOptions.borderColor
                     };

                    this.chartObj.svgRenderer.drawRect(candleOptions, this.gSeriesGroupEle);

                    var svgXy = BoldBIDashboard.EjSvgRender.utils._getSvgXY(rect.X, rect.Y, currentseries, this.chartObj);
                    var bounds = { X: svgXy.X, Y: svgXy.Y, Width: rect.Width, Height: rect.Height };

                    BoldBIDashboard.EjSvgRender.utils._addRegion(this.chartObj, bounds, currentseries, point, i);
                                    
             }
             
         }
         this.chartObj.svgRenderer.append(this.gSeriesGroupEle, this.chartObj.gSeriesEle);
        

     },
     
     hiloTypes: true
 });
 BoldBIDashboard.seriesTypes.candle = BoldBIDashboard.ejCandleSeries;

 BoldBIDashboard.ejPieSeries = ejExtendClass(BoldBIDashboard.EjSeriesRender, {

     draw: function (chart, options) {

         this.chartObj = chart;
         var currentseries = options;
         var internalRegion = [];
         var visiblePoints = this._calculateVisiblePoints(options).visiblePoints;
        
         var size = this.calculatingSliceAngle(currentseries);                  
         var seriesIndex = bbdesigner$.inArray(currentseries, this.chartObj.model._visibleSeries);
         var seriesLength = this.chartObj.model._visibleSeries.length;
         var chartObj = this.chartObj;
		 var svgWidth = bbdesigner$(chartObj.svgObject).width();
		 var svgHeight = bbdesigner$(chartObj.svgObject).height();
		 this.getRadius(chartObj, seriesIndex, size);
					
		 if (chartObj.model.adaptiveRendering && !chartObj.model.totalRadius)
		     this.getCompleteRadius(this.chartObj, size);
       
	     chartObj.flag = false
		 chartObj.responsiveFlag = false;
         if (this.chartObj.model.adaptiveRendering) {
             if (chartObj.model.legend.visible && chartObj.model.legend.responsiveVisibility && !chartObj.model.legend._position) {
                 if (svgWidth > svgHeight && svgWidth > chartObj.model.totalRadius * 2)
                     chartObj.model.legend.responsivePosition = "right";
                 else
                     chartObj.model.legend.responsivePosition = "bottom";
             }
            while ((2 * this.chartObj.model.totalRadius < svgHeight / 2 || svgHeight <= 150) && !chartObj.flag) {
                this.count = BoldBIDashboard.util.isNullOrUndefined(this.count) ? 1 : this.count + 1;
				chartObj.responsiveFlag = true;
                this.responsiveAccLayout(this.count, currentseries);
            }
			
			this.accumulationLayout(chartObj);
			   
            BoldBIDashboard.BoldBIDashboardChart._calculateLegendBounds(chartObj);
            BoldBIDashboard.BoldBIDashboardChart._calculateAreaBounds(chartObj.params, chartObj);
            size = this.calculatingSliceAngle(currentseries);
            this.getRadius(chartObj, seriesIndex, size);
         }
		 
        var min= Math.min(size.width, size.height);
        if (min < 0)
        {
            return min;
        }
        var totalDegree=Math.abs(currentseries.endAngle-currentseries.startAngle);
        if (totalDegree < 270) 
            this.pieDoughnutCenter(currentseries);
         var text;
        
         var serOptions = { 'id': this.chartObj.svgObject.id + '_SeriesGroup' + '_' + seriesIndex };
         this.gSeriesGroupEle = this.chartObj.svgRenderer.createGroup(serOptions);

         var visibility = (currentseries.enableAnimation && !currentseries._animatedSeries) ? 'hidden' : 'visible';

        
         var txtOptions = { 'id': this.chartObj.svgObject.id + '_TextGroup' + '_' + seriesIndex, 'visibility': visibility };
         if (!this.chartObj.gSeriesTextEle) this.chartObj.gSeriesTextEle = [];
         this.chartObj.gSeriesTextEle[seriesIndex] = this.chartObj.svgRenderer.createGroup(txtOptions);
         var symbolOptions = { 'id': this.chartObj.svgObject.id + '_symbolGroup' + '_' + seriesIndex, 'visibility': visibility };
         if (!this.chartObj.gSymbolGroupEle) this.chartObj.gSymbolGroupEle = [];
         this.chartObj.gSymbolGroupEle[seriesIndex] = this.chartObj.svgRenderer.createGroup(symbolOptions);

         var connectorOptions = { 'id': this.chartObj.svgObject.id + '_connectorGroup' + '_' + seriesIndex, 'visibility': visibility };
         if (!this.chartObj.gConnectorEle) this.chartObj.gConnectorEle = [];
         this.chartObj.gConnectorEle[seriesIndex] = this.chartObj.svgRenderer.createGroup(connectorOptions);
         var dataLabelOptions = { 'id': this.chartObj.svgObject.id + '_DataLabel_' + seriesIndex, 'visibility': visibility };
         if (!this.chartObj.gDataLabelEle) this.chartObj.gDataLabelEle = [];
         this.chartObj.gDataLabelEle[seriesIndex] = this.chartObj.svgRenderer.createGroup(dataLabelOptions);
             
                 
         for (var j = 0; j < visiblePoints.length; j++) {
             pointIndex = j;
             if (isNaN(currentseries._visiblePoints[j].startAngle)) continue;
             var point = currentseries._visiblePoints[j];
             if (point.visible) {
                 var result = this._calculateArcData(this.chartObj, pointIndex, point, currentseries, seriesIndex);
                 var sliceXY = result.Direction.split(" "); 
             var styleOptions = this.chartObj.setStyle(this, currentseries, seriesIndex,  pointIndex);
			 if (currentseries.startAngle < currentseries.endAngle) // for canvas rendering with modified start and end angle
                     var counterClockWise = false;
                 else
                     counterClockWise = true;
            
             for (k = 0; k < currentseries.visiblePoints.length; k++) {
                        if (point == currentseries.visiblePoints[k]) {
                            pointIndex = k;
                            break;
                        }
                    }		 
             options = {
                 'id': this.chartObj.svgObject.id + '_Series' + seriesIndex + "_Point" + pointIndex,
                 'fill': styleOptions.interior,
                 'stroke-width': styleOptions.borderWidth,
                 'stroke': styleOptions.borderColor,
                 'stroke-dasharray': styleOptions.dashArray,
                     'stroke-linecap': currentseries.lineCap,
                     'stroke-linejoin': currentseries.lineJoin,
                     'd': result.Direction,
                     'opacity': styleOptions.opacity,
                     'radius':this.chartObj.model.circularRadius[seriesIndex],
                     'start': point.startAngle - 1.57,
                     'end': point.endAngle - 1.57,
                     'pointIndex': pointIndex,
					 'counterClockWise': counterClockWise,
                     'innerR': 0,
					  'cx': result.centerX,
                     'cy':result.centerY,
                     'x': sliceXY[12],
                     'y': sliceXY[13]
                 };
                 this.chartObj.svgRenderer.drawPath(options, this.gSeriesGroupEle);

                 region = { PointIndex: pointIndex, Index: j, StartAngle: point.startAngle, EndAngle: point.endAngle, StartX: this.chartObj.model.startX[j], StartY: this.chartObj.model.startY[j] ,
                            SeriesIndex: bbdesigner$.inArray(currentseries, this.chartObj.model._visibleSeries)};
                 internalRegion.push(region);

             }
         }

         var seriesData = { Radius: this.chartObj.model.circularRadius[seriesIndex], CenterX: this.chartObj.model.circleCenterX[seriesIndex], CenterY: this.chartObj.model.circleCenterY[seriesIndex] };
         var region = { Series: currentseries, SeriesData: seriesData, Region: internalRegion, SeriesIndex: bbdesigner$.inArray(currentseries, this.chartObj.model._visibleSeries) };
         this.chartObj.model.chartRegions.push(region);

         this.chartObj.svgRenderer.append(this.gSeriesGroupEle, this.chartObj.gSeriesEle);
     },
 
     chartAreaType : "None"

 });

 BoldBIDashboard.seriesTypes.pie = BoldBIDashboard.ejPieSeries;

 BoldBIDashboard.ejDoughnutSeries = ejExtendClass(BoldBIDashboard.EjSeriesRender, {
     draw: function (chart, options) {
         this.chartObj = chart;
         var currentseries = options;
         var internalRegion = [];
         var chartObj = this.chartObj;
         this.chartObj.model.bounds = [];
         var coefficient = currentseries.doughnutCoefficient >= 0 ? (currentseries.doughnutCoefficient <= 1 ? currentseries.doughnutCoefficient : 1) : 0;
         var doughnutSize = currentseries.doughnutSize >= 0 ? (currentseries.doughnutSize <= 1 ? currentseries.doughnutSize : 1) : 0;
         var visiblePoints = this._calculateVisiblePoints(options).visiblePoints;
         var size = this.calculatingSliceAngle(currentseries);
		 var visiblePointslength = visiblePoints.length;  
          var seriesIndex = bbdesigner$.inArray(currentseries, this.chartObj.model._visibleSeries);
         var seriesLength = this.chartObj.model._visibleSeries.length;
         var seriesLength = this.chartObj.model._visibleSeries.length;
		 var currentSeries = chartObj.model._visibleSeries[seriesIndex];
		 var svgWidth = bbdesigner$(chartObj.svgObject).width();
		 var svgHeight = bbdesigner$(chartObj.svgObject).height();
         this.getRadius(chartObj, seriesIndex, size);
					
		 if (chartObj.model.adaptiveRendering && !chartObj.model.totalRadius)
		     this.getCompleteRadius(this.chartObj, size);   
         
         chartObj.flag = false
		 chartObj.responsiveFlag = false;
         if (this.chartObj.model.adaptiveRendering) {
             if (chartObj.model.legend.visible && chartObj.model.legend.responsiveVisibility && !chartObj.model.legend._position) {
                 if (svgWidth > svgHeight && svgWidth > chartObj.model.totalRadius * 2)
                     chartObj.model.legend.responsivePosition = "right";
                 else
                     chartObj.model.legend.responsivePosition = "bottom";
             }

             while ((2 * this.chartObj.model.totalRadius < svgHeight / 2 || svgHeight <= 150) && !chartObj.flag) {
                 this.count = BoldBIDashboard.util.isNullOrUndefined(this.count) ? 1 : this.count + 1;
				 chartObj.responsiveFlag = true;
                 this.responsiveAccLayout(this.count, currentseries, coefficient, doughnutSize);
             }

            this.accumulationLayout(chartObj);
			 
             BoldBIDashboard.BoldBIDashboardChart._calculateLegendBounds(chartObj);
             BoldBIDashboard.BoldBIDashboardChart._calculateAreaBounds(chartObj.params, chartObj);
             size = this.calculatingSliceAngle(currentseries);
			 this.getRadius(chartObj, seriesIndex, size);
         }

         var min = Math.min(size.width, size.height);
         if (min < 0) {
             return min;
         }
         var totalDegree = Math.abs(currentseries.endAngle - currentseries.startAngle);
         if (totalDegree < 270)//for centering the chart
             this.pieDoughnutCenter(currentseries);
         this.chartObj.model.innerRadius[seriesIndex] = currentSeries._doughnutCoefficient * this.chartObj.model.circularRadius[seriesIndex];


         var numberToFixed = BoldBIDashboard.util.isNullOrUndefined(this.chartObj.model.roundingPlaces) ? 2 : this.chartObj.model.roundingPlaces;

         var seriesIndex = bbdesigner$.inArray(currentseries, this.chartObj.model._visibleSeries);
         var serOptions = { 'id': this.chartObj.svgObject.id + '_SeriesGroup' + '_' + seriesIndex };
         this.gSeriesGroupEle = this.chartObj.svgRenderer.createGroup(serOptions);

         var visibility = (currentseries.enableAnimation && !currentseries._animatedSeries) ? 'hidden' : 'visible';

          
         var txtOptions = { 'id': this.chartObj.svgObject.id + '_TextGroup' + '_' + seriesIndex, 'visibility': visibility };
         if (!this.chartObj.gSeriesTextEle) this.chartObj.gSeriesTextEle = [];
         this.chartObj.gSeriesTextEle[seriesIndex] = this.chartObj.svgRenderer.createGroup(txtOptions);

         var symbolOptions = { 'id': this.chartObj.svgObject.id + '_symbolGroup' + '_' + seriesIndex, 'visibility': visibility };
         if (!this.chartObj.gSymbolGroupEle) this.chartObj.gSymbolGroupEle = [];
         this.chartObj.gSymbolGroupEle[seriesIndex] = this.chartObj.svgRenderer.createGroup(symbolOptions);

         var connectorOptions = { 'id': this.chartObj.svgObject.id + '_connectorGroup' + '_' + seriesIndex, 'visibility': visibility };
         if (!this.chartObj.gConnectorEle) this.chartObj.gConnectorEle = [];
         this.chartObj.gConnectorEle[seriesIndex] = this.chartObj.svgRenderer.createGroup(connectorOptions);

         var dataLabelOptions = { 'id': this.chartObj.svgObject.id + '_DataLabel_' + seriesIndex, 'visibility': visibility };
         if (!this.chartObj.gDataLabelEle) this.chartObj.gDataLabelEle = [];
         this.chartObj.gDataLabelEle[seriesIndex] = this.chartObj.svgRenderer.createGroup(dataLabelOptions);
		 if ((currentseries._doughnutSize > 0) && (currentSeries._doughnutCoefficient >= 0) && (currentseries._doughnutSize <= 1) && (currentSeries._doughnutCoefficient <= 1)) {
           
             for (var j = 0; j < visiblePointslength; j++) {
             var point = currentseries._visiblePoints[j];
             var pointIndex = j;
             if (point.visible) {
                 var explodeX = 0;
                 var explodeY = 0;
                 var result = this._calculateArcData(this.chartObj, pointIndex, point, currentseries,seriesIndex);
				 //for canvas slice explode
                 if ((point.actualIndex == currentseries.explodeIndex || currentseries.explodeAll) && !this.chartObj.vmlRendering) {
                     var chartStartAngle = -.5 * Math.PI; 
                     var startAngle = point.startAngle + chartStartAngle;
                     var endAngle = point.endAngle + chartStartAngle - 0.000001;
                     var midAngle = (startAngle + endAngle) / 2;
                     explodeX = this.chartObj.model.circleCenterX[seriesIndex] + Math.cos(midAngle) * currentseries.explodeOffset;
                     explodeY = this.chartObj.model.circleCenterY[seriesIndex] + Math.sin(midAngle) * currentseries.explodeOffset;
                 }

             var styleOptions = this.chartObj.setStyle(this, currentseries, seriesIndex, pointIndex);

                 if (currentseries.startAngle < currentseries.endAngle) // for canvas rendering with modified start and end angle
                     var counterClockWise = false;
                 else
                     counterClockWise = true;
                
                  for (k = 0; k < currentseries.visiblePoints.length; k++) {
                        if (point == currentseries.visiblePoints[k]) {
                            pointIndex = k;
                            break;
                        }
                    }
             options = {
                 'id': this.chartObj.svgObject.id + '_Series' + seriesIndex + "_Point" + pointIndex,
                 'fill': styleOptions.interior,
                 'stroke-width': styleOptions.borderWidth,
                 'stroke': styleOptions.borderColor,
                 'stroke-dasharray': styleOptions.dashArray,
                     'stroke-linecap': currentseries.lineCap,
                     'opacity': styleOptions.opacity,
                     'stroke-linejoin': currentseries.lineJoin,
                     'd': result.Direction,
                     'start': point.startAngle - 1.57,
                     'end': point.endAngle - 1.57,
                     'pointIndex': pointIndex,
                     'radius': this.chartObj.model.circularRadius[seriesIndex],
                     'innerR': this.chartObj.model.innerRadius[seriesIndex],
                     'counterClockWise': counterClockWise,
                     'x': explodeX !=0 ? explodeX : this.chartObj.model.circleCenterX[seriesIndex],
                     'y': explodeY !=0 ? explodeY : this.chartObj.model.circleCenterY[seriesIndex]
             };
            this.chartObj.svgRenderer.drawPath(options, this.gSeriesGroupEle);


                 region = { PointIndex: pointIndex, Index:j, StartAngle: point.startAngle, EndAngle: point.endAngle, StartX: this.chartObj.model.startX[j], StartY: this.chartObj.model.startY[j] ,  SeriesIndex: bbdesigner$.inArray(currentseries, this.chartObj.model._visibleSeries)};
                 internalRegion.push(region);

             }
         }
}
         var seriesData = { Radius: this.chartObj.model.circularRadius[seriesIndex], DRadius: this.chartObj.model.innerRadius[seriesIndex], CenterX: this.chartObj.model.circleCenterX[seriesIndex], CenterY: this.chartObj.model.circleCenterY[seriesIndex] };
         var region = { Series: currentseries, SeriesData: seriesData, Region: internalRegion, SeriesIndex: bbdesigner$.inArray(currentseries, this.chartObj.model._visibleSeries) };
         this.chartObj.model.chartRegions.push(region);

         this.chartObj.svgRenderer.append(this.gSeriesGroupEle, this.chartObj.gSeriesEle);

     },

     chartAreaType:"None"
 });

 BoldBIDashboard.seriesTypes.doughnut = BoldBIDashboard.ejDoughnutSeries;

 BoldBIDashboard.ejPyramidSeries = ejExtendClass(BoldBIDashboard.EjSeriesRender, {
     draw: function (chart, options) {

         this.chartObj = chart;
         var chartModel = chart.model,
             point,
             seriesRender = this,
             legendActualBounds = chartModel.LegendActualBounds,
             currentseries = options,
             visiblePoints = this._calculateVisiblePoints(currentseries).visiblePoints,
             visiblePointslength = visiblePoints.length,
             internalRegion = [],
             translate = [],
             legend = chartModel.legend,
			 dataLabel = currentseries.marker.dataLabel,
             legendPosition = legend.position.toLowerCase(),
             legendWidth = legend.border.width,
             textSize = 0,
             text,
             borderSize = chartModel.border.width,
             measureTitle = (chartModel.title.text && chartModel.title.responsiveVisibility && chartModel.title.visible) ? BoldBIDashboard.EjSvgRender.utils._measureText(chartModel.title.text, bbdesigner$(this.svgObject).width() - chartModel.margin.left - chartModel.margin.right, chartModel.title.font) : 0,
             measureSubTitle = (chartModel.title.subTitle.text && chartModel.title.subTitle.responsiveVisibility && chartModel.title.subTitle.visible) ? BoldBIDashboard.EjSvgRender.utils._measureText(chartModel.title.subTitle.text, bbdesigner$(this.svgObject).width() - chartModel.margin.left - chartModel.margin.right, chartModel.title.subTitle.font) : 0;
             this.xOffset = (chartModel.margin.left + chartModel.elementSpacing + (borderSize * 2) + chartModel.elementSpacing + chartModel.margin.right + ((legendPosition === "right" || legendPosition === "left") ? legendActualBounds.Width + (2 * legendWidth) : 0)),
             yOffset = this.yOffset = (((chartModel.title.text && !BoldBIDashboard.util.isNullOrUndefined(chartModel._titleLocation)) ? (chartModel._titleLocation.Y + measureTitle.height) : chartModel.elementSpacing) + (borderSize * 2) + chartModel.margin.top + chartModel.elementSpacing + chartModel.elementSpacing + ((legendPosition === "top" || legendPosition === "bottom") ? legendActualBounds.Height + (2 * legendWidth) + chartModel.elementSpacing : 0));
		if (dataLabel.visible && dataLabel.shape != 'none' && currentseries.labelPosition == 'outside')
			this.xOffset = this.xOffset + (dataLabel.margin.left + dataLabel.margin.right);
         chartModel.chartRegions = [];
         chartModel.sumofYValues = 0;
         chartObj = this.chartObj;
         chartObj.flag = false;
		 chartObj.responsiveFlag = false;
         if (this.chartObj.model.adaptiveRendering) {
             while (((chartObj.svgHeight - this.yOffset) < chartObj.svgHeight / 2 || chartObj.svgHeight <= 150) && !chartObj.flag) {
                 this.count = BoldBIDashboard.util.isNullOrUndefined(this.count) ? 1 : this.count + 1;
				 chartObj.responsiveFlag = true;
                 this.responsiveAccLayout(this.count, currentseries);
             }

            this.accumulationLayout(chartObj, yOffset);
            
             BoldBIDashboard.BoldBIDashboardChart._calculateLegendBounds(chartObj);
             BoldBIDashboard.BoldBIDashboardChart._calculateAreaBounds(chartObj.params, chartObj);
           
         }
         if (currentseries.labelPosition.toLowerCase() === 'outside') {
             for (var i = 0; i < visiblePointslength; i++) {
                 var textWidth = BoldBIDashboard.EjSvgRender.utils._measureText((BoldBIDashboard.util.isNullOrUndefined(visiblePoints[i].text) ? visiblePoints[i].y : visiblePoints[i].text), null, currentseries.marker.dataLabel.font).width;
                 if (textSize < textWidth)
                     textSize = textWidth;
             }
             chartModel.textSize = textSize;
         }
         if (currentseries._enableSmartLabels) {
             chartModel.actualWidth = (bbdesigner$(chart.svgObject).width() - this.xOffset) * 0.8; //calculate a pyramid width when smartlabel is enabled
             chartModel.resWidth = (bbdesigner$(chart.svgObject).width() - this.xOffset - chartModel.actualWidth) / 2;
         }
         else {
             chartModel.actualWidth = bbdesigner$(chart.svgObject).width() - this.xOffset - textSize;
             chartModel.resWidth = 0;
         }
         var seriesIndex = bbdesigner$.inArray(currentseries, chartModel._visibleSeries);
         chartModel.actualHeight = bbdesigner$(chart.svgObject).height() - this.yOffset;
         var subtitleHeight = (chart.model.title.subTitle.text == '') ? 0 : measureSubTitle.height;
         var pyrX = chart.pyrX = ((legend.visible && legend.responsiveVisibility && legendPosition === "left") ? (legendActualBounds.Width + (2 * legendWidth)) : 0) + chartModel.elementSpacing + chartModel.margin.left;
         var pyrY = chart.pyrY = ((legend.visible && legend.responsiveVisibility && legendPosition === "top") ? (legendActualBounds.Height + (2 * legendWidth)) : 0) + ((chartModel.title.text && !BoldBIDashboard.util.isNullOrUndefined(chartModel._titleLocation)) ? (chartModel._titleLocation.Y + measureTitle.height) : (chartModel.margin.top + chartModel.elementSpacing));
         translate[0] = pyrX;
         translate[1] = pyrY;
         for (var j = 0; j < visiblePointslength; j++) {
             chartModel.sumofYValues += visiblePoints[j].YValues[0];
         }
         var dataLabelOptions = { 'id': chart.svgObject.id + '_DataLabel_' + seriesIndex, 'transform': 'translate(' + pyrX + ',' + pyrY + ')' };
          if (!this.chartObj.gDataLabelEle) this.chartObj.gDataLabelEle = [];
            chart.gDataLabelEle[seriesIndex] = chart.svgRenderer.createGroup(dataLabelOptions);


         var numberToFixed = BoldBIDashboard.util.isNullOrUndefined(chartModel.roundingPlaces) ? 2 : chartModel.roundingPlaces;

         var serOptions = { 'id': chart.svgObject.id + '_SeriesGroup' + '_' + seriesIndex, 'transform': 'translate(' + pyrX + ',' + pyrY + ')' };
         this.gSeriesGroupEle = chart.svgRenderer.createGroup(serOptions);


         var txtOptions = { 'id': chart.svgObject.id + '_textGroup' + '_' + seriesIndex, 'transform': 'translate(' + pyrX + ',' + pyrY + ')' };
          if (!this.chartObj.gSeriesTextEle) this.chartObj.gSeriesTextEle = [];
            chart.gSeriesTextEle[seriesIndex] = chart.svgRenderer.createGroup(txtOptions);

           var symbolOptions = { 'id': chart.svgObject.id + '_symbolGroup' + '_' + seriesIndex, 'transform': 'translate(' + pyrX + ',' + pyrY + ')' };
            if (!this.chartObj.gSymbolGroupEle) this.chartObj.gSymbolGroupEle = [];
            chart.gSymbolGroupEle[seriesIndex] = chart.svgRenderer.createGroup(symbolOptions);

            var connectorOptions = { 'id': chart.svgObject.id + '_connectorGroup' + '_' + seriesIndex, 'transform': 'translate(' + pyrX + ',' + pyrY + ')' };
            if (!this.chartObj.gConnectorEle) this.chartObj.gConnectorEle = [];
            chart.gConnectorEle[seriesIndex] = chart.svgRenderer.createGroup(connectorOptions);


         if (currentseries.pyramidMode.toLowerCase() == "linear")
             this.calculateLinearSegments(currentseries);
         else
             this.calculateSurfaceSegments(currentseries);

         for (j = 0; j < visiblePointslength; j++) {
             var pointIndex = j;
             point = currentseries._visiblePoints[j];
             if (point.visible) {
                 var result = this._getPyramidData(currentseries, pointIndex);

                 var styleOptions = chart.setStyle(this, currentseries, 0, pointIndex);
            for (k = 0; k < currentseries.visiblePoints.length; k++) {
                        if (point == currentseries.visiblePoints[k]) {
                            pointIndex = k;
                            break;
                        }
                    }
             options = {
                     'id': chart.svgObject.id + '_Series' + seriesIndex + "_Point" + pointIndex,
                 'fill': styleOptions.interior,
                 'stroke-width': styleOptions.borderWidth,
                 'stroke': styleOptions.borderColor,
                 'stroke-dasharray': styleOptions.dashArray,
                     'stroke-linecap': currentseries.lineCap,
                     'stroke-linejoin': currentseries.lineJoin,
                     'opacity': styleOptions.opacity,
                     'pointIndex': pointIndex,
                     'd': result.Direction
                 };
                 chart.svgRenderer.drawPath(options, this.gSeriesGroupEle, translate);

                 if (currentseries.marker.dataLabel.template) {
                     BoldBIDashboard.EjSvgRender.utils._getSeriesTemplateSize(point, pointIndex, currentseries, true, chart);
                 }

                 point.xLocation = result.PositionX;
                 point.yLocation = result.PositionY;
                 point.connectorLine = result.Connector;
                 point.startX = result.startX;
                 point.startY = result.startY;
                 point.Polygon = result.Polygon;
                 region = { PointIndex: pointIndex, Line1: result.Line1, Line2: result.Line2, Line3: result.Line3, Line4: result.Line4, Polygon: result.Polygon };
                 internalRegion.push(region);
             }
         }
         var region = { Series: currentseries, Region: internalRegion, SeriesIndex: bbdesigner$.inArray(currentseries, chartModel._visibleSeries) };
         chartModel.chartRegions.push(region);

         if (this.gSeriesGroupEle) {
             bbdesigner$(this.gSeriesGroupEle.childNodes[pointIndex]).bind('mousemove', function (evt) {
                 evt.target = seriesRender.gSeriesGroupEle.childNodes[pointIndex];
                 seriesRender.chartObj.chartInteractiveBehavior(evt);
             });

             chart.svgRenderer.append(this.gSeriesGroupEle, chart.gSeriesEle);
         }

        

     },

     _getPyramidData: function (series, index) {
        
         var model = this.chartObj.model;
         var pointMarker = series._visiblePoints[index].marker;
         var actualIndex = series._visiblePoints[index].actualIndex;
         var offset = ((series.explodeIndex == actualIndex) || (series.explodeAll) ? series.explodeOffset : 0);
         var resWidth = model.resWidth;
         var top = model.pyramidData[index].CurrY;
         var bottom = model.pyramidData[index].CurrY + model.pyramidData[index].Height;
         var topRadius = 0.5 * (1 - model.pyramidData[index].CurrY);
         var bottomRadius = 0.5 * (1 - bottom);
         var point = series.points[index];

         var line1 = { x: resWidth + offset + topRadius * model.actualWidth, y: top * model.actualHeight };
         var line2 = { x: resWidth + offset + (1 - topRadius) * model.actualWidth, y: top * model.actualHeight };
         var line3 = { x: resWidth + offset + (1 - bottomRadius) * model.actualWidth, y: bottom * model.actualHeight };
         var line4 = { x: resWidth + offset + bottomRadius * model.actualWidth, y: bottom * model.actualHeight };

         var direction = "M" + " " + (line1.x) + " " + (line1.y) + " " + "L" + " " + (line2.x) + " " + (line2.y) + " " + "L" + " " + (line3.x) + " " + (line3.y) + " " + "L" + " " + (line4.x) + " " + (line4.y) + " " + "z";
         var polygon = [
             { x: line1.x, y: line1.y },
             { x: line2.x, y: line2.y },
             { x: line3.x, y: line3.y },
             { x: line4.x, y: line4.y }
            ];
         if ((pointMarker && pointMarker.dataLabel && pointMarker.dataLabel.visible) || (!pointMarker || !pointMarker.dataLabel) && series.marker.dataLabel.visible) {
             var positionX;
             var positionY;
             var startX = (line2.x + line3.x) / 2;
             var startY = (line2.y + line3.y) / 2;
             if (series.labelPosition.toLowerCase() === 'outside' ) {

                 positionX = (line2.x + line3.x) / 2;
                 positionY = (line2.y + line3.y) / 2;

                 var pyrX = ((this.chartObj.model.legend.position.toLowerCase() == "left" || this.chartObj.model.legend.position.toLowerCase() == "right") ? (this.chartObj.model.LegendActualBounds.Width) : 0) + this.chartObj.model.elementSpacing + this.chartObj.model.margin.left;

                 if (BoldBIDashboard.util.isNullOrUndefined(series.marker.dataLabel.connectorLine.height)) {
                     if (series._enableSmartLabels)
                         var textOffset = bbdesigner$(this.chartObj.svgObject).width() - (pyrX + positionX + resWidth + (2 * this.chartObj.model.elementSpacing));
                     else
                         var textOffset = bbdesigner$(this.chartObj.svgObject).width() - (pyrX + positionX + this.chartObj.model.textSize + this.chartObj.model.elementSpacing);
                 }
                 else
                     textOffset = series.marker.dataLabel.connectorLine.height;
                                                
                 var connectorX = this.getXCordinate(positionX, textOffset, 0);
                 var connectorY = this.getYCordinate(positionY, textOffset, 0);
                
                 var connectorDirection = "M" + " " + positionX + " " + positionY + " " + "L" + " " + connectorX + " " + connectorY;

                 positionX = connectorX;
                 positionY = connectorY ;

                 
             }
             else {
                 positionX = (line1.x + line2.x) / 2;
                 positionY = (line3.y + line1.y) / 2;
             }
         }
         return { Direction: direction, PositionX: positionX, PositionY: positionY, Connector: connectorDirection, Line1: line1, Line2: line2, Line3: line3, Line4: line4, startX: startX, startY: startY, Polygon: polygon };
     },

     calculateLinearSegments: function (series) {
         var currY = 0;
         var model = this.chartObj.model;
         model.pyramidData = [];
         var gapRatio = series.gapRatio >= 0 ? (series.gapRatio <= 1 ? series.gapRatio : 1) : 0;
         var coef = 1 / ((model.sumofYValues * (1 + gapRatio / (1 - gapRatio))) ? (model.sumofYValues * (1 + gapRatio / (1 - gapRatio))) : 1);
         var count = series._visiblePoints.length;
         for (var i = 0; i < count; i++) {
             if (series._visiblePoints[i].visible || series._visiblePoints[i].gapMode) {
                 var height = coef * series._visiblePoints[i].YValues[0];
                 model.pyramidData[i] = { CurrY: currY, Height: height };
                 currY += (gapRatio / (count - 1)) + height;
             }
         }
     },

     calculateSurfaceSegments: function (series) {
         var count = series._visiblePoints.length;
         var model = this.chartObj.model;
         model.pyramidData = [];
         var currY = 0;
         var y = [];
         var height = [];
         var gapRatio = series.gapRatio >= 0 ? (series.gapRatio <= 1 ? series.gapRatio : 1) : 0;
         var gapHeight = gapRatio / (count - 1);
         var preSum = this.getSurfaceHeight(0, model.sumofYValues);
         for (i = 0; i < count; i++) {
             if (series._visiblePoints[i].visible || series._visiblePoints[i].gapMode) {
                 y[i] = currY;
                 height[i] = this.getSurfaceHeight(currY, Math.abs(series._visiblePoints[i].YValues[0]));
                 currY += height[i] + gapHeight * preSum;
             }
         }
         var coef = 1 / (currY - gapHeight * preSum);
         for (var i = 0; i < count; i++) {
             if (series._visiblePoints[i].visible || series._visiblePoints[i].gapMode) {
                 var currHeight = coef * y[i];
                 model.pyramidData[i] = { CurrY: currHeight, Height: coef * height[i] };
             }
         }
     },

     getSurfaceHeight: function (y, surface) {
         var result = this.solveQuadraticEquation(1, 2 * y, -surface);
         if (result) {
             return result;
         }
         return 0;
     },
     solveQuadraticEquation: function (a, b, c) {
         var root1;
         var root2;

         if (a != 0) {
             var d = b * b - 4 * a * c;

             if (d >= 0) {
                 var sd = Math.sqrt(d);

                 root1 = (-b - sd) / (2 * a);
                 root2 = (-b + sd) / (2 * a);
                 return Math.max(root1, root2);

             }
         }
         else if (b != 0) {
             root1 = -c / b;
             root2 = -c / b;
             return Math.max(root1, root2);
         }

         return false;
     },

     chartAreaType: "None"
 });

 BoldBIDashboard.seriesTypes.pyramid = BoldBIDashboard.ejPyramidSeries;
   
 BoldBIDashboard.ejFunnelSeries = ejExtendClass(BoldBIDashboard.EjSeriesRender, {
     draw: function (chart, options) {        
         this.chartObj = chart;
         var chartModel = chart.model,
             legend = chartModel.legend,
             legendPosition = !BoldBIDashboard.util.isNullOrUndefined(legend.responsivePosition) ? legend.responsivePosition : legend.position.toLowerCase(),
             legendActualBounds = chartModel.LegendActualBounds,
             point,
             seriesRender = this,
             currentseries = options,
             visiblePoints = this._calculateVisiblePoints(currentseries).visiblePoints,
             visiblePointslength = visiblePoints.length,
             internalRegion = [],
			 dataLabel = currentseries.marker,
             legendWidth = legend.border.width,
             translate = [],
             textSize = 0,
             text,
             borderSize = chartModel.border.width,
             measureTitle = (chartModel.title.text && chartModel.title.responsiveVisibility && chartModel.title.visible) ? BoldBIDashboard.EjSvgRender.utils._measureText(chartModel.title.text, bbdesigner$(this.svgObject).width() - chartModel.margin.left - chartModel.margin.right, chartModel.title.font) : 0,
             measureSubTitle = (chartModel.title.subTitle.text) ? BoldBIDashboard.EjSvgRender.utils._measureText(chartModel.title.subTitle.text, bbdesigner$(this.svgObject).width() - chartModel.margin.left - chartModel.margin.right, chartModel.title.subTitle.font) : 0;
             this.xOffset = (chartModel.margin.left + chartModel.elementSpacing + chartModel.elementSpacing + chartModel.margin.right + (borderSize * 2) + ((legendPosition === "right" || legendPosition === "left") ? legendActualBounds.Width + (2 * legendWidth) : 0));
             yOffset = this.yOffset = (((chartModel.title.text && !BoldBIDashboard.util.isNullOrUndefined(chartModel._titleLocation)) ? (chartModel._titleLocation.Y + measureTitle.height) : chartModel.elementSpacing) + chartModel.margin.top + (borderSize * 2) + chartModel.elementSpacing + chartModel.elementSpacing + ((legendPosition === "top" || legendPosition === "bottom") ? legendActualBounds.Height + (2 * legendWidth) + chartModel.elementSpacing : 0));

		if (dataLabel.visible && dataLabel.shape != 'none' && currentseries.labelPosition == 'outside')
			this.xOffset = this.xOffset + (dataLabel.margin.left + dataLabel.margin.right);
         chartModel.chartRegions = [];
         chartModel.sumofYValues = 0;
         var chartObj = this.chartObj;
         chartObj.flag = false;
		 chartObj.responsiveFlag = false;
         if (chartObj.model.adaptiveRendering) {
             while (((chartObj.svgHeight - this.yOffset) < chartObj.svgHeight / 2 || chartObj.svgHeight <= 150) && !chartObj.flag) {
                 this.count = BoldBIDashboard.util.isNullOrUndefined(this.count) ? 1 : this.count + 1;
				 chartObj.responsiveFlag = true;
                 this.responsiveAccLayout(this.count, currentseries);
             }

             this.accumulationLayout(chartObj, yOffset);

             BoldBIDashboard.BoldBIDashboardChart._calculateLegendBounds(chartObj);
             BoldBIDashboard.BoldBIDashboardChart._calculateAreaBounds(chartObj.params, chartObj);
             var measureTitle = (chartModel.title.text && chartModel.title.responsiveVisibility && chartModel.title.visible) ? BoldBIDashboard.EjSvgRender.utils._measureText(this.chartObj.model.title.text, bbdesigner$(this.svgObject).width() - this.chartObj.model.margin.left - this.chartObj.model.margin.right, this.chartObj.model.title.font) : 0;
             this.xOffset = (this.chartObj.model.margin.left + this.chartObj.model.elementSpacing + this.chartObj.model.margin.right + this.chartObj.model.elementSpacing + ((this.chartObj.model.legend.position.toLowerCase() === "right" || this.chartObj.model.legend.position.toLowerCase() === "left") ? this.chartObj.model.LegendActualBounds.Width + (2 * legendWidth) : 0));
             yOffset = this.yOffset = (((this.chartObj.model.title.text && !BoldBIDashboard.util.isNullOrUndefined(this.chartObj.model._titleLocation)) ? (this.chartObj.model._titleLocation.Y + measureTitle.height) : this.chartObj.model.elementSpacing) + this.chartObj.model.margin.top + this.chartObj.model.elementSpacing + this.chartObj.model.margin.bottom + this.chartObj.model.elementSpacing + ((this.chartObj.model.legend.position.toLowerCase() === "top" || this.chartObj.model.legend.position.toLowerCase() === "bottom") ? this.chartObj.model.LegendActualBounds.Height + (2 * legendWidth) : 0));
         }
         if (currentseries.labelPosition.toLowerCase() === 'outside') {
             for (var i = 0; i < visiblePointslength; i++) {
                 var textWidth = BoldBIDashboard.EjSvgRender.utils._measureText((BoldBIDashboard.util.isNullOrUndefined(visiblePoints[i].text) ? visiblePoints[i].y : visiblePoints[i].text), null, currentseries.marker.dataLabel.font).width;
                 if (textSize < textWidth)
                     textSize = textWidth;
             }
             chartModel.textSize = textSize;
         }
         if (currentseries._enableSmartLabels) {
             chartModel.actualWidth = (bbdesigner$(chart.svgObject).width() - this.xOffset) * 0.8;  //calculate a width of a funnel chart when smartlabel is enabled
             chartModel.resWidth = (bbdesigner$(chart.svgObject).width() - this.xOffset - chartModel.actualWidth) / 2;
         }
         else {
             chartModel.actualWidth = bbdesigner$(chart.svgObject).width() - this.xOffset - textSize;
             chartModel.resWidth = 0;
         }
         var subtitleHeight = (chart.model.title.subTitle.text == '') ? 0 : measureSubTitle.height;
         chartModel.actualHeight = bbdesigner$(chart.svgObject).height() - this.yOffset;
         var pyrX = chart.pyrX = ((legendPosition === "left" && legend.responsiveVisibility) ? (legendActualBounds.Width + (2 * legendWidth)) : 0) + chart.model.elementSpacing + chartModel.margin.left;
         var pyrY = chart.pyrY = ((legendPosition === "top" && legend.responsiveVisibility) ? (legendActualBounds.Height + (2 * legendWidth)) : 0) + ((chartModel.title.text && !BoldBIDashboard.util.isNullOrUndefined(chartModel._titleLocation)) ? (chartModel._titleLocation.Y + measureTitle.height) : (chartModel.margin.top + chart.model.elementSpacing));
         translate[0] = pyrX;
         translate[1] = pyrY;
         for (var j = 0; j < visiblePointslength; j++) {
             chartModel.sumofYValues += visiblePoints[j].YValues[0];
         }


         var numberToFixed = BoldBIDashboard.util.isNullOrUndefined(chartModel.roundingPlaces) ? 2 : chartModel.roundingPlaces;

         var seriesIndex = bbdesigner$.inArray(currentseries, chartModel._visibleSeries);
         var serOptions = { 'id': chart.svgObject.id + '_SeriesGroup' + '_' + seriesIndex, 'transform': 'translate(' + pyrX + ',' + pyrY + ')' };
         this.gSeriesGroupEle = chart.svgRenderer.createGroup(serOptions);
         var dataLabelOptions = { 'id': chart.svgObject.id + '_DataLabel_' + seriesIndex, 'transform': 'translate(' + pyrX + ',' + pyrY + ')' };
            if (!this.chartObj.gDataLabelEle) this.chartObj.gDataLabelEle = [];
            chart.gDataLabelEle[seriesIndex] = chart.svgRenderer.createGroup(dataLabelOptions);


            var txtOptions = { 'id': chart.svgObject.id + '_textGroup' + '_' + seriesIndex, 'transform': 'translate(' + pyrX + ',' + pyrY + ')' };
            if (!this.chartObj.gSeriesTextEle) this.chartObj.gSeriesTextEle = [];
            chart.gSeriesTextEle[seriesIndex] = chart.svgRenderer.createGroup(txtOptions);

            var symbolOptions = { 'id': chart.svgObject.id + '_symbolGroup' + '_' + seriesIndex, 'transform': 'translate(' + pyrX + ',' + pyrY + ')' };
            if (!this.chartObj.gSymbolGroupEle) this.chartObj.gSymbolGroupEle = [];
            chart.gSymbolGroupEle[seriesIndex] = chart.svgRenderer.createGroup(symbolOptions);

            var connectorOptions = { 'id': chart.svgObject.id + '_connectorGroup' + '_' + seriesIndex, 'transform': 'translate(' + pyrX + ',' + pyrY + ')' };
            if (!this.chartObj.gConnectorEle) this.chartObj.gConnectorEle = [];
            chart.gConnectorEle[seriesIndex] = chart.svgRenderer.createGroup(connectorOptions);

         var currY = 0;
         var model = chartModel;
         model.funnelData = [];
         var gapRatio = currentseries.gapRatio >= 0 ? (currentseries.gapRatio <= 1 ? currentseries.gapRatio : 1) : 0;
         var coef = 1 / ((model.sumofYValues * (1 + gapRatio / (1 - gapRatio))) ? (model.sumofYValues * (1 + gapRatio / (1 - gapRatio))) : 1);
          var spacing = gapRatio / visiblePointslength;
         for (var i = visiblePointslength - 1; i >= 0; i--) {
             if (currentseries._visiblePoints[i].visible || currentseries._visiblePoints[i].gapMode) {
                 var height = coef * currentseries._visiblePoints[i].YValues[0];
                 model.funnelData[i] = { CurrY: currY, Height: height };
                 currY += height + spacing;
             }
         }
         for (j = 0; j < visiblePointslength  ; j++) {
             var pointIndex = j;
             point = currentseries._visiblePoints[j];
             if (point.visible) {
                 var result = this._getFunnelData(currentseries, pointIndex, chart);

                 var styleOptions = chart.setStyle(this, currentseries, 0, pointIndex);
              for (k = 0; k < currentseries.visiblePoints.length; k++) {
                        if (point == currentseries.visiblePoints[k]) {
                            pointIndex = k;
                            break;
                        }
                    }
                 options = {
                     'id': chart.svgObject.id + '_Series' + seriesIndex + "_Point" + pointIndex,
                     'fill': styleOptions.interior,
                     'stroke-width': styleOptions.borderWidth,
                     'stroke': styleOptions.borderColor,
                     'stroke-dasharray': styleOptions.dashArray,
                     'stroke-linecap': currentseries.lineCap,
                     'stroke-linejoin': currentseries.lineJoin,
                     'opacity': styleOptions.opacity,
                     'pointIndex': pointIndex,
                     'd': result.Direction
                 };
                 chart.svgRenderer.drawPath(options, this.gSeriesGroupEle, translate);

                 if (currentseries.marker.dataLabel.template) {
                     BoldBIDashboard.EjSvgRender.utils._getSeriesTemplateSize(point, pointIndex, currentseries, true, chart);
                 }

                 point.xLocation = result.PositionX;
                 point.yLocation = result.PositionY;
                 point.connectorLine = result.Connector;
                 point.startX = result.startX;
                 point.startY = result.startY;
                 point.Polygon = result.Polygon;
                 region = { PointIndex: pointIndex, Line1: result.Line1, Line2: result.Line2, Line3: result.Line3, Line4: result.Line4, Line5: result.Line5, Line6: result.Line6, Polygon: result.Polygon };
                 internalRegion.push(region);
             }
         }
         var region = { Series: currentseries, Region: internalRegion, SeriesIndex: bbdesigner$.inArray(currentseries, chartModel._visibleSeries) };
         chartModel.chartRegions.push(region);

         if(this.gSeriesGroupEle)
         bbdesigner$(this.gSeriesGroupEle.childNodes[pointIndex]).bind('mousemove', function (evt) {
             evt.target = seriesRender.gSeriesGroupEle.childNodes[pointIndex];
             seriesRender.chartObj.chartInteractiveBehavior(evt);
         });

         chart.svgRenderer.append(this.gSeriesGroupEle, chart.gSeriesEle);


     },

     _getFunnelData: function (series, index, chart) {

         var model = this.chartObj.model,
		     legend = model.legend,
             point = series._visiblePoints[index],
             pointMarker = point.marker,
             seriesMarer = series.marker,
             funnelWidth = series.funnelWidth,
             funnelHeight = series.funnelHeight,
             actualHeight = model.actualHeight,
             actualWidth = model.actualWidth,
             elementSpacing = model.elementSpacing,
             pyrX, legendPosition = model.legend.position.toLowerCase(),
             actualIndex = point.actualIndex,
             direction,
             resWidth = model.resWidth, polygon,
             textOffset, connectorDirection,
             offset = ((series.explodeIndex == actualIndex) || (series.explodeAll) ? series.explodeOffset : 0),
             topRadius, minRadius, bottomRadius, endTop,
             endMin, endBottom, top, bottomY,
             bottom, connectorX, connectorY,
             positionX, positionY, startX, startY,
             line1, line2, line3, line4, line5, line6,
             lineWidth, minimumHeight, minimumWidth;
         if (funnelHeight.indexOf("%") != -1)
             minimumHeight = actualHeight * (parseInt(funnelHeight) / 100);
         else
             minimumHeight = parseInt(funnelHeight);
         if (funnelWidth.indexOf("%") != -1)
             minimumWidth = actualWidth * (parseInt(funnelWidth) / 100);
         else
             minimumWidth = parseInt(funnelWidth);

         top = model.funnelData[index].CurrY * actualHeight;
         bottom = top + model.funnelData[index].Height * actualHeight;
         lineWidth = minimumWidth + (actualWidth - minimumWidth) * ((actualHeight - minimumHeight - top) / (actualHeight - minimumHeight));
         topRadius = (actualWidth / 2) - lineWidth / 2;
         endTop = topRadius + lineWidth;
         if (bottom > actualHeight - minimumHeight || actualHeight == minimumHeight)
             lineWidth= minimumWidth;
         else
             lineWidth = minimumWidth + (actualWidth - minimumWidth) * ((actualHeight - minimumHeight - bottom) / (actualHeight - minimumHeight));
         bottomRadius = (actualWidth / 2) - (lineWidth / 2);
         endBottom = bottomRadius + lineWidth;
         if (top >= actualHeight - minimumHeight) {
             topRadius = bottomRadius = minRadius = (actualWidth / 2) - minimumWidth / 2;
             endTop = endBottom = endMin = (actualWidth / 2) + minimumWidth / 2;

         } else if (bottom > (actualHeight - minimumHeight)) {
             minRadius = bottomRadius = (actualWidth / 2) - lineWidth / 2;
             endMin = endBottom = minRadius + lineWidth;
             bottomY = actualHeight - minimumHeight;
         }

         line1 = { x: resWidth + offset + topRadius, y: top };
         line2 = { x: resWidth + offset + endTop, y: top };
         line4 = { x: resWidth + offset + endBottom, y: bottom };
         line5 = { x: resWidth + offset + bottomRadius, y: bottom };
         line3 = { x: resWidth + offset + endBottom, y: bottom };
         line6 = { x: resWidth + offset + bottomRadius, y: bottom };
         if (bottomY) {
             line3 = { x: resWidth + offset + endMin, y: bottomY };
             line6 = { x: resWidth + offset + minRadius, y: bottomY };
         }
         direction = "M" + " " + (line1.x) + " " + (line1.y) + " " + "L" + " " + (line2.x) + " " + (line2.y) + " " + "L" + " " + (line3.x) + " " + (line3.y) + " " + "L" + " " + (line4.x) + " " + (line4.y) + " " + "L" + " " + (line5.x) + " " + (line5.y) + " " + "L" + " " + (line6.x) + " " + (line6.y) + " " + "z";
         polygon = [
           { x: line1.x, y: line1.y },
           { x: line2.x, y: line2.y },
           { x: line3.x, y: line3.y },
           { x: line4.x, y: line4.y },
           { x: line5.x, y: line5.y },
           { x: line6.x, y: line6.y }
            ];
         if ((pointMarker && pointMarker.dataLabel && pointMarker.dataLabel.visible) || (!pointMarker || !pointMarker.dataLabel) && seriesMarer.dataLabel.visible) {
             positionX;
             positionY;
             startX = (line2.x + line3.x) / 2;
             startY = (line2.y + line3.y) / 2;   
             if (series.labelPosition.toLowerCase() === 'outside' ) {

                 positionX = (line2.x + line3.x) / 2;
                 positionY = (line2.y + line3.y) / 2;

                 var position = !BoldBIDashboard.util.isNullOrUndefined(legend.responsivePosition) ? legend.responsivePosition : legend.position.toLowerCase();
                 var pyrX = ((position == "left" || position == "right") ? (this.chartObj.model.LegendActualBounds.Width) : 0) + this.chartObj.model.elementSpacing + this.chartObj.model.margin.left;

                 if (BoldBIDashboard.util.isNullOrUndefined(seriesMarer.dataLabel.connectorLine.height)) {
                     if (series._enableSmartLabels)
                         textOffset = bbdesigner$(this.chartObj.svgObject).width() - (pyrX + positionX + resWidth + (2 * elementSpacing));
                     else
                         textOffset = bbdesigner$(this.chartObj.svgObject).width() - (positionX + model.textSize + elementSpacing);
                 }
                 else
                     textOffset = seriesMarer.dataLabel.connectorLine.height;

                 connectorX = this.getXCordinate(positionX, textOffset, 0);
                 connectorY = this.getYCordinate(positionY, textOffset, 0);

                 connectorDirection = "M" + " " + positionX + " " + positionY + " " + "L" + " " + connectorX + " " + connectorY;

                 positionX = connectorX;
                 positionY = connectorY;


             }
             else {
                 positionX = (line1.x + line2.x) / 2;
                 positionY = (line1.y + line4.y) / 2;
             }
         }
         return { Direction: direction, PositionX: positionX, PositionY: positionY, Connector: connectorDirection, Line1: line1, Line2: line2, Line3: line3, Line4: line4, Line5: line5, Line6: line6, startX: startX, startY: startY, Polygon: polygon };
     },

     
     chartAreaType: "None"
 });

 BoldBIDashboard.seriesTypes.funnel = BoldBIDashboard.ejFunnelSeries;
    /*Funnel series*/

 BoldBIDashboard.ejPolarSeries = ejExtendClass(BoldBIDashboard.EjSeriesRender, {

     draw: function (chart, options) {

         this.chartObj = chart;
         var point;
         var seriesRender = this;
         var currentseries = options;
         var visiblePoints = this._isVisiblePoints(currentseries);
         var internalRegion = [];
        

         var style = this.setLineSeriesStyle(currentseries);
        
         if (currentseries.drawType.toLowerCase() == "column") {
             var range=currentseries.xAxis.visibleRange;
			 range.interval = 1;
             var length = (currentseries.xAxis._valueType == "category") ? range.max : range.max - 1;
             this.chartObj.model.sumofYValues = 0;
             var count = range.interval;
             var min = range.min;
             do{
                 this.chartObj.model.sumofYValues += range.interval;
                 min += range.interval;
             } while (min <= length)
           //  this.chartObj.model.sumofYValues = visiblePoints.length;
         }

         var direction = this._calculatePolarAxesSegment(currentseries);

         if (currentseries.drawType.toLowerCase() == "area")
             this.drawAreaPath(currentseries, style, direction);
         else if (currentseries.drawType.toLowerCase() == "line")
             this._drawLinePath(currentseries, style, direction);
         
         
         
         this.chartObj.svgRenderer.append(this.gSeriesGroupEle, this.chartObj.gSeriesEle);

       
     },
 
     chartAreaType: "PolarAxes"

 });

 BoldBIDashboard.seriesTypes.polar = BoldBIDashboard.ejPolarSeries;
 BoldBIDashboard.ejRadarSeries = ejExtendClass(BoldBIDashboard.EjSeriesRender, {

     draw: function (chart, options) {

         this.chartObj = chart;
         var point;
         var seriesRender = this;
         var currentseries = options;
         var visiblePoints = this._isVisiblePoints(currentseries);
         var internalRegion = [];

         var style = this.setLineSeriesStyle(currentseries);

         if (currentseries.drawType.toLowerCase() == "column") {
             var range = currentseries.xAxis.visibleRange;
			 range.interval = 1;
             var length = (currentseries.xAxis._valueType == "category") ? range.max : range.max - 1;
             this.chartObj.model.sumofYValues = 0;
             var count = range.interval;
             var min = range.min;
             do {
                 this.chartObj.model.sumofYValues += range.interval;
                 min += range.interval;
             } while (min <= length)
             //  this.chartObj.model.sumofYValues = visiblePoints.length;
         }

         var direction = this._calculatePolarAxesSegment(currentseries);

          if (currentseries.drawType.toLowerCase() == "area")
             this.drawAreaPath(currentseries, style, direction);
         else if (currentseries.drawType.toLowerCase() == "line")
             this._drawLinePath(currentseries, style, direction);

         this.chartObj.svgRenderer.append(this.gSeriesGroupEle, this.chartObj.gSeriesEle);

         

     },
     doAnimation: function (series, chart) {     // for polar/radar animation
         var chartObj = chart.chartObj;
         series.regionAdded = true;
         chartObj.model._radius = chartObj.model.Radius;
         chartObj.model.Radius = 0;
         seriesRender = chart;
         var seriesIndex = bbdesigner$.inArray(series, chartObj.model._visibleSeries);
         var Path = bbdesigner$(chartObj.gSeriesEle).find("#" + seriesRender.gSeriesGroupEle.id)[0].childNodes[0];
         bbdesigner$(Path).animate(
             { Radius: chartObj.model._radius },

             {
                 duration: 1200, queue: false, step: function (now, fx) {

                     chartObj.model.Radius = now;

                     var direction = seriesRender._calculatePolarAxesSegment(series);
                     if (series.drawType.toLowerCase() != 'column')
                         chartObj.svgRenderer._setAttr(bbdesigner$(Path), { "d": direction });
                     chartObj.model.Radius = chartObj.model._radius;
                 },
                 complete: function () {
                     series.regionAdded = false;                    
                     chartObj.svgRenderer._setAttr(bbdesigner$(chartObj.gSeriesEle).find("#" + chartObj.svgObject.id + '_TextGroup' + '_' + seriesIndex), { "visibility": "visible" });
                   
                     chartObj.svgRenderer._setAttr(bbdesigner$(chartObj.gSeriesEle).find("#" + chartObj.svgObject.id + '_symbolGroup' + '_' + seriesIndex), { "visibility": "visible" });
					chartObj.svgRenderer._setAttr(bbdesigner$(chartObj.gSeriesEle).find("#" + chartObj.svgObject.id + '_DataLabel' + '_' + seriesIndex), { "visibility": "visible" });
                     chartObj.model.AnimationComplete = true;
                     var commonEventArgs = bbdesigner$.extend({}, BoldBIDashboard.EjSvgRender.commonChartEventArgs);
                     commonEventArgs.data = { series: series };
                     chartObj._trigger("animationComplete", commonEventArgs);
                 }

             });
     },
     chartAreaType: "PolarAxes"

 });

 BoldBIDashboard.seriesTypes.radar = BoldBIDashboard.ejRadarSeries;
})(bbdesigner$);
;
BoldBIDashboard.BoldBIDashboardChart = {};
(function(bbdesigner$) {
String.prototype.parseTemplate = function () {
    var str = this;
    var count = 0;
    var otherCulture = /[^\x00-\x7F]+/;
    bbdesigner$.each(arguments[0], function (dataIndex, dataValue) {
        if (dataValue.count > 0) {
            bbdesigner$.each(dataValue, function (datachildIndex, datachildValue) {
                var val = new RegExp('#' + dataIndex + '.' + datachildIndex + '#', 'gm');
                count++;
                if (otherCulture.test(str) && count == 2) {
                    var str1 = str.split(' ');
                    for (var i = 0; i < str1.length; i++) {
                        var txt = str1[i];
                        if (otherCulture.test(txt)) {
                            txt = txt + '&lrm;';
                            str1[i] = txt;
                        }
                    }
                    str = str1.join(' ');
                }
                str = str.replace(val.source, datachildValue);
            });
        } else {
            str = str.replace(new RegExp('\\#' + dataIndex + '\\#', 'gm'), dataValue);
        }

    });
	while (str.indexOf('BoldBIDashboard.') >= 0) {
        substr = str.substring(str.indexOf('BoldBIDashboard.'), str.indexOf(")") + 1);
        str = str.replace(substr, eval(substr));
    }
    return str;
};

String.prototype.capitalizeFirstString = (function () {
    return this.charAt(0).toUpperCase() + this.slice(1);
});

var Gradient = function (colors) {
    this._gradientStop = [];
    for (var j = 0; j < colors.length; j++) {
        this._gradientStop.push(colors[j]);
    }
};



 BoldBIDashboard.BoldBIDashboardChart = {

    _renderSfChart: function () {

        var svgSupport = (window.SVGSVGElement) ? true : false;
        bbdesigner$("#chartContainer_" + this._id).remove();
        if (svgSupport) {
            if (this.model.enableCanvasRendering) {
                this.svgRenderer = new BoldBIDashboard.EjCanvasRender(this.element);
                this.legendSvgContainer = this.svgRenderer.createLegendCanvas(this.element); //creating new CANVAS element for legend
                this.legendContainer = bbdesigner$("<div></div>").attr('id', "legend_" + this._id).css("height", "0px");
				this.scrollerContainer = bbdesigner$("<div></div>").attr('id', "legend_Scroller" + this._id).css("height", "0px");
                this.chartContainer = bbdesigner$("<div></div>").css("position", "relative").attr('id', "chartContainer_" + this._id);
                this.svgRenderer.append(this.legendSvgContainer, this.scrollerContainer);
                bbdesigner$(this.scrollerContainer).appendTo(this.legendContainer);
                bbdesigner$(this.legendContainer).appendTo(this.chartContainer);
                bbdesigner$(this.chartContainer).appendTo(this.element);
            } else {
                this.svgRenderer = new BoldBIDashboard.EjSvgRender(this.element);
                this.legendSvgContainer = this.svgRenderer.createLegendSvg(this.element); //creating new SVG element for legend
                this.legendContainer = bbdesigner$("<div></div>").attr('id', "legend_" + this._id).css("height","0px");
				this.scrollerContainer = bbdesigner$("<div></div>").attr('id', "legend_Scroller" + this._id).css("height", "0px");
                this.chartContainer = bbdesigner$("<div></div>").css("position", "relative").attr('id', "chartContainer_" + this._id);
                this.svgRenderer.append(this.legendSvgContainer, this.scrollerContainer);
                bbdesigner$(this.scrollerContainer).appendTo(this.legendContainer);
                bbdesigner$(this.legendContainer).appendTo(this.chartContainer);
                bbdesigner$(this.chartContainer).appendTo(this.element);
				this.legendContainer.find("svg").attr("class", "e-designerhide");
            }

                this._createChart();
                bbdesigner$(this.svgObject).appendTo(this.element);
        }
        else {
            this.model.enableCanvasRendering = false;
            this.svgRenderer = new BoldBIDashboard.EjVmlRender(this.element);
            this.legendSvgContainer = this.svgRenderer.createLegendSvg(this.element); //creating new div element for legend
            this.legendContainer = bbdesigner$("<div></div>").attr('id', "legend_" + this._id).css("height", "0px");
			this.ScrollerContainer = bbdesigner$("<div></div>").attr('id', "legend_Scroller" + this._id).css("height", "0px");
            this.chartContainer = bbdesigner$("<div></div>").css("position", "relative").attr('id', "chartContainer_" + this._id);
            this.svgRenderer.append(this.legendSvgContainer, this.ScrollerContainer);
            bbdesigner$(this.ScrollerContainer).appendTo(this.legendContainer);
            bbdesigner$(this.legendContainer).appendTo(this.chartContainer);
            bbdesigner$(this.chartContainer).appendTo(this.element);
            this._createChart();
            bbdesigner$(this.svgObject).appendTo(this.chartContainer);
        }
        return true;
    },

 setSvgSize: function (sender) {
            var chartObj = sender;
            var containerHeight = bbdesigner$(chartObj.element).height();
            var height = 450; //set default height if size not specified to chart or container
            var width =(BoldBIDashboard.isTouchDevice()) ? 250: 600;
            var containerWidth = bbdesigner$(chartObj.element).width();
            var legendcontainerHeight = bbdesigner$(chartObj.chartContainer).height();
            if (chartObj.model.size.width) {
                var chartWidth = chartObj.model.size.width;
                if (typeof (chartWidth)== "string" && chartWidth.indexOf("%") != -1)
                    width = (containerWidth / 100) * parseInt(chartWidth);
                else
                    width = parseInt(chartWidth);
            }
            else if (containerWidth > 0)
                width = containerWidth;

            bbdesigner$(chartObj.svgObject).width(width);

            if (chartObj.model.size.height) {
                var chartHeight = chartObj.model.size.height;
                if (typeof (chartHeight) == "string" && chartHeight.indexOf("%") != -1)
                    height = (!this.vmlRendering) ? (containerHeight / 100) * parseInt(chartHeight) : height;
                else
                    height = parseInt(chartHeight);
            }
            else if (containerHeight > 0)
                height = containerHeight;
            else
                bbdesigner$(chartObj.svgObject).css("display", "block"); //Added css to chart due to 5px difference for container and svg (http://jsfiddle.net/Me5Zd/)       
            bbdesigner$(chartObj.svgObject).height(height);
			
			chartObj.svgObject.width = width;   // assigning width for canvas
			chartObj.svgObject.height = height;  // assigning height for 
},


    setModelProperties: function (excludeDataUpdate) {

        //set size for the svgObject
        this.setSvgSize(this);

        this.svgWidth = bbdesigner$(this.svgObject).width();
        this.svgHeight = bbdesigner$(this.svgObject).height();

        this.chartCross = {
            visible: (excludeDataUpdate) ? this.chartCross.visible : this.model.crosshair.visible,
            mArea: this.model.crosshair.type
        };

        // extend series with commonSeriesOptions
        this.serAnimation = [];
        if (this.model.series && !excludeDataUpdate) {
            var trendlines, len, currentPoint, currentSeries, nullValue = false, trendLineType;
            this.model._drawTrendline = false;
            for (var j = 0; j < this.model.series.length; j++) {
                this.model.series[j] = BoldBIDashboard.copyObject({}, this.model.commonSeriesOptions, this.model.series[j]);
				 currentSeries = this.model.series[j];
                this.serAnimation.push((currentSeries.enableAnimation === null || currentSeries.enableAnimation === undefined) ? this.model.commonSeriesOptions.enableAnimation : currentSeries.enableAnimation);
                    trendlines = currentSeries.trendlines;
                    len = trendlines.length;
                    for (var i = 0; i < len; i++) {
                        trendlines[i] = BoldBIDashboard.copyObject({}, this.model.trendlineDefaults, trendlines[i]);
						trendlines[i]._visibility = trendlines[i].visibility;
                        if (trendlines[i].visibility.toLowerCase() == "visible"){
						    this.model._drawTrendline = true;
						    trendLineType = trendlines[i].type.toLowerCase();
							if (!BoldBIDashboard.util.isNullOrUndefined(currentSeries.points)){
								for (var l= 0; l< currentSeries.points.length; l++){
									currentPoint = currentSeries.points[l];
									if (BoldBIDashboard.util.isNullOrUndefined(currentPoint.y)){
										nullValue = true; 
										break;
									}
								}
							}
						    trendlines[i].isNull  = nullValue;
						}
            }
          }
        }
        if (this.model.indicators) {
            for (var k = 0; k < this.model.indicators.length; k++) {
                this.model.indicators[k] = BoldBIDashboard.copyObject({}, this.model.indicatorDefaults, this.model.indicators[k]);
            }
        }

    },

    _createChart: function () {
        this.svgObject = this.svgRenderer.svgObj;
        var commonlaodEventArgs = bbdesigner$.extend({}, BoldBIDashboard.EjSvgRender.commonChartEventArgs);
        this._trigger("load", commonlaodEventArgs);
        this.setTheme(BoldBIDashboard.EjSvgRender.themes, this.model.theme);
        var model = this.model;
  
        if (model.series[0] && model.series[0]._isdesigntime) {
            model.series[0] = {};
            model.series[0].points = [];
            var randomPoints = [];
            for (var i = 1; i <= 10; i++) {
                randomPoints.push({ x: i, y: (Math.floor(Math.random() * (10 - 40)) + 40) });

            }
            model.series[0].points = randomPoints;
        }
		this.vmlRendering = (this.svgRenderer.vmlNamespace) ? true : false;
        if (bbdesigner$(this.element).is(":visible") || bbdesigner$(this.element).css("visibility") != "hidden" || bbdesigner$(this.element).css('display') != 'none') {
            this.bindEvents();
            this.bindTo();
        }
    },
    setTheme: function (jsonObj, themeName) {
        var name = themeName.toLowerCase();
        if ((name.indexOf("azure") >= 0 || name.indexOf("lime") >= 0 || name.indexOf("saffron") >= 0) && (name.indexOf("gradient") == -1) && (name.indexOf("dark") == -1))
            jsonObj[name] = bbdesigner$.extend(true, {}, jsonObj["flatlight"], jsonObj[name]);
        else if ((name.indexOf("azuredark") >= 0 || name.indexOf("limedark") >= 0 || name.indexOf("saffrondark")) >= 0 && (name.indexOf("gradient") == -1))
            jsonObj[name] = bbdesigner$.extend(true, {}, jsonObj["flatdark"], jsonObj[name]);
        else if ((name.indexOf("azure") >= 0 || name.indexOf("lime") >= 0 || name.indexOf("saffron") >= 0) && (name.indexOf("gradient") >= 0) && (name.indexOf("dark") == -1))
            jsonObj[name] = bbdesigner$.extend(true, {}, jsonObj["gradientlight"], jsonObj[name]);
        else if ((name.indexOf("azuredark") >= 0 || name.indexOf("limedark") >= 0 || name.indexOf("saffrondark") >= 0) && (name.indexOf("gradient") >= 0))
            jsonObj[name] = bbdesigner$.extend(true, {}, jsonObj["gradientdark"], jsonObj[name]);
        else if (!(jsonObj[name])) name = "flatlight";

        if (this.model._themeChanged)
            this.model = BoldBIDashboard.copyObject({}, this.model, jsonObj[name]);
        else
            this.model = BoldBIDashboard.copyObject({}, jsonObj[name], this.model);


    },
    _drawBackInterior: function () {
        if (this.model.backInterior && this.model.backInterior._gradientStop) {
            var options = {
                'id': this.svgObject.id + '_backGradient',
                'x1': '0%',
                'y1': '0%',
                'x2': '0%',
                'y2': bbdesigner$(this.svgObject).height() + '%'
            };
            this.svgRenderer.drawGradient(options, this.model.backInterior._gradientStop);
        }
    },
    


    _drawBackImage: function () {
        var options = {
            'height': bbdesigner$(this.svgObject).height(),
            'width': bbdesigner$(this.svgObject).width(),
            'href': this.model.backGroundImageUrl,
            'x': 0,
            'y': 0,
            'id': this.svgObject.id + '_backImage',
            'visibility': 'visible',
            'preserveAspectRatio': 'none'
        };

        this.svgRenderer.drawImage(options, this.svgObject);

    },
    _getDataType: function (val) {
        var type = typeof (val);
        if (type === "number" || type === "string")
            return type;
        else if (bbdesigner$.type(val) == "date")
            return "date";
        else if (val == null) {
            return null;
        }
        else
            return false;

    },
    addedXYValues: function (excludeDataUpdate) {
        excludeDataUpdate = (excludeDataUpdate) ? excludeDataUpdate : false;
        var type = this.model.series[0].type.toLowerCase(),
			xValueType = this.model.primaryXAxis.valueType,
			valueType = !BoldBIDashboard.util.isNullOrUndefined(xValueType) ? xValueType.toLowerCase() : xValueType,
            pointLength;
        if (BoldBIDashboard.seriesTypes[type].prototype.chartAreaType == "cartesianAxes") {
            this.model.AreaType = "cartesianaxes";
        }
        else if (BoldBIDashboard.seriesTypes[type].prototype.chartAreaType == "None")
            this.model.AreaType = "none";
        else {
            if (type == 'polar')
                this.model.isPolar = true;
            else
                this.model.isPolar = false;

            this.model.AreaType = "polaraxes";
        }
        if (!excludeDataUpdate) {
            for (var i = 0; i < this.model.series.length; i++) {
                if (this.model.series[i].visibility == "visible") {
                    var setXValueType = false, isDatetime = false, pointX, currentSeries;

                    if (!this.model.series[i].dataSource || this.model.series[i].dataSource.length == 0) {
                        this.model.series[i] = bbdesigner$.extend(true, {}, this.model.commonSeriesOptions, this.model.series[i]);
                        currentSeries = this.model.series[i];
                        if (valueType == "datetime")
                            isDatetime = true;
                        pointLength = currentSeries.points.length;
                        for (k = 0; k < pointLength; k++) {
                            currentSeries.points[k].YValues = [];
                            if (!isNaN(parseFloat(currentSeries.points[k].x)) && (/^[.0-9- ]*$/.test(currentSeries.points[k].x) == true) && (valueType != "category") && (this.model.AreaType != "none")) {
                                if (!isDatetime) {
                                    currentSeries.points[k].xValue = parseFloat(currentSeries.points[k].x);
                                    currentSeries.points[k].x = parseFloat(currentSeries.points[k].x);
                                }
                                else {
                                    currentSeries.points[k].xValue = new Date(currentSeries.points[k].x);
                                    currentSeries.points[k].x = new Date(currentSeries.points[k].x);
                                }
                            }
                            else
                                currentSeries.points[k].xValue = currentSeries.points[k].x;
                            if (!setXValueType) {
                                pointX = currentSeries.points[k].x;
                                if (!BoldBIDashboard.util.isNullOrUndefined(pointX)) {
                                    currentSeries._xAxisValueType = this._getDataType(pointX);
                                    setXValueType = true;
                                }
                            }
                            if (!(currentSeries._hiloTypes)) {
                                currentSeries.points[k].YValues[0] = currentSeries.points[k].y == "" ? 0 : currentSeries.points[k].y;

                                if (!BoldBIDashboard.util.isNullOrUndefined(currentSeries.points[k].size))
                                    currentSeries.points[k].YValues[1] = currentSeries.points[k].size;

                            }
                            else {
                                if (!BoldBIDashboard.util.isNullOrUndefined(currentSeries.points[k].high)) {
                                    currentSeries.points[k].YValues[0] = currentSeries.points[k].high;
                                    currentSeries.points[k].y = currentSeries.points[k].high;
                                }
                                if (!BoldBIDashboard.util.isNullOrUndefined(currentSeries.points[k].low))
                                    currentSeries.points[k].YValues[1] = currentSeries.points[k].low;
                                if (!BoldBIDashboard.util.isNullOrUndefined(currentSeries.points[k].open))
                                    currentSeries.points[k].YValues[2] = currentSeries.points[k].open;
                                if (!BoldBIDashboard.util.isNullOrUndefined(currentSeries.points[k].close))
                                    currentSeries.points[k].YValues[3] = currentSeries.points[k].close;
                            }
                        }
                    }
                    else {
                        currentSeries = this.model.series[i];
                        currentSeries._xAxisValueType = null;
                        pointLength = currentSeries.points.length;
                        for (var j = 0, length = pointLength; j < length; j++) {
                            pointX = currentSeries.points[j].x;
                            if ((pointX != null && pointX != undefined) && (currentSeries._xAxisValueType === null || currentSeries._xAxisValueType === undefined)) {
                                currentSeries._xAxisValueType = this._getDataType(pointX);
                            }
                            currentSeries.points[j].xValue = currentSeries.points[j].x;
                        }
                    }
                    //Calculate waterfall series points and remove on series changed
                    if (currentSeries.type.toLowerCase() == "waterfall")
                        this.calculateWaterfallSeriesPoints(currentSeries.points);
                    else if (currentSeries._previousType && currentSeries._previousType.toLowerCase() == "waterfall") {
                        var visiblePoints = currentSeries.points;
                        for (var j = 0; j < visiblePoints.length; j++) {
                            visiblePoints[j].waterfallSum = undefined;
                            visiblePoints[j].textOptions = null;
                        }
                    }
                }
            }
           this._setInternalValues();
         }
    },
    calculateWaterfallSeriesPoints: function (visiblePoints) {
        
        var intermediateStartValue = 0;
        var totalSum = 0;
        var previousSum = 0;

        for (var j = 0; j < visiblePoints.length; j++) {
            if (!visiblePoints[j].isEmpty) {
                totalSum += ((visiblePoints[j].showIntermediateSum || visiblePoints[j].showTotalSum) ? 0 : visiblePoints[j].y);

                if (visiblePoints[j].showIntermediateSum) {
                    visiblePoints[j].YValues[1] = intermediateStartValue;
                    visiblePoints[j].YValues[0] = totalSum;
                    visiblePoints[j].waterfallSum = totalSum - intermediateStartValue;
                    intermediateStartValue = totalSum;
                } else if (visiblePoints[j].showTotalSum) {
                    visiblePoints[j].YValues[1] = 0;
                    visiblePoints[j].YValues[0] = totalSum;
                    visiblePoints[j].waterfallSum = totalSum;
                }
                else {
                    visiblePoints[j].YValues[1] = previousSum;
                    visiblePoints[j].YValues[0] = previousSum + visiblePoints[j].y;
                    previousSum = totalSum;
                }
            } else {
                visiblePoints[j].YValues[1] = 0;
                visiblePoints[j].YValues[0] = 0;
            }
        }
    },
    _setInternalValues: function () {
        
        for (var k = 0; k < this.model.series.length; k++) {
            var series = this.model.series[k];
            if (this.model.AreaType == "cartesianaxes" && BoldBIDashboard.seriesTypes[series.type.toLowerCase()].prototype.chartAreaType == "cartesianAxes") {
                series._zOrder = (series.zOrder) ? series.zOrder : 0;
                this.model._visibleSeries.push(series);
            }
            else if (this.model.AreaType == "none" && BoldBIDashboard.seriesTypes[series.type.toLowerCase()].prototype.chartAreaType == "None") {
                series._zOrder = (series.zOrder) ? series.zOrder : 0;
                var type = this.model.series[k].type.toLowerCase();
                if (type == 'funnel' || type == 'pyramid') {
                    this.model._visibleSeries.push(series);
                    break;
                }
                else {
                    this.model._visibleSeries.push(series);
                }
            }
            else if (this.model.AreaType == "polaraxes" && BoldBIDashboard.seriesTypes[series.type.toLowerCase()].prototype.chartAreaType == "PolarAxes") {
                series._zOrder = (series.zOrder) ? series.zOrder : 0;
                this.model._visibleSeries.push(series);
            }

            if (series._yAxisName || series._xAxisName) {
                if (this.model._axes) {
                    for (var t = 0; t < this.model._axes.length; t++) {
                        if (series._yAxisName && (series._yAxisName == this.model._axes[t].name)) {
                            this.model._axes[t].orientation = (this.model._axes[t].orientation) ? this.model._axes[t].orientation : (this.model.requireInvertedAxes) ? "horizontal" : "vertical";
                        }
                        if (series._xAxisName && (series._xAxisName == this.model._axes[t].name)) {
                            this.model._axes[t].orientation = (this.model._axes[t].orientation) ? this.model._axes[t].orientation : (this.model.requireInvertedAxes) ? "vertical" : "horizontal";
                        }
                    }
                }
            }
        }
    },
    setHiloStyle: function(series, pointIndex, seriesIndex, interiorColor){
        var point = series.points[pointIndex];
                  
        if (point.fill)
              interior = point.fill;
         else
              interior = series.fill ? series.fill : interiorColor;
				
            // setting default series color		
            var colors = interior ? interior : this.model.seriesColors[seriesIndex];
          
            // applying gradient color		  
         
            seriesInterior = bbdesigner$.type(colors) == "array" ? colors[0].color : colors;

            return seriesInterior;
                       
    },
	setStyle: function (chart, series, seriesIndex, pointIndex, interiorColor) {
    
	    var point = series._visiblePoints[pointIndex], interior, borderColor, borderWidth, dashArray, 
            opacity, seriesFill, pointBorder = point.border, seriesBorder = series.border;
	    var mode = chart.chartObj.model.legend.mode.toLowerCase();
       // var pointStyle = point.style ? point.style : " ";
      
		if (series._hiloTypes)
		   seriesFill = series.isFill ? series.fill : null; 
		   
        // setting interior
        if (chart.chartObj.model.AreaType == "cartesianaxes") {			
            if (point.fill)
                interior = bbdesigner$.type(point.fill) != "array" ? point.fill : (mode != "series" ? point.fill : point.fill[0]) ;
            else {
                if (series.type.toLowerCase() == "waterfall") {
                    if (((point.showIntermediateSum || point.showTotalSum) && (point.waterfallSum > 0)) || (point.y > 0) && !point.showIntermediateSum && !point.showTotalSum)
                        interior = series.positiveFill ? series.positiveFill : interiorColor;
                } else{
					if(point.rangeFill)
						interior = point.rangeFill;
					else 
						interior = seriesFill ? seriesFill : interiorColor;
				}
            }
				
		// setting default series color		
			
			var colors = interior ? interior : this.model.seriesColors[seriesIndex];
            //colors = typeof colors == "object" && mode != "series" ? colors : this.model.seriesColors[seriesIndex];
        // applying gradient color		  
			if (chart.chartObj.model.requireInvertedAxes) 
			    var seriesInterior = this.svgRenderer.createGradientElement(chart.getSeriesName(series) + "_" + seriesIndex + pointIndex, colors, 0, 0, 100, 0, chart.gSeriesGroupEle, chart.chartObj.model);
            else                                       
			    seriesInterior = this.svgRenderer.createGradientElement(chart.getSeriesName(series) + "_" + seriesIndex + pointIndex, colors, 0, 0, 0, 100, chart.gSeriesGroupEle, chart.chartObj.model);
         } 
		 
		// interior for pie type series
        else {
            var pointColors = this.model.pointColors;
            interior = point.fill ? point.fill : bbdesigner$.type(pointColors[pointIndex]) == "array" ? pointColors[pointIndex][0].color : pointColors[pointIndex];
            var pointInterior = this.svgRenderer.createGradientElement(chart.getSeriesName(series) + pointIndex, interior, 0, 0, 0, (bbdesigner$(chart.svgObject).height() || parseFloat(this.model.size.height)), chart.chartObj.gSeriesEle, chart.chartObj.model);
        }
        
        // setting borderColor
        borderColor = ((pointBorder) && pointBorder.color) ? pointBorder.color : seriesBorder.color;
        borderWidth = ((pointBorder) && pointBorder.width) ? pointBorder.width : seriesBorder.width;
        opacity = point.opacity ? point.opacity : series.opacity;
        width = (point.width && mode == "series") ? point.width : series.width;
        dashArray = ((pointBorder) && pointBorder.dashArray) ? pointBorder.dashArray : seriesBorder.dashArray;

        var options = {
            'interior': seriesInterior ? seriesInterior: pointInterior,
            'borderColor': borderColor,
            'borderWidth': borderWidth,
            'width': width,
            'opacity': opacity,
            'dashArray': dashArray
        };
        return options;
    },
	
    colorNameToHex: function (colour) {
        var color = colour;
        var colours = {
            "aliceblue": "#f0f8ff", "antiquewhite": "#faebd7", "aqua": "#00ffff", "aquamarine": "#7fffd4", "azure": "#f0ffff",
            "beige": "#f5f5dc", "bisque": "#ffe4c4", "black": "#000000", "blanchedalmond": "#ffebcd", "blue": "#0000ff", "blueviolet": "#8a2be2", "brown": "#a52a2a", "burlywood": "#deb887",
            "cadetblue": "#5f9ea0", "chartreuse": "#7fff00", "chocolate": "#d2691e", "coral": "#ff7f50", "cornflowerblue": "#6495ed", "cornsilk": "#fff8dc", "crimson": "#dc143c", "cyan": "#00ffff",
            "darkblue": "#00008b", "darkcyan": "#008b8b", "darkgoldenrod": "#b8860b", "darkgray": "#a9a9a9", "darkgreen": "#006400", "darkkhaki": "#bdb76b", "darkmagenta": "#8b008b", "darkolivegreen": "#556b2f",
            "darkorange": "#ff8c00", "darkorchid": "#9932cc", "darkred": "#8b0000", "darksalmon": "#e9967a", "darkseagreen": "#8fbc8f", "darkslateblue": "#483d8b", "darkslategray": "#2f4f4f", "darkturquoise": "#00ced1",
            "darkviolet": "#9400d3", "deeppink": "#ff1493", "deepskyblue": "#00bfff", "dimgray": "#696969", "dodgerblue": "#1e90ff",
            "firebrick": "#b22222", "floralwhite": "#fffaf0", "forestgreen": "#228b22", "fuchsia": "#ff00ff",
            "gainsboro": "#dcdcdc", "ghostwhite": "#f8f8ff", "gold": "#ffd700", "goldenrod": "#daa520", "gray": "#808080", "green": "#008000", "greenyellow": "#adff2f",
            "honeydew": "#f0fff0", "hotpink": "#ff69b4",
            "indianred ": "#cd5c5c", "indigo ": "#4b0082", "ivory": "#fffff0", "khaki": "#f0e68c",
            "lavender": "#e6e6fa", "lavenderblush": "#fff0f5", "lawngreen": "#7cfc00", "lemonchiffon": "#fffacd", "lightblue": "#add8e6", "lightcoral": "#f08080", "lightcyan": "#e0ffff", "lightgoldenrodyellow": "#fafad2",
            "lightgrey": "#d3d3d3", "lightgreen": "#90ee90", "lightpink": "#ffb6c1", "lightsalmon": "#ffa07a", "lightseagreen": "#20b2aa", "lightskyblue": "#87cefa", "lightslategray": "#778899", "lightsteelblue": "#b0c4de",
            "lightyellow": "#ffffe0", "lime": "#00ff00", "limegreen": "#32cd32", "linen": "#faf0e6",
            "magenta": "#ff00ff", "maroon": "#800000", "mediumaquamarine": "#66cdaa", "mediumblue": "#0000cd", "mediumorchid": "#ba55d3", "mediumpurple": "#9370d8", "mediumseagreen": "#3cb371", "mediumslateblue": "#7b68ee",
            "mediumspringgreen": "#00fa9a", "mediumturquoise": "#48d1cc", "mediumvioletred": "#c71585", "midnightblue": "#191970", "mintcream": "#f5fffa", "mistyrose": "#ffe4e1", "moccasin": "#ffe4b5",
            "navajowhite": "#ffdead", "navy": "#000080",
            "oldlace": "#fdf5e6", "olive": "#808000", "olivedrab": "#6b8e23", "orange": "#ffa500", "orangered": "#ff4500", "orchid": "#da70d6",
            "palegoldenrod": "#eee8aa", "palegreen": "#98fb98", "paleturquoise": "#afeeee", "palevioletred": "#d87093", "papayawhip": "#ffefd5", "peachpuff": "#ffdab9", "peru": "#cd853f", "pink": "#ffc0cb", "plum": "#dda0dd", "powderblue": "#b0e0e6", "purple": "#800080",
            "red": "#ff0000", "rosybrown": "#bc8f8f", "royalblue": "#4169e1",
            "saddlebrown": "#8b4513", "salmon": "#fa8072", "sandybrown": "#f4a460", "seagreen": "#2e8b57", "seashell": "#fff5ee", "sienna": "#a0522d", "silver": "#c0c0c0", "skyblue": "#87ceeb", "slateblue": "#6a5acd", "slategray": "#708090", "snow": "#fffafa", "springgreen": "#00ff7f", "steelblue": "#4682b4",
            "tan": "#d2b48c", "teal": "#008080", "thistle": "#d8bfd8", "tomato": "#ff6347", "turquoise": "#40e0d0",
            "violet": "#ee82ee",
            "wheat": "#f5deb3", "white": "#ffffff", "whitesmoke": "#f5f5f5",
            "yellow": "#ffff00", "yellowgreen": "#9acd32"
        };

        if (Object.prototype.toString.call(color) == '[object Array]')
            return color;

        if (typeof colours[color.toLowerCase()] != 'undefined')
            return colours[color.toLowerCase()];

        return color;
    },
	
	// set culture for chart
     _setCulture: function (culture) {
         this.culture = BoldBIDashboard.preferredCulture(culture);
    },

     _chartResponsiveLayout: function (params) {
         var model = this.model, title = model.title, subTitle = title.subTitle,
                     legend = model.legend,
                     legendPosition = !BoldBIDashboard.util.isNullOrUndefined(legend.responsivePosition) ? legend.responsivePosition : legend.position.toLowerCase(),
                     svgWidth = bbdesigner$(this.svgObject).width(),svgHeight = bbdesigner$(this.svgObject).height(), margin = model.margin,
                     axesLength = model._axes.length;

         if (model.AreaType != "none") {
             flag = false;
             flag1 = false;
             if (svgWidth <= 100 && svgHeight <= 100) {
                 margin.left = margin.right = margin.top = margin.bottom = 0;
             }
             if (svgWidth <= 100 || svgHeight <= 100) {
                 model.elementSpacing = 0;
                 title.responsiveVisibility = false;
                 subTitle.responsiveVisibility = false;
                 for (var i = 0; i < model.series.length; i++) {
                     model.series[i].marker.responsiveVisibility = false;
                     model.series[i].marker.dataLabel.responsiveVisibility = false;
                 }
                 legend.responsiveVisibility = false;
				 
				 if (svgWidth <= 100){
				   for (var i = 0; i < axesLength; i++) {
                             var axis = model._axes[i];
                             if (axis.orientation.toLowerCase() == "vertical"){
                                 axis.responsiveVisibility = false;
								 axis.title.responsiveVisibility = false;
							 }	
                         }
				 }
				 
				 if (svgHeight <= 100){
				   for (var i = 0; i < axesLength; i++) {
                             var axis = model._axes[i];
                             if (axis.orientation.toLowerCase() == "horizontal"){
                                 axis.responsiveVisibility = false;
								 axis.title.responsiveVisibility = false;
							}
                         }
				 }
             }
             if (model.m_AreaBounds.Width < svgWidth / 2 && svgWidth > 100 && this.count <5) {
                 switch (this.count) {
                     case 4:
                         model.elementSpacing = 0;

                     case 3 || 4:
                         for (var i = 0; i < axesLength; i++) {
                             var axis = model._axes[i];
                             if (axis.orientation.toLowerCase() == "vertical")
                                 axis.responsiveVisibility = false;
                         }

                     case 2 || 3 || 4:
                         for (var i = 0; i < axesLength; i++) {
                             var axis = model._axes[i];
                             if(axis.orientation.toLowerCase()=="vertical")
                                 axis.title.responsiveVisibility = false;
                         }

                     case 1 || 2 || 3 || 4:
                         if (legendPosition == "left" || legendPosition == "right")
                             legend.responsiveVisibility = false;

                     default:
                         break;
                 }
             }
             else flag = true;
             if (model.derivedBoundsHeight < svgHeight / 2 && svgHeight > 100 && this.count <7) {
                 switch (this.count) {
                     case 6:
                         model.elementSpacing = 0;

                     case 5 || 6:
                         for (var i = 0; i < axesLength; i++) {
                             var axis = model._axes[i];
                             if (axis.orientation.toLowerCase() == "horizontal")
                                 axis.responsiveVisibility = false;
                         }

                     case 4 || 5 || 6:
                         for (var i = 0; i < axesLength; i++) {
                             var axis = model._axes[i];
                             if (axis.orientation.toLowerCase() == "horizontal")
                                 axis.title.responsiveVisibility = false;
                         }

                     case 3 || 4 || 5 || 6:
                         if (legendPosition == "top" || legendPosition == "bottom")
                             legend.responsiveVisibility = false;

                     case 2 || 3 || 4 || 5 || 6:
                         title.responsiveVisibility = false;
						 model._titleLocation = null;

                     case 1 || 2 || 3 || 4 || 5 || 6:
                         subTitle.responsiveVisibility = false;
						 model._subTitleLocation = false;

                     default:
                         break;
                 }
             } else
                 flag1 = true;

             if (flag && flag1) {
                 this.count =  -1;
                 for (var i = 0; i < axesLength; i++) {
                     var axis = model._axes[i];
                     if (axis.orientation.toLowerCase() == "vertical") {
                         var titleText = !BoldBIDashboard.util.isNullOrUndefined(axis.title.trimmedText) || svgWidth <= 100 ? "" : axis.title.text;
                         if (titleText != "" && axis.title.visible) {
                             var height = axis.length - model.m_AreaBounds.Y - 2;
                             var axisTitleSize = BoldBIDashboard.EjSvgRender.utils._measureText(titleText, (height), axis.title.font);
                             while (axisTitleSize.width > Math.abs(height)) {
                                 titleText = BoldBIDashboard.EjAxisRenderer.prototype.trimText(titleText, titleText.length, "...");
                                 axisTitleSize = BoldBIDashboard.EjSvgRender.utils._measureText(titleText, (height), axis.title.font);
                                 if (titleText == "...") {
                                     titleText = "";
                                     break;
                                 }
                             }
                         }
                     }
                     else {
                         var titleText = !BoldBIDashboard.util.isNullOrUndefined(axis.title.trimmedText) || svgHeight <= 100 ? "" : axis.title.text;
                         if (titleText != "" && axis.title.visible) {
                             var width = axis.length - model.m_AreaBounds.X -1;
                             var axisTitleSize = BoldBIDashboard.EjSvgRender.utils._measureText(axis.title.text, (width), axis.title.font);
                             var titleText = axis.title.text;
                             while (axisTitleSize.width > width) {
                                 titleText = BoldBIDashboard.EjAxisRenderer.prototype.trimText(titleText, titleText.length, "...");
                                 axisTitleSize = BoldBIDashboard.EjSvgRender.utils._measureText(titleText, (width), axis.title.font);
                                 if (titleText == "...") {
                                     titleText = "";
                                     break;
                                 }
                             }
                         }
                     }
                     axis.trimmedText = titleText;
                 }
             }
             this._calculateLegendBounds(this);
             this._calculateAreaBounds(params);
             
         } else {
             if (svgHeight <= 200 && svgWidth <= 200) {
                 title.trimmedText = "";
                 title.subTitle.trimmedText = "";
                 title.responsiveVisibility = false;
                 subTitle.responsiveVisibility = false;
                 legend.responsiveVisibility = false;
                 model._titleLocation = null;
                 model.chartTitleRegion = null;
                 model.chartSubTitleRegion = null;
             } else {
                 var width = svgWidth;
                 var titleText = title.text;
                 if (titleText != "" && title.visible) {
                     var chartTitleSize = BoldBIDashboard.EjSvgRender.utils._measureText(titleText, bbdesigner$(this.svgObject).width() - margin.left - margin.right, title.font);
                     while (chartTitleSize.width > width) {
                         titleText = BoldBIDashboard.EjAxisRenderer.prototype.trimText(titleText, titleText.length, "...");
                         chartTitleSize = BoldBIDashboard.EjSvgRender.utils._measureText(titleText, bbdesigner$(this.svgObject).width() - margin.left - margin.right, title.font);
                         if (titleText == "...") {
                             titleText = "";
                             break;
                         }
                     }
                 }
                 title.trimmedText = titleText;
             }
             this._calculateLegendBounds(this);
         }
     },

     draw: function (excludeDataUpdate) {
        this.removeMultiRect();
        var params = {};
		params.axes = {};		
		this._drawBackInterior();
        this.model.chartRegions = [];         
		this.model.outsideDataRegionPoints = [];
		this.model.regionCount = null;
		this.model.totalRadius = null;
		this.model.circularRadius = [];
		this.model._circularRadius = [];
       this.model.innerRadius = [];
       this.model.bounds = [];
       this.model.connectorBounds = [];
       this.model.dataLabelSeries = [];
       this.model.explode = false;
       this.model.explodeOut = false;
       this.accDataLabelRegion = [];
       this.model.rightsidebounds = [];
		this.model.leftsidebounds = [];
        this.model.excludeDataUpdate = excludeDataUpdate;
		this.model.yAxisLabelRegions = [];
        this.model.xAxisLabelRegions = [];
		this.model.minhightwidth = false;
        if (!excludeDataUpdate)
            this.model._visibleSeries = [];
        this.model.stackedValue = {};
		this._setCulture(this.model.locale);
		 var seriesLength = this.model.series.length;
		 var series, seriesType;
        if (BoldBIDashboard.util.isNullOrUndefined(this.model.sideBySideSeriesPlacement))  // for setting sideBySideSeriesPlacement property values
            this.model._sideBySideSeriesPlacement = (this.model.enable3D) ? false : true;
        else
            this.model._sideBySideSeriesPlacement = this.model.sideBySideSeriesPlacement;
        for (var i = 0; i < seriesLength; i++)
        {
            series = this.model.series[i];
            seriesType = series.type.toLowerCase();
            series._isTransposed = (seriesType.indexOf("bar") == -1) ? series.isTransposed : !series.isTransposed;
        }
        if (seriesLength > 0)
            this.addedXYValues(excludeDataUpdate);
        this.model.AreaType = this.model.AreaType || "cartesianaxes";
        
		this._isEjScroller();        

        var commonpreRenderEventArgs = bbdesigner$.extend({}, BoldBIDashboard.EjSvgRender.commonChartEventArgs);
        commonpreRenderEventArgs.data = {};
        this._trigger("preRender", commonpreRenderEventArgs);

        this.gLegendEle = this.svgRenderer.createGroup({ 'id': this.svgObject.id + '_Legend' });

        this.gTitleEle = this.svgRenderer.createGroup({ 'id': this.svgObject.id + '_ChartTitle' });
        this.gSubTitleEle = this.svgRenderer.createGroup({ 'id': this.svgObject.id + '_ChartsubTitle' });
        this._createAxisLabelAndRange();
		for(var i=0; i<this.model._axes.length; i++)
			params.axes[this.model._axes[i].name] = {};
        this._initializeSeriesColors();

        this.model.legend.responsiveVisibility = this.model.legend.visible;
        this._calculateLegendBounds(this);

        this.legendRender = new BoldBIDashboard.EjLegendRender(this);

        var commonLegendEventArgs = bbdesigner$.extend({}, BoldBIDashboard.EjSvgRender.commonChartEventArgs);
        commonLegendEventArgs.data = { legendBounds: this.model.LegendBounds };
        this._trigger("legendBoundsCalculate", commonLegendEventArgs);

         // Assigning indicator points
        for (var j = 0; j < this.model.indicators.length; j++) {
            var indicator = this.model.indicators[j];
			indicator._points = [];
            indicator.xAxisName = (!(indicator.xAxisName)) ? this.model._axes[0].name : indicator.xAxisName;
            indicator.yAxisName = (!(indicator.yAxisName)) ? this.model._axes[1].name : indicator.yAxisName;
            indicator.isIndicator = true;
            if (indicator.dataSource) {
                indicator._hiloTypes = true;
                this._processJsonData(indicator.dataSource, indicator);
            } else if (indicator.points.length > 0) {
                for (var i = 0; i < indicator.points.length; i++) {
				     indicator._points = indicator.points;
                    indicator._points[i].xValue = indicator.points[i].x;
                    indicator._points[i].YValues = [];
                    indicator._points[i].YValues[0] = indicator.points[i].close;
                }
            }
            else if (indicator.seriesName != "") {
                for (var index = 0; index < this.model._visibleSeries.length; index++) {
                    var series = this.model._visibleSeries[index];
                    if (indicator.seriesName == series.name)
                        indicator._points = bbdesigner$.extend(true, [], series.points);
                }
            }
        }

         // calculate category points
        for (k = 0; k < this.model._axes.length; k++) {
            if (this.model._axes[k].valueType && this.model._axes[k].valueType.toLowerCase() == "category") {
                for (i = 0; i < this.model.indicators.length; i++) {
                    indicator = this.model.indicators[i];
                    if (this.model._axes[k].name == indicator.xAxisName) {
                        for (j = 0; j < indicator._points.length; j++)
                            indicator._points[j].xValue = j;
                    }
                }
            }
        }

         // calculate ranges for indicator
        this.model.indicatorRange = [];
        for (index = 0; index < this.model.indicators.length; index++) {
            indicator = this.model.indicators[index];
            if (indicator._points.length > 0) {
                type = indicator.type.toLowerCase();
              options = new BoldBIDashboard.indicatorTypes[type]();
              options.calculateSegment(indicator, this);
         }
     }


         for (var m = 0; m < this.model._visibleSeries.length; m++) {
            var options = this.model._visibleSeries[m];
            for (i = 0; i < options.points.length; i++) {
                if (typeof options.points[i].xValue == "string" && options.points[i].xValue.indexOf("/Date(") != -1)
                    options.points[i].xValue = new Date(parseInt(options.points[i].xValue.substr(6)));
            }
        }
        this.model.hAxes = [];
        this.model.vAxes = [];
        var chartobj = this;
        var isStriplineOver = false, isStriplineBehind = false;
        this._arrangeAxis();
        for (var k = 0; k < this.model._axes.length; k++) {
            var axis = this.model._axes[k];
            var seriesCollection = [];
            var seriesLength = this.model.series.length;
            var orientation = this.model._axes[k].orientation.toLowerCase();
            var padding = this.model._axes[k].rangePadding.toLowerCase();
            if (padding == "auto") {
                if (orientation == "vertical") {
                    axis.rangePadding = (!this.model.requireInvertedAxes) ? "normal" : "none";
                }
                if (orientation == "horizontal") {
                    axis.rangePadding = (this.model.requireInvertedAxes) ? "normal" : "none";
                }
                for (var j = 0; j < seriesLength; j++) {
                    var type = this.model.series[j].type.toLowerCase();
                    if (type.indexOf("100") != -1) {
                        if (axis.name == this.model.series[j]._yAxisName) {
                            axis.rangePadding = "round"; break;
                        }
                    }
                }
            }          
            for (var slCount = 0; slCount < axis.stripLine.length; slCount++) {
                axis.stripLine[slCount] = bbdesigner$.extend(true, {}, this.model.stripLineDefault, axis.stripLine[slCount]);
                if (axis.stripLine[slCount].zIndex.toLowerCase() == 'over') {
                    isStriplineOver = true;
                } else {
                    isStriplineBehind = true;
                }
            }
            var axisOrientation = axis.orientation.toLowerCase();
            var zOrder = this.model._visibleSeries.length - 1;
            for (j = 0; j < this.model._visibleSeries.length; ++j) {
                zOrder -= 1;
                                      
                    var series = this.model._visibleSeries[j];
                    if((!series.xAxisName)){
                    series._xAxisName = chartobj.model._axes[0].name;
					 }
					if(!series.yAxisName){
                    series._yAxisName = chartobj.model._axes[1].name;
                    }
					series._xAxisName=(!(series._xAxisName))?(!(series.xAxisName)?chartobj.model._axes[0].name:series.xAxisName):(series.xAxisName ? series.xAxisName : series._xAxisName);
                    series._yAxisName = (!(series._yAxisName)) ? (!(series.yAxisName)?chartobj.model._axes[1].name :series.yAxisName):(series.yAxisName ? series.yAxisName : series._yAxisName);
                    var xAxisName = series._xAxisName.toLowerCase();
                    var yAxisName = series._yAxisName.toLowerCase();
                    var name = axis.name.toLowerCase();
                    if (xAxisName || yAxisName) {
                        if (xAxisName == name || yAxisName == name) {
                            if ((axisOrientation == "horizontal" || (series.type.toLowerCase().indexOf("bar") != -1 && axisOrientation == "vertical")) && axis.valueType && axis.valueType.toString() == "datetime") {
                                for (var m = 0; m < series.points.length; m++) {
                                    if (typeof series.points[m].xValue == "string" && !isNaN(Date.parse(series.points[m].xValue)))
                                        series.points[m].xValue = new Date(Date.parse(series.points[m].xValue));
                                }
                            }
                            else {
                                if (series._xAxisValueType == "string" && !(axis.valueType))
                                    axis._valueType = (axisOrientation == 'horizontal' && !this.model.requireInvertedAxes) ? 'category' : (axisOrientation == 'vertical' && this.model.requireInvertedAxes) ? 'category' : 'double';

                                if (series._xAxisValueType == "date" && !(axis.valueType))
                                    axis._valueType = (axisOrientation == 'horizontal' && !this.model.requireInvertedAxes) ? "datetime" : (axisOrientation == 'vertical' && this.model.requireInvertedAxes) ? 'datetime' : 'double';
                            }
							if (this.model._visibleSeries[j].visibility.toLowerCase() == 'visible')
                            seriesCollection.push(series);
                        }
                    
                }
            }
            if (axisOrientation == ((!this.model.requireInvertedAxes) ? "vertical" : "horizontal")) {
                var isStacked100 = false;
                var isStacked = false;               
                var seriesLength = seriesCollection.length;
                axis.isStacked100 = (seriesCollection.length>0) ? true :false;
                for (var i = 0; i < seriesLength; i++) {
                    var type = seriesCollection[i].type.toLowerCase();
                    if (BoldBIDashboard.seriesTypes[type].prototype.stackingSeries || (this.model.AreaType == 'polaraxes' && seriesCollection[i].drawType.toLowerCase() == 'column' && seriesCollection[i].isStacking)) {
                        if (type.indexOf("100") != -1 && (!isStacked100)) {
                            this._calculateStackingCumulativeValues(seriesCollection, axis, params);
                            isStacked100 = true;
                        } else if (type.indexOf("100") == -1 && (!isStacked)) {
                            this._calculateStackingValues(seriesCollection, axis, params);
                            isStacked = true;
                            axis.isStacked100 = false;
                        }                     
                    }
                    else {
                        axis.isStacked100 = false;
                    }
                }
            }
            if (axis.enableScrollbar) {
                this.model.disableZoom = true;
            }
            axis._valueType = (!(axis._valueType)) ? (!(axis.valueType) ? "double" : axis.valueType) : axis._valueType;
            var axisRange = new BoldBIDashboard.axisTypes[axis._valueType.toLowerCase()]();
            axisRange._calculateRanges(chartobj, axis, seriesCollection, params);             
        }

        var commonAxesInitEventArgs = bbdesigner$.extend({}, BoldBIDashboard.EjSvgRender.commonChartEventArgs);
        commonAxesInitEventArgs.data = { axes: this.model._axes };
        this._trigger("axesLabelsInitialize", commonAxesInitEventArgs);

        

        if (this.model.adaptiveRendering) {
			this.model.elementSpacing = 10;
			this.model.chartTitleRegion = null;
			this.model.chartSubTitleRegion = null;
			this.model.xAxisTitleRegion = null;
			this.model.yAxisTitleRegion = null;
			this.model.legend.responsiveVisibility = this.model.legend.visible;
			this.model.title.responsiveVisibility = this.model.title.visible;
			this.model.title.subTitle.responsiveVisibility = this.model.title.subTitle.visible;
			this.model.title.trimmedText = null;
			this.model.title.subTitle.trimmedText = null;
            this.model.margin.left = 10;
            this.model.margin.right = 10;
            this.model.margin.top = 10;
            this.model.margin.bottom = 10;
			this.count = null;
        }
            var axesLength = this.model._axes.length;
            for (var i = 0; i < axesLength; i++) {
                this.model._axes[i].title.trimmedText = null;
                this.model._axes[i].responsiveVisibility = this.model._axes[i].visible;
                this.model._axes[i].title.responsiveVisibility = this.model._axes[i].title.visible;
            }
           
            for (var i = 0; i < this.model.series.length; i++) {
                this.model.series[i].marker.responsiveVisibility = this.model.series[i].marker.visible;
                this.model.series[i].marker.dataLabel.responsiveVisibility = this.model.series[i].marker.dataLabel.visible;
            }
        
		 var prevHeight,
             prevWidth;
         if (this.svgHeight != this.model.svgHeight || this.svgWidth != this.model.svgWidth) {
            // beforeResize event
            prevHeight=BoldBIDashboard.util.isNullOrUndefined(this.prevHeight)?this.svgHeight:this.prevHeight;
            prevWidth = BoldBIDashboard.util.isNullOrUndefined(this.prevWidth) ? this.svgWidth : this.prevWidth;
            commonEventArgs = bbdesigner$.extend({}, BoldBIDashboard.EjSvgRender.commonChartEventArgs);
            commonEventArgs.data = { currentHeight: prevHeight, currentWidth: prevWidth, newHeight: this.model.svgHeight, newWidth: this.model.svgWidth };
            this._trigger("beforeResize", commonEventArgs);
            if (!commonEventArgs.cancel) {
                if (this.model.enableCanvasRendering) {
                    this.svgRenderer.svgObj.width = commonEventArgs.data.newWidth;
                    this.svgRenderer.svgObj.height = commonEventArgs.data.newHeight;
                }
                this.model.svgWidth = commonEventArgs.data.newWidth;
                this.model.svgHeight = commonEventArgs.data.newHeight;
                bbdesigner$(this.svgObject).width(commonEventArgs.data.newWidth);
                bbdesigner$(this.svgObject).height(commonEventArgs.data.newHeight);
            }
            else
            { 
                if (this.model.enableCanvasRendering)
                {
                    this.svgRenderer.svgObj.width = commonEventArgs.data.currentWidth;
                    this.svgRenderer.svgObj.height = commonEventArgs.data.currentHeight;
                }
                this.model.svgWidth = commonEventArgs.data.currentWidth;
                this.model.svgHeight = commonEventArgs.data.currentHeight;
                bbdesigner$(this.svgObject).width(commonEventArgs.data.currentWidth);
                bbdesigner$(this.svgObject).height(commonEventArgs.data.currentHeight);
            }
        }
        this._calculateAreaBounds(params);

        if (this.model.enable3D) {

            var Ej3DRender = new BoldBIDashboard.Ej3DRender();
            this.vector = new Ej3DRender.vector3D();
            this.matrixobj = new Ej3DRender.matrix3D();
            this.bsptreeobj = new Ej3DRender.BSPTreeBuilder();
            this.polygon = new Ej3DRender.polygon3D();
            this.graphics = new Ej3DRender.Graphics3D();

            this.chart3D = this.svgRenderer.createGroup({ 'id': this.svgObject.id + '_Chart3D' });
            BoldBIDashboard.Ej3DRender.Polygons = [];
        }


        if (this.model.AreaType != "none") {        

            this._calculateAxisSize(params);

            //AxisCrossing                
            for (var i = 0, len = this.model._axes.length; i < len; i++)
                if (this._validateCrossing(this.model._axes[i]))
                    this._axisCrossing(this.model._axes[i], false, params);
            if (params._crossAxisOverlap)
			{
                for (var i = 0, len = this.model._axes.length; i < len; i++)
                    if (params.axes[this.model._axes[i].name]._validCross)
                        this._axisCrossing(this.model._axes[i], true, params);
                params._crossAxisOverlap = false;
			}

            var commonAreaEventArgs = bbdesigner$.extend({}, BoldBIDashboard.EjSvgRender.commonChartEventArgs);
            commonAreaEventArgs.data = { areaBounds: this.model.m_AreaBounds };
            this._trigger("chartAreaBoundsCalculate", commonAreaEventArgs);

            this._drawChartAreaRect();

            var titleText = this.model.title.text;
            if (titleText != "" && this.model.title.visible && this.model.title.responsiveVisibility)
                this._drawTitle();
            
            this.gXaxisEle = this.svgRenderer.createGroup({ 'id': this.svgObject.id + '_XAxis' });

            this.gYaxisEle = this.svgRenderer.createGroup({ 'id': this.svgObject.id + '_YAxis' });
     
            this.gPolarAxisEle = this.svgRenderer.createGroup( { 'id': this.svgObject.id + '_AxisLine' });
            if (this.model.enable3D) {

                bbdesigner$.extend(BoldBIDashboard.Ej3DAxisRenderer.prototype, this);
                this.chartaxis = new BoldBIDashboard.Ej3DAxisRenderer(this);
            }
            else {
                bbdesigner$.extend(BoldBIDashboard.EjAxisRenderer.prototype, this);
                this.chartaxis = new BoldBIDashboard.EjAxisRenderer(this);
            }

            var chartaxis = this.chartaxis;
			this.model.xAxisTitleRegion = [];
            this.model.yAxisTitleRegion = [];
                               
			if (this.model.enable3D) {
			    for (var l = 0; l < this.model._axes.length; l++) {
			        chartaxis._drawAxes(l, this.model._axes[l], params);
			    }
			    BoldBIDashboard.Ej3DChart.prototype.update3DWall(this, params);
			}
			else {
			    for (var l = 0; l < this.model._axes.length; l++) {
			        chartaxis._drawGridLines(l, this.model._axes[l], params);
			    }
			}
          

            //Based on the column/bar series, modified primaryAxis append to the SVG Object
            if (!this.model.requireInvertedAxes) { 
                this.svgRenderer.append(this.gXaxisEle, this.svgObject);
                this.svgRenderer.append(this.gYaxisEle, this.svgObject);
            } else {
                this.svgRenderer.append(this.gYaxisEle, this.svgObject);
                this.svgRenderer.append(this.gXaxisEle, this.svgObject);
            }

            var x = (this.model.AreaType == 'polaraxes') ? 0: this.model.m_AreaBounds.X;
            var y = (this.model.AreaType == 'polaraxes') ? 0 : this.model.m_AreaBounds.Y;

            var width = (this.model.AreaType == 'polaraxes') ? bbdesigner$(this.svgObject).width() : this.model.m_AreaBounds.Width;
            var height = (this.model.AreaType == 'polaraxes') ? bbdesigner$(this.svgObject).height() : this.model.m_AreaBounds.Height;

            var clipRectOptions = {
                'id': this.svgObject.id + '_ChartAreaClipRect',
                'x': x,
                'y': y,
                'width': width,
                'height': height,
                'fill': 'white',
                'stroke-width': 1,
                'stroke': 'Gray'
            };

            this.svgRenderer.drawClipPath(clipRectOptions, this.svgObject);
			
			this._setZoomProperties();
        }

        else {
            this._drawChartAreaRect();

            clipRectOptions = {
                'id': this.svgObject.id + '_ChartAreaClipRect',
                'x': 0,
                'y': 0,
                'width': bbdesigner$(this.svgObject).width(),
                'height': bbdesigner$(this.svgObject).height(),
                'fill': 'white',
                'stroke-width': 1,
                'stroke': 'Gray'
            };

            this.svgRenderer.drawClipPath(clipRectOptions, this.svgObject);

            var titleText = this.model.title.text;
            if (titleText != "" && this.model.title.visible && this.model.title.responsiveVisibility)
                this._drawTitle();
        }

        if (isStriplineBehind && this.model.AreaType == "cartesianaxes" && !this.model.enable3D) {
            this.gStriplineBehind = this.svgRenderer.createGroup({ 'id': this.svgObject.id + '_StriplineBehind', 'clip-path': 'url(#' + this.svgObject.id + '_ChartAreaClipRect)' });
            this._renderStripline('behind');
        }
		if (this.model.initSeriesRender) {
            this.seriesRender(params);
            this.indicatorRender();
        }
         
		var annotationsLength = this.model.annotations.length; 
        bbdesigner$('#annotation_group_' + this._id).empty();
		for (var a = 0; a < annotationsLength; a++) {
            var currentAnnotation = this.model.annotations[a];
            if (currentAnnotation.visible) {
                this.annotationRender(currentAnnotation, a);
              }
        }
		
		if (this.model.AreaType == "polaraxes" && this.model._axes[1].visible  && this.model._axes[1].responsiveVisibility  && !this.model.enable3D) {
            this.chartaxis._drawAxisLine(this.model._axes[1]);
        }
		
		if(this.model.AreaType==="cartesianaxes"){
			if (!this.model.requireInvertedAxes) {
				this.svgRenderer.append(this.gXaxisEle, this.svgObject);
				this.svgRenderer.append(this.gYaxisEle, this.svgObject);
			} else {
				this.svgRenderer.append(this.gYaxisEle, this.svgObject);
				this.svgRenderer.append(this.gXaxisEle, this.svgObject);
			}

			this.gXaxisTickEle = this.svgRenderer.createGroup({ 'id': this.svgObject.id + '_XAxisTick' });

			this.gYaxisTickEle = this.svgRenderer.createGroup({ 'id': this.svgObject.id + '_YAxisTick' });
        }      

        bbdesigner$.extend(BoldBIDashboard.EjAxisRenderer.prototype, this);
        this.chartaxis = new BoldBIDashboard.EjAxisRenderer(this);
        var chartaxis = this.chartaxis;
       
        if (isStriplineOver && this.model.AreaType == "cartesianaxes" && !this.model.enable3D) {
            this.gStriplineOver = this.svgRenderer.createGroup({ 'id': this.svgObject.id + '_StriplineOver', 'clip-path': 'url(#' + this.svgObject.id + '_ChartAreaClipRect)' });
            this._renderStripline('over');
        }

        if(!this.model.enable3D)
        //draw axes, labels and ticks
        for (var l = 0, len = this.model._axes.length; l < len; l++) {
            var axis = this.model._axes[l], lineOption = params.axes[axis.name]._lineOption;
			var horizontalLineOption = params.axes[axis.name]._lineOption ? params.axes[axis.name]._lineOption[1] : null;
			var verticalLineOptions = lineOption ? lineOption[1] : null;
            if (this.model.AreaType.toLowerCase() == "cartesianaxes") {                
                chartaxis._drawAxes(l, axis, params);
                if (lineOption && lineOption[0])
                    this.svgRenderer.drawLine(lineOption[0], lineOption[1]);
                if (axis.orientation.toLowerCase() === "horizontal")
                    chartaxis._drawXAxisTickLine(l, axis, this.model.enableCanvasRendering ? null : horizontalLineOption);
                else
					chartaxis._drawYAxisTickLine(l, axis, this.model.enableCanvasRendering ? null : verticalLineOptions);
                axis._crossValue = null;
            }
        }
         if (!this.resetZooming && (this.model._chartAreaZoom || this.panning))
             this._enableZoomingButtons();
         this.resetZooming = false;

         if (this.svgHeight != this.model.svgHeight || this.svgWidth != this.model.svgWidth) {
                      
             this.prevHeight = this.model.svgHeight;
             this.prevWidth = this.model.svgWidth; 
             // afterResize event 
             var commonEventArgs = bbdesigner$.extend({}, BoldBIDashboard.EjSvgRender.commonChartEventArgs);
             commonEventArgs.data = { height: this.prevHeight, width: this.prevWidth, prevHeight: prevHeight, prevWidth: prevWidth, originalHeight: this.svgHeight, originalWidth: this.svgWidth };
             this._trigger("afterResize", commonEventArgs);
         }

         //Checking Selection setting enable 
         var seriesCollection = this.model._visibleSeries, selectionFound;
         selectionFound = bbdesigner$.grep(seriesCollection, function (series) { return series.selectionSettings.enable == true; });
         if (selectionFound.length == 0) {
             this.model.selectedDataPointIndexes = [];
             this.model.selectionEnable = false;
             this._removeSelection();
         } else
             this.model.selectionEnable = true;

         var selectedData = this.model.selectedDataPointIndexes;
         //Maintaning the selection state and triggering seleceted data
         if (selectedData) {
             this._removeSelection();
             this.model._isStateChaged = true;
             var data,
             length = selectedData.length;                      
             for (var i = 0; i < length; i++) {
                 data = selectedData[i];                 
                 series = this.model._visibleSeries[data.seriesIndex];
                 series.selectionSettings._currentType = series.selectionSettings.type;
                 this.segmentSelection(data.event, data.legendData, data.seriesIndex, data.pointIndex, data.data);
             }
         }

        var commonLoadedEventArgs = bbdesigner$.extend({}, BoldBIDashboard.EjSvgRender.commonChartEventArgs);
        commonLoadedEventArgs.data = { model: this.model };
        this._trigger("loaded", commonLoadedEventArgs);
		for (var i = 0; i < this.model._axes.length; i++) {
            var axis = bbdesigner$.extend(true, {}, this.model._axes[i]);
                this.model._axes[i].range = axis._initialRange;
        }

    },
	
	// set value to private variable for two way binding
	_setZoomProperties: function () {

         var axis, _zf, _zp, orientation;
	    for (var l = 0; l < this.model._axes.length; l++) {
	        axis = this.model._axes[l];
	        orientation = axis.orientation.toLowerCase();
	        _zf = axis.zoomFactor.toFixed(3);
	        _zp = axis.zoomPosition.toFixed(3);
	        if (orientation == "horizontal" && (_zf != this._xZoomFactor() || _zp != this._xZoomPosition())) {
	            this._xZoomFactor(axis.zoomFactor.toFixed(3));
	            this._xZoomPosition(axis.zoomPosition.toFixed(3));
	        }
	        if (orientation == "vertical" && (_zf != this._yZoomFactor() || _zp != this._yZoomPosition())) {
	            this._yZoomFactor(axis.zoomFactor.toFixed(3));
	            this._yZoomPosition(axis.zoomPosition.toFixed(3));
	        }
	    }			
	},

	  annotationRender: function (currentAnnotation, a) {                           // method to render annotation
            //declaration and initialization
            var chartContainer = this._id;
            var flag = false;
            var currentSeries = this.model.series[0];
            var seriesType = currentSeries.type.toLowerCase();
            var areaBoundsX = this.model.m_AreaBounds.X;
            var areaBoundsY = this.model.m_AreaBounds.Y;
            var areaBoundsWidth = this.model.m_AreaBounds.Width;
            var areaBoundsHeight = this.model.m_AreaBounds.Height;
            var marginLeft = this.model.margin.left;
            var marginTop = this.model.margin.top;
          
            var seriesIndex = bbdesigner$.inArray(currentSeries, this.model._visibleSeries);
            var radius = this.model.circularRadius[seriesIndex];
			  var centerX = this.model.circleCenterX[seriesIndex];
            var centerY = this.model.circleCenterY[seriesIndex];
			var currentDocument = bbdesigner$(document);

            currentAnnotation = bbdesigner$.extend(true, {}, this.model.annotationsDefault, currentAnnotation);   // extending defaults

            // creating annotation group
            if (bbdesigner$('#annotation_group_' + chartContainer).length != 0)
                var annotationContainer = bbdesigner$('#annotation_group_' + chartContainer);
            else
                annotationContainer = bbdesigner$("<div></div>").attr('id', "annotation_group_" + chartContainer);
            annotationContainer.css({ "position": "absolute", "left": "0px", "top": "0px" });

            var content = currentAnnotation.content;
            element = bbdesigner$("#" + content);
            if (element.get(0).tagName == "SCRIPT")                // for jsrender
                var element = bbdesigner$(bbdesigner$("#" + content)[0].innerHTML);
            var cloneNode = element.clone();                        // clone
            var id = 'annotation_' + chartContainer + "_" + content + "_" + a;
            bbdesigner$(cloneNode).attr("id", id);
            var bbdesigner$cloneNode = bbdesigner$(cloneNode);
            bbdesigner$cloneNode.css({
                'position': "absolute",
                'z-index': 2000
            });

            // initialization
            var region = currentAnnotation.region.toLowerCase();
            var coordinateUnit = currentAnnotation.coordinateUnit.toLowerCase();
            var annotationX = (typeof currentAnnotation.x=="string"||typeof currentAnnotation.x=="object") ? Date.parse(currentAnnotation.x) : currentAnnotation.x;
            var annotationY = currentAnnotation.y;
            var horizontalAlignment = currentAnnotation.horizontalAlignment.toLowerCase();
            var verticalAlignment = currentAnnotation.verticalAlignment.toLowerCase();

            if (coordinateUnit == "pixels") {                          //pixels
                if (region == "series") {                             // chart area / series
                    if ((areaBoundsWidth + areaBoundsX + marginLeft > annotationX + areaBoundsX) &&
                        areaBoundsHeight + areaBoundsY + marginTop > annotationY + areaBoundsY) {
                        var left = annotationX + areaBoundsX;
                        var top = annotationY + areaBoundsY;
                    }
                }
                else if (region == "chart") {                         // chart
                    if ((bbdesigner$(this.svgObject).width() > annotationX) &&
                         bbdesigner$(this.svgObject).height() > annotationY) {
                        left = annotationX;
                        top = annotationY;
                    }
                }

                bbdesigner$cloneNode.css({
                    "left": left,
                    "top": top
                });
                flag = true;                                // to denote that the annotation should be appended in DOM
            } else if (coordinateUnit == "points") {        //points
                point = {
                    'x': annotationX,
                    'y': annotationY
                };

                if (this.model.AreaType == "polaraxes") {   // polar
                    xAxis = this.model._axes[0];
                    yAxis = this.model._axes[1];
                    if ((annotationX >= xAxis.visibleRange.min && annotationX <= xAxis.visibleRange.max)
                        && (annotationY >= yAxis.visibleRange.min && annotationY <= yAxis.visibleRange.max)) {
                        var location = this.TransformToVisibleAnnotation(xAxis, yAxis, annotationX, annotationY, this);
                        bbdesigner$cloneNode.css({
                            "left": location.X,
                            "top": location.Y
                        });
                        flag = true;
                    }
                } else if (seriesType == "pyramid" || seriesType == "funnel") { // pyramid and funnel
                    var currentPoint = currentSeries.points[annotationX];
                    bbdesigner$cloneNode.css({
                        "left": currentPoint.xLocation + this.pyrX,
                        "top": currentPoint.yLocation + this.pyrY
                    });
                    flag = true;
                } else if (seriesType == "pie" || seriesType == "doughnut") { // pie and doughnut
                    currentPoint = currentSeries._visiblePoints[annotationX];
                    var pointIndex = annotationX;
                    var startX, startY;
                    var series = new BoldBIDashboard.seriesTypes[seriesType]();
                    var midAngle = currentPoint ? currentPoint.currentMidAngle : 0;
                    if ((pointIndex == currentSeries.explodeIndex || currentSeries.explodeAll) && !chartObj.vmlRendering) {
                        startX = centerX + Math.cos(midAngle) * currentSeries.explodeOffset;
                        startY = centerY + Math.sin(midAngle) * currentSeries.explodeOffset;
                    } else {
                        startX = centerX;
                        startY = centerY;
                    }
                    var midX = series.getXCordinate(startX, (radius), midAngle);
                    var midY = series.getYCordinate(startY, (radius), midAngle);

                    positionX = (midX + startX) / 2;
                    positionY = (midY + startY) / 2;

                    positionX = (midX + positionX) / 2;
                    positionY = (midY + positionY) / 2;

                    bbdesigner$cloneNode.css({
                        "left": positionX,
                        "top": positionY
                    });
                    flag = true;
                } else {                                               // cartesianaxes
                    var xAxisName = currentAnnotation.xAxisName;
                    var yAxisName = currentAnnotation.yAxisName;
                    var axesLength = this.model._axes.length;
                    for (var i = 0; i < axesLength; i++) {
                        if (this.model._axes[i].name == xAxisName)
                            var xAxis = this.model._axes[i];
                        if (this.model._axes[i].name == yAxisName)
                            var yAxis = this.model._axes[i];
                    }
                    if (!xAxis) xAxis = this.model._axes[0];           // setting primary axis by default
                    if (!yAxis) yAxis = this.model._axes[1];

                        if (!this.model.requireInvertedAxes) {
						    location = this._getAnnotationPoint(point, xAxis, yAxis);
                            bbdesigner$cloneNode.css({
                                "left": location.X + areaBoundsX,
                                "top": location.Y + yAxis.y
                            });
                        }
                        else {
                            point.x = point.y + (point.y = point.x, 0);// swapping x, y => a = b + (b=a, 0)
                            location = this._getAnnotationPoint(point, yAxis, xAxis);
                            bbdesigner$cloneNode.css({
                                 "left": location.X + areaBoundsX,
                                 "top": location.Y + xAxis.y
                            });
						}
                        flag = true;
                }
            } else {                                                                      //other alignment
                bbdesigner$cloneNode.css("display", "block").appendTo(bbdesigner$(annotationContainer));       //append
                bbdesigner$(annotationContainer).appendTo('#' + 'chartContainer_' + chartContainer);
                width = bbdesigner$cloneNode.outerWidth();
                height = bbdesigner$cloneNode.outerHeight();
                if (region == "chart") {
                    switch (horizontalAlignment) {
                        case "middle":
                            left = bbdesigner$(this.svgObject).width() / 2 - width / 2;
                            break;
                        case "left":
                            left = 0;
                            break;
                        case "right":
                            left = bbdesigner$(this.svgObject).width() - width;
                    }
                    switch (verticalAlignment) {
                        case "middle":
                            top = bbdesigner$(this.svgObject).height() / 2 - height / 2;
                            break;
                        case "top":
                            top = 0;
                            break;
                        case "bottom":
                            top = bbdesigner$(this.svgObject).height() - height;
                    }
                } else {
                    if (seriesType == "pie" || seriesType == "doughnut") {             // for pie and doughnut
                        left = centerX;
                        top = centerY;
                        switch (horizontalAlignment) {
                            case "middle":
                                left = centerX - width / 2;
                                break;
                            case "left":
                                left = centerX - radius;
                                break;
                            case "right":
                                left = centerX + radius - width;
                        }

                        switch (verticalAlignment) {
                            case "middle":
                                top = centerY - height / 2;
                                break;
                            case "top":
                                top = centerY - radius;
                                break;
                            case "bottom":
                                top = centerY + radius;
                        }
                    } else {
                        switch (horizontalAlignment) {
                            case "middle":
                                left = areaBoundsX + (areaBoundsWidth / 2) - width / 2;
                                break;
                            case "left":
                                left = areaBoundsX;
                                break;
                            case "right":
                                left = areaBoundsX + areaBoundsWidth - width;
                        }

                        switch (verticalAlignment) {
                            case "middle":
                                top = areaBoundsY + (areaBoundsHeight / 2) - height / 2;
                                break;
                            case "top":
                                top = areaBoundsY;
                                break;
                            case "bottom":
                                top = areaBoundsY + areaBoundsHeight - height;
                        }
                    }
                }
                if (seriesType == "pyramid" || seriesType == "funnel") {         // to remove margin value
                    left -= marginLeft;
                }
                bbdesigner$cloneNode.css({
                    "left": left,
                    "top": top
                });
            }

            left = parseFloat(bbdesigner$cloneNode.css("left"));
            top = parseFloat(bbdesigner$cloneNode.css("top"));                              // get left and top value
            if (coordinateUnit != "none" && flag) {
                bbdesigner$cloneNode.css("display", "block").appendTo(bbdesigner$(annotationContainer));   //append
                bbdesigner$(annotationContainer).appendTo('#' + 'chartContainer_' + chartContainer);
				width = bbdesigner$cloneNode.outerWidth();
                height = bbdesigner$cloneNode.outerHeight();
                switch (horizontalAlignment) {
                    case "middle":
                        left -= width / 2;
                        break;
                    case "left":
                        left -= width;
                        break;
                }
                switch (verticalAlignment) {
                    case "middle":
                        top -= height / 2;
                        break;
                    case "top":
                        top -= height;
                        break;
                }
            }
            var margin = currentAnnotation.margin;                      // margin values
            left = left + margin.left - margin.right;
            top = top + margin.top - margin.bottom;

            commonEventArgs = bbdesigner$.extend({}, BoldBIDashboard.EjSvgRender.commonChartEventArgs);          // trigger event
            commonEventArgs.data = {
                content: bbdesigner$cloneNode.html(), location: { x: left, y: top },
                opacity: currentAnnotation.opacity, angle: currentAnnotation.angle
            };
            this._trigger("annotationRendering", commonEventArgs);

            bbdesigner$cloneNode.html(commonEventArgs.data.content);
            bbdesigner$cloneNode.css({
                "left": commonEventArgs.data.location.x,
                "top": commonEventArgs.data.location.y,
                "opacity": commonEventArgs.data.opacity                  //opacity
            });

            var angle = commonEventArgs.data.angle;                     // angle
            if (angle) {
                bbdesigner$cloneNode.css({
                    '-ms-transform': 'rotate(' + angle + 'deg)',        //IE 10 and 9
                    '-webkit-transform': 'rotate(' + angle + 'deg)',    // chrome
                    '-moz-transform': 'rotate(' + angle + 'deg)',       // firefox
                    '-o-transform': 'rotate(' + angle + 'deg)',         // opera
                    '-transform': 'rotate(' + angle + 'deg)'            // general
                });
            }

            var eleId = bbdesigner$cloneNode.attr("id");                          // id of annotation
            var topHeight = bottomHeight = leftWidth = rightWidth = 0;
            var chartWidth = bbdesigner$("#" + this._id).width();
            var chartHeight = bbdesigner$("#" + this._id).height();
            if (flag && (angle == 0) && (region == "series" || coordinateUnit == "points")) {
                if (areaBoundsWidth + areaBoundsX < left + width) {                       // clip right width
                    var excessWidth = (left + width) - (areaBoundsWidth + areaBoundsX);
                    rightWidth = width - excessWidth;
                }
                if (left < areaBoundsX) {                                                  // clip left width
                    leftWidth = areaBoundsX - left;
                }
                if (areaBoundsHeight + areaBoundsY < top + height) {                      // clip bottom height
                    excessHeight = (top + height) - (areaBoundsHeight + areaBoundsY);
                    bottomHeight = height - excessHeight;
                }
                if (top < areaBoundsY) {                                                 // clip top height
                    topHeight = areaBoundsY - top;
                }
                rightWidth = (rightWidth == 0) ? width : rightWidth;
                bottomHeight = (bottomHeight == 0) ? height : bottomHeight;
                document.getElementById(eleId).style.clip = "rect(" + topHeight.toString() + "px," +  // clipping annotation
                     rightWidth.toString() + "px," +
                     bottomHeight.toString() + "px," +
                     leftWidth + "px)";
            }
            else if (flag && (angle == 0) && region == "chart") {
                if (chartWidth < left + width) {                              // clip right width
                    excessWidth = (left + width) - chartWidth;
                    var rightWidth = width - excessWidth;
                }
                if (left < 0) {                                              // clip left width
                    var leftWidth = width + left;
                    leftWidth = (leftWidth == 0) ? width : leftWidth;
                }
                if (chartHeight < top + height) {                            // clip bottom height
                    var excessHeight = (top + height) - chartHeight;
                    var bottomHeight = height - excessHeight;
                }
                if (top < 0) {                                               // clip top height
                    topHeight = height + top;
                    topHeight = (topHeight == 0) ? height : topHeight;
                }
                rightWidth = (rightWidth == 0) ? width : rightWidth;
                bottomHeight = (bottomHeight == 0) ? height : bottomHeight;
                document.getElementById(eleId).style.clip = "rect(" +
                    topHeight.toString() + "px," +
                    rightWidth.toString() + "px," +
                    bottomHeight.toString() + "px," +
                    leftWidth + "px)";
            }
			else if (flag && (angle == 90) && (region == "series" || coordinateUnit == "points")) {
               
                var clientRect = document.getElementById(eleId).getBoundingClientRect();
                left = clientRect.left - bbdesigner$(this.svgObject).offset().left + currentDocument.scrollLeft();
                top = clientRect.top - bbdesigner$(this.svgObject).offset().top + currentDocument.scrollTop();
                
                if (areaBoundsHeight + areaBoundsY < top + width) {                      // clip right width
                    excessWidth = (top + width) - (areaBoundsHeight + areaBoundsY);
                    rightWidth = width - excessWidth;
                }

                if (left < areaBoundsX) {                                                  // clip bottom height

                    excessHeight = areaBoundsX - left;
                    bottomHeight = height - excessHeight;
                }

                if (top < areaBoundsY) {                                                 // clip left width
                    leftWidth = areaBoundsY - top;
                }

                if (areaBoundsWidth + areaBoundsX < left + height) {                       // clip top height
                    excessHeight = (left + height) - (areaBoundsWidth + areaBoundsX);
                    topHeight = excessHeight;
                }

                rightWidth = (rightWidth == 0) ? width : rightWidth;
                bottomHeight = (bottomHeight == 0) ? height : bottomHeight;
               
                document.getElementById(eleId).style.clip = "rect(" + topHeight.toString() + "px," +         // clipping annotation
                     rightWidth.toString() + "px," +
                     bottomHeight.toString() + "px," +
                     leftWidth + "px)";
            }
            else if (flag && (angle == 90) && region == "chart") {
                var clientRect = document.getElementById(eleId).getBoundingClientRect();
                left = clientRect.left - bbdesigner$(this.svgObject).offset().left ;
                top = clientRect.top - bbdesigner$(this.svgObject).offset().top ;

                if (chartHeight < top + width) {                              // clip right width
                    excessWidth = (top + width) - chartHeight;
                    rightWidth = width - excessWidth;
                }
                if (left < 0) {                                              // clip bottom height
                    excessHeight = 0 - left;
                    bottomHeight = height - excessHeight;
                    bottomHeight = (bottomHeight == 0) ? height : bottomHeight;
                }
                if (top < 0) {                                               // clip left width
                    leftWidth = 0 - top;
                    leftWidth = (leftWidth == 0) ? width : leftWidth ;
                }
                if (chartWidth < left + height) {                            // clip top height
                    excessHeight = (left + height) - chartWidth;
                    topHeight = excessHeight;
                }
               
                rightWidth = (rightWidth == 0) ? width : rightWidth;
                bottomHeight = (bottomHeight == 0) ? height : bottomHeight;
                document.getElementById(eleId).style.clip = "rect(" +
                    topHeight.toString() + "px," +
                    rightWidth.toString() + "px," +
                    bottomHeight.toString() + "px," +
                    leftWidth + "px)";
            }
        },                                                                 // ---------------------------- end of annotation 

        TransformToVisibleAnnotation: function (xAxis, yAxis, x, y, sender) {       // method to get the position of points in polar/ radar
            x = (xAxis._valueType == "logarithmic") && x > 0 ? Math.log(x, xAxis.logBase) : x;
            y = (xAxis._valueType == "logarithmic") && y > 0 ? Math.log(y, yAxis.logBase) : y;
            var radius = sender.model.Radius * BoldBIDashboard.EjSvgRender.utils._valueToCoefficient(yAxis, y, this);
            var point = BoldBIDashboard.EjSvgRender.utils._valueToVector(xAxis, x);
            return { X: sender.model.centerX + radius * point.X, Y: sender.model.centerY + radius * point.Y };
        },

        _getAnnotationPoint: function (point, xAxis, yAxis) {                     // method to get the position of points (cartesianaxes)
            var requireInvertedAxes = this.model.requireInvertedAxes;
			 var x = point.x;
            var y = point.y;

            var xvalue = (xAxis._valueType == "logarithmic") ? BoldBIDashboard.EjSvgRender.utils._logBase((x == 0 ? 1 : x), xAxis.logBase) : x;
            var yvalue = (yAxis._valueType == "logarithmic") ? BoldBIDashboard.EjSvgRender.utils._logBase((y == 0 ? 1 : y), xAxis.logBase) : y;
            xvalue = BoldBIDashboard.EjSvgRender.utils._getPointXY(xvalue, xAxis.visibleRange, xAxis.isInversed) * (xAxis.width);
            yvalue = (1 - BoldBIDashboard.EjSvgRender.utils._getPointXY(yvalue, yAxis.visibleRange, yAxis.isInversed)) * (yAxis.height);

            point.location = { X: xvalue, Y: yvalue };
            return point.location;
        },
		
     indicatorRender: function() {
         if (bbdesigner$(this.svgObject).find("#" + this.svgObject.id + "_IndicatorCollection").length > 0) {
             bbdesigner$(this.svgObject).find("#" + this.svgObject.id + "_IndicatorCollection").remove();
         }

         var indOptions = { 'id': this.svgObject.id + '_IndicatorCollection', 'clip-path': 'url(#' + this.svgObject.id + '_ChartAreaClipRect)' };

         this.gIndicatorEle = this.svgRenderer.createGroup(indOptions);

         for (var i = 0; i < this.model.indicators.length && this.model.indicators[i].visible && this.model.indicators[i]._points.length>0; i++) {
             var indicator = this.model.indicators[i];
             var options;
             for (var j = 0; j < this.model._axes.length; j++) {
                 var axis = this.model._axes[j];

                 if (axis.name && axis.orientation.toLowerCase() == 'horizontal' && axis.name.toLowerCase() == indicator.xAxisName.toLowerCase()) {
                     indicator.xAxis = axis;
                 } else if (axis.name && axis.orientation.toLowerCase() == 'vertical' && axis.name.toLowerCase() == indicator.yAxisName.toLowerCase()) {
                     indicator.yAxis = axis;
                 }
             }
             var type = indicator.type.toLowerCase();
             options = new BoldBIDashboard.indicatorTypes[type]();
             //Clip the canvas Chart indicator series out of chartArea Bounds
             if (this.model.enableCanvasRendering) {
                 this.svgRenderer.ctx.save();
                 this.svgRenderer.ctx.beginPath();
                 this.svgRenderer.ctx.rect(this.model.m_AreaBounds.X, indicator.yAxis.y, indicator.xAxis.width, indicator.yAxis.height);
                 this.svgRenderer.ctx.clip();
                 options.draw(indicator, this);
                 this.svgRenderer.ctx.restore();
             } else
                 options.draw(indicator, this);
             var element = options.gIndicatorGroupEle;
             if (element) BoldBIDashboard.EjSvgRender.utils._drawAxesBoundsClipPath(element, indicator, this);

             if (!this.vmlRendering && !this.model.enableCanvasRendering) {
                 if (indicator.enableAnimation && (!indicator._animatedSeries || indicator.type != indicator._previousType)) {
                     this.svgRenderer.append(this.gIndicatorEle, this.svgObject);
                     var clipRect = bbdesigner$(this.gIndicatorEle).find("#" + this.svgObject.id + '_indicatorGroup' + '_' + i + "_ClipRect").children();					 
					 BoldBIDashboard.EjSeriesRender.prototype._doLineAnimation(this, clipRect);    // for indicator animation
                     this.model.AnimationComplete = true;
                     indicator._animatedSeries = true;
                     indicator._previousType = indicator.type;

                 }
             }
	   	  this.svgRenderer.append(this.gIndicatorEle, this.svgObject); 
         }
		 
     },
	 
	 doAnimation: function (series) {
	   // Declaration
	   var chartObj = this,	 
	       model = chartObj.model,
	       requireInvertedAxes = model.requireInvertedAxes,
		   type = series.type.toLowerCase(),
	       seriesIndex = bbdesigner$.inArray(series, model._visibleSeries),
	       gSeriesGroupId = this.svgObject.id + "_SeriesGroup_" + seriesIndex,
		   markerElements = bbdesigner$(chartObj.gSymbolGroupEle)[seriesIndex].childNodes,
		   markerLength = markerElements.length,
		   dataLabels = bbdesigner$(chartObj.gDataLabelEle)[seriesIndex].childNodes,
		   dataLabelLength = dataLabels.length,
		   connectorLines = bbdesigner$(chartObj.gConnectorEle)[seriesIndex].childNodes,
		   connectorLineLength = connectorLines.length,
		   errorBarElements = bbdesigner$(chartObj.gErrorBarGroupEle)[seriesIndex] == undefined ? 
		                      undefined :bbdesigner$(chartObj.gErrorBarGroupEle)[seriesIndex].childNodes,
		   errorBarEleLength = BoldBIDashboard.util.isNullOrUndefined(errorBarElements) ? 0 : errorBarElements.length,
		   animationType = series.animationType, clipRect, errorBarInterval,
		   markerInterval, dataLabelInterval, index, elements, elementsLength, clipRect,
           ubound = 20, lbound = 0, randomValue, delayInterval, marker, i, j,
		   seriesRender = BoldBIDashboard.EjSeriesRender.prototype;
		   chartObj.gSeriesGroupEle = bbdesigner$("#" + gSeriesGroupId)[0];
		   
		   switch (animationType){
			  case "rect":
			        elements = bbdesigner$(this.gSeriesEle).find("#" + gSeriesGroupId).children("rect");
		            elementsLength = elements.length;
                    for (i = 0; i < elementsLength; i++) {
			          if (type.indexOf("stacking") > -1) 
                         seriesRender.animateStackingRect(elements[i], series, requireInvertedAxes, chartObj);
			          else
				         seriesRender.animateRect(elements[i], series, requireInvertedAxes, chartObj);
		             }
                    markerInterval = dataLabelInterval = errorBarInterval = 500;
					break;					
              case "path":
			         clipRect = bbdesigner$(chartObj.gSeriesEle).find("#" + gSeriesGroupId + "_ClipRect").children();
                     seriesRender._doLineAnimation(chartObj, clipRect);
                     markerInterval = 2000 / markerLength;
		             dataLabelInterval = 2000 / dataLabelLength;
		             errorBarInterval = 2000 / errorBarEleLength;
					 break;					 
              case "scatter":
			         for (i = 0; i < markerLength; i++) {
                        randomValue = Math.floor(Math.random() * (ubound - lbound) + lbound);
                        delayInterval = parseInt(randomValue * 50);
                        seriesRender.animateSymbol(markerElements[i], delayInterval, series, requireInvertedAxes, chartObj);  
	                 } 
					 break;				 
              case "bubble":
			          elements = bbdesigner$(this.gSeriesGroupEle).children().not("defs");
                      randomValue = Math.floor(Math.random() * (ubound - lbound) + lbound);
                      delayInterval = parseInt(randomValue * 50);
                      for (i = 0; i < elements.length; i++) 
                           seriesRender.animateSymbol(elements[i], delayInterval, series, requireInvertedAxes, chartObj);
		              for (i = 0; i < markerLength; i++) 
                           seriesRender.animateSymbol(markerElements[i], delayInterval, series, requireInvertedAxes, chartObj);   
		              for (i = 0; i < dataLabelLength; i++) 
                           seriesRender.animateSymbol(dataLabels[i], delayInterval, series, requireInvertedAxes, chartObj);
		              for (i = 0; i < connectorLineLength; i++)
                           seriesRender.animateSymbol(connectorLines[i], delayInterval, series, requireInvertedAxes, chartObj);
					   break;           
			   case "hilo":		
			          elements = bbdesigner$(this.gSeriesGroupEle).children().not("defs");
		              elementsLength = elements.length;
                      time = 2000 / elementsLength;
                      for (var i = 0; i < elementsLength; i++)
                      seriesRender._doLineSymbol(elements[i], time, i, series, requireInvertedAxes, chartObj);
		              dataLabelInterval = 2000/ dataLabelLength;
                      break;					  
		   }
	  
	      if (animationType != "bubble") {
	        for (j = 0; j < markerLength; j++) {              // for marker
	           index = animationType == "rect" || animationType == "stackingRect" ? 2 : j;
               seriesRender._doLineSymbol(markerElements[j], markerInterval, index, series, requireInvertedAxes, chartObj);
	         }
		
	        for (j = 0; j< dataLabelLength; j++) {            // for data label
		       index = animationType == "rect" || animationType == "stackingRect"  ? 2 : j;
		       seriesRender._doLineSymbol(dataLabels[j], dataLabelInterval, index, series, requireInvertedAxes, chartObj);
		     }
		
	        time = 2000/ connectorLineLength;
		    for (j = 0; j< connectorLineLength; j++) {        // for connector lines
		       index = animationType == "rect" || animationType == "stackingRect"  ? 2 : j;
		       seriesRender._doLineSymbol(connectorLines[j], time, index, series, requireInvertedAxes, chartObj);
		     }
	      }
		
		  if (series.errorBar.visibility == "visible"){     
		     for (j = 0; j< errorBarEleLength; j++) {      // for error bar
		       index = animationType == "rect" || animationType == "stackingRect"  ? 2 : j;
		       seriesRender._doLineSymbol(errorBarElements[j], errorBarInterval, index, series, requireInvertedAxes, chartObj);
		     }	
		  }
   },
   _animationElements: function (seriesOptions, seriesType, seriesIndex) {
            var chartObj = this;
            seriesOptions._previousType = BoldBIDashboard.util.isNullOrUndefined(seriesOptions._previousType) ? seriesOptions.type : seriesOptions._previousType;
            if (seriesOptions.enableAnimation && !this.vmlRendering && !this.model.enableCanvasRendering && (!seriesOptions._animatedSeries || seriesOptions.type != seriesOptions._previousType)) {
                BoldBIDashboard.EjSeriesRender.prototype.doCircularAnimation(this, seriesOptions, seriesType, seriesIndex);
                seriesOptions._animatedSeries = true;
            }
            this.drawAccDisplayText(seriesType, seriesOptions, seriesIndex);
            //Show the datalabel text element on redraw when enable animation of series
            if (seriesOptions.enableAnimation && seriesOptions._visiblePoints.length > 0 && seriesOptions.AnimationComplete && !this.vmlRendering && !this.model.enableCanvasRendering) {
                chartObj.svgRenderer._setAttr(bbdesigner$(chartObj.gSeriesEle).find("#" + chartObj.gSeriesTextEle[seriesIndex].id), { "visibility": "visible" });
                if (chartObj.gSymbolGroupEle)
                    chartObj.svgRenderer._setAttr(bbdesigner$(chartObj.gSeriesEle).find("#" + chartObj.gSymbolGroupEle[seriesIndex].id), { "visibility": "visible" });
                var elements;
                if (seriesOptions.marker.dataLabel.template) {
                    elements = bbdesigner$(chartObj.element[0].childNodes[0].childNodes);
                    for (var i = 0; i < elements.length; i++)
                        bbdesigner$(elements[i]).css('display', 'block');
                }
                if (chartObj.gConnectorEle)
                    chartObj.svgRenderer._setAttr(bbdesigner$(chartObj.gSeriesEle).find("#" + chartObj.gConnectorEle[seriesIndex].id), { "visibility": "visible" });
                if (chartObj.gDataLabelEle)
                    chartObj.svgRenderer._setAttr(bbdesigner$(chartObj.gSeriesEle).find("#" + chartObj.gDataLabelEle[seriesIndex].id), { "visibility": "visible" });
            }



        },
		  _appendConnectorElements: function (i) {
            var visibleSeries = BoldBIDashboard.DataManager(this.model._visibleSeries, BoldBIDashboard.Query().sortBy("_zOrder")).executeLocal();
            var currentSeries = visibleSeries[i];
            var type = currentSeries.type.toLowerCase();
			var currentDataLabel = currentSeries.marker.dataLabel;
            if (currentSeries.visibility == "visible" && !this.model.enable3D && currentDataLabel.visible && currentDataLabel.responsiveVisibility && (currentSeries.connectorLines || this.model.AreaType == "none")) {
                this.svgRenderer.append(this.gConnectorEle[i], this.gSeriesEle);
                currentSeries.connectorLines = false;
            }
        },
        _appendDataLabelElement: function (i) {
            var currentSeries, type, index;
            currentSeries = this.model._visibleSeries[i];
            index = !BoldBIDashboard.util.isNullOrUndefined(currentSeries.zOrder) ? currentSeries.zOrder : index;
            if (currentSeries.visibility == "visible" && !this.model.enable3D) {
                if (currentSeries.marker.responsiveVisibility)
                   this.svgRenderer.append(this.gSymbolGroupEle[i], this.gSeriesEle);
                if (!this.model.enableCanvasRendering && currentSeries.marker.dataLabel.responsiveVisibility) {
                    if (this.gDataLabelEle[i].childNodes.length > 0)
                        this.svgRenderer.append(this.gDataLabelEle[i], this.gSeriesEle);
                    if (this.gSeriesTextEle[i].childNodes.length > 0)
                        this.svgRenderer.append(this.gSeriesTextEle[i], this.gSeriesEle);
                }
            }

        },
        _accSeriesDraw: function (index, seriesOptions, type) {
            var chartObj = this;
            var visibleSeries = BoldBIDashboard.DataManager(this.model._visibleSeries, BoldBIDashboard.Query().sortBy("_zOrder")).executeLocal();
            var seriesIndex = bbdesigner$.inArray(visibleSeries[index], this.model._visibleSeries);
            this.model._visibleSeries[seriesIndex] = visibleSeries[index] = bbdesigner$.extend(true, seriesOptions, visibleSeries[index]);
            var commonEventArgs = bbdesigner$.extend({}, BoldBIDashboard.EjSvgRender.commonChartEventArgs);
            commonEventArgs.data = { series: seriesOptions };
            this._trigger("seriesRendering", commonEventArgs);
            var seriesType = new BoldBIDashboard.seriesTypes[type.toLowerCase()]();
            var minhightwidth = seriesType.draw(chartObj, seriesOptions);
            if (!minhightwidth) {
			this.model.minhightwidth = true;
                chartObj._animationElements(seriesOptions, seriesType, seriesIndex);
            }


        },
    seriesRender: function (params) {
	        this.model.allPoints = [];
           this.model.markerRegion = [];
           this.model.circleCenterX = [];
            this.model.circleCenterY = [];
           this.model.startX = [];
           this.model.startY = [];
           this.model.centerCount = 0;
		    this.gTrendlinesGroupEle = null;
			this.model._seriesIndex = null;
		   if(!params){
				params ={ _crossAxisOverlap : false, axes:{}};
				for(var i=0; i<this.model._axes.length; i++)
					params.axes[this.model._axes[i].name] = {};
		   }
        var chartObj = this;
        if (bbdesigner$(this.svgObject).find("#" + this.svgObject.id + "_SeriesCollection").length > 0) {
            bbdesigner$(this.svgObject).find("#" + this.svgObject.id + "_SeriesCollection").remove();
        }
        var serOptions = { 'id': this.svgObject.id + '_SeriesCollection', 'clip-path': 'url(#' + this.svgObject.id + '_ChartAreaClipRect)' };
        var enable3D = this.model.enable3D;
        var areaType = this.model.AreaType;
        var enableCanvasRendering = this.model.enableCanvasRendering;
		 var axesLength = this.model._axes.length;
        this.gSeriesEle = this.svgRenderer.createGroup(serOptions);
        var visibleSeries = BoldBIDashboard.DataManager(this.model._visibleSeries, BoldBIDashboard.Query().sortBy("_zOrder")).executeLocal();
		 var visibleSeriesLength=visibleSeries.length;
        for (var i = 0; i < visibleSeriesLength; i++) {
            if (visibleSeries[i].visibility == "visible") {
			    if(BoldBIDashboard.util.isNullOrUndefined(this.model.series[i].enableSmartLabels))  // for setting enablesmartlabels property values
                     this.model.series[i]._enableSmartLabels = (this.model.AreaType) == "none" ? true : false;
			     else 
			         this.model.series[i]._enableSmartLabels = this.model.series[i].enableSmartLabels; 
            if (!BoldBIDashboard.util.isNullOrUndefined(visibleSeries[i].xAxis)) {
                visibleSeries[i].xAxis = null;
                visibleSeries[i].yAxis = null;
            }
            for (var j = 0; j < axesLength; j++) {
                var axis = this.model._axes[j];
                var index = i;
				 var axisOrientation = axis.orientation.toLowerCase();
                if (axis.name && axisOrientation == 'horizontal' && axis.name.toLowerCase() == visibleSeries[i]._xAxisName.toLowerCase()) {
                    visibleSeries[i].xAxis = axis;
                }
                else if (axis.name && axisOrientation == 'vertical' && axis.name.toLowerCase() == visibleSeries[i]._yAxisName.toLowerCase()) {
                    visibleSeries[i].yAxis = axis;
                }
                if (this.model.requireInvertedAxes) {
                    if (axis.name && axisOrientation == 'vertical' && axis.name.toLowerCase() == visibleSeries[i]._xAxisName.toLowerCase()) {
                        visibleSeries[i].xAxis = axis;
                    }
                    else if (axis.name && axisOrientation == 'horizontal' && axis.name.toLowerCase() == visibleSeries[i]._yAxisName.toLowerCase()) {
                        visibleSeries[i].yAxis = axis;
                    }
                }

            }
        }
        }
		
        var index, seriesOptions, seriesOptionsVisibility, type, commonEventArgs,
         seriesIndex, seriesType, minhightwidth;
        //pie doughnut rendering from higher order to lower order
        for (var l = visibleSeriesLength; l > 0 && areaType == "none"; l--) {
            index = l - 1;
            seriesOptions = visibleSeries[l - 1];
            seriesOptionsVisibility = seriesOptions.visibility.toLowerCase();
            type = seriesOptions.type.toLowerCase();
            if (seriesOptionsVisibility === 'visible' && !enable3D && (type == "pie" || type == "doughnut")) {
             
                   this._accSeriesDraw(index, seriesOptions, type);   

                
            }
            else {
                if ((areaType == "none") && seriesOptionsVisibility === 'visible' && !enableCanvasRendering)
                    BoldBIDashboard.Ej3DChart.prototype.renderSeries(this, seriesOptions);
            }
        }
        for (var m = 0; m < visibleSeriesLength; m++) {
            var index = m;
            var seriesOptions = visibleSeries[m];
            var  seriesOptionsVisibility=seriesOptions.visibility.toLowerCase();
            var type = seriesOptions.type.toLowerCase();
            if (areaType == "none" &&  seriesOptionsVisibility === 'visible' && !enable3D && (index === 0) && (type == "pyramid" || type == "funnel")) {
                this._accSeriesDraw(index, seriesOptions, type);


            }
            else {			 
                if (seriesOptionsVisibility === 'visible' && !enable3D && areaType != "none") {
                    this.model._seriesIndex = BoldBIDashboard.util.isNullOrUndefined(this.model._seriesIndex) ? 0 : this.model._seriesIndex + 1;
					this.renderSeries(seriesOptions, params);
                    if (areaType == "cartesianaxes")
                        this._renderTrendline(chartObj, seriesOptions);
                }
                else {
                    if (!enable3D && areaType != "none")
                        this.svgRenderer.append(this.svgObject, this.element);
                    else {
                        if ((areaType == "cartesianaxes" ) && seriesOptionsVisibility === 'visible' && !enableCanvasRendering)
                       BoldBIDashboard.Ej3DChart.prototype.renderSeries(this, seriesOptions, params);
					 }
			      }
			  }
        }
		
		if (this.model.AreaType != "none"){
		 // smart labels for cartesian axis
		  var i, currentSeries, currentPoint, points, currentSeriesType, anchor, pointWidth;
		  var areaBounds = this.model.m_AreaBounds;
		  for (i = 0; i < visibleSeriesLength; i++) {
	        currentSeries = this.model.series[i];
			anchor = currentSeries.marker.dataLabel.textAnchor.toLowerCase();
		   if (currentSeries.visibility != "hidden"){
	        points = currentSeries._visiblePoints;
	        if (currentSeries._enableSmartLabels && this.model.AreaType == "cartesianaxes" && !BoldBIDashboard.util.isNullOrUndefined(points)) {
			   currentSeriesType = currentSeries.type.toLowerCase();
			   if (currentSeriesType == "column" || currentSeriesType == "stackingcolumn" ||
                   currentSeriesType == "bar" || currentSeriesType == "stackingbar" || currentSeriesType == "stackingbar100" || currentSeriesType == "stackingcolumn100" || currentSeriesType == "rangecolumn") {
			       this.cartesianColumnSmartLabels(currentSeries, points, i);
			       this.compareColumnDataLabelsRegion();
			   }
			   else {
			       this.cartesianSmartLabels(currentSeries, points, i);
			   }
				    for (var j=0; j< points.length; j++){
					    currentPoint = points[j]; // condition to hide partially visible labels
						pointWidth = (anchor == "middle") ? (currentPoint.width/2) : (anchor == "end" ? 0 : currentPoint.width);
						beforeWidth = (anchor == "middle") ? (currentPoint.width/2) : (anchor == "end" ? currentPoint.width : 2);
					    if ((currentPoint.xPos - beforeWidth < 0) || (currentPoint.xPos + pointWidth > areaBounds.Width)||
						     (currentPoint.yPos + currentPoint.height/2 > areaBounds.Height)||(currentPoint.yPos - currentPoint.height/2 < 0))
							 currentPoint.hide = true;
		            }
			}
		  }
		 }
		
        // to draw connector lines for data label
		  var h, currentPoint, visiblePointsLength;
		  var areaBoundsX = chartObj.model.m_AreaBounds.X;
		  for (i = 0; i < visibleSeriesLength; i++) {
		      currentSeries = visibleSeries[i];
		   if (currentSeries.visibility == "visible" && currentSeries.marker.dataLabel.visible) {
			   visiblePointsLength = currentSeries._visiblePoints.length;
		       for (h = 0; h < visiblePointsLength; h++) {
		           currentPoint = currentSeries._visiblePoints[h];
		           if ((currentPoint.connectorFlag || currentPoint.newConnectorFlag) && !currentPoint.hide && currentPoint.drawText != "" && currentSeries.visibility == "visible" && !BoldBIDashboard.util.isNullOrUndefined(currentPoint.textOptions)) {
		               if (chartObj.model.enableCanvasRendering) {
		                   chartObj.svgRenderer.ctx.save();
                        if (!chartObj.model.requireInvertedAxes)
                            chartObj.svgRenderer.ctx.rect(areaBoundsX, currentSeries.yAxis.y, currentSeries.xAxis.width, currentSeries.yAxis.height);
                        else
                            chartObj.svgRenderer.ctx.rect(areaBoundsX + currentSeries.yAxis.plotOffset, currentSeries.xAxis.y, currentSeries.yAxis.width, currentSeries.xAxis.height);
                        chartObj.svgRenderer.ctx.clip();
                        this.drawConnectorLines(i, h, currentPoint);
                        chartObj.svgRenderer.ctx.restore();
                    } else if (currentSeries._enableSmartLabels)
                        this.drawConnectorLines(i, h, currentPoint);
                }
            }
		  }
        }

        // to draw data label symbol and text
		  var currentPointLabel;
		  var areaBoundsX = chartObj.model.m_AreaBounds.X;
		  for (i = 0; i < visibleSeriesLength; i++) {
		      currentSeries = visibleSeries[i];
		      var type=currentSeries.type.toLowerCase();
		      if (currentSeries.visibility == "visible" && !this.model.enable3D) {
				  visiblePointsLength = currentSeries._visiblePoints.length;
		          for (h = 0; h < visiblePointsLength; h++) {
		              currentPoint = currentSeries._visiblePoints[h];
					  currentPointLabel = currentPoint.marker && currentPoint.marker.dataLabel && currentPoint.marker.dataLabel.visible;
		              if ((currentSeries.marker.dataLabel.visible || currentPointLabel) && !currentPoint.hide && !currentPoint.dataLabeltemplate && currentSeries.visibility == "visible"  && !BoldBIDashboard.util.isNullOrUndefined(currentPoint.textOptions) && !currentPoint.hide) {
						if (!BoldBIDashboard.util.isNullOrUndefined(currentPoint.textOptions.angle))
                        currentPoint.textOptions.transform = 'rotate(' + currentPoint.textOptions.angle + ',' + (currentPoint.xPos) + ',' + (currentPoint.yPos) + ')';                        
                        if (chartObj.model.enableCanvasRendering) {    // for canvas
							currentPoint.textOptions.labelRotation = currentPoint.textOptions.angle;  //for canvas label rotation
                            chartObj.svgRenderer.ctx.save();
                        if (!chartObj.model.requireInvertedAxes)
                            chartObj.svgRenderer.ctx.rect(areaBoundsX, currentSeries.yAxis.y, currentSeries.xAxis.width, currentSeries.yAxis.height);
                        else
                            chartObj.svgRenderer.ctx.rect(areaBoundsX + currentSeries.yAxis.plotOffset, currentSeries.xAxis.y, currentSeries.yAxis.width, currentSeries.xAxis.height);
                        chartObj.svgRenderer.ctx.save();
                        chartObj.svgRenderer.ctx.clip();
                        BoldBIDashboard.EjSeriesRender.prototype.dataLabelSymbol(i, currentSeries, h, currentPoint.xPos, currentPoint.yPos, currentPoint.width, currentPoint.height, currentPoint.symbolName, this)
                        this.svgRenderer.drawText(currentPoint.textOptions, currentPoint.drawText, this.gSeriesTextEle);
                        chartObj.svgRenderer.ctx.restore();
                    } else {
                            // To check whether the rotated datalabel crop in the chart border or not (Start)
                            var isCrop = false;
                            var chartBounds = chartObj.model.m_AreaBounds;
                            var angle = currentPoint.textOptions["angle"];
                            var y = currentPoint.textOptions["y"];
                            var textYvalue;
                            if (angle) {
                                currentPoint.textOptions["text-anchor"] = "middle";
                                textYvalue = y - (currentPoint.height / 2);
                                textYvalue += chartBounds.Y;
                                isCrop = textYvalue < chartBounds.Y;
                            }
                            // To check whether the rotated datalabel crop in the chart border or not (End)

                            if (!isCrop) {
                                BoldBIDashboard.EjSeriesRender.prototype.dataLabelSymbol(i, currentSeries, h, currentPoint.xPos, currentPoint.yPos, currentPoint.width, currentPoint.height, currentPoint.symbolName, this, this.gDataLabelEle[i])
                                this.svgRenderer.drawText(currentPoint.textOptions, currentPoint.drawText, this.gSeriesTextEle[i]);
                            }
                    }
		                  if (type == "rangecolumn" || type == "rangearea" || type == "splinerangearea") {
		                      
		                      currentPoint.textOptionsLow.transform = 'rotate(' + currentPoint.textOptionsLow.angle + ',' + (currentPoint.xPosLow) + ',' + (currentPoint.yPosLow) + ')';
		                      currentPoint.textOptionsLow.labelRotation = currentPoint.textOptionsLow.angle;  //for canvas label rotation
		                      if (chartObj.model.enableCanvasRendering) {    // for canvas
		                          chartObj.svgRenderer.ctx.save();
		                          if (!chartObj.model.requireInvertedAxes)
		                              chartObj.svgRenderer.ctx.rect(areaBoundsX, currentSeries.yAxis.y, currentSeries.xAxis.width, currentSeries.yAxis.height);
		                          else
		                              chartObj.svgRenderer.ctx.rect(areaBoundsX + currentSeries.yAxis.plotOffset, currentSeries.xAxis.y, currentSeries.yAxis.width, currentSeries.xAxis.height);
		                          chartObj.svgRenderer.ctx.clip();
		                          
		                          BoldBIDashboard.EjSeriesRender.prototype.dataLabelSymbol(i, currentSeries, h, currentPoint.xPosLow, currentPoint.yPosLow, currentPoint.widthLow, currentPoint.heightLow, currentPoint.symbolName, this)
		                          
		                          this.svgRenderer.drawText(currentPoint.textOptionsLow, currentPoint.drawTextLow, this.gSeriesTextEle);
		                          chartObj.svgRenderer.ctx.restore();
		                      }
		                      else {
		                          
		                          BoldBIDashboard.EjSeriesRender.prototype.dataLabelSymbol(i, currentSeries, h, currentPoint.xPosLow, currentPoint.yPosLow, currentPoint.widthLow, currentPoint.heightLow, currentPoint.symbolName, this, this.gDataLabelEle[i])
		                          this.svgRenderer.drawText(currentPoint.textOptionsLow, currentPoint.drawTextLow, this.gSeriesTextEle[i]);

		                      }
		                  }
                }
            }
		  }
        }

        // to append connector lines
		   if (this.model.AreaType != "none") {
                    // to append connector lines
                    var i, currentSeries;
                    for (i = 0; i < visibleSeriesLength; i++) {
                        this._appendConnectorElements(i);

                    }

                    // to append marker, data label symbol and text
                    var index;
                    var length = this.model._visibleSeries.length;
                    for (i = 0; i < length; i++) {
                        if (this.model._visibleSeries[i].marker.visible || this.model._visibleSeries[i].marker.dataLabel.visible)
                        this._appendDataLabelElement(i);
                    }
                }
            }  //to append conector lines ,marker,datalabel symbol and text  for pie and doughnut 
            else {
                var p, currentSeries;
                for (p = visibleSeriesLength - 1; p >= 0 ; p--) {
                    currentSeries = this.model._visibleSeries[p];
                    type = currentSeries.type.toLowerCase();
                   if ((type == "pie" || type == "doughnut") && this.model.minhightwidth)
                        this._appendConnectorElements(p);
                }
                var index;
                var length = this.model._visibleSeries.length;
                for (p = visibleSeriesLength - 1; p >= 0 ; p--) {
                    currentSeries = this.model._visibleSeries[p];
                    type = currentSeries.type.toLowerCase();
                 if ((type == "pie" || type == "doughnut") && this.model.minhightwidth)
                        this._appendDataLabelElement(p);
                }
            }
        this.svgRenderer.append(this.gSeriesEle, this.svgObject);
        this.svgRenderer.append(this.svgObject, this.element);
		var length = this.model._visibleSeries.length;
		var s, series, templateContainer, dataLabel;
		for (s = 0; s < length; s++){
		 options = this.model._visibleSeries[s];
		    type = options.type.toLowerCase();
       options._previousType = BoldBIDashboard.util.isNullOrUndefined(options._previousType) ? options.type : options._previousType;
		 if (!this.vmlRendering && options.visibility =="visible" && !this.model.enableCanvasRendering && !this.model.enable3D && this.model.AreaType != "none") {
			 series = new BoldBIDashboard.seriesTypes[options.type.toLowerCase()]();
			 series.chartObj = chartObj;
			 series.gSeriesGroupEle = bbdesigner$("#" + this.svgObject.id + "_SeriesGroup_" + s)[0];
            if (options.enableAnimation && (!options._animatedSeries || options._previousType != options.type)&& this.model.AreaType != "none" ) {
                options._animatedSeries = true;
			    templateContainer = bbdesigner$('#template_group_' + this._id); 
                dataLabel=options.marker.dataLabel;				
               if (templateContainer.children().length != 0 && (dataLabel.visible && dataLabel.template))	 	
                   series.animateLabelTemplate(options);
			      if (type == "polar" || type == "radar")
					  BoldBIDashboard.ejRadarSeries.prototype.doAnimation(options, series); // to animate polar/ radar
				  else
                      this.doAnimation(options);   // to animate cartesian series
            }
         }
		}
		
		// to append trend line to DOM and perform animation
		  var visibleSeries = this.model._visibleSeries;
		  var length = visibleSeries.length;
		  if (!this.model.enableCanvasRendering && !this.model.enable3D){
		    for (var k =0; k <length; k++){
		          if (visibleSeries[k].visibility.toLowerCase() == "visible" && this.gTrendlinesGroupEle && 
				      this.gTrendlinesGroupEle[k] && this.gTrendlinesGroupEle[k].childElementCount != 0)
		         this.svgRenderer.append(this.gTrendlinesGroupEle[k], this.svgObject);
			}
		  }
		 
		  var trendlines, trendline, trendlineType, options, i, j, trendLineLength;
		  for (i = 0; i < length; i++){
		    currentSeries = this.model._visibleSeries[i];
			trendlines = currentSeries.trendlines;
			trendLineLength = currentSeries.trendlines.length;
			for (j = 0; j < trendLineLength; j++) {
              trendline = trendlines[j];
                   if (trendline.visibility) {
			        trendlineType = trendline.type.toLowerCase();
			        options = new BoldBIDashboard.trendlineTypes[trendlineType]();
			        if (trendline.visibility.toLowerCase() === 'visible' && trendline.points && trendline.points.length > 1 &&
                       currentSeries.enableAnimation && !this.vmlRendering && (!currentSeries._animatedTrendline || trendline._previousType != trendline.type)) {
			            trendline._previousType = trendline.type;
						var clipRect = bbdesigner$(this.svgObject).find("#" + this.svgObject.id + '_TrendGroup' + '_' + i + '_' + j + "_ClipRect").children();
			            BoldBIDashboard.EjSeriesRender.prototype._doLineAnimation(this, clipRect); // for trendline animation
			            currentSeries._animatedTrendline = (trendLineLength - 1 == i) ? true : false;
			        }
				}
			}
		  }
	
	      var seriesEle, symbolEle;
		  var length = this.model._visibleSeries.length;
		  var svgObjectId = this.svgObject.id;
		  for (var i =0; i <length; i++){
		      var seriesEle = bbdesigner$("#" + svgObjectId + "_SeriesGroup_" + i);
		      var waterfallLineEle = bbdesigner$("#" + svgObjectId + '_SeriesGroup_waterfallLine_' + i);
			 var symbolEle = bbdesigner$("#" + svgObjectId + "_symbolGroup_" + i);
			 if (seriesEle.length >0 && symbolEle.length >0)
			     symbolEle.insertAfter(seriesEle);
			 if (seriesEle.length > 0 && waterfallLineEle.length > 0)
			     waterfallLineEle.insertAfter(seriesEle);
		  }
		  
	
		  this.model.AnimationComplete = true;
          var commonEventArgs = bbdesigner$.extend({}, BoldBIDashboard.EjSvgRender.commonChartEventArgs);
          commonEventArgs.data = {series : options};
          this._trigger("animationComplete", commonEventArgs);
		
		if (enableCanvasRendering) {
            this.svgRenderer.append(this.svgObject, this.element);
            if (this.panning) bbdesigner$("#" + this._id+ "_canvas").css({ "cursor": "pointer" });
        }       
		if (enable3D && !enableCanvasRendering) {
          this.svgRenderer.append(this.chart3D, this.svgObject);
           
          var size = { Width: bbdesigner$(this.svgObject).width(), Height: bbdesigner$(this.svgObject).height() };
          this.graphics.prepareView(this.model.perspectiveAngle, this.model.depth, this.model.rotation, this.model.tilt, size, this);
          this.graphics.view(this.svgObject, this);
		  this.svgRenderer.append(this.svgObject, this.element);
          //for (var i = 0; i < visibleSeries.length; i++) {
          //    if (visibleSeries[i].visibility.toLowerCase() == "visible" && visibleSeries[i].enableAnimation && !(this.model.animated)) {
          //        var seriesRendering = new BoldBIDashboard.Ej3DSeriesRender();
          //        var type = visibleSeries[i].type.toLowerCase();
          //        var options = BoldBIDashboard.series3DTypes[type];
          //        if (this.model.AreaType == "none" && i > 0)
          //            break;
          //        options.doAnimation(visibleSeries[i], seriesRendering);
          //    }

          //}

        }
      
       if (this.svgRenderer.vmlNamespace)
            this.svgRenderer.append(this.gSeriesEle, this.svgObject);
        if (areaType == 'polaraxes')
            this.svgRenderer.append(this.gPolarAxisEle, this.svgObject);
        if (bbdesigner$(this.svgObject).find("#" + this.svgObject.id + "_StriplineOver").length > 0) {
            var detachEle = bbdesigner$(this.svgObject).find("#" + this.svgObject.id + "_StriplineOver").detach();
            detachEle.appendTo(this.svgObject);
        }

        this._renderScrollbar();      
		
		this.legendRender.drawLegend(params);
		
        chartObj.model.initSeriesRender = true;
    },

    _scrollChanged: function (evt) {        
      this.model._axes[evt.model.index]._scrollLeft = evt.scrollLeft;
      this.model._axes[evt.model.index]._scrollTop = evt.scrollTop;      
      if (!this.model.disableZoom) {
           this._scrollRedraw();
        }           
    },
     
    _renderScrollbar: function () {

        var scrollerSize = this.model.scrollerSize,
            scrollObj, index,  
            chartOffsetVal = bbdesigner$('#' + this._id).offset(),
            offsetVal = (bbdesigner$(this.svgObject).offset().left - chartOffsetVal.left),
            scrollerWidth, scrollerHeight, scrollerX,
            scrollerY, size;
        for (var r = 0; r < this.model._axes.length; r++) {
            var axis = this.model._axes[r],
                orientation = axis.orientation.toLowerCase(),
                zoomingScroll = this.model.zooming.enableScrollbar;
				index = ((orientation == "horizontal") ? axis.columnIndex : axis.rowIndex); 
            if (this.model.AreaType == "cartesianaxes" && !this.model.enable3D && ((axis._scrollBar && axis.maxPointLength < axis.pointsLength) || ((axis.zoomFactor < 1 || axis.zoomPosition > 0) && (zoomingScroll)))) {
                                 
                scrollerWidth = ((orientation == "horizontal") ? axis.width + scrollerSize : scrollerSize);
                scrollerHeight = ((orientation == "vertical") ? axis.height : scrollerSize);
                scrollerX = axis.x + ((orientation == "vertical") ? -scrollerSize : 0) + (offsetVal <= 0 ? 0 : offsetVal);
                scrollerY = axis.y + ((orientation == "horizontal") ? axis.height : 0);
                size = (orientation == "horizontal") ? axis.width : axis.height;

                if (axis.enableScrollbar) {
                    axis.zoomFactor = axis.maxPointLength / axis.pointsLength;
                    if (bbdesigner$("#ScrollerParent_" + orientation + "_" + index + "_" + this._id).length == 0) {
                        axis.zoomPosition = (axis.isInversed) ? (1 - axis.zoomPosition) : axis.zoomPosition;
                    }
                }

                value = (size / axis.zoomFactor);
                if (orientation == "horizontal") {
                    divWidth = (value);
                    divHeight = scrollerSize;
                    axis._previousXScrollValue = axis._scrollLeft = value * axis.zoomPosition;
                    axis._previousYScrollValue = axis._scrollTop = 0;
                }
                else {
                    divWidth = scrollerSize;
                    divHeight = (value);
                    axis._previousYScrollValue = axis._scrollTop = (value - (value * axis.zoomPosition) - size);
                    axis._previousXScrollValue = axis._scrollLeft = 0;
                }

                if (this.element.find("#ScrollerParent_" + orientation + "_" + index + "_" + this._id).hasClass("e-scroller")) {
                    bbdesigner$("#ScrollerParent_" + orientation + "_" + index + "_" + this._id).css({ "width": (scrollerWidth), "height": scrollerHeight, "left": scrollerX, "top": scrollerY });
                    bbdesigner$("#ScrollerParent_" + orientation + "_" + index + "_" + this._id).find("#" + this._id + "_" + orientation + "_Scroller").css({
                        "height": divHeight,
                        "width": divWidth,
                        "top": scrollerX,
                        "left": scrollerY
                    });
                   
                    scrollObj = bbdesigner$("#ScrollerParent_" + orientation + "_" + index + "_" + this._id).BoldBIDashboardScroller("instance");

                    if (scrollObj.scrollLeft() != axis._scrollLeft || scrollObj.scrollTop() != axis._scrollTop || scrollObj.model.width != scrollerWidth || scrollObj.model.height != scrollerHeight) {
                        scrollObj.model.scrollLeft = axis._scrollLeft;
                        scrollObj.model.scrollTop = axis._scrollTop;
                        scrollObj.model.width = scrollerWidth;
                        scrollObj.model.height = scrollerHeight;
                        scrollObj.refresh();
                    }

                }
                else {
                    var scrollerContainer = bbdesigner$("<div></div>").attr('id', "ScrollerParent_" + orientation + "_" + index + "_" + this._id).css({
                        "position": "absolute", "height": scrollerHeight, "width": scrollerWidth, "left": scrollerX, "top": scrollerY
                    });
                    var scroller = bbdesigner$("<div></div>").attr('id', "Scroller_" + orientation + "_" + this._id).css("height", "0px", "z-index", 10000);
                    var scrollerDiv = bbdesigner$("<div></div>").attr('id', this._id + "_" + orientation + "_Scroller").css({
                        "height": divHeight,
                        "width": divWidth,
                        "top": scrollerX,
                        "left": scrollerY
                    });
                    bbdesigner$(scrollerDiv).appendTo(scroller);
                    bbdesigner$(scroller).appendTo(scrollerContainer);
                    bbdesigner$(scrollerContainer).appendTo(this.chartContainer);
                    bbdesigner$(scrollerContainer).BoldBIDashboardScroller({
                        width: scrollerWidth,
                        scrollTop: axis._scrollTop,
                        scrollLeft: axis._scrollLeft,
                        height: scrollerHeight,
                        orientation: orientation,
                        index: r,
                        scroll: bbdesigner$.proxy(this._scrollChanged, this)
                    });
					
					if(orientation == "horizontal")//remove unwanted vertical scrollbar from horizontal axes
					   bbdesigner$("#ScrollerParent_" + orientation + "_" + index + "_" + this._id).find(".e-vscrollbar").remove();
                }
            }
			else {
                bbdesigner$("#ScrollerParent_" + orientation + "_" + index + "_" + this._id).remove();
            }
        }
    },
    
    _scrollRedraw: function () {        
          
        var chart = this;
        var scrollChanged=false;
        bbdesigner$.each(this.model._axes, function (index, axis) {
            if (((axis._scrollLeft != undefined && axis._scrollLeft != axis._previousXScrollValue) || (axis._scrollTop != undefined && axis._scrollTop != axis._previousYScrollValue))) {
                
                 var leftChange = (axis._scrollLeft != undefined) ? (axis._scrollLeft - axis._previousXScrollValue) : 0,
                 topChange = (axis != undefined) ? (axis._scrollTop - axis._previousYScrollValue) : 0,
                 orientation,
                 invertedAxis = chart.model.requireInvertedAxes,
                 orientation = axis.orientation.toLowerCase(),
                 endIndex,
                 startIndex,
                 oDeltaX = 0,
                 oDeltaY = 0;
				 axis.zoomPosition = parseFloat(axis.zoomPosition.toFixed(10));//roundOff when more than 10 decimalPlaces
                var currentScale = Math.max(1 / BoldBIDashboard.EjSvgRender.utils._minMax(axis.zoomFactor, 0, 1), 1);
                if (orientation == "horizontal")
                    oDeltaX = leftChange;
                else
                    oDeltaY = topChange;               

                chart.translate(axis, oDeltaX, oDeltaY, currentScale);

                if (chart.model.disableZoom && ((!invertedAxis && orientation == "horizontal") || (invertedAxis && orientation == "vertical"))) {
					if(!(Math.round((axis.isInversed ? (1 - axis.zoomPosition) : axis.zoomPosition) * axis.pointsLength)))
						axis.zoomPosition = 0;
                    var currentPointIndex = Math.ceil((axis.isInversed ? (1 - axis.zoomPosition) : axis.zoomPosition) * axis.pointsLength);
                    var commonAxesEventArgs = bbdesigner$.extend({}, BoldBIDashboard.EjSvgRender.commonChartEventArgs);
                    if (axis.isInversed) {
                        endIndex = currentPointIndex;
                        startIndex = (currentPointIndex - axis.maxPointLength - 1);
                    }
                    else {
                        startIndex = currentPointIndex;
                        endIndex = (currentPointIndex + axis.maxPointLength - 1);
                    }
                    var commonAxesEventArgs = bbdesigner$.extend({}, BoldBIDashboard.EjSvgRender.commonChartEventArgs);
                    commonAxesEventArgs.data = { axis: axis, zoomFactor: axis.zoomFactor, zoomPosition: axis.zoomPosition, startIndex: startIndex, endIndex: endIndex };
                    chart._trigger("scrollChanged", commonAxesEventArgs);
                }
                else {
                    var axisRange = new BoldBIDashboard.axisTypes[axis._valueType.toLowerCase()]();
                    var currentRange = axisRange._calculateVisibleRange(axis, chart, true);
                    var commonAxesEventArgs = bbdesigner$.extend({}, BoldBIDashboard.EjSvgRender.commonChartEventArgs);
                    commonAxesEventArgs.data = { axis: axis, zoomFactor: axis.zoomFactor, zoomPosition: axis.zoomPosition, oldRange: axis.visibleRange, newRange: currentRange };
                    chart._trigger("scrollChanged", commonAxesEventArgs);
                    scrollChanged = true;
                }
            }
            if (!BoldBIDashboard.util.isNullOrUndefined(axis._scrollLeft)) {
                axis._previousXScrollValue = axis._scrollLeft;                
            }
            else {
                axis._previousYScrollValue = axis._scrollTop;                 
            }
            });

        if (!this.model.disableZoom && scrollChanged)
              this.redraw(true);            
      },

     //Draw the trendline series
    _renderTrendline: function (chartObj, seriesOptions) {
		// declaration
        var seriesIndex = bbdesigner$.inArray(seriesOptions, chartObj.model.series),
        transX = chartObj.model.requireInvertedAxes ? seriesOptions.yAxis.x : seriesOptions.xAxis.x,
        transY = chartObj.model.requireInvertedAxes ? seriesOptions.xAxis.y :seriesOptions.yAxis.y,
        translate = 'translate(' + transX + ',' + transY + ')',
        trendlinesOptions = { 'id': chartObj.svgObject.id + '_TrendlinesGroup' + '_' + seriesIndex, 'clip-path': 'url(#' + chartObj.svgObject.id + '_TrendlinesGroup' + '_' + seriesIndex + '_ClipRect)' },
        trendlines = seriesOptions.trendlines, m, element, polynomialSlopes,  slopeLength,
        options, trendline, i, slope, intercept, displayText, text = "",
        length = trendlines.length, trendOptions, trendlineType, commonEventArgs, backwardPoints, forwardPoints;
		
		if (!chartObj.gTrendlinesGroupEle) chartObj.gTrendlinesGroupEle = [];
        chartObj.gTrendlinesGroupEle[seriesIndex] = chartObj.svgRenderer.createGroup(trendlinesOptions);
        for (i = 0; i < length; i++) {
            trendline = trendlines[i];
            trendline.seriesIndex = seriesIndex;
            trendline.isTrendLine = true;
            trendline.trendlineIndex = i;
            if (trendline.visibility.toLowerCase() === 'visible' && !trendline.isNull && trendline.points && trendline.points.length > 1) {
                trendOptions = { 'id': chartObj.svgObject.id + '_TrendGroup' + '_' + seriesIndex + '_' + i, 'transform': translate, 'clip-path': 'url(#' + chartObj.svgObject.id + '_TrendGroup' + '_' + seriesIndex + '_' + i + '_ClipRect)' };
                seriesOptions.gTrendGroupEle = null;
                seriesOptions.gTrendGroupEle = chartObj.svgRenderer.createGroup(trendOptions);
                trendlineType = trendline.type.toLowerCase();
                options = new BoldBIDashboard.trendlineTypes[trendlineType]();
                slope = trendline.slope;
                intercept = trendline._intercept;
                switch (trendlineType) {
                    case "linear":
                        text = "y = " + slope.toFixed(4) + "x + " + intercept.toFixed(4);
                        break;
                    case "exponential":
                        text = "y = " + intercept.toFixed(3) + "e" + "^" + slope.toFixed(4) + "x";
                        break;
                    case "logarithmic":
                        text = "y = " + slope.toFixed(3) + "ln(x) + " + intercept.toFixed(4);
                        break;
                    case "power":
                        text = "y = " + intercept.toFixed(3) + "x^" + slope.toFixed(4);
                        break;
                    case "polynomial":
                        polynomialSlopes = trendline.polynomialSlopes;
                        slopeLength = polynomialSlopes.length;
                        text = "y = ";
                        for (m = slopeLength - 1; m >= 0; m--) {
                            displayText = polynomialSlopes[m];
                            text += displayText > 0 ? "+" + displayText : "-" + Math.abs(displayText);
                            if (m != 0)
                                text += "x^" + m + " ";
                        }
                        break;
                }
                trendline.equation = text;   // for equation

                ////Trigger Trendline rendering events
                commonEventArgs = bbdesigner$.extend({}, BoldBIDashboard.EjSvgRender.commonChartEventArgs);
                backwardPoints = trendline.points[0];
                forwardPoints = trendline.points[trendline.points.length - 1];
                commonEventArgs.data = { series: seriesOptions, trendline: trendline, forwardForecastPoints: forwardPoints, backwardForecastPoints: backwardPoints };
                this._trigger("trendlineRendering", commonEventArgs);

                if (chartObj.model.enableCanvasRendering) {
                    this.svgRenderer.ctx.save();
                    this.svgRenderer.ctx.beginPath();
                    this.svgRenderer.ctx.rect(chartObj.model.m_AreaBounds.X, seriesOptions.yAxis.y, seriesOptions.xAxis.width, seriesOptions.yAxis.height);
                    this.svgRenderer.ctx.clip();
                    this.svgRenderer.ctx.beginPath();
                    options.draw(trendline, seriesOptions, chartObj);
                    this.svgRenderer.ctx.restore();
                } else {
                    options.draw(trendline, seriesOptions, chartObj);
                    //Add axes bounds clip path for series
                    element = seriesOptions.gTrendGroupEle;
                    if (element) BoldBIDashboard.EjSvgRender.utils._drawAxesBoundsClipPath(element, seriesOptions, this);
                }
            }
        }

    },
    _renderStripline: function (zIndex) {
        bbdesigner$.extend(BoldBIDashboard.EjStripline.prototype, this);
        this.chartstripline = new BoldBIDashboard.EjStripline(this);
        var stripline = this.chartstripline;
		 this.model._stripeline = false;
        for (var sl = 0; sl < this.model._axes.length; sl++) {
            var slAxis = this.model._axes[sl];
            for (var slCount = 0; slCount < slAxis.stripLine.length; slCount++) {
                if (slAxis.stripLine[slCount].zIndex.toLowerCase() == zIndex)
                    stripline._drawStripline(slAxis, slAxis.stripLine[slCount]);
            }
        }
        if (zIndex == 'over' && this.model._stripeline) {

            this.svgRenderer.append(this.gStriplineOver, this.svgObject);
        } else if(this.model._stripeline){
            this.svgRenderer.append(this.gStriplineBehind, this.svgObject);
        }
    },

    renderSeries: function (options, params) {

        var chart = this;
        var axis;
        var index;
        var seriesIndex = bbdesigner$.inArray(options, this.model._visibleSeries);
		options._seriesIndex = seriesIndex;
        for (var i = 0; i < options.points.length; i++) {
            if (typeof options.points[i].x == "string" && options.points[i].x.indexOf("/Date(") != -1)
                options.points[i].x = new Date(parseInt(options.points[i].x.substr(6)));
        }
        options.xAxis = (options.xAxis === null || options.xAxis === undefined) ? this.model._axes[0] : options.xAxis;
        options.yAxis = (options.yAxis === null || options.yAxis === undefined) ? this.model._axes[1] : options.yAxis;
        var type = options.type.toLowerCase();
		var drawtype = options.drawType.toLowerCase();
        var symbolOptions;
        var translate = null;
        var visibility;

        if (this.model.AreaType == "cartesianaxes") {
            var trans = BoldBIDashboard.EjSvgRender.utils._getTransform(options.xAxis, options.yAxis, this.model.requireInvertedAxes);
            var translate = 'translate(' + trans.x + ',' + trans.y + ')';
            visibility = 'visible';
        }
        else {
            visibility = (options.enableAnimation && !options._animatedSeries) ? 'hidden' : 'visible'
        }
        var txtOptions = { 'id': this.svgObject.id + '_TextGroup_' + seriesIndex , 'transform': translate, 'visibility': visibility };
        var dataLabelOptions = { 'id': this.svgObject.id + '_DataLabel_' + seriesIndex , 'transform': translate, 'visibility': visibility };
        if (type != "scatter")
            symbolOptions = { 'id': this.svgObject.id + '_symbolGroup_' + seriesIndex , 'transform': translate, 'visibility': visibility };
        else
            symbolOptions = { 'id': this.svgObject.id + '_SeriesGroup' + '_' + seriesIndex, 'transform': translate };
        var connectorOptions = { 'id': this.svgObject.id + '_ConnectorGroup_' + seriesIndex , 'transform': translate, 'visibility': visibility };
        if (!this.gSymbolGroupEle) this.gSymbolGroupEle = [];
        this.gSymbolGroupEle[seriesIndex] = this.svgRenderer.createGroup(symbolOptions);
	    if (!this.gSeriesTextEle) this.gSeriesTextEle = [];
        this.gSeriesTextEle[seriesIndex] = this.svgRenderer.createGroup(txtOptions);
		if (!this.gConnectorEle) this.gConnectorEle = [];
        this.gConnectorEle[seriesIndex] = this.svgRenderer.createGroup(connectorOptions);
		if (!this.gDataLabelEle) this.gDataLabelEle = [];
        this.gDataLabelEle[seriesIndex] = this.svgRenderer.createGroup(dataLabelOptions);

        var commonEventArgs = bbdesigner$.extend({}, BoldBIDashboard.EjSvgRender.commonChartEventArgs);
        commonEventArgs.data = { series: options };
        this._trigger("seriesRendering", commonEventArgs);

        var series = new BoldBIDashboard.seriesTypes[type]();
        if (this.model.enableCanvasRendering && this.model.AreaType != "none") {
            this.svgRenderer.ctx.save();
            this.svgRenderer.ctx.beginPath();
            if (!this.model.requireInvertedAxes) { //checked for bar and stackingbar series
                this.canvasX = options.xAxis.x;
                this.canvasY = options.yAxis.y;
                this.svgRenderer.ctx.rect(options.xAxis.x, options.yAxis.y, options.xAxis.width, options.yAxis.height);
            } else {
                var translate = BoldBIDashboard.EjSvgRender.utils._getTransform(options.xAxis, options.yAxis, this.model.requireInvertedAxes);
                this.canvasX = translate.x;
                this.canvasY = translate.y;
                this.svgRenderer.ctx.rect(options.yAxis.x, options.xAxis.y, options.yAxis.width, options.xAxis.height);
            }
            this.svgRenderer.ctx.clip();
            series.draw(this, options, params);
			this.svgRenderer.ctx.restore();
        }
        else if (this.model.enableCanvasRendering && this.model.AreaType == "polaraxes") {
            this.svgRenderer.ctx.save();
            this.svgRenderer.ctx.beginPath();
            this.svgRenderer.ctx.arc(this.model.centerX, this.model.centerY, this.model.Radius, 0, 2 * Math.PI, false);
            this.svgRenderer.ctx.clip();
            this.canvasX = this.canvasY = 0;
            series.draw(this, options);
            this.svgRenderer.ctx.restore();
        }
        else {
            this.canvasX = this.canvasY = 0;
            if (this.model.AreaType == "cartesianaxes")
                series.draw(this, options, params);
            else if (this.model.AreaType == "polaraxes" && (options._xAxisName == this.model._axes[0].name && options._yAxisName == this.model._axes[1].name))
                series.draw(this, options);
        }
        var errorbar = this.model.series[seriesIndex].errorBar,   
            areaType=this.model.AreaType;
        if (errorbar.visibility == 'visible' && areaType=='cartesianaxes')
        	this.renderErrorBar(errorbar, options);                           // to render error bar
		if (type == "splinerangearea")
            series.gSeriesGroupEle = this.gSeriesGroupEle;
        //Add axes bounds clip path for series
        var element = series.gSeriesGroupEle;
        if (element) BoldBIDashboard.EjSvgRender.utils._drawAxesBoundsClipPath(element, options, this);

        // Draw Symbols       
            if (!(type == "candle" || type == "hilo" || type == "hiloopenclose")) {
                var chartObj = this;
				var point1;
				var areatype = chartObj.model.AreaType.toLowerCase();
				var regiontype = BoldBIDashboard.seriesTypes[type].prototype.isRegion;
				if (!(type == "scatter")){
				    bbdesigner$.each(options._visiblePoints, function (pointIndex, point) {
				        if ((point.visible) && (point.x !== "") && ((point.marker && point.marker.visible) || (options.marker.visible))) {
				            //this condition provide for better Scatter performance
				            if ((areatype == "polaraxes" && drawtype == "column") || regiontype && (type != "rangearea" && type != 'splinerangearea'))
				                point1 = point.symbolLocation;
				            else
				                point1 = (areatype != "polaraxes")
                                ? BoldBIDashboard.EjSvgRender.utils._getPoint(point, options) : BoldBIDashboard.EjSvgRender.utils.TransformToVisible(options, point.xValue, point.y, chartObj)
				            if (areatype == "polaraxes") {
				                var labelFormat = options.yAxis.labelFormat ? options.yAxis.labelFormat : "";
				                var pointText = (point.text) ? point.text : point.y + labelFormat.substring(labelFormat.indexOf('}') + 1);
				                var textOffset = BoldBIDashboard.EjSvgRender.utils._measureText(pointText, null, options.marker.dataLabel.font);
				            }

				            series.drawSymbol(seriesIndex, options, pointIndex, point1.X, point1.Y);
							if(type == "rangearea" || type == "splinerangearea")
								series.drawSymbol(seriesIndex, options, pointIndex, point1.X, point1.low);
				        }
                });
				}
                if (type != "scatter") {
                    //Add axes bounds clip path for marker
                    if (options.marker.visible) {
                        element = this.gSymbolGroupEle[seriesIndex];
                       BoldBIDashboard.EjSvgRender.utils._drawAxesBoundsClipPath(element, options, this);
                    }
                    // Add axes bounds clip path for marker text
                    if (options.marker.dataLabel.visible) {
                        element = this.gSeriesTextEle[seriesIndex];
                        BoldBIDashboard.EjSvgRender.utils._drawAxesBoundsClipPath(element, options, this);
						 // for data label shape
						 element = this.gDataLabelEle[seriesIndex];
						 BoldBIDashboard.EjSvgRender.utils._drawAxesBoundsClipPath(element, options, this);
                      }
					// Add axes bounds clip path for connector line
					if (!BoldBIDashboard.util.isNullOrUndefined(this.gConnectorEle) && this.gConnectorEle.length >0) {
					    element = this.gConnectorEle[seriesIndex];
                        BoldBIDashboard.EjSvgRender.utils._drawAxesBoundsClipPath(element, options, this);
					}
                } else {
                    element = this.gSymbolGroupEle[seriesIndex];
                    BoldBIDashboard.EjSvgRender.utils._drawAxesBoundsClipPath(element, options, this);
                    this.svgRenderer.append(element, this.gSeriesEle);

                    if (options.tooltip.visible || type == "scatter") {
                        if (this.vmlRendering) {
                            this.cloneSeriesEle = bbdesigner$(this.gSeriesEle).clone();
                            this.cloneobj = bbdesigner$(this.element).clone();
                            this.svgclone = bbdesigner$(this.svgObject).clone();
                            bbdesigner$(document.body).append(this.cloneobj);
                            this.svgRenderer.append(this.cloneSeriesEle, this.svgclone);
                            this.svgRenderer.append(this.svgclone, this.cloneobj);
                        }
                        else {
                            this.svgRenderer.append(this.gSeriesEle, this.svgObject);
                            this.svgRenderer.append(this.svgObject, this.element);
                        }

                        if (this.vmlRendering) {
                            bbdesigner$(this.cloneobj).remove();
                            bbdesigner$(this.svgclone).remove();
                        }
                    }
                }
            }

        

        //Draw Series Text

        this.drawDisplayText(series, options, params);

    },
	
	 renderErrorBar:function(errorOptions,seriesOptions)
    {
        // declaration
        var chartobj = this,
        model = chartobj.model,
        currentseries = seriesOptions,
        type,mode,direction,fill,cap,
        capFill,capWidth,capLength,
        visiblePoints = currentseries._visiblePoints,
        len = visiblePoints.length,
        canvasX = chartobj.canvasX, canvasY = chartobj.canvasY,
        seriesIndex = bbdesigner$.inArray(currentseries, model._visibleSeries),
        translate = null,i,
        trans = BoldBIDashboard.EjSvgRender.utils._getTransform(currentseries.xAxis, currentseries.yAxis, model.requireInvertedAxes),
        verticalErrorValue,horizontalErrorValue,
        requireInvertedAxes = model.requireInvertedAxes,
        verticalPositive,verticalNegative,
        horizontalPositive,horizontalNegative,
        svgObjectId = chartobj.svgObject.id,
        areaBounds = chartobj.model.m_AreaBounds,
        translate = 'translate(' + trans.x + ',' + trans.y + ')',
        errorBarElement,errorBarGroup,event,errorBarPoint,
        pointIndex,point,yValue,xVal,standY,standX,
        location, verHighvalue, verLowvalue,
        horHighvalue, horLowvalue, mean, verMean, horMean,
        verStandSquareRoot, horStandSquareRoot, centervalueX, centervalueY,
        verStandardDeviationValue, horStandardDeviationValue,
        verCentervalue, horCentervalue,
        verStandardErrorValue, horStandardErrorValue,
        values, values1, verHighCapX1, verHighCapX2,
        verLowCapX1, verLowCapX2, horHighCapY1, horHighCapY2,
        horLowCapY1, horLowCapY2, eDirectionV, cDirectionV,
        eDirectionH, cDirectionH,eDirection,cDirection,
        fixvalue,pervalue,perY,perX,standDeviValue,standError,
        custom,capValues;

        // parent group creation
         errorBarGroup = {
            'id': svgObjectId + '_ErrorBarGroup' + '_' + seriesIndex,
            'transform': translate,
            'clip-path': 'url(#' + svgObjectId + '_ChartAreaClipRect)'
        };

        if (BoldBIDashboard.util.isNullOrUndefined(chartobj.gErrorBarGroupEle))
            chartobj.gErrorBarGroupEle = [];
        errorBarElement =  chartobj.gErrorBarGroupEle[seriesIndex] = chartobj.svgRenderer.createGroup(errorBarGroup);

        commonEventArgs = bbdesigner$.extend({}, BoldBIDashboard.EjSvgRender.commonChartEventArgs);         
        commonEventArgs.data = {
            errorBar: errorOptions
        };
        this._trigger("errorBarRendering", commonEventArgs);      // trigger event

        event = commonEventArgs.data.errorBar;
        type = event.type;
        mode = event.mode;
        direction = event.direction;
        fill = event.fill;
        cap = event.cap;
        capFill = event.cap.fill;
        capWidth = event.cap.width;
        capLength = event.cap.length;
        verticalErrorValue = event.verticalErrorValue;
        horizontalErrorValue = event.horizontalErrorValue;
        verticalPositive = event.verticalPositiveErrorValue;
        verticalNegative = event.verticalNegativeErrorValue;
        horizontalPositive = event.horizontalPositiveErrorValue;
        horizontalNegative= event.horizontalNegativeErrorValue;
       
         for (i = 0; i < len; i++)
        {
             if (visiblePoints[i].isEmpty == false && visiblePoints[i].visible == true) {
                 // error bar group creation
                 errorBarPoint = {
                     'id': chartobj.svgObject.id + '_ErrorBarGroup' + '_' + seriesIndex + '_Point' + i
                 }
                 errorBarPointGroup = chartobj.svgRenderer.createGroup(errorBarPoint);
                 
                 pointIndex = i;
                 point = visiblePoints[i];
                 yValue = point.YValues[0];
                 xVal = point.xValue;
                 standY = visiblePoints[i].YValues[0];
                 standX = visiblePoints[i].xValue;

                 if (type.indexOf("column") || type.indexOf("bar") > -1)
                     location = point.symbolLocation;
                 else
                     location = point.location;
                 if (BoldBIDashboard.util.isNullOrUndefined(location))
                        location = BoldBIDashboard.EjSvgRender.utils._getPoint(point, currentseries);
                  centervalueX = location.X;
				  centervalueY = location.Y;
                 //error bar type calculation
                 switch (type) {             
                     case "fixedValue":         
                         fixvalue = point;
                         if (mode == 'vertical'||mode=='both') {          //vertical mode calculation for fixed value point location
                             fixvalue.YValues[0] = yValue + verticalErrorValue;
                              verHighvalue = BoldBIDashboard.EjSvgRender.utils._getPoint(fixvalue, currentseries);
                             fixvalue.YValues[0] = yValue - verticalErrorValue;
                             verLowvalue = BoldBIDashboard.EjSvgRender.utils._getPoint(fixvalue, currentseries);
                             if (!requireInvertedAxes)
                                 verHighvalue.X = verLowvalue.X = location.X;
                             else
                                 verHighvalue.Y = verLowvalue.Y = location.Y;
                         }
                         if (mode == 'horizontal' || mode == 'both') {
                             fixvalue.YValues[0] = yValue;
                             fixvalue.xValue = xVal;                    //horizontal mode calculation for fixed value point location
                             fixvalue.xValue = xVal + horizontalErrorValue;
                             horHighvalue = BoldBIDashboard.EjSvgRender.utils._getPoint(fixvalue, currentseries);
                             fixvalue.xValue = xVal - horizontalErrorValue;
                             horLowvalue = BoldBIDashboard.EjSvgRender.utils._getPoint(fixvalue, currentseries);
                         }
                         fixvalue.YValues[0] = yValue;
                         fixvalue.xValue = xVal;
                         break;

                     case "percentage":         
                         pervalue = point;
                         perY = verticalErrorValue / 100 * yValue;
                         perX = horizontalErrorValue / 100 * xVal;
                         if (mode == 'vertical'||mode=='both') {                  //vertical mode calculation for percentage point locaion
                             pervalue.YValues[0] = yValue + perY;
                             verHighvalue = BoldBIDashboard.EjSvgRender.utils._getPoint(pervalue, currentseries);
                             pervalue.YValues[0] = yValue - perY;
                             verLowvalue = BoldBIDashboard.EjSvgRender.utils._getPoint(pervalue, currentseries);
                             if (!requireInvertedAxes) 
                                 verHighvalue.X =verLowvalue.X= location.X;
                             else 
                                 verHighvalue.Y =verLowvalue.Y = location.Y;
                         }
                         if (mode == 'horizontal' || mode == 'both') {
                             pervalue.YValues[0] = yValue;
                             pervalue.xValue = xVal;                              //horizontal mode calculation for percentage
                             pervalue.xValue = xVal + perX;
                             horHighvalue = BoldBIDashboard.EjSvgRender.utils._getPoint(pervalue, currentseries);
                             pervalue.xValue = xVal - perX;
                             horLowvalue = BoldBIDashboard.EjSvgRender.utils._getPoint(pervalue, currentseries);
                         }
                         pervalue.YValues[0] = yValue;
                         pervalue.xValue = xVal;
                         break;

                     case "standardDeviation":          
                          standDeviValue = point;
                             mean = chartobj.meanCalculation(mode, visiblePoints);
                             verMean = mean.verMean;
                             horMean = mean.horMean;
                             verStandSquareRoot = mean.verStandSquareRoot;
                             horStandSquareRoot = mean.horStandSquareRoot;
                         if (mode == 'vertical'|| mode=='both') {                 
                             verStandardDeviationValue = verticalErrorValue * verStandSquareRoot;
                             standDeviValue.YValues[0] = verMean;
                             verCentervalue = BoldBIDashboard.EjSvgRender.utils._getPoint(standDeviValue, currentseries);
                             yValue = standDeviValue.YValues[0];
                             standDeviValue.YValues[0] = yValue + verStandardDeviationValue;
                             verHighvalue = BoldBIDashboard.EjSvgRender.utils._getPoint(standDeviValue, currentseries);
                             standDeviValue.YValues[0] = yValue - verStandardDeviationValue;
                             verLowvalue = BoldBIDashboard.EjSvgRender.utils._getPoint(standDeviValue, currentseries);
                             if (!requireInvertedAxes) 
                                 verCentervalue.X = verHighvalue.X = verLowvalue.X = location.X;
                             else
                                 verCentervalue.Y = verHighvalue.Y = verLowvalue.Y = location.Y;
                             verCentervalue.X = verCentervalue.X + canvasX;
							 verCentervalue.Y = verCentervalue.Y + canvasY;
                         }
                         if (mode == 'horizontal' || mode == 'both') {
                             horStandardDeviationValue = horizontalErrorValue * horStandSquareRoot;
                             standDeviValue.xValue = horMean;
                             horCentervalue = BoldBIDashboard.EjSvgRender.utils._getPoint(standDeviValue, currentseries);
                             if (!requireInvertedAxes)
                                 horCentervalue.Y = location.Y;
							 else
								 horCentervalue.X = location.X;
                             standDeviValue.YValues[0] = standY;
                             xVal = standDeviValue.xValue;
                             standDeviValue.xValue = xVal + horStandardDeviationValue;
                             horHighvalue = BoldBIDashboard.EjSvgRender.utils._getPoint(standDeviValue, currentseries);  
                             standDeviValue.xValue = xVal - horStandardDeviationValue;
                             horLowvalue = BoldBIDashboard.EjSvgRender.utils._getPoint(standDeviValue, currentseries);
							 horCentervalue.X = horCentervalue.X + canvasX;
                             horCentervalue.Y = horCentervalue.Y + canvasY;
							 
                         } 
                         standDeviValue.YValues[0] = standY;
                         standDeviValue.xValue = standX;
                        
                         break;
                     case "standardError":           
                         standError = point;
                         mean = chartobj.meanCalculation(mode, visiblePoints);
                         verStandSquareRoot = mean.verStandSquareRoot;
                         horStandSquareRoot = mean.horStandSquareRoot;
                         if (mode == 'vertical'||mode=='both') {                                   //vertical mode standard Error calculation
                             verStandardDeviationValue = verticalErrorValue * verStandSquareRoot;
                             verStandardErrorValue = verStandardDeviationValue / Math.sqrt(len);
                             standError.YValues[0] = yValue + verStandardErrorValue;
                             verHighvalue = BoldBIDashboard.EjSvgRender.utils._getPoint(standError, currentseries);
                             standError.YValues[0] = yValue - verStandardErrorValue
                             verLowvalue = BoldBIDashboard.EjSvgRender.utils._getPoint(standError, currentseries);
                             if (!requireInvertedAxes)
                                 verHighvalue.X = verLowvalue.X = location.X;
                             else
                                 verHighvalue.Y = verLowvalue.Y = location.Y;
                         }
                         if (mode == 'horizontal'||mode=='both') {                             //horizontal mode standard Error calculation
                             horStandardDeviationValue = horizontalErrorValue *horStandSquareRoot;
                             horStandardErrorValue = horStandardDeviationValue / Math.sqrt(len);
                             standError.YValues[0] = yValue;
                             standError.xValue = xVal;                      //horizontal mode calculation for  point location
                             standError.xValue = xVal + horStandardErrorValue;
                             horHighvalue = BoldBIDashboard.EjSvgRender.utils._getPoint(standError, currentseries);
                             standError.xValue = xVal - horStandardErrorValue;
                             horLowvalue = BoldBIDashboard.EjSvgRender.utils._getPoint(standError, currentseries);
                         }
                         standError.YValues[0] = yValue;
                         standError.xValue = xVal;
                         i = pointIndex;
                         break;

                     case "custom":
                         custom = point;
                         if (mode == 'vertical'||mode=='both') {                         //calculation for vertical mode point locaton
                             custom.YValues[0] = yValue + verticalPositive;
                             verHighvalue = BoldBIDashboard.EjSvgRender.utils._getPoint(custom, currentseries);
                             custom.YValues[0] = yValue - verticalNegative;
                             verLowvalue = BoldBIDashboard.EjSvgRender.utils._getPoint(custom, currentseries);
                             if (!requireInvertedAxes) 
                                 verHighvalue.X = verLowvalue.X=location.X;
                             else 
                                 verHighvalue.Y =verLowvalue.Y = location.Y;
                         }
                         if (mode == 'horizontal'||mode=='both') {
                             custom.YValues[0] = yValue;
                             custom.xValue = xVal;                     //calculation for horizontal mode point location
                             custom.xValue = xVal + horizontalPositive;
                             horHighvalue = BoldBIDashboard.EjSvgRender.utils._getPoint(custom, currentseries);
                             custom.xValue = xVal - horizontalNegative;
                             horLowvalue = BoldBIDashboard.EjSvgRender.utils._getPoint(custom, currentseries);
                         }
                         custom.YValues[0] = yValue;
                         custom.xValue = xVal;
                         break;
                 }
                
                 //to render cap 
                 if (cap.visible == true) {
                     if(mode=='vertical'||mode=='both')
                          values = { verHighvalue: verHighvalue, verLowvalue: verLowvalue }
                     if(mode=='horizontal'||mode=='both')
                          values1={   horHighvalue: horHighvalue,horLowvalue: horLowvalue}
                     capValues = chartobj.renderCap(cap, mode, values,values1, requireInvertedAxes); 
                     verHighCapX1 = capValues.verHighCapX1, verHighCapX2 = capValues.verHighCapX2,
                     verLowCapX1 = capValues.verLowCapX1,verLowCapX2 = capValues.verLowCapX2,
                     horHighCapY1 = capValues.horHighCapY1,horHighCapY2 = capValues.horHighCapY2,
                     horLowCapY1 = capValues.horLowCapY1,horLowCapY2 = capValues.horLowCapY2;
                 }
                 centervalueX = centervalueX + canvasX;
                 centervalueY = centervalueY + canvasY;
                 if (mode == 'vertical' || mode == 'both') {
                     verHighvalue.X = verHighvalue.X + canvasX;
                     verHighvalue.Y = verHighvalue.Y + canvasY;
                     verLowvalue.X = verLowvalue.X + canvasX;
                     verLowvalue.Y = verLowvalue.Y + canvasY;
                 }
                 if (mode == 'horizontal' || mode == 'both') {
                     horHighvalue.X = horHighvalue.X + canvasX;
                     horHighvalue.Y = horHighvalue.Y + canvasY;
                     horLowvalue.X = horLowvalue.X + canvasX;
                     horLowvalue.Y = horLowvalue.Y + canvasY;
                 }
    //drawing error bar and error bar cap  
             //drawing both direction    
             if (direction == 'both') {   
                  if (mode == 'vertical'|| mode =='both') {             //vertical mode for both direction
                       if (type != 'standardDeviation') 
                           eDirectionV = "M" + " " + (centervalueX) + " " + (centervalueY) + " " + "L" + " " + (verHighvalue.X) + " " + (verHighvalue.Y) + " " + "M" + " " + (centervalueX) + " " + (centervalueY) + " " + "L" + " " + (verLowvalue.X) + " " + (verLowvalue.Y) + " ";
                       else if (type == 'standardDeviation') 
                           eDirectionV = "M" + " " + (verCentervalue.X) + " " + (verCentervalue.Y) + " " + "L" + " " + (verHighvalue.X) + " " + (verHighvalue.Y) + " " + "M" + " " + (verCentervalue.X) + " " + (verCentervalue.Y) + " " + "L" + " " + (verLowvalue.X) + " " + (verLowvalue.Y) + " ";
                       if(!requireInvertedAxes)
                           cDirectionV = !cap.visible ? "" : "M" + " " + (verHighvalue.X) + " " + (verHighvalue.Y) + " " + "L" + " " + (verHighCapX1) + " " + (verHighvalue.Y) + " " + "M" + " " + (verHighvalue.X) + " " + (verHighvalue.Y) + " " + "L" + " " + (verHighCapX2) + " " + (verHighvalue.Y) + " " + "M" + " " + (verLowvalue.X) + " " + (verLowvalue.Y) + " " + "L" + " " + (verLowCapX1) + " " + (verLowvalue.Y) + " " + "M" + " " + (verLowvalue.X) + " " + (verLowvalue.Y) + " " + "L" + " " + (verLowCapX2) + " " + (verLowvalue.Y) + " ";
                       else
                           cDirectionV = !cap.visible ? "" : "M" + " " + (verHighvalue.X) + " " + (verHighvalue.Y) + " " + "L" + " " + (verHighvalue.X) + " " + (verHighCapX1) + " " + "M" + " " + (verHighvalue.X) + " " + (verHighvalue.Y) + " " + "L" + " " + (verHighvalue.X) + " " + (verHighCapX2) + " " + "M" + " " + (verLowvalue.X) + " " + (verLowvalue.Y) + " " + "L" + " " + (verLowvalue.X) + " " + (verLowCapX1) + " " + "M" + " " + (verLowvalue.X) + " " + (verLowvalue.Y) + " " + "L" + " " + (verLowvalue.X) + " " + (verLowCapX2) + " ";
                           eDirection = eDirectionV,cDirection = cDirectionV;
                   }
                   if (mode == 'horizontal' || mode == 'both') {
                       if (type != 'standardDeviation')                          //horizontal mode for both direction
                           eDirectionH = "M" + " " + (centervalueX) + " " + (centervalueY ) + " " + "L" + " " + (horHighvalue.X ) + " " + (horHighvalue.Y ) + " " + "M" + " " + (centervalueX ) + " " + (centervalueY ) + " " + "L" + " " + (horLowvalue.X ) + " " + (horLowvalue.Y ) + " ";
                       else if (type == 'standardDeviation')
                           eDirectionH = "M" + " " + (horCentervalue.X) + " " + (horCentervalue.Y ) + " " + "L" + " " + (horHighvalue.X ) + " " + (horHighvalue.Y) + " " + "M" + " " + (horCentervalue.X ) + " " + (horCentervalue.Y ) + " " + "L" + " " + (horLowvalue.X ) + " " + (horLowvalue.Y) + " ";
                       if (!requireInvertedAxes)
                           cDirectionH = !cap.visible ? "" :"M" + " " + (horHighvalue.X) + " " + (horHighvalue.Y ) + " " + "L" + " " + (horHighvalue.X ) + " " + (horHighCapY1) + " " + "M" + " " + (horHighvalue.X ) + " " + (horHighvalue.Y ) + " " + "L" + " " + (horHighvalue.X ) + " " + (horHighCapY2) + " " + "M" + " " + (horLowvalue.X ) + " " + (horLowvalue.Y ) + " " + "L" + " " + (horLowvalue.X ) + " " + (horLowCapY1) + " " + "M" + " " + (horLowvalue.X ) + " " + (horLowvalue.Y ) + " " + "L" + " " + (horLowvalue.X) + " " + (horLowCapY2) + " ";
                       else
                           cDirectionH = !cap.visible ? "" : "M" + " " + (horHighvalue.X) + " " + (horHighvalue.Y) + " " + "L" + " " + (horHighCapY1) + " " + (horHighvalue.Y) + " " + "M" + " " + (horHighvalue.X ) + " " + (horHighvalue.Y ) + " " + "L" + " " + (horHighCapY2) + " " + (horHighvalue.Y) + " " + "M" + " " + (horLowvalue.X) + " " + (horLowvalue.Y) + " " + "L" + " " + (horLowCapY1) + " " + (horLowvalue.Y ) + " " + "M" + " " + (horLowvalue.X) + " " + (horLowvalue.Y) + " " + "L" + " " + (horLowCapY2) + " " + (horLowvalue.Y ) + " ";
                       eDirection = eDirectionH, cDirection = cDirectionH;
                   }
                    if (mode == 'both') {
                        eDirectionH += eDirectionV,cDirectionH += cDirectionV;
                        eDirection = eDirectionH,cDirection = cDirectionH;
                    }
             }
           //drawing plus direction
             else if (direction == 'plus') {  
                    if (mode == 'vertical'|| mode =='both') {        //vertical mode for plus direction
                            if (type != 'standardDeviation') 
                                  eDirectionV = "M" + " " + (centervalueX) + " " + (centervalueY) + " " + "L" + " " + (verHighvalue.X) + " " + (verHighvalue.Y) + " ";
                            else if (type == 'standardDeviation') 
                                eDirectionV = "M" + " " + (verCentervalue.X) + " " + (verCentervalue.Y ) + " " + "L" + " " + (verHighvalue.X) + " " + (verHighvalue.Y) + " ";
                                if (!requireInvertedAxes)
                                    cDirectionV = !cap.visible ? "" : "M" + " " + (verHighvalue.X) + " " + (verHighvalue.Y) + " " + "L" + " " + (verHighCapX1) + " " + (verHighvalue.Y) + " " + "M" + " " + (verHighvalue.X) + " " + (verHighvalue.Y) + " " + "L" + " " + (verHighCapX2) + " " + (verHighvalue.Y) + " ";
                                else
                                    cDirectionV = !cap.visible ? "" : "M" + " " + (verHighvalue.X) + " " + (verHighvalue.Y) + " " + "L" + " " + (verHighvalue.X) + " " + (verHighCapX1) + " " + "M" + " " + (verHighvalue.X) + " " + (verHighvalue.Y) + " " + "L" + " " + (verHighvalue.X) + " " + (verHighCapX2) + " ";
                            var eDirection = eDirectionV,cDirection = cDirectionV;
                    }
                    if (mode == 'horizontal' || mode == 'both') {
                        if (type != 'standardDeviation')                        //horizontal mode for both direction
                            eDirectionH = "M" + " " + (centervalueX) + " " + (centervalueY) + " " + "L" + " " + (horHighvalue.X) + " " + (horHighvalue.Y) + " ";
                        else if (type == 'standardDeviation')
                            eDirectionH =  "M" + " " + (horCentervalue.X) + " " + (horCentervalue.Y) + " " + "L" + " " + (horHighvalue.X) + " " + (horHighvalue.Y) + " " ;
                        if (!requireInvertedAxes)
                            cDirectionH = !cap.visible ? "" : "M" + " " + (horHighvalue.X) + " " + (horHighvalue.Y) + " " + "L" + " " + (horHighvalue.X) + " " + (horHighCapY1) + " " + "M" + " " + (horHighvalue.X) + " " + (horHighvalue.Y) + " " + "L" + " " + (horHighvalue.X) + " " + (horHighCapY2) + " " ;
                        else 
                            cDirectionH = !cap.visible ? "" : "M" + " " + (horHighvalue.X) + " " + (horHighvalue.Y) + " " + "L" + " " + (horHighCapY1) + " " + (horHighvalue.Y) + " " + "M" + " " + (horHighvalue.X) + " " + (horHighvalue.Y) + " " + "L" + " " + (horHighCapY2) + " " + (horHighvalue.Y) + " ";
                        eDirection = eDirectionH,cDirection = cDirectionH;
                    }
                    if (mode == 'both') {
                        eDirectionH += eDirectionV,cDirectionH += cDirectionV;
                        eDirection = eDirectionH,cDirection = cDirectionH;
                    }
                }
          // drawing minus direction
                else
                {
                    if (mode == 'vertical' || mode == 'both') {             //vertical mode for both direction
                        if (type != 'standardDeviation') 
                             eDirectionV =  "M" + " " + (centervalueX) + " " + (centervalueY) + " " + "L" + " " + (verLowvalue.X) + " " + (verLowvalue.Y) + " ";
                        else if (type == 'standardDeviation') 
                            eDirectionV =  "M" + " " + (verCentervalue.X) + " " + (verCentervalue.Y) + " " + "L" + " " + (verLowvalue.X) + " " + (verLowvalue.Y) + " ";
                           if (!requireInvertedAxes)
                                cDirectionV = !cap.visible ? "" : "M" + " " + (verLowvalue.X) + " " + (verLowvalue.Y) + " " + "L" + " " + (verLowCapX1) + " " + (verLowvalue.Y) + " " + "M" + " " + (verLowvalue.X) + " " + (verLowvalue.Y) + " " + "L" + " " + (verLowCapX2) + " " + (verLowvalue.Y) + " ";
                            else
                                cDirectionV = !cap.visible ? "" :  "M" + " " + (verLowvalue.X) + " " + (verLowvalue.Y) + " " + "L" + " " + (verLowvalue.X) + " " + (verLowCapX1) + " " + "M" + " " + (verLowvalue.X) + " " + (verLowvalue.Y) + " " + "L" + " " + (verLowvalue.X) + " " + (verLowCapX2) + " ";
                        var eDirection = eDirectionV, cDirection = cDirectionV;
                    }
                    if (mode == 'horizontal' || mode == 'both') {
                        if (type != 'standardDeviation')                        //horizontal mode for both direction
                            eDirectionH =  "M" + " " + (centervalueX) + " " + (centervalueY) + " " + "L" + " " + (horLowvalue.X) + " " + (horLowvalue.Y) + " ";
                        else if (type == 'standardDeviation')
                            eDirectionH =  "M" + " " + (horCentervalue.X) + " " + (horCentervalue.Y) + " " + "L" + " " + (horLowvalue.X) + " " + (horLowvalue.Y) + " ";
                        if (!requireInvertedAxes)
                            cDirectionH = !cap.visible ? "" : "M" + " " + (horLowvalue.X) + " " + (horLowvalue.Y) + " " + "L" + " " + (horLowvalue.X) + " " + (horLowCapY1) + " " + "M" + " " + (horLowvalue.X) + " " + (horLowvalue.Y) + " " + "L" + " " + (horLowvalue.X ) + " " + (horLowCapY2) + " ";
                        else
                            cDirectionH = !cap.visible ? "" : "M" + " " + (horLowvalue.X) + " " + (horLowvalue.Y) + " " + "L" + " " + (horLowCapY1) + " " + (horLowvalue.Y) + " " + "M" + " " + (horLowvalue.X) + " " + (horLowvalue.Y) + " " + "L" + " " + (horLowCapY2) + " " + (horLowvalue.Y) + " ";
                        eDirection = eDirectionH, cDirection = cDirectionH;
                    }
                    if (mode == 'both') {
                        eDirectionH += eDirectionV,cDirectionH += cDirectionV;
                        eDirection = eDirectionH,cDirection = cDirectionH;
                    }
                }
                                                 
                var errorBarOptions = {             //error bar path creation
                    'id': chartobj.svgObject.id + '_ErrorBar' + '_' + seriesIndex + '_Point' + pointIndex,
                    'd': eDirection,
                    'stroke': fill,
                    'stroke-width': errorOptions.width,
                    'opacity': errorOptions.opacity
                };
                var errorBarCapOptions = {       //error bar cap creation
                    'id': chartobj.svgObject.id + '_ErrorBarCap' + '_' + seriesIndex + '_Point' + pointIndex,
                    'd': cDirection,
                    'stroke':capFill,
                    'stroke-width':capWidth
                }
        //canvas rendering
                if (chartobj.model.enableCanvasRendering) {
                    this.svgRenderer.ctx.rect(areaBounds.X, areaBounds.Y, areaBounds.Width, areaBounds.Height);
                    this.svgRenderer.ctx.clip();
                    chartobj.svgRenderer.drawPath(errorBarOptions, null);              //To draw error bar for canvas
                    chartobj.svgRenderer.drawPath(errorBarCapOptions, null);           //To drae error bar cap for canvas
                }
                else {                                        //svg rendering
                    chartobj.svgRenderer.drawPath(errorBarOptions, errorBarPointGroup);
                    chartobj.svgRenderer.drawPath(errorBarCapOptions, errorBarPointGroup);
                    chartobj.svgRenderer.append(errorBarPointGroup, errorBarElement);
                }
            }
        }
        //append with series group
         chartobj.svgRenderer.append(errorBarElement, chartobj.gSeriesEle);
        //clip-path 
         BoldBIDashboard.EjSvgRender.utils._drawAxesBoundsClipPath(errorBarElement,currentseries,chartobj);
    },
     
    meanCalculation:function(mode,visiblePoints)
    {
        var temp = temp1 = 0, total, verTotal, horTotal, verMean, horMean, ded,i,
            eachDev, squareEachDev, squareTotal, verEachDev, horEachDev,
            verSquareEachDev, verSquareTotal, horSquareTotal, horSquareTotal,
            verStandardMean, horStandardMean, verStandSquareRoot,
            horStandSquareRoot, values, len = visiblePoints.length;
        for (i = 0; i < len; i++) {
            if (mode == 'vertical') {             //vertical mode total calculation
                total = temp + visiblePoints[i].y;
                temp = total;
            }
            else if (mode == 'horizontal') {    //horizontal mode total calculation 
                total = temp1 + visiblePoints[i].xValue;
                temp1 = total;
            }
            else {                     //both mode  total calculation
                 verTotal = temp + visiblePoints[i].y;
                 temp = verTotal;
                 horTotal = temp1 + visiblePoints[i].xValue;
                 temp1 = horTotal;
            }
        }
         verMean = temp / len;
         horMean = temp1 / len;
         ded = len - 1;
        for (i = 0; i < len; i++) {
            if (mode == 'vertical') {
                eachDev = visiblePoints[i].y - verMean;
                squareEachDev = Math.pow(eachDev, 2);
                squareTotal = temp + squareEachDev;
                temp = squareTotal;
            }
            else if (mode == 'horizontal') {
                eachDev = visiblePoints[i].xValue - horMean;
                squareEachDev = Math.pow(eachDev, 2);
                squareTotal = temp1 + squareEachDev;
                temp1 = squareTotal;
            }
            else {
                verEachDev = visiblePoints[i].y - verMean;
                verSquareEachDev = Math.pow(verEachDev, 2);
                verSquareTotal = temp + verSquareEachDev;
                temp = verSquareTotal;
                horEachDev = visiblePoints[i].xValue - horMean;
                horSquareEachDiv = Math.pow(horEachDev, 2);
                horSquareTotal = temp1 + horSquareEachDiv;
                temp1 = horSquareTotal;
            }
        }
        verStandardMean = temp / ded;
        verStandSquareRoot = Math.sqrt(verStandardMean);
        horStandardMean = temp1 / ded;
        horStandSquareRoot = Math.sqrt(horStandardMean);
        values = { verStandSquareRoot: verStandSquareRoot, horStandSquareRoot: horStandSquareRoot, verMean: verMean, horMean: horMean }
        return values;
    },
    renderCap:function(cap,mode,values,values1,requireInvertedAxes)
    {
        //declaration
        var canvasX, canvasY, capLen, verHighvalue,
            verLowvalue, horHighvalue, horLowvalue,
            verHighCapX1, verHighCapX2, verLowCapX1,
            verLowCapX2, horHighCapY1, horHighCapY2,
            horLowCapY1, horLowCapY2,capValues;
        canvasX = this.canvasX;
        canvasY = this.canvasY;
        capLen = cap.length / 2;
        if (mode == 'vertical' || mode == 'both') {
            verHighvalue = values.verHighvalue;
            verLowvalue = values.verLowvalue;
        }
        if (mode == 'horizontal' || mode == 'both') {
            horHighvalue = values1.horHighvalue;
            horLowvalue = values1.horLowvalue;
        }
        if (mode == 'vertical' || mode == 'both') {
            if (!requireInvertedAxes) {
                 verHighCapX1 = verHighvalue.X+canvasX - capLen,
                 verHighCapX2 = verHighvalue.X+canvasX + capLen,
                 verLowCapX1 = verLowvalue.X+canvasX- capLen,
                 verLowCapX2 = verLowvalue.X+canvasX + capLen;
            }
            else {
                verHighCapX1 = verHighvalue.Y+canvasY + capLen;
                verHighCapX2 = verHighvalue.Y+canvasY - capLen;
                verLowCapX1 = verLowvalue.Y+canvasY + capLen;
                verLowCapX2 = verLowvalue.Y+canvasY - capLen;
            }
        }
        if (mode == 'horizontal' || mode == 'both') {
            if (!requireInvertedAxes) {
                 horHighCapY1 = horHighvalue.Y+canvasY - capLen,
                 horHighCapY2 = horHighvalue.Y+canvasY + capLen,
                 horLowCapY1 = horLowvalue.Y+canvasY - capLen,
                 horLowCapY2 = horLowvalue.Y+canvasY + capLen;
            }
            else {
                horHighCapY1 = horHighvalue.X+canvasX + capLen;
                horHighCapY2 = horHighvalue.X+canvasX - capLen;
                horLowCapY1 = horLowvalue.X+canvasX + capLen;
                horLowCapY2 = horLowvalue.X+canvasX - capLen;
            }
        }
            capValues = { verHighCapX1: verHighCapX1, verHighCapX2: verHighCapX2, verLowCapX1: verLowCapX1, verLowCapX2: verLowCapX2, horHighCapY1: horHighCapY1, horHighCapY2: horHighCapY2, horLowCapY1: horLowCapY1, horLowCapY2: horLowCapY2 }
        return capValues;
    },
	
	drawDisplayText: function (series, options, params){
	    // method to draw text 
	   
	        var chartObj = this;
			var point1;
			var type = options.type.toLowerCase();
	        var areatype = chartObj.model.AreaType.toLowerCase();
	        var regiontype = BoldBIDashboard.seriesTypes[type].prototype.isRegion;
	        var drawtype = options.drawType.toLowerCase();
	        var pointMarker;
	        var seriesIndex = bbdesigner$.inArray(options, chartObj.model._visibleSeries);
	        if (BoldBIDashboard.util.isNullOrUndefined(chartObj.model.regionCount))
                chartObj.model.regionCount = -1;	        
	         
            var isCanvas = chartObj.model.enableCanvasRendering;
            var isPolar = chartObj.model.AreaType.toLowerCase() == 'polaraxes';
            bbdesigner$.each(options._visiblePoints, function (pointIndex, point) {
                var type = chartObj.model.series[seriesIndex].type.toLowerCase();
                pointMarker = point.marker;
                if ((areatype == "polaraxes" && drawtype == "column") || regiontype && type != "rangearea" && type != "splinerangearea")
                    point1 = point.symbolLocation;
                else
                    point1 = (areatype != "polaraxes")
                    ? BoldBIDashboard.EjSvgRender.utils._getPoint(point, options) : BoldBIDashboard.EjSvgRender.utils.TransformToVisible(options, point.xValue, point.y, chartObj)
                if (options.marker.dataLabel.responsiveVisibility && point.visible && ((pointMarker && pointMarker.dataLabel && pointMarker.dataLabel.visible) || (!pointMarker || !pointMarker.dataLabel) && options.marker.dataLabel.visible)) {
                    if (regiontype)
                        chartObj.model.regionCount++;


                    //we have reset the chartRegions array based on the zooming points for column and stackingColumn series only
                    if ((chartObj.zoomed || options.xAxis._scrollBar) && (type == "column" || type == "stackingcolumn" || type == "stackingcolumn100")) {
                        for (var i = 0; i < chartObj.model.chartRegions.length; i++) {
                            if (seriesIndex == chartObj.model.chartRegions[i].SeriesIndex && pointIndex == chartObj.model.chartRegions[i].Region.PointIndex) {
                                if (isCanvas && chartObj.model.AreaType == "cartesianaxes") {
                                    chartObj.svgRenderer.ctx.save();
                                    chartObj.svgRenderer.ctx.beginPath();
                                    if (!chartObj.model.requireInvertedAxes) // checked for bar and stackingbar
                                        chartObj.svgRenderer.ctx.rect(options.xAxis.x, options.yAxis.y, options.xAxis.width, options.yAxis.height);
                                    else
                                        chartObj.svgRenderer.ctx.rect(options.yAxis.x, options.xAxis.y, options.yAxis.width, options.xAxis.height);
                                    chartObj.svgRenderer.ctx.clip();
                                    series.drawDataLabel(options, pointIndex, point, point1.X, point1.Y, i, params);
                                    chartObj.svgRenderer.ctx.restore();
                                }
                                else
                                    series.drawDataLabel(options, pointIndex, point, point1.X, point1.Y, i, params);
                            }
                        }
                    }
                    else {
                        if (isCanvas && chartObj.model.AreaType == "cartesianaxes") {
                            chartObj.svgRenderer.ctx.save();
                            chartObj.svgRenderer.ctx.beginPath();
                            if (!chartObj.model.requireInvertedAxes) // checked for bar and stackingbar
                                chartObj.svgRenderer.ctx.rect(options.xAxis.x, options.yAxis.y, options.xAxis.width, options.yAxis.height);
	                        else
	                            chartObj.svgRenderer.ctx.rect(options.yAxis.x, options.xAxis.y, options.yAxis.width, options.xAxis.height);
	                        chartObj.svgRenderer.ctx.clip();
							//Check regions for column type, bar type and waterfall series
							if(chartObj.model.chartRegions[chartObj.model.regionCount] || (type.indexOf('column')==-1 && type.indexOf('bar')==-1 && type.indexOf('waterfall')==-1)){
								series.drawDataLabel(options, pointIndex, point, point1.X, point1.Y, chartObj.model.regionCount, params);
								if (type == "rangecolumn" || type == "rangearea" || type == "splinerangearea") {
									point.y = point.low;
                                    series.drawDataLabel(options, pointIndex, point, point1.X, point1.Y, chartObj.model.regionCount, params);
                                    point.y = point.high;
                                }
                            }
                            chartObj.svgRenderer.ctx.restore();
                        }
                        else {
                            if (isCanvas && isPolar) {
                                chartObj.svgRenderer.ctx.save();
                                chartObj.svgRenderer.ctx.beginPath();
                                chartObj.svgRenderer.ctx.arc(chartObj.model.centerX, chartObj.model.centerY, chartObj.model.Radius, 0, 2 * Math.PI, false);
                                chartObj.svgRenderer.ctx.clip();
                                point1.X -= chartObj.canvasX;
                                point1.Y -= chartObj.canvasY;
                            }
                            if ((type == "column" || type == "stackingcolumn" || type == "stackingcolumn100")) {
                                if (chartObj.model.chartRegions[chartObj.model.regionCount])
                                    series.drawDataLabel(options, pointIndex, point, point1.X, point1.Y, chartObj.model.regionCount, params);
                            }
                            else {
                                series.drawDataLabel(options, pointIndex, point, point1.X, point1.Y, chartObj.model.regionCount, params);
                            }
                            if (type == "rangecolumn" || type == "rangearea" || type == "splinerangearea") {
                                point.y = point.low;
                                series.drawDataLabel(options, pointIndex, point, point1.X, point1.Y, chartObj.model.regionCount, params);
                                point.y = point.high;
                            }
                            if (isCanvas && isPolar)
                                chartObj.svgRenderer.ctx.restore();
                        }
                    }
                }
            });
	},
	
	// method to avoid collision between data labels 
	cartesianSmartLabels: function (currentSeries, points, seriesIndex) {
        // declaration
	    var length = points.length;
	    var count = 0;
	    connectorFlag = false;
	    this.processCount = 1;
	    this.posObj = {
	        top: [], rightTop: [],
	        left : [], leftTop : [],
	        right : [], rightTop : [],
	        rightBottom : [], leftBottom : [],
	        bottom: []
	    };
		var markerWidth, markerHeight, i, d, c, currentPoint, location,
		ele, leftValue, topValue, seriesColl = this.model.series, series, serLength = seriesColl.length;
	    // loop to store marker region
	    for (d = 0; d < serLength; d++) {
		  series = seriesColl[d];
		  if(series.visibility.toLowerCase() == "visible"){			
		    markerWidth = series.marker.size.width;
	        markerHeight = series.marker.size.height;
	        if (series.marker.visible) {
	            for (c = 0; c < series._visiblePoints.length; c++) {
	                currentPoint = series._visiblePoints[c];
					location = currentPoint.location;
	                this.model.markerRegion[this.model.markerRegion.length] = { seriesIndex: d, xPos: location.X + this.canvasX, yPos: location.Y + this.canvasY, width: markerWidth, height: markerHeight };
	            }
	        }
		  }
	    }
		
		var currentPoint, j, padding = 10, diff;
		var areaBounds = this.model.m_AreaBounds;
		var width, height, xPos, yPos;
		for (j=0; j< length; j++){   // to reposition the partially visible data labels
		    currentPoint = points[j];
			currentPoint.connectorFlag = false;
			currentPoint.newConnectorFlag = false;
			currentPoint.hide = false;
			xPos = currentPoint.xPos; yPos = currentPoint.yPos;
			width = currentPoint.width; height = currentPoint.height;
		    if (xPos - width/2 < 0 && xPos > -width/2){
		         diff = xPos - width/2;
		         currentPoint.textOptions.x = currentPoint.xPos = xPos + Math.abs(diff) + 10;
				 currentPoint.newConnectorFlag  = true;
		    }
			if (xPos + width/2 > areaBounds.Width && xPos + width/2 < areaBounds.Width + width/2){
			     diff = xPos - width/2;
		         currentPoint.textOptions.x = currentPoint.xPos = areaBounds.Width - width/2 -10;
				 currentPoint.newConnectorFlag  = true;
			}
		    if (yPos + width/2 > areaBounds.Height && yPos + height/2 < areaBounds.Height + height/2){
			     diff = yPos + height/2 - areaBounds.Height;
		         currentPoint.yPos = yPos - diff - 10 ;
				 currentPoint.textOptions.y = currentPoint.yPos + 5;
				 currentPoint.newConnectorFlag  = true;
			}
			 if (yPos - height/2 < 0 && yPos > -height/2){
		         diff = yPos - height/2;
		         currentPoint.yPos = currentPoint.yPos + Math.abs(diff) + 10;
				 currentPoint.textOptions.y = currentPoint.yPos +5; 
				 currentPoint.newConnectorFlag  = true;
		    }
		}
		
	    // loop to compare the points
	    for (i = 0; i < length; i++) {
	        if (!BoldBIDashboard.util.isNullOrUndefined(points[i].yPos))
	          this.model.allPoints[this.model.allPoints.length] = points[i];
		    else
		      continue;
	        connectorFlag = false;
	        this.compareDataLabels(i, points, count, this.processCount); 
	        currentPoint = points[i];
	        currentPoint.connectorFlag = connectorFlag; // flag to draw connector lines
	        if (points[i].dataLabeltemplate) {    // for repositioning data label template
	            ele = bbdesigner$("#" + points[i].id);
	            leftValue = points[i].xPos;
	            topValue = !this.model.enableCanvasRendering ? points[i].yPos : points[i].yPos + this.model.m_AreaBounds.Y;
	            ele.css("left", leftValue).css("top", topValue);
	            if (this.model.AreaType == "cartesianaxes") {   // to avoid template rendering outside area bounds
	                areaBounds = this.model.m_AreaBounds;
	                xPosition = areaBounds.X + (this.model.requireInvertedAxes ? currentSeries.yAxis.plotOffset : currentSeries.xAxis.plotOffset);
	                yPosition = currentSeries.yAxis.y;
	                width = points[i].width;
	                height = points[i].height;
	                if ((leftValue > xPosition + areaBounds.Width || leftValue + width < xPosition || topValue + height < yPosition || topValue + height > areaBounds.Y + areaBounds.Height) ||
                        (this.zoomed && (leftValue < xPosition || topValue < yPosition || leftValue > xPosition + areaBounds.Width || topValue > yPosition + areaBounds.Height)))
	                    ele.remove();
	            }
	        }
	        else {
	            // to store data label position for furture processing
				this.storeDataLabelPositions (currentPoint);
	        }
	    }
	},
	
	storeDataLabelPositions: function (currentPoint){
	  var position = currentPoint.position;
	  var posObj = this.posObj;
	  switch(position){
				case "top":
				    posObj.top[this.processCount - 1] = currentPoint;
					this.processCount = 1;
					break;
				case "rightTop":
				    posObj.rightTop[this.processCount - 1] = currentPoint;
					this.processCount = 1;
					break;
				case "right":
				    posObj.right[this.processCount - 1] = currentPoint;
					this.processCount = 1;
					break;
				case "rightBottom":
				    posObj.rightBottom[this.processCount - 1] = currentPoint;
					this.processCount = 1;
					break
				case "bottom":
				    posObj.bottom[this.processCount - 1] = currentPoint;
					this.processCount = 1;
					break;
				case "left":
				    posObj.left[this.processCount - 1] = currentPoint;
					this.processCount = 1;
					break;
				case "leftBottom":
				    posObj.leftBottom[this.processCount - 1] = currentPoint;
					this.processCount = 1;
					break;
				case "leftTop":
				    posObj.leftTop[this.processCount - 1] = currentPoint;
					break;
				}
	},
	
	// method to avoid collision between data labels  - column series type
	cartesianColumnSmartLabels: function (currentSeries, points, seriesIndex) {
	    var length = points.length;
	    var count = 0;
	    connectorFlag = false;
	    this.processCount = 1;
		var i, currentPoint, ele;
	    // loop to compare the points
	    for (i = 0; i < length; i++) {
	        if(!BoldBIDashboard.util.isNullOrUndefined(points[i].yPos)){
			    points[i].hide = false;
	            this.model.allPoints[this.model.allPoints.length] = points[i];
			}
	        else
	            continue;
	        if (currentSeries._enableSmartLabels) {
	            connectorFlag = false;
	            this.compareColumnDataLabels(currentSeries, i, points, count, this.processCount);
	        }
	        currentPoint = currentSeries.points[i];
	        if (points[i].dataLabeltemplate) {
	            ele = bbdesigner$("#" + points[i].id);
	            ele.css("left", points[i].xPos).css("top", points[i].yPos);
	        }
	    }
	},

	compareColumnDataLabels: function (currentSeries, i, points, count, processCount) {
	    var length = this.model.allPoints.length - 1;
		var prevLabel, currentLabel, padding;
		var type = currentSeries.type.toLowerCase();
	    for (var j = 0; j < length; j++) {
	        prevLabel = this.model.allPoints[j];
	        currentLabel = this.model.allPoints[this.model.allPoints.length - 1];
	        this.currentCollideLabel = prevLabel;
	        padding = 5;
	        collide = this.isCollide(prevLabel, currentLabel);
	        textPosition = currentSeries.marker.dataLabel.textPosition;
	        if (collide.state) {  
			   currentLabel.hide = true;
	        }
	    }
	},
	// method to compare data lables with chart region
	compareColumnDataLabelsRegion: function () {
	    var regions = this.model.chartRegions, type, i, j;	
	    for (i = 0; i < regions.length; i++) {
			type = regions[i].type.toLowerCase();
	        for (j = 0; j < this.model.allPoints.length; j++) {
	            if ((type.indexOf("column") > -1 || type.indexOf("bar") > -1) && !this.model.allPoints[j].hide) {
	                collide = this.isCollideRegion(regions[i], this.model.allPoints[j]);
	                if (collide.state) 
	                    this.model.allPoints[j].hide = true;
	            }
	        }
	    }
	},
    // method to comapare data labels and place without collision
	compareDataLabels: function (i, points, count, processCount) {
	    var length = this.model.allPoints.length;
		var j, padding, prevLabel, currentLabel;
	    for (j = 0; j < length; j++) {
	        prevLabel = this.model.allPoints[j];
	        currentLabel = this.model.allPoints[length - 1];
	        this.currentCollideLabel = prevLabel;
	        padding = 10;
	        collide = this.isCollide(prevLabel, currentLabel, j);
	        if (collide.state) {
               currentLabel.hide = true;
	        }
	    }
	},
	isCollideRegion: function (a, b) {               // method to find collision between region and data label
	    // declaration
	    var aIndex = this.model.series[a.SeriesIndex].points[a.Region.PointIndex],
	    bIndex = this.model.series[b.seriesIndex].points[b.index];
	    width = 0, height = 0, state = false, aVal = a.Region.Bounds,
		areaBounds = this.model.m_AreaBounds,
		anchor = this.model.series[b.seriesIndex].marker.dataLabel.textAnchor.toLowerCase();
		pointWidth = (anchor == "middle") ? (b.width/2) : (anchor == "end" ? 0 : b.width);
		beforeWidth = (anchor == "middle") ? (b.width/2) : (anchor == "end" ? b.width : 2);	
	        if (aIndex != bIndex) {
	            var aBounds = {
	                "X": aVal.X - areaBounds.X,
	                "Y": aVal.Y - areaBounds.Y,
	                "Width": aVal.Width,
	                "Height": aVal.Height
	            };
	            if (b.symbolName != "None") {
	                rectLeft = b.xPos;
	                rectRight = b.xPos + b.width;
	                rectTop = b.yPos - b.height / 2;
	                rectBottom = b.yPos + b.height / 2;
	            }
	            else {
	                rectLeft = b.textOptions.x - beforeWidth;
	                rectRight = b.textOptions.x + pointWidth;
                    rectTop = b.textOptions.y - (b.height / 2); // (JS-63849)
	                rectBottom = b.textOptions.y;
	            }
	            state = ((aBounds.X <= rectRight) && ((aBounds.X + aBounds.Width) >= rectLeft) &&
                         (aBounds.Y <= rectBottom) && ((aBounds.Y + aBounds.Height) >= rectTop));
	        } 
			
			if (aIndex == bIndex) {
				if ((this.model.series[b.seriesIndex].type.toLowerCase()).indexOf("column") != -1){
					if (aVal.Width <= b.width)
						state = true;
				} else if ((this.model.series[b.seriesIndex].type.toLowerCase()).indexOf("bar") != -1){
					if (aVal.Height <= b.height)
						state = true;
				}	
			}
	    return { state: state };
	},
     // method to draw connector lines for data labels in cartesian axis
	drawConnectorLines: function (seriesIndex, index, currentPoint) {
	    var bottom = false;
		var drawConnectorLine = true;
		var xPos = currentPoint.xPos;
		var yPos = currentPoint.yPos;
		var areaBounds = this.model.m_AreaBounds;
	    var location = currentPoint.location ? currentPoint.location : currentPoint.symbolLocation;
	    if (location.Y > currentPoint.textOptions.y)
	        var endY = (currentPoint.textOptions.y);                         // top
	    else {
            bottom = true
	        endY = (currentPoint.textOptions.y - currentPoint.height / 2);  // bottom
	    }
	    if (currentPoint.dataLabeltemplate) {                               // for template
	        endY = currentPoint.yPos - this.model.m_AreaBounds.Y + currentPoint.height ;
	        currentPoint.textOptions.x = currentPoint.textOptions.x - this.model.m_AreaBounds.X + currentPoint.width/4 + this.canvasX;
	    } else if (xPos > areaBounds.Width || (xPos + currentPoint.width) < 0 ||
             		yPos - currentPoint.height > areaBounds.Height || yPos+ currentPoint.height < 0)
		    drawConnectorLine = false;
		if (drawConnectorLine){
	      var connectorDirection = "M" + " " + (location.X + this.canvasX) + " " + (location.Y + this.canvasY) + " " + "L" + " " + (currentPoint.textOptions.x) + " " + (endY);
	      var connectorLineValues = this.model.series[seriesIndex].marker.dataLabel.connectorLine;
	      var stroke = !BoldBIDashboard.util.isNullOrUndefined(connectorLineValues.color) ? connectorLineValues.color : this.model.series[seriesIndex].fill;
	      var connectorOptions = {
	        'id': this.svgObject.id +  "_dataLabelConnectorLine_series" + seriesIndex + "_" + index,
	        'stroke': stroke,
	        'stroke-width': connectorLineValues.width,
	        'd': connectorDirection
	      };
	      this.model.series[seriesIndex].connectorLines = true;
	      this.svgRenderer.drawPath(connectorOptions, this.gConnectorEle[seriesIndex]);
		}
	},

    // to reset the data label values back 
	resetValues: function (currentPoint) {
	    currentPoint.textOptions.y = currentPoint.dataLabel.textY;
	    currentPoint.yPos = currentPoint.dataLabel.y;
	    currentPoint.textOptions.x = currentPoint.dataLabel.textX;
	    currentPoint.xPos = currentPoint.dataLabel.x
	},

	// to detect collision
	isCollide: function (a, b, j) {
	    if (!a.hide){
	    var width = 0;
	    var height = 0;
		var state = false, markerState = false;
		var borderWidth = a.seriesIndex ? this.model.series[a.seriesIndex].marker.dataLabel.border.width : 0;
		borderWidth += b.seriesIndex ? this.model.series[b.seriesIndex].marker.dataLabel.border.width : 0;
		var series = this.model.series;
		var firstSeries = series[a.seriesIndex];
		var secondSeries = series[b.seriesIndex];
		var aXPos = a.xPos , aYPos= a.yPos, bXPos = b.xPos, bYPos = b.yPos;
		if (!this.model.requireInvertedAxes){
		    a.xPos += firstSeries.xAxis.x, a.yPos += firstSeries.yAxis.y,
            b.xPos += secondSeries.xAxis.x, b.yPos += secondSeries.yAxis.y;		
		} else{
		    a.xPos += firstSeries.xAxis.y, a.yPos += firstSeries.yAxis.x,
            b.xPos += secondSeries.xAxis.y, b.yPos += secondSeries.yAxis.x;	
		}
		
	    if (a != b) {
			firstText = a.drawText.toString();
			secondText = b.drawText.toString();
			if(firstText.replace(/\s/g, "").length && secondText.replace(/\s/g, "").length) // to check text between double quotes
	        state = !(                    // to compare data labels
            ((a.yPos + a.height) < (b.yPos)) ||
            (a.yPos > (b.yPos + b.height)) ||
            ((a.xPos + a.width / 2 + borderWidth) < b.xPos - b.width / 2) ||
            (a.xPos - a.width/2 > (b.xPos + b.width/2)));
	        if (state) {
	            height = (a.yPos + a.height) - b.yPos;
	            width = (a.xPos + a.width) - b.xPos;
	        }
			a.xPos = aXPos, a.yPos = aYPos;
	    }
		
		a.xPos = aXPos, a.yPos = aYPos;
		b.xPos = bXPos, b.yPos = bYPos;
		// to hide the partially visible data labels
	   } else 
	      state = false;
		  
	    return { state: state, width: width, height: height };
	},

	drawAccDisplayText: function (series, options, seriesIndex) {
	    // method to draw text 
	    var chartObj = this, legend = chartObj.model.legend, 
		    legendPosition = !BoldBIDashboard.util.isNullOrUndefined(legend.responsivePosition) ? legend.responsivePosition : legend.position.toLowerCase();
		var pointsLength = options._visiblePoints.length;
		chartObj.firstStartAngle = [];
	    
	        if ((options.type.toLowerCase() != "pyramid" && options.type.toLowerCase() != "funnel") && (options.leftsidePoints.length > 0 || options.rightsidePoints.length > 0)) {
				var rightsidePointsLength = options.rightsidePoints.length;
	            var leftsidePointsLength = options.leftsidePoints.length;

	            for (var i = 0; i < rightsidePointsLength; i++) {
	                options.rightsidePoints[i].index = i;
	               series.drawDataLabelAcc(chartObj, options, options.rightsidePoints[i].pointIndex, options.rightsidePoints[i], seriesIndex)
	            }
	            for (var j = leftsidePointsLength - 1; j >= 0; j--) {
	                options.leftsidePoints[j].index = j;
	                series.drawDataLabelAcc(chartObj, options, options.leftsidePoints[j].pointIndex, options.leftsidePoints[j],seriesIndex)
	            }
	        }
	        else {
	            if (legendPosition == "left" || legendPosition == "right")
	                options._legendBounds = series._getLegendBounds();//get legned bounds to place the pie datalabel over the legend
	             for (var i = 0; i < pointsLength; i++) {
	                 options._visiblePoints[i].index = i;
	                if (isNaN(options._visiblePoints[i].startAngle) && options.type.toLowerCase() == "pie") continue;
	                series.drawDataLabelAcc(chartObj, options, i, options._visiblePoints[i],seriesIndex)
	             }
	        }
			 if (options.type.toLowerCase() == "pyramid" || options.type.toLowerCase() == "funnel")
                {
	        this.svgRenderer.append(this.gConnectorEle, this.gSeriesEle);

	        this.svgRenderer.append(this.gSymbolGroupEle, this.gSeriesEle);

	        this.svgRenderer.append(this.gDataLabelEle, this.gSeriesEle);

	        this.svgRenderer.append(this.gSeriesTextEle, this.gSeriesEle);


	        this.svgRenderer.append(this.gSeriesEle, this.svgObject);

	        if (!this.vmlRendering)
               this.svgRenderer.append(this.svgObject, this.element)
	           
	            }
	},

    _processOData: function (series) {
        var chart = this,type = series.type.toLowerCase();
        var queryPromise = series.dataSource.executeQuery(series.query);
        queryPromise.done(function (e) {
            chart._processJsonData(e.result, series);
            series.visibility = 'visible';
            bbdesigner$(chart.svgObject).empty();
            bbdesigner$(chart.legendSvgContainer).empty();
            if (chart.model.enableCanvasRendering) {
                chart.svgRenderer.ctx.clearRect(0, 0, chart.svgObject.width, chart.svgObject.height);
                bbdesigner$("#canvas_trackSymbol").remove();
            }

            var redrawChart=true;
            var dec = (type != "pie" || type != "doughnut") ? 0 : chart.model.series.length - 1
            for (var i = dec, cond ; cond = (type != "pie" || type != "doughnut") ? i < chart.model.series.length : i >= 0; (type != "pie" || type != "doughnut") ? i++ : i--) {
                    if (chart.model.series[i].dataSource) {
                        if (chart.model.series[i].visibility == 'hidden') {
                            redrawChart = false;
                            break;
                        }
                    }
                }
            if (redrawChart) {
                chart.draw();
            }
        });
        queryPromise.fail(function (e) {
            series.visibility = 'visible';
            bbdesigner$(chart.svgObject).empty();
            bbdesigner$(chart.legendSvgContainer).empty();
            var redrawChart=true;
            for (var i = 0; i < chart.model.series.length; i++)
                if (chart.model.series[i].dataSource)
                {
                    if (chart.model.series[i].visibility == 'hidden') {
                        redrawChart = false;
                        break;
                    }
                }
            if (redrawChart) {
                chart.draw();
            }
        });
    },
    _processJsonData: function (jsonObj, series) {
	    if(series.points.length > 0)
           series.points.length = 0;
        var xdata = [];
        var dataSource = series.dataSource;
        var xName = series.xName;
        var yNames = series.yName;
        var pointColorMappingName = series.pointColorMappingName;
        var textMappingName = series.marker.dataLabel.textMappingName;
        var pointColorMappingNameValue = [];
        var textMappingNameValue = [];
        var type = series.type.toLowerCase();
        var jsonLength = jsonObj.length, xDataLength, yValuesLength;

        for (var j = 0; j < jsonLength; j++) {
            if (typeof jsonObj[j][xName] == "string" && jsonObj[j][xName].indexOf("/Date(") != -1) {
                jsonObj[j][xName] = new Date(parseInt(jsonObj[j][xName].substr(6)));
                xdata[j] = ((jsonObj[j][xName]) ? jsonObj[j][xName] : j);
            }
            else
                xdata[j]= (jsonObj[j][xName]!=null && jsonObj[j][xName] !=undefined) ? jsonObj[j][xName] : null;
            pointColorMappingNameValue[j] =  (jsonObj[j][pointColorMappingName]!=null && jsonObj[j][pointColorMappingName] !=undefined) ? jsonObj[j][pointColorMappingName] : null;
            textMappingNameValue[j] =  (jsonObj[j][textMappingName]!=null && jsonObj[j][textMappingName] !=undefined) ? jsonObj[j][textMappingName] : null;
        }
        var yValues = [];
        var index = 0;
            if (series._hiloTypes) {
                var yVal = [];
                //For high
                var high = series.high;
                for (var s = 0; s < jsonLength; s++) {
                    yVal[s]=(jsonObj[s][high] === null || jsonObj[s][high] === undefined ? jsonObj[s][high] : parseFloat(jsonObj[s][high]));

                }
                yValues[index] = yVal;
                index = index + 1;
                //For low
                yVal = [];
                var low = series.low;
                for (var l = 0; l < jsonLength; l++) {
                    yVal[l]= (jsonObj[l][low] === null || jsonObj[l][low] === undefined ? jsonObj[l][low] : parseFloat(jsonObj[l][low]));
                }
                yValues[index] = yVal;
                index = index + 1;
                if (series.type.toLowerCase() !== 'hilo') {
                    //For open
                    yVal = [];
                    var open = series.open;
                    for (var h = 0; h < jsonLength; h++) {
                        yVal[h]=(jsonObj[h][open] === null || jsonObj[h][open] === undefined ? jsonObj[h][open] : parseFloat(jsonObj[h][open]));
                    }
                    yValues[index] = yVal;
                    index = index + 1;

                    //For close
                    yVal = [];
                    var close = series.close;
                    for (var mI = 0; mI < jsonLength; mI++) {
                        yVal[mI]=((jsonObj[mI][close] === null || jsonObj[mI][close] === undefined) ? jsonObj[mI][close] : parseFloat(jsonObj[mI][close]));
                    }
                    yValues[index] = yVal;
 index = index + 1;
                    //For volume
                    if (series.volume) {
                        yVal = [];
                        var volume = series.volume;
                        for (var vI = 0; vI < jsonLength; vI++) {
                            yVal[vI]=((jsonObj[vI][volume] === null || jsonObj[vI][volume] === undefined) ? jsonObj[vI][volume] : parseFloat(jsonObj[vI][volume]));
                        }
                        yValues[index] = yVal;
                    }
                }
            }
        if (yNames) {
           
                var yNVal = [];
                for (var yI = 0; yI < jsonLength; yI++) {
                    yNVal[yI]= ((jsonObj[yI][yNames]) ? parseFloat(jsonObj[yI][yNames]) : jsonObj[yI][yNames]);
                }
                yValues[index] = yNVal;
                index = index + 1;
            

            if (series.type.toLowerCase() == 'bubble') {
                yVal = [];
                var size = series.size;
                for (var b = 0; b < jsonLength; b++) {
                    yVal[b]= (jsonObj[b][size] === null || jsonObj[b][size] === undefined ? jsonObj[b][size] : parseFloat(jsonObj[b][size]));
                }
                yValues[index] = yVal;
            }
        }
        xDataLength = xdata.length;
        yValuesLength = yValues.length;
        for (var m = 0; m < xDataLength; m++) {
            series.points[m] = { x: xdata[m], xValue: xdata[m], y: yValues[0][m], YValues: [], fill: pointColorMappingNameValue[m], text: textMappingNameValue[m] };
            if(jsonObj[m].visible != null || jsonObj[m].visible != undefined)
				series.points[m].visible = jsonObj[m].visible;
            if (type == 'bubble') {
                series.points[m].YValues[0] = (yValues[0][m]);
                series.points[m].size = series.points[m].YValues[1] = yValues[1][m];
            }
            else if (series._hiloTypes && yValuesLength > 1) {
                series.points[m].high = series.points[m].YValues[0] = yValues[0][m];
                series.points[m].low = series.points[m].YValues[1] = yValues[1][m];
                if (type != 'hilo' && type != 'rangecolumn' && type != 'waterfall' && yValuesLength > 3) {
                    series.points[m].open = series.points[m].YValues[2] = yValues[2][m];
                    series.points[m].close = series.points[m].YValues[3] = yValues[3][m];
                if (series.volume)
                    series.points[m].volume = series.points[m].YValues[4] = yValues[4][m];
                }
            }
            else {
                series.points[m].YValues[0]=(yValues[0][m]);
            }
        }
    },
    bindTo: function (excludeDataUpdate) {
          bbdesigner$("#" + this.svgObject.id + '_CrosshairVertical').remove();
          bbdesigner$("#" + this.svgObject.id + '_CrosshairHorizontal').remove();
		  bbdesigner$(document).find('[id*="_TrackToolTip"]').remove();// fixed for mobile issue
          bbdesigner$('#template_group_' + this._id).remove();
		  this.model.primaryXAxis._valueType = null;
		  this.model.primaryXAxis.position = null;
		  this.model.primaryYAxis._valueType = null;
		  this.model.primaryYAxis.position = null;
		  this.model.requireInvertedAxes = false;
		  var seriesLength = this.model.series.length,
		  axesLength = this.model.axes.length,
          axis;
         for (var i = 0; i < axesLength; i++)
		  {
             axis = this.model.axes[i];
             axis._valueType = null;
             axis.position = null;
         }
		  if (this.model._axes)
         {
		       axesLength = this.model._axes.length;
		       for (var j = 0; j < axesLength; j++) {
		           axis = this.model._axes[j];
		           axis._valueType = null;
		           axis.position = null;
		           axis.zoomFactor = (axis._pointsLength && axis._pointsLength != axis.virtualPointLength) ? 1 : axis.zoomFactor;
		       }
         }
		  for (var i = 0; i < seriesLength; i++) {
		      var series = this.model.series[i];
		      series.position = null;
		      if (series.fill && this.model.seriesColors && series.fill != this.model.seriesColors[i])
		          this.model.series[i].isFill = true;      
		  }
		  if (this.model.AreaType && (this.model.AreaType == "none" || this.model.AreaType == "cartesianaxes")) {
		      var seriesColl = this.model.series;
			  var point;
			  for(var j = 0;j < seriesColl.length ; j++){
				  var series = seriesColl[j];
		      for (var i = 0; series.points && i < series.points.length; i++) {
		          point = series.points[i]
		          point._visibility = point._visibility ? point._visibility : null;				  
		          if (point.fill && this.model.pointColors && point.fill != this.model.pointColors[i])
		              point.isFill = true;
		          if (!point.isFill)  
		              point.fill = null;
				 if(this.model.rangeColorMapping )
				 { point.isFill = false;
					point.rangeFill = null;
				 }			 
		      }
			}
		  }
          if(this.model.enable3D)
            BoldBIDashboard.Ej3DRender.transform = null;
          if (this.model.series) {
            var series = this.model.series;
            this.setModelProperties(excludeDataUpdate);
            if (!excludeDataUpdate) {
			    var scrollId;
                for (var l = 0; l < bbdesigner$(".e-scrollbar").length; l++) {
                  scrollId = (bbdesigner$(".e-scrollbar")[l].parentElement.id);
                  if (scrollId.indexOf(this._id) > -1 && this._scrollBarEnabled == false && scrollId.indexOf("legend")==-1)
                       bbdesigner$("#"+scrollId).remove();
                }
                for (var i = 0; i < series.length; i++) {
                    if (series[i].visibility == null || series[i].visibility == undefined) {
                        series[i].visibility = 'visible';
                    }
					 if (series[i].type) series[i]._hiloTypes = BoldBIDashboard.seriesTypes[series[i].type.toLowerCase()].prototype.hiloTypes;
                    if (!(series[i].points))
                        series[i].points = [];
                    if (series[i].dataSource) {
                        if (series[i].dataSource instanceof BoldBIDashboard.DataManager) {
                            series[i].visibility = 'hidden';
						    if (BoldBIDashboard.isNullOrUndefined(series[i].query) || !(series[i].query instanceof BoldBIDashboard.Query))
                                series[i].query = BoldBIDashboard.Query();
                            this._processOData(series[i]);
                        } else if (series[i].dataSource.length > 0) {

                            this._processJsonData(series[i].dataSource, series[i]);

                        }
                    }
                }
            }
            if(bbdesigner$(this.svgObject).width()>0)
            this.draw(excludeDataUpdate);
        }



    },

	calculateHeight : function(chart){              // height calculation
	     var bbdesigner$svgObj = bbdesigner$(chart.svgObject);
	     var chartHeight = chart.model.size.height;
         var containerHeight= bbdesigner$(chart.element).height();
         var height = (containerHeight / 100) * parseInt(chartHeight);
		 bbdesigner$svgObj.height(height);
		 return height;
	},
	
	calculateWidth : function(chart){               // width calculation
	       var bbdesigner$svgObj = bbdesigner$(chart.svgObject);
	       var chartWidth = chart.model.size.width;
           var containerWidth = bbdesigner$(chart.element).width();
           var width = (containerWidth / 100) * parseInt(chartWidth);
		   bbdesigner$svgObj.width(width);
		   return width;
	},

     // store the element class logic perform here
	selectedStyle: function (chart) {
	    var selected= bbdesigner$('#' + chart._id).find('[class*="Selection"]');
	    var selection = [];
	    for (var i = 0; i < selected.length; i++) {
	        selection[i] = [];
	        selection[i].id = selected[i].id;
	        selection[i].className = bbdesigner$('#' + selection[i].id).attr('class');
	    }
	    if (bbdesigner$('[id $= Def ]').length > 0) {
	        selection.pattern = bbdesigner$('[id $= Def ]');
	    }

	    return selection;
	},
	
	chartResize: function () {
        var chart = this;
        var bbdesigner$svgObj = bbdesigner$(chart.svgObject);
        var selection = this.selectedStyle(chart);
	    this.removeMultiRect();
        if (this.model.enableCanvasRendering) {
            bbdesigner$('[id*=' + this._id + '_Selection_' + ']').remove();
            bbdesigner$("#canvas_trackSymbol").remove();
            var ctx = chart.svgObject.getContext("2d");
            ctx.clearRect(0, 0, this.svgRenderer.svgObj.width, this.svgRenderer.svgObj.height);
			
			if (typeof chart.model.size.width=="string" && chart.model.size.width.indexOf("%") != -1) {           // to set width 
                var width = chart.calculateWidth(chart);
				this.svgRenderer.svgObj.width = width;
            }
			else
              this.svgRenderer.svgObj.width = bbdesigner$("#" + this._id).width();
            
			if (typeof chart.model.size.height=="string" && chart.model.size.height.indexOf("%") != -1) {          // to set height
                 var height = chart.calculateHeight(chart);
				  this.svgRenderer.svgObj.height = height;
            }
            else
			 this.svgRenderer.svgObj.height = BoldBIDashboard.util.isNullOrUndefined(this.model.size.height) ? "450" : parseInt(bbdesigner$(chart.element).height());
			

        }
        if (this.resizeTO) clearTimeout(this.resizeTO);
        this.resizeTO = setTimeout(function () {
          if (!BoldBIDashboard.util.isNullOrUndefined(chart.model)) {
            if (typeof chart.model.size.width == "string" && chart.model.size.width.indexOf("%") != -1) {
               chart.calculateWidth(chart);
            }
            else
                bbdesigner$svgObj.width(bbdesigner$(chart.element).width());
      
            if (typeof chart.model.size.height == "string" && chart.model.size.height.indexOf("%") != -1) {
                 chart.calculateHeight(chart);
            }
            else
                bbdesigner$svgObj.height(bbdesigner$(chart.element).height());
            if (bbdesigner$(chart.svgObject).width() > 0) {
                bbdesigner$(chart.svgObject).empty();
	        bbdesigner$(chart.legendSvgContainer).empty();
                bbdesigner$('#template_group_' + chart._id).remove();
				bbdesigner$("#annotation_group_" + chart._id).remove();       //to remove annotation from DOM on resize
                chart.disableAnimation();
                for (var j = 0; j < chart.model.series.length; j++)
                    chart.model.series[j].regionAdded = false;
                chart.draw();
                for (var i = 0; i < selection.length; i++) {
                    bbdesigner$('#' + selection[i].id).attr('class', selection[i].className);
                }
                if(selection.pattern)
                    chart.svgRenderer.append(selection.pattern, chart.svgObject);
                if (chart.zoomed && !chart.vmlRendering)
                    chart._enableZoomingButtons();
                chart.enableAnimation();
            }
		  }
        }, 500);

    },
    isDevice: function () {
        return (/mobile|tablet|android|kindle/i.test(navigator.userAgent.toLowerCase()));
        // comment above line temporary. Due to the below code event wont bind for tablet device
        //  return (/mobile|android|kindle/i.test(navigator.userAgent.toLowerCase()));
    },
    bindResizeEvents: function () {
        if (this.model._resizeEventRegistered)
            return 0;
        if (BoldBIDashboard.isTouchDevice() && this._isOrientationSupported())
            this._on(bbdesigner$(window), "orientationchange", this.chartResize);
        else
            this._on(bbdesigner$(window), "resize", this.chartResize);
        this.model._resizeEventRegistered = true;
    },
    removeResizeEvents: function () {
        if (this.model._resizeEventRegistered) {
            if (BoldBIDashboard.isTouchDevice() && this._isOrientationSupported())
                this._off(bbdesigner$(window), "orientationchange", this.chartResize);
            else
				this._off(bbdesigner$(window), "resize", this.chartResize);
            this.model._resizeEventRegistered = false;
        }
    },
	 _isOrientationSupported: function () {
            return ("orientation" in window && "onorientationchange" in window);
    },
    bindEvents: function () {
	   var matched = bbdesigner$.uaMatch(navigator.userAgent),
         browserInfo = BoldBIDashboard.EjSvgRender.utils.browserInfo(),
         isPointer = browserInfo.isMSPointerEnabled,
	     isIE11Pointer = browserInfo.pointerEnabled,	    
         touchStartEvent = isPointer ? (isIE11Pointer ? "pointerdown" : "MSPointerDown") : "touchstart mousedown",
         touchStopEvent = isPointer ? (isIE11Pointer ? "pointerup" : "MSPointerUp") : "touchend mouseup",
         touchMoveEvent = isPointer ? (isIE11Pointer ? "pointermove" : "MSPointerMove") : "touchmove mousemove",
         touchCancelEvent = isPointer ? (isIE11Pointer ? "pointerleave" : "MSPointerOut") : "touchleave mouseleave";
	     this.model.browserInfo = browserInfo;  

	     if ((window.navigator.maxTouchPoints > 1 && window.PointerEvent) || window.PointerEventsPolyfill) { //For IE11 and IE devices that supports pointer events
	         this._on(this.element, "pointerup", this._pointerTouchEnd);
			 this._on(this.element, "pointerleave", this.chartMouseLeave);
	         this._on(this.element, "pointerdown", this.chartMouseDown);
	         this._on(this.element, "pointermove", this.chartMouseMove);
	     }
	     else if (window.TouchEvent)//For chrome, safari and android
	     {	         
	         this._on(this.element, "touchstart", this.chartMouseDown);
	         this._on(this.element, "touchmove", this.chartMouseMove);
	         this._on(this.element, "touchend", this._pointerTouchEnd);	         
	         this._on(bbdesigner$(this.element), "mousedown", this.chartMouseDown);
	         this._on(bbdesigner$(this.element), "mousemove", this.chartMouseMove);
	         this._on(this.element, 'mouseleave', this.chartMouseLeave);
	         this._on(bbdesigner$(document), "mouseup", this.chartMouseUp);	 
	     }        
	     else if (window.navigator.msMaxTouchPoints && window.navigator.msPointerEnabled) { //For IE10
	         this._on(this.element, "MSPointerUp", this._pointerTouchEnd);
	         this._on(this.element, "mouseleave", this.chartMouseLeave);
	         this._on(this.element, "MSPointerDown", this.chartMouseDown);
	         this._on(this.element, "MSPointerMove", this.chartMouseMove);
	     }
	     else {
	         this._on(this.element, touchMoveEvent, this.chartMouseMove);
	         this._on(this.element, touchCancelEvent, this.chartMouseLeave);
	         this._on(bbdesigner$(document), touchStopEvent, this.chartMouseUp);
	         this._on(bbdesigner$(this.element), touchStartEvent, this.chartMouseDown);
	     }
		 this._isSafari = !!navigator.userAgent.match(/Version\/[\d\.]+.*Safari/);	     
	     if ((this.isDevice() && this._isSafari) != true)
			this._on(bbdesigner$(this.element), "click", this.chartMouseClick);	     
	     this._on(bbdesigner$(this.element), "dblclick", this.chartMouseDoubleClick);
	     this._on(bbdesigner$(this.element), "contextmenu", this.chartRightClick);
         if (this.model.enableRightClick)
	         this._on(bbdesigner$(this.element), "contextmenu", this.chartMouseClick);	     


	     if (this.model.canResize || this.model.isResponsive) {
	         this.bindResizeEvents();
	     }
	     var touchAction = this.model.zooming.enable ? 'none' : 'pan-y';

	     bbdesigner$(this.element).css({ 'ms-touch-action': touchAction, 'touch-action': touchAction, 'content-zooming': 'none' }); //disable browser touch action   
	     bbdesigner$(this.element).css({
	     "-webkit-touch-callout": "none", /* iOS Safari */
	     "-webkit-user-select": "none",  /* Chrome/Safari/Opera */ 	     
	     "-moz-user-select": "none",     /* Firefox */
	     "-ms-user-select": "none",     /* Internet Explorer/Edge */
	     "user-select": "none"
	     });
	     var eventName = matched.browser.toLowerCase() == "mozilla" ? (isIE11Pointer ? "mousewheel" : "DOMMouseScroll") : "mousewheel";
	     this._on(this.element, eventName, this.chartMouseWheel);

    },
    calZoomFactors: function (cumulativeScale, origin, currentZoomFactor, currentZoomPos) {
        var calcZoomFactorVal, calcZoomPosition;
        if (cumulativeScale == 1) {
            calcZoomFactorVal = 1;
            calcZoomPosition = 0;
        } else {
            calcZoomFactorVal = BoldBIDashboard.EjSvgRender.utils._minMax(1 / cumulativeScale, 0, 1);
            calcZoomPosition = currentZoomPos + ((currentZoomFactor - calcZoomFactorVal) * origin);
        }
        return { zoomMFactor: calcZoomFactorVal, zoomMPosition: calcZoomPosition };
    },
    doMouseWheelZoom: function (cumulativeScale, origin, axis) {
        if (cumulativeScale >= 1) {
            var calZoomVal = this.calZoomFactors(cumulativeScale, origin, axis.zoomFactor, axis.zoomPosition);
            //calcZoomPos = Math.Round(calcZoomPos, 2);
            if (axis.zoomPosition != calZoomVal.zoomMPosition || axis.zoomFactor != calZoomVal.zoomMFactor) {
                this.zoomed = true;
                axis.zoomPosition = calZoomVal.zoomMPosition;
                axis.zoomFactor = (calZoomVal.zoomMPosition + calZoomVal.zoomMFactor) > 1 ? (1 - calZoomVal.zoomMPosition) : calZoomVal.zoomMFactor;
                return true;
            }
        }

        return false;

    },
    enableAnimation: function () {
        for (var m = 0; m < this.model.series.length; m++) {
            var series = this.model.series[m];
            series.enableAnimation = this.serAnimation[m];
        }
    },
    disableAnimation: function () {
        var chart = this;
        for (var m = 0; m < chart.model.series.length; m++) 
            chart.model.series[m].enableAnimation = false;
        for (var k = 0; k < chart.model.indicators.length; k++) 
            chart.model.indicators[k].enableAnimation = false;
    },
    _removeTrackBall: function () {
        var id = "#" + this.svgObject.id;
        bbdesigner$("#" + this.svgObject.id + "_trackSymbol").remove();
		 bbdesigner$(document).find("#measureTex").remove();
		 if (this.chartCross.visible) {
		     // Visibility is set to hidden
		     var element = bbdesigner$(this.svgObject).find(id + "_AxisCrossToolTip");
        this.svgRenderer._setAttr(bbdesigner$(element), { "visibility": 'hidden' });
		     element = bbdesigner$(this.svgObject).find(id + "_CrosshairVertical");
        this.svgRenderer._setAttr(bbdesigner$(element), { "d": 'M 0 0' });
		     element = bbdesigner$(this.svgObject).find(id + "_CrosshairHorizontal");
        this.svgRenderer._setAttr(bbdesigner$(element), { "d": 'M 0 0' });
		     
        element = bbdesigner$(this.svgObject).find(id + "_TrackAxisToolTip");
        this.svgRenderer._setAttr(bbdesigner$(element), { "visibility": 'hidden'});
        element = bbdesigner$(this.svgObject).find(id + "_Tracker");
        this.svgRenderer._setAttr(bbdesigner$(element), { "d": 'M 0 0'});
        element = bbdesigner$(this.svgObject).find('[id*="_TrackToolTip"]');
        this.svgRenderer._setAttr(bbdesigner$(element), { "visibility": 'hidden' });
        element = bbdesigner$(this.svgObject).find('[id*="_TrackToolTip"]').children();
        this.svgRenderer._setAttr(bbdesigner$(element), { "visibility": 'hidden' });
        bbdesigner$(element).css('visibility', 'hidden');
        element = bbdesigner$(this.svgObject).find('[id*="_trackSymbol_"]');
        this.svgRenderer._setAttr(bbdesigner$(element), { "visibility": 'hidden' });
        bbdesigner$(document).find('[id*="_TrackToolTipTemplate_"]').attr("visibility", "hidden");
        bbdesigner$(document).find('[id*="_TrackToolTipTemplate_"]').css("display", "none");
        bbdesigner$(id + "_CrosshairVertical").css("visibility", "hidden");
        bbdesigner$(id + "_CrosshairHorizontal").css("visibility", "hidden");
        bbdesigner$("#" + this._id).find('[id*="canvas_AxisToolTipRect"]').css("visibility", "hidden");
		bbdesigner$("#" + this._id).find('[id*="canvas_Tracker"]').remove();
        bbdesigner$("#" + this._id).find('[id*="canvas_trackSymbol"]').css("visibility", "hidden");
		bbdesigner$("#" + this._id).find('[id*="_gTooltip_"]').remove();
		bbdesigner$("#secondCanvas").remove();
		}
		 
    },
    enableTrackBall: function () {
        this.model.crosshair.visible = this.chartCross.visible;
        this.model.crosshair.type = this.chartCross.mArea;
    },
    disableTrackBall: function () {

        this.model.crosshair.visible = false;
        
        this._removeTrackBall();
    },
    _enableZoomingButtons: function () {
	    if (this.model.AreaType != 'cartesianaxes') {
                bbdesigner$("#" + this._id + "_canvas_ResetZoom").remove();
                bbdesigner$("#" + this._id + "_canvas_PanBtn").remove();
                bbdesigner$("#" + this._id + "_canvas_ZoomBtn").remove();
                bbdesigner$("#" + this._id + "_canvas_ZoomInBtn").remove();
                bbdesigner$("#" + this._id + "_canvas_ZoomOutBtn").remove();
        }
        if (this.model.AreaType == 'cartesianaxes' && (bbdesigner$("#" + this._id + '_ResetZoom').length == 0 || this.model.enableCanvasRendering)) {
            //Remove zoom buttons before adding them
            this._removeZoomkit();
            var isRTL = this.model.zooming.isReversed;
            if (!this.toolbarItems)
            {
                this.toolbarItems = bbdesigner$.extend(true, [], this.model.zooming.toolbarItems);
                this.toolbarItems.reverse();
            }
            var toolbar = isRTL ? this.toolbarItems : this.model.zooming.toolbarItems;
            var length = toolbar.length;
			var currentItem, index;
            for (var i= length -1; i>= 0; i--) {
                currentItem = toolbar[i];
                index = length - i;
                switch (currentItem) {
                    case "reset":
                        this.resetZoomButton(index);
                        break;
                    case "pan":
                        this.panButton(index);
                        break;
                    case "zoom":
                    case "zoomIn":
                    case "zoomOut":
                        this.zoomButton(index, currentItem);
                        break;
                    default:
                        length = length - 1;
                        break;
                }
            }
        }
    },
    chartMouseWheel: function (e) {
        bbdesigner$("#" + this.svgObject.id + "_TrackToolTip").hide(); // fixed tooltip mouse wheel issue
		if (this.model.zooming.enableMouseWheel && this.model.AreaType == "cartesianaxes" && !this.model.enable3D && !this.vmlRendering) {
            var chart = this;       
            var chartZoomed;
            this.zoomed = false;
            var canUpdate = false;
            var id = "#" + chart.svgObject.id;
            var matched = bbdesigner$.uaMatch(navigator.userAgent);
			var isIE11 = !!navigator.userAgent.match(/Trident\/7\./);
            var wheelDelta = e.originalEvent.wheelDelta;
			var direction = matched.browser.toLowerCase() == "mozilla" ? ((isIE11 ? ((wheelDelta / 120) > 0 ? 1 : -1) : -(e.originalEvent.detail) / 3 > 0 ? 1 : -1)) : ((wheelDelta / 120) > 0 ? 1 : -1);
            for (var i = 0; i < this.model._axes.length; i++) {
                var axis = this.model._axes[i];
                if ((axis.orientation.toLowerCase() == "vertical" && (chart.model.zooming.type.toLowerCase() == "y" || chart.model.zooming.type.trim().toLowerCase() == "x,y")) || (axis.orientation.toLowerCase() == "horizontal" && (chart.model.zooming.type.toLowerCase() == "x" || chart.model.zooming.type.trim().toLowerCase() == "x,y"))) {

                    var currentScale = Math.max(1 / BoldBIDashboard.EjSvgRender.utils._minMax(axis.zoomFactor, 0, 1), 1);
                    var cumulativeScale = Math.max(currentScale + (0.25 * direction), 1);
                    canUpdate = canUpdate | chart.doMouseWheelZoom(cumulativeScale, 0.5, axis);
                }
                if (axis.zoomFactor != 1 && axis.zoomPosition != 0)
                    chartZoomed = true;
				if (axis.zoomFactor == 1) {
                    bbdesigner$(document).find('[id*="ScrollerParent_"]').remove();
                }
            }

            this.disableAnimation();

            this.disableTrackBall();
            if (canUpdate) {
                this.model.legendCollapsed = false;
                this.zoomed = true;
                chart.redraw(true);
              }
            
            this._enableZoomingButtons();
            this.mouseWheelCoords = { x: e.originalEvent.pageX, y: e.originalEvent.pageY };
            if (!chartZoomed) {
                bbdesigner$(id + '_ResetZoom').remove();
                bbdesigner$(id + '_PanBtn').remove();
                bbdesigner$(id + '_ZoomBtn').remove();
                bbdesigner$(id + '_ZoomInBtn').remove();
                bbdesigner$(id + '_ZoomOutBtn').remove();
				bbdesigner$("#" + chart._id + '_ResetZoom').remove();
                bbdesigner$("#" + chart._id + '_PanBtn').remove();
                bbdesigner$("#" + chart._id + '_ZoomBtn').remove();
                bbdesigner$("#" + chart._id + '_ZoomInBtn').remove();
                bbdesigner$("#" + chart._id + '_ZoomOutBtn').remove();
                this.enableAnimation();
                this.panning = false;
            }
			var matched = bbdesigner$.uaMatch(navigator.userAgent);
            if (e.preventDefault && matched.browser == 'chrome' && this.model.zooming.enable)
                e.preventDefault();
            e.returnValue = false;
        }

        bbdesigner$(".tooltipDiv").remove();
    },
	 getAxisLabelData: function (evt) {
           
        var mouseMoveCords = this.calMousePosition(evt),
            targetid = evt.target.id,
            region,
            x,
            y,
            width,
            height,
            data,
            labelsLength,
            axisVisible,
            axesLength = this.model._axes.length;
        this.mousemoveX = mouseMoveCords.X;
        this.mousemoveY = mouseMoveCords.Y;
        if (this.model.AreaType == 'cartesianaxes' || this.model.AreaType == 'polaraxes') {
            if (!this.model.enable3D ) {
                for (var j = 0; j < axesLength; j++) {
                    labelsLength = this.model._axes[j].visibleLabels.length;
                    axisVisible=this.model._axes[j].visible;
                    if (axisVisible)
                    for (var k = 0; k < labelsLength; k++) {
                        var checkId = (targetid == (this.svgObject.id + '_' + this.model._axes[j].name + '_XLabel_' + k || this.svgObject.id + '_' + this.model._axes[j].name + '_YLabel_' + k));
                        region = this.model._axes[j].visibleLabels[k].region;
                        if (!BoldBIDashboard.util.isNullOrUndefined(region)) {
                            x = region.bounds.x;
                            y = region.bounds.y;
                            width = region.bounds.width;
                            height = region.bounds.height;
                            x = (this.vmlRendering && (targetid.indexOf("_YLabel_") >= 0)) ? (this.model._axes[j].opposedPosition) ? x : x + width : x;
                            if (((this.mousemoveX >= x) && (this.mousemoveX <= x + width)) || checkId) {
                                if ((this.vmlRendering) ? ((this.mousemoveY <= y + height) && (this.mousemoveY >= y)) : ((this.mousemoveY >= y - height) && (this.mousemoveY <= y)) || checkId) {
                                    data = { id: evt.target.id, location: { x: this.mousemoveX, y: this.mousemoveY }, index: k, axis: this.model._axes[j], text: region.labelText, pageX: evt.pageX, pageY: evt.pageY };
                                    return data;
                                }
                            }
                        }

                    }
                }
            }
            else {
                if (targetid.indexOf("horizontal") >= 0 || targetid.indexOf("vertical") >= 0 ) {
                    for (var j = 0; j < axesLength; j++) {
                        labelsLength = this.model._axes[j].visibleLabels.length;
                        for (var k = 0; k < labelsLength; k++) {

                            if (targetid == this.svgObject.id + this.model._axes[j].orientation + k) {
                                data = { id: evt.target.id, location: { x: this.mousemoveX, y: this.mousemoveY }, index: k, axis: this.model._axes[j], text: this.model._axes[j].visibleLabels[k].Text, pageX: evt.pageX, pageY: evt.pageY};
                                return data;

                            }
                        }
                    }
                } 
            }
    }
    },
    getLegendData: function (evt) {
        var mouseMoveCords = this.calMousePosition(evt);
        var isEjScroll = this.model.legend._BoldBIDashboardScroller;
        var scrolltop = isEjScroll ? bbdesigner$("#legend_" + this._id).BoldBIDashboardScroller('instance').model.scrollTop : bbdesigner$("#legend_" + this._id).scrollTop();
        var scrollleft = isEjScroll ? bbdesigner$("#legend_" + this._id).BoldBIDashboardScroller('instance').model.scrollLeft : bbdesigner$("#legend_" + this._id).scrollLeft();
        this.scrolltop = scrolltop;
        this.scrollleft = scrollleft;
        this.mousemoveX = mouseMoveCords.X+scrollleft;
        this.mousemoveY = mouseMoveCords.Y+scrolltop;
        var targetId = evt.target.id;
        var chartObj = this;
		var legendMode = chartObj.model.legend.mode.toLowerCase();

        {
            var currentX = this.mousemoveX;
            var currentY = this.mousemoveY;
            var chartId = this._id;
            var region;
            if ((!BoldBIDashboard.util.isNullOrUndefined(evt.target.id) && this.svgRenderer._getAttrVal(bbdesigner$(evt.target).parents(':eq(1)'), 'id') == this.svgObject.id + '_Legend') ||(this.model.enableCanvasRendering) || (this.vmlRendering)) {
                bbdesigner$.each(this.model.legendRegion, function (index, regionItem) {
                   
                        if ((legendMode !='series' && chartObj.model.AreaType == 'cartesianaxes' && (targetId == chartObj.svgObject.id + "_LegendItemShape" + regionItem.LegendItem.PointIndex || targetId == chartObj.svgObject.id + "_LegendItemText" + regionItem.LegendItem.PointIndex)) ||(legendMode =='series' && chartObj.model.AreaType == 'cartesianaxes' &&(targetId == chartObj.svgObject.id + "_LegendItemShape" + regionItem.LegendItem.SeriesIndex || targetId == chartObj.svgObject.id + "_LegendItemText" + regionItem.LegendItem.SeriesIndex) && BoldBIDashboard.util.isNullOrUndefined(regionItem.LegendItem.trendLineIndex)) || (legendMode =='series' && chartObj.model.AreaType !== 'cartesianaxes' && (targetId == chartObj.svgObject.id + "_LegendItemShape" + regionItem.LegendItem.PointIndex || targetId == chartObj.svgObject.id + "_LegendItemText" + regionItem.LegendItem.PointIndex))){
                            region = regionItem;
						}
                    
					   else if((currentX >= regionItem.Bounds.LegendBound.X + regionItem.Bounds.ItemBound.X) && (currentX <= regionItem.Bounds.LegendBound.X + regionItem.Bounds.ItemBound.X + regionItem.Bounds.ItemBound.Width)) {
                        if ((currentY >= regionItem.Bounds.LegendBound.Y + regionItem.Bounds.ItemBound.Y - (regionItem.Bounds.ItemBound.Height / 4)) && (currentY <= regionItem.Bounds.LegendBound.Y + regionItem.Bounds.ItemBound.Y + regionItem.Bounds.ItemBound.Height)) {
                           region = regionItem;
                           bbdesigner$("#legend_" +chartId + "_canvas").css("cursor", "pointer");
                        }else
                            bbdesigner$("#legend_" + chartId + "_canvas").css("cursor", "default");
                    } 
                    
                });
                if (!BoldBIDashboard.util.isNullOrUndefined(region)) {
                    return { legendItem: region, series: this.model._visibleSeries[region.LegendItem.SeriesIndex] };
                }
            }

        }
        return false;
    },

    get3DSeriesPoint: function (evt) {
        var currentX = this.mousemoveX;
        var currentY = this.mousemoveY;
        var x = (this.model.AreaType == 'polaraxes') ? 0 : this.model.m_AreaBounds.X;
        var y = (this.model.AreaType == 'polaraxes') ? 0 : this.model.m_AreaBounds.Y;
        var width = (this.model.AreaType == 'polaraxes') ? bbdesigner$(this.svgObject).width() : this.model.m_AreaBounds.Width;
        var height = (this.model.AreaType == 'polaraxes') ? bbdesigner$(this.svgObject).height() : this.model.m_AreaBounds.Height;

        if (currentX > x && currentX < (x + width) && currentY > y && currentY < (y + height)) {
            var nodeName = bbdesigner$(evt.target)[0].nodeName;
            if ((nodeName == "path" || nodeName == "shape") && bbdesigner$(evt.target)[0].id.indexOf("Region")>1) {
                index = bbdesigner$(evt.target)[0].id.match(/(\d+)/g);
                pointIndex = parseInt(index[index.length - 1]);
                seriesIndex = parseInt(index[index.length - 2]);
                var regionValue = {};
                regionValue.Region = {};
                regionValue.Region.PointIndex = pointIndex;
                regionValue.SeriesIndex = seriesIndex;
                var pointData = {};
                pointData.pointIndex = pointIndex;
                region = { region: regionValue, pointData: pointData, location: { x: currentX, y: currentY} };
                return region;
            }
        }
    },

    GetSeriesPoint: function (evt) {
        var mouseX;
        var mouseY;
        var isCanvas = this.model.enableCanvasRendering;
        var clientX, clientY;
		if(evt.originalEvent)
		{
			clientX = evt.originalEvent.clientX;
			clientY = evt.originalEvent.clientY;
		}
		else
		{
			clientX = evt.clientX;
			clientY = evt.clientY;
		}
        var currentX = this.mousemoveX;
        var currentY = this.mousemoveY;
        var region;
        var chartObj = this;
		 var indicators = chartObj.model.indicators;
        var seriesCollection = chartObj.model._visibleSeries;
        for (var j = 0; j < indicators.length && indicators[j].segment; j++) {
            seriesCollection = seriesCollection.concat(indicators[j].segment);
        }
        if (chartObj.model.enable3D) {
            return this.get3DSeriesPoint(evt);           
        }
        var x = (this.model.AreaType == 'polaraxes') ? 0 : this.model.m_AreaBounds.X;
        var y = (this.model.AreaType == 'polaraxes') ? 0 : this.model.m_AreaBounds.Y;
        var width = (this.model.AreaType == 'polaraxes') ? bbdesigner$(this.svgObject).width() : this.model.m_AreaBounds.Width;
        var height = (this.model.AreaType == 'polaraxes') ? bbdesigner$(this.svgObject).height() : this.model.m_AreaBounds.Height;

        if ((this.model.AreaType == 'cartesianaxes' || this.model.AreaType == 'polaraxes')) {
          
            if (!this.model.enableCanvasRendering || (currentX > x && currentX < (x + width) && currentY > y && currentY < (y + height))) {
                bbdesigner$.each(this.model.chartRegions, function (index, regionItem) {
                    if (!BoldBIDashboard.util.isNullOrUndefined(regionItem.SeriesIndex)) {
					var currentSer = seriesCollection[regionItem.SeriesIndex];
                    if (chartObj.model.AreaType == "polaraxes" && currentSer.drawType.toLowerCase() == 'column' && evt.target) {
                        if (chartObj.model.enableCanvasRendering) {
                                    if (currentSer.type.toLowerCase() == "polar") {
                                        var bounds = regionItem.Region.Bounds;
                                        var chartStartAngle = -.5 * Math.PI;
                                        var innerRadius = bounds.innerRadius;
                                        var fromCenterX;
                                        var fromCenterY;
                                        fromCenterX = (currentX) - (bounds.CenterX);
                                        fromCenterY = (currentY) - (bounds.CenterY);
                                        var series = chartObj.model._visibleSeries[regionItem.SeriesIndex];
                                        var startAngle = series.startAngle;
                                        var endAngle = series.endAngle;

                                        var arcAngle = (startAngle) ? 2 * Math.PI * (chartObj.model.itemCurrentXPos < 0 ? 1 + chartObj.model.itemCurrentXPos : chartObj.model.itemCurrentXPos) : 0;
                                        var clickAngle = (Math.atan2(fromCenterY, fromCenterX) - chartStartAngle - arcAngle) % (2 * Math.PI);
                                        if (clickAngle < 0 && bounds.PointIndex != 0) clickAngle = 2 * Math.PI + clickAngle;

                                        var pointStartAngle = parseFloat(bounds.StartAngle.toFixed(14));
                                        var pointEndAngle = parseFloat(bounds.EndAngle.toFixed(14));
                                        pointStartAngle -= arcAngle;
                                        pointEndAngle -= arcAngle;

                                        if (clickAngle >= pointStartAngle && clickAngle <= pointEndAngle) {
                                            index = bounds.PointIndex;
                                            distanceFromCenter = Math.sqrt(Math.pow(Math.abs(fromCenterX), 2) + Math.pow(Math.abs(fromCenterY), 2));
                                            if (distanceFromCenter <= bounds.Radius && distanceFromCenter > innerRadius) {
                                                var pointRegion = { Region: { PointIndex: index }, SeriesIndex: regionItem.SeriesIndex, type: regionItem.type };
                                                region = pointRegion;
                                            }
                                        }
                                    } else if (currentSer.type.toLowerCase() == "radar") {
                                        var bounds = regionItem.Region.Bounds;
                                        if (bounds.Line1) {
                                            line1 = bounds.Line1;
                                            line2 = bounds.Line2;
                                            line3 = bounds.Line3;
                                            var polygon = [
                                                            { x: line1.x, y: line1.y },
                                                            { x: line2.x, y: line2.y },
                                                            { x: line3.x, y: line3.y },
                                            ];
                                            var currentPoint = { x: currentX, y: currentY };
                                            var point = false;
                                            for (var p = false, i = -1, l = polygon.length, j = l - 1; ++i < l; j = i)
                                                ((polygon[i].y <= currentPoint.y && currentPoint.y < polygon[j].y) || (polygon[j].y <= currentPoint.y && currentPoint.y < polygon[i].y))
                                                && (currentPoint.x < (polygon[j].x - polygon[i].x) * (currentPoint.y - polygon[i].y) / (polygon[j].y - polygon[i].y) + polygon[i].x)
                                                && (p = !p);
                                            point = p;
                                            if (point) {
                                                index = bounds.PointIndex;
                                                var pointRegion = { Region: { PointIndex: index }, SeriesIndex: regionItem.SeriesIndex, type: regionItem.type };
                                                region = pointRegion;
                                            }
                                        }
                                    }
                                }
                                else {
                                    var nodeName = bbdesigner$(evt.target)[0].nodeName;
                                    if ((nodeName == "path" || nodeName == "shape") && bbdesigner$(bbdesigner$(evt.target).parent())[0].id == chartObj.svgObject.id + '_SeriesGroup' + '_' + regionItem.SeriesIndex) {
                                        index = bbdesigner$(evt.target)[0].id.match(/(\d+)/g);
                                        pointIndex = parseInt(index[index.length - 1]);
                                        regionItem = { Region: { PointIndex: pointIndex }, SeriesIndex: regionItem.SeriesIndex, type: regionItem.type };
                                        region = regionItem;
                                        return false;
                                    }
                                }
                    }
                    else {
                        if (!chartObj.model.enableCanvasRendering) {
                            if(evt.target.id == chartObj.svgObject.id + "_Series" + regionItem.SeriesIndex + "_Point" + regionItem.Region.PointIndex ||
                                evt.target.id == chartObj.svgObject.id + "_Series" + regionItem.SeriesIndex + "_Point" + regionItem.Region.PointIndex + "_symbol" ||
                                evt.target.id == chartObj.svgObject.id + "_trackSymbol_" + regionItem.SeriesIndex + "_" + regionItem.Region.PointIndex)
                                region = regionItem;                           
                        }
                        else if ((((currentX >= regionItem.Region.Bounds.X) && (currentX <= (regionItem.Region.Bounds.X + (regionItem.Region.Bounds.Width))))) && ((currentY > regionItem.Region.Bounds.Y) && (currentY < (regionItem.Region.Bounds.Y) + (regionItem.Region.Bounds.Height)))) {
                            region = regionItem;
                        }
                    }
                    }
					else {
                        regionValue = chartObj.model.chartRegions;
                        var pointData = {};
						 var areaValue;
					if (!regionItem.isStripLine) {
                        var regionLength = regionItem.length;
						 var requireInvertedAxes = chartObj.model.requireInvertedAxes;
                        var axisName = (!requireInvertedAxes) ? chartObj.model.series[regionItem[regionLength - 1].SeriesIndex]._yAxisName : chartObj.model.series[regionItem[regionLength - 1].SeriesIndex]._xAxisName;
                        for (var k = 0; k < chartObj.model._axes.length; k++)
                        {
                            if (axisName == chartObj.model._axes[k].name)
                            {
                               areaValue = chartObj.model._axes[k];
                               break;
                            }
                        }
                        for (var i = 0; i < regionValue.length; i++) {                          
                            for (var j = 0; j < regionValue[i].length; j++) {
                                var polygon = [];
                                line1 = regionValue[i][j].region;
                                if (line1[0]) polygon.push({ x: line1[0].X + areaValue.x, y: line1[0].Y + areaValue.y });
                                if (line1[1]) polygon.push({ x: line1[1].X + areaValue.x, y: line1[1].Y + areaValue.y });
                                if (line1[2]) polygon.push({ x: line1[2].X + areaValue.x, y: line1[2].Y + areaValue.y });
                                if (line1[3]) polygon.push({ x: line1[3].X + areaValue.x, y: line1[3].Y + areaValue.y });

                                var currentPoint = { x: currentX, y: currentY };
                                var point = chartObj.isPointInPolygon(polygon, currentPoint);
                                if (point)
                                    region = regionValue[i][j];
                            }                                               
                        }
                    }
                    }
                });
            }
            if (region) {
                return { region: region, location: { x: currentX, y: currentY} };
            }
        }

        else {
            var chartObj = this;
            var distanceFromCenter;
            var regionValue;
            var chartRegions = chartObj.model.chartRegions;
            if (chartRegions.length > 0 && (chartRegions[0].Series.type.toLowerCase() == "pyramid"|| chartRegions[0].Series.type.toLowerCase() == "funnel")) {
                var nodeName = bbdesigner$(evt.target)[0].nodeName;
                if ((nodeName == "path" || nodeName == "shape") && bbdesigner$(bbdesigner$(evt.target).parent())[0].id == chartObj.svgObject.id + '_SeriesGroup' + '_' + chartRegions[0].SeriesIndex) {
                    regionValue = chartObj.model.chartRegions[0];
                    index = bbdesigner$(evt.target)[0].id.match(/(\d+)/g);
                    index = parseInt(index[index.length - 1]);
                    regionValue.Region.PointIndex = index;
                    var pointData = {};
                    pointData.pointIndex = index;
                    region = { region: regionValue, pointData: pointData, location: { x: currentX, y: currentY} };
                    return region;
                }
                else {                    
                    regionValue = chartRegions[0];
                    var pyrX = this.pyrX;
                    var pyrY = this.pyrY;
                    var pointData = {};
                    var polygon;
                        for (var j = 0; j < regionValue.Region.length; j++) {
                            line1 = regionValue.Region[j].Line1;
                            line2 = regionValue.Region[j].Line2;
                            line3 = regionValue.Region[j].Line3;
                            line4 = regionValue.Region[j].Line4;
                            if (chartRegions[0].Series.type.toLowerCase() == "pyramid")
                                polygon = [
                                            { x: line1.x + pyrX, y: line1.y + pyrY },
                                            { x: line2.x + pyrX, y: line2.y + pyrY },
                                            { x: line3.x + pyrX, y: line3.y + pyrY },
                                            { x: line4.x + pyrX, y: line4.y + pyrY }
                                ];
                            else {
                                line5 = regionValue.Region[j].Line5;
                                line6 = regionValue.Region[j].Line6;
                                polygon = [
                                            { x: line1.x + pyrX, y: line1.y + pyrY },
                                            { x: line2.x + pyrX, y: line2.y + pyrY },
                                            { x: line3.x + pyrX, y: line3.y + pyrY },
                                            { x: line4.x + pyrX, y: line4.y + pyrY },
                                            { x: line5.x + pyrX, y: line5.y + pyrY },
                                            { x: line6.x + pyrX, y: line6.y + pyrY }
                                ];
                            }

                            var currentPoint = { x: currentX, y: currentY };
                            var point = this.isPointInPolygon(polygon, currentPoint);
                            if (point) {
                                pointData.pointIndex = regionValue.Region[j].PointIndex;
                                regionValue.Region.PointIndex = pointData.pointIndex;
                                region = { region: regionValue, pointData: pointData, location: { x: currentX, y: currentY } };                                                                
                                return region;
                            }

                        }
                    }                
                }
            
            else {
                // ReSharper disable DuplicatingLocalDeclaration
                var event = evt;
                bbdesigner$.each(chartObj.model.chartRegions, function (regionIndex, regionValue) {
                    // ReSharper restore DuplicatingLocalDeclaration
                    var chartStartAngle = -.5 * Math.PI;
                    var seriesData = regionValue.SeriesData,
                    regionData = regionValue.Region,
                    innerRadius = (chartObj.model._visibleSeries[regionValue.SeriesIndex].type.toLowerCase() == 'doughnut') ? seriesData.DRadius: 0;
                    var fromCenterX;
                    var fromCenterY;
                    fromCenterX = (currentX) - (seriesData.CenterX);
                    fromCenterY = (currentY) - (seriesData.CenterY);
                    var series = chartObj.model._visibleSeries[regionValue.SeriesIndex];
                    var startAngle = series.startAngle;
                    var endAngle = series.endAngle;
                    startAngle = startAngle < 0 ? startAngle + 360 : startAngle;
                    endAngle = endAngle < 0 ? endAngle + 360 : endAngle;
                    var totalDegree = (series.endAngle - series.startAngle);
                    //Anticlockwise pie and doughnut
                    if (totalDegree < 0) {
                        endAngle = endAngle / 360;
                        var arcAngle = (endAngle) ? 2 * Math.PI * (endAngle < 0 ? 1 + endAngle : endAngle) : 0;
                        var clickAngle = (Math.atan2(fromCenterY, fromCenterX) - chartStartAngle - arcAngle) % (2 * Math.PI);;
                        if (clickAngle < 0) clickAngle = 2 * Math.PI + clickAngle;
                            clickAngle = parseFloat(clickAngle.toFixed(2));
                        pointData = [];
                        for (var i = 0; i < regionData.length; i++) {
                            var pointStartAngle = parseFloat(regionData[i].StartAngle.toFixed(14));
                            var pointEndAngle = parseFloat(regionData[i].EndAngle.toFixed(14));
                            pointStartAngle = pointStartAngle < 0 ? 2 * Math.PI + pointStartAngle : pointStartAngle;
                            pointEndAngle = pointEndAngle < 0 ? 2 * Math.PI + pointEndAngle : pointEndAngle;
                            pointStartAngle -= arcAngle;
                            pointEndAngle -= arcAngle;
                            pointStartAngle = parseFloat(pointStartAngle.toFixed(14));
                            pointEndAngle = parseFloat(pointEndAngle.toFixed(14));
                            if (series.startAngle >= 0 && series.endAngle <= 0) {
                                pointStartAngle = pointStartAngle <= 0 ? 2 * Math.PI + pointStartAngle : pointStartAngle;
                                pointEndAngle = pointEndAngle < 0 ? 2 * Math.PI + pointEndAngle : pointEndAngle;
                            }
                            if ((clickAngle <= pointStartAngle && clickAngle >= pointEndAngle)||(evt.target.id == chartObj.svgObject.id + "_Series" + regionValue.SeriesIndex + "_Point" + regionData[i].PointIndex)) {
                                var matchStr = chartObj.svgObject.id + "_Series" + regionValue.SeriesIndex + "_Point";
                                var pointIndex = event.target.id.substr(matchStr.length);
                                if (pointIndex == regionData[i].PointIndex) {
                                    pointData.push(regionData[i]);
                                    break;
                                }
                                pointData.push(regionData[i]);
                                break;
                            }
                        }
                    }  //Clockwise pie and doughnut
                    else {
                        var arcAngle = (startAngle) ? 2 * Math.PI * (chartObj.model.itemCurrentXPos < 0 ? 1 + chartObj.model.itemCurrentXPos : chartObj.model.itemCurrentXPos) : 0;
                        var clickAngle = (Math.atan2(fromCenterY, fromCenterX) - chartStartAngle - arcAngle)%(2*Math.PI);
                        if (clickAngle < 0) clickAngle = 2 * Math.PI + clickAngle;
                        clickAngle = parseFloat(clickAngle.toFixed(2));
                        pointData = [];
                        for (var i = 0; i < regionData.length; i++) {
                            var pointStartAngle = parseFloat(regionData[i].StartAngle.toFixed(14));
                            var pointEndAngle = parseFloat(regionData[i].EndAngle.toFixed(14));
                            pointStartAngle = pointStartAngle < 0 ? 2 * Math.PI + pointStartAngle : pointStartAngle;
                            pointEndAngle = pointEndAngle < 0 ? 2 * Math.PI + pointEndAngle : pointEndAngle;
                            pointStartAngle -= arcAngle;
                            pointEndAngle -= arcAngle;
                            pointStartAngle = parseFloat(pointStartAngle.toFixed(14));
                            pointEndAngle = parseFloat(pointEndAngle.toFixed(14));
                            if (series.startAngle < 0 && (series.endAngle > -1||series.endAngle==null)) {
                            pointStartAngle = pointStartAngle < 0 ? 2 * Math.PI + pointStartAngle : pointStartAngle;
                            pointEndAngle = pointEndAngle <= 0 ? 2 * Math.PI + pointEndAngle : pointEndAngle;
                            }
                            if ((clickAngle >= pointStartAngle && clickAngle <= pointEndAngle)||(evt.target.id == chartObj.svgObject.id + "_Series" + regionValue.SeriesIndex + "_Point" + regionData[i].PointIndex)) {
                                var matchStr = chartObj.svgObject.id + "_Series" + regionValue.SeriesIndex + "_Point";
                                var pointIndex = event.target.id.substr(matchStr.length);
                                if (pointIndex == regionData[i].PointIndex) {
                                    pointData.push(regionData[i]);
                                    break;
                                }
                            }
                        }
                    }
                    if (pointData.length > 0) {
                        var isExploded = (series.explodeAll || (series.explodeIndex == pointData[0].PointIndex));
                        if (isExploded) {

                            var fromCenterX1 = currentX - pointData[0].StartX;
                            var fromCenterY1 = currentY - pointData[0].StartY;

                            if (pointData.length > 0) {

                                distanceFromCenter = Math.sqrt(Math.pow(Math.abs(fromCenterX1), 2) + Math.pow(Math.abs(fromCenterY1), 2));
                                if ((distanceFromCenter <= seriesData.Radius && distanceFromCenter > innerRadius) ||(evt.target.id == chartObj.svgObject.id + "_Series" + pointData[0].SeriesIndex + "_Point" + pointData[0].PointIndex)) {
                                    regionData.PointIndex = pointData[0].PointIndex;
                                    regionData.Index = pointData[0].Index;
                                    regionData.SeriesIndex = pointData[0].SeriesIndex;
                                    region = { region: regionValue, pointData: pointData, location: { x: currentX, y: currentY} };
                                }
                            }
                        }
                        else {
                            distanceFromCenter = Math.sqrt(Math.pow(Math.abs(fromCenterX), 2) + Math.pow(Math.abs(fromCenterY), 2));
                            if ((distanceFromCenter <= seriesData.Radius && distanceFromCenter > innerRadius) || evt.target.id == chartObj.svgObject.id + "_Series" + pointData[0].SeriesIndex + "_Point" + pointData[0].PointIndex) {
                                regionData.PointIndex = pointData[0].PointIndex;
                                regionData.Index = pointData[0].Index;
                                regionData.SeriesIndex = pointData[0].SeriesIndex;
                                region = { region: regionValue, pointData: pointData, location: { x: currentX, y: currentY} };
                            }
                        }
                    }

                });

                return region;
            }
        }
    },
    isPointInPolygon: function (polygon, point) {
        for (var p = false, i = -1, l = polygon.length, j = l - 1; ++i < l; j = i)
            ((polygon[i].y <= point.y && point.y < polygon[j].y) || (polygon[j].y <= point.y && point.y < polygon[i].y))
            && (point.x < (polygon[j].x - polygon[i].x) * (point.y - polygon[i].y) / (polygon[j].y - polygon[i].y) + polygon[i].x)
            && (p = !p);
        return p;
    },
    mousePosition: function (evt) {
         if (!BoldBIDashboard.util.isNullOrUndefined(evt.pageX) && evt.pageX>0)
            return { x: evt.pageX, y: evt.pageY };
        else if (!BoldBIDashboard.util.isNullOrUndefined(evt.originalEvent.pageX) && evt.originalEvent.pageX>0)
            return { x: evt.originalEvent.pageX, y: evt.originalEvent.pageY };
         else if (evt.originalEvent.changedTouches != undefined)
         {
             if (!BoldBIDashboard.util.isNullOrUndefined(evt.originalEvent.changedTouches[0].pageX) && evt.originalEvent.changedTouches[0].pageX > 0)
                 return { x: evt.originalEvent.changedTouches[0].pageX, y: evt.originalEvent.changedTouches[0].pageY };
         }
         else
             return { x: 0, y: 0 };
         
    },


    calMousePosition: function (e) {
        var matched = bbdesigner$.uaMatch(navigator.userAgent);
        var mouseposition = this.mousePosition(e);
        e.pageX = mouseposition.x;
        e.pageY = mouseposition.y;
        var mouseX, mouseY;
        var browser = matched.browser.toLowerCase();
        var isRTL = this.model.legend.isReversed;
        mouseX = isRTL && bbdesigner$("#legend_" + this._id)[0].style['overflow-y'] == "scroll"? (e.pageX) - bbdesigner$(this.svgObject).offset().left - 18 : (e.pageX) - bbdesigner$(this.svgObject).offset().left;
        mouseY = (e.pageY) - bbdesigner$(this.svgObject).offset().top;
       

        return { X: mouseX, Y: mouseY };

    },

    cancelEvent: function (e) {
        if(e.which != 3)
			e.stopPropagation();
        var matched = bbdesigner$.uaMatch(navigator.userAgent);
        if(matched.browser == 'chrome' && (this.model.zooming.enable||this.model.crosshair.visible) ){
            e.preventDefault();
        }
        if (this.model.enable3D) {
            e.preventDefault();
            if(e.which != 3)
				e.stopPropagation();
        }
        e.returnValue = false;
        e.cancelBubble = true;
        return false;
    },
    resetZoom: function () {
        var chartobj = this;
        var id = "#" + this.svgObject.id;
		bbdesigner$(".tooltipDiv").remove(); //To remove tooltip template
        if (chartobj.zoomed) {
            bbdesigner$.each(this.model._axes, function (index, axis) {
                axis.zoomFactor = 1;
                axis.zoomPosition = 0;
            });
			//Reset primary axis zoomFactor and zoomPosition
			chartobj.model.primaryXAxis.zoomFactor = 1;
            chartobj.model.primaryYAxis.zoomFactor = 1;
            chartobj.model.primaryXAxis.zoomPosition = 0;
            chartobj.model.primaryYAxis.zoomPosition = 0;
			bbdesigner$("#"+chartobj._id + "_canvas").css({ "cursor": "default" });
			bbdesigner$("#" + chartobj._id + "_ResetZoom").remove();
			bbdesigner$("#" + chartobj._id + "_PanBtn").remove();
			bbdesigner$("#" + chartobj._id + "_ZoomBtn").remove();
			bbdesigner$("#" + chartobj._id + "_ZoomInBtn").remove();
			bbdesigner$("#" + chartobj._id + "_ZoomOutBtn").remove();
			    
            bbdesigner$(id + "_ResetZoom").remove();
            bbdesigner$(id + "_PanBtn").remove();
            bbdesigner$(id + "_ZoomBtn").remove();
            bbdesigner$(id + "_ZoomInBtn").remove();
            bbdesigner$(id + "_ZoomOutBtn").remove();            
            chartobj.zoomed = false;
            chartobj.zooming = false;
            chartobj.panning = false;
            chartobj.resetZooming = true;
            chartobj.enableTrackBall();
            chartobj.redraw();
            chartobj.enableAnimation();          
            chartobj.svgRenderer._setAttr(bbdesigner$(chartobj.svgObject).find(id + "_XAxis," + id + "_ChartArea," + id + "_YAxis," + id + "_SeriesCollection"), { "cursor": "default" });
        }
    },
    startZoomInOut: function (currentEle) {
	    var currentItem = currentEle.target.id.indexOf("ZoomIn") > -1 ? "zoomIn" : "zoomOut";
        this.drag = false;
        this.zoomed = true;
		var type = this.model.zooming.type.toLowerCase();
		var zoomValue = currentItem == "zoomIn" ? 0.2: -0.2;
		var axis, previousZoomFactor, previousZoomPosition;
        for (var k = 0; k < this.model._axes.length; k++) {
            axis = this.model._axes[k];
            previousZoomFactor = axis.zoomFactor;
            previousZoomPosition = axis.zoomPosition;
            if (axis.orientation.toLowerCase() == "horizontal") {
                axis.zoomFactor = type != "y" ? previousZoomFactor - zoomValue : axis.zoomFactor;
                axis.zoomPosition = type != "y" ? previousZoomPosition + zoomValue : axis.zoomPosition;
            } else {
                axis.zoomFactor = type != "x" ? previousZoomFactor - zoomValue: axis.zoomFactor;
                axis.zoomPosition = type != "x" ? previousZoomPosition + zoomValue : axis.zoomPosition;
            }
			if (parseFloat(axis.zoomFactor.toFixed(3)) <= 0.001) {
                axis.zoomFactor = previousZoomFactor;
                axis.zoomPosition = previousZoomPosition;
             }
			 if (parseFloat(axis.zoomFactor.toFixed(3)) >= 1) {
                axis.zoomFactor = 1;
                axis.zoomPosition = 0;
                bbdesigner$(document).find('[id*="ScrollerParent_"]').remove();
            }
        }
        this.redraw(true);
    },
    startZoom: function () {
        var chartObj = this;
        var id = "#" + this.svgObject.id;
		bbdesigner$(".tooltipDiv").remove(); //To remove tooltip template
        var iconColor = this.model.theme.toLowerCase().indexOf("dark") >= 0 ? "#000000" : " #FFFFFF";
        chartObj.svgRenderer._setAttr(bbdesigner$(id + '_ZoomBtn'), { 'selected': 'true' });
        chartObj.svgRenderer._setAttr(bbdesigner$(id + '_ZoomPath'), { "fill": "#14B9FF" });
        chartObj.svgRenderer._setAttr(bbdesigner$(id + '_ZoomIcon'), { "fill": '#FFFFFF' });
        chartObj.svgRenderer._setAttr(bbdesigner$(id + '_PanPath'), { "fill": '#B7B7B7' });
        chartObj.svgRenderer._setAttr(bbdesigner$(id + '_panIcon'), { "fill": iconColor });
        bbdesigner$(id + "_ZoomBtn").css({ "border-color": "#14B9FF", "background-color": "#14B9FF" });
        bbdesigner$(id + "_PanBtn").css({ "border-color": "#B7B7B7", "background-color": "#B7B7B7" });
		bbdesigner$("#"+chartObj._id + "_canvas").css({ "cursor": "default" });
        this._cursorToDefault();
        chartObj.panning = false;
        chartObj.enableTrackBall();
    },
    startPan: function () {
        var chartObj = this;
        var id = "#" + this.svgObject.id;
		bbdesigner$(".tooltipDiv").remove(); //To remove tooltip template
        var iconColor = this.model.theme.toLowerCase().indexOf("dark") >= 0 ? "#000000" : " #FFFFFF";
        chartObj.svgRenderer._setAttr(bbdesigner$(id + '_ZoomBtn'), { 'selected': 'false' });
        chartObj.svgRenderer._setAttr(bbdesigner$(id + '_PanBtn'), { 'selected': 'true' });
        chartObj.svgRenderer._setAttr(bbdesigner$(id + '_ZoomPath'), { "fill": "#B7B7B7" });
        chartObj.svgRenderer._setAttr(bbdesigner$(id + '_ZoomIcon'), { "fill": iconColor });
        chartObj.svgRenderer._setAttr(bbdesigner$(id + '_PanPath'), { "fill": '#14B9FF' });
        chartObj.svgRenderer._setAttr(bbdesigner$(id + '_panIcon'), { "fill": '#FFFFFF' });
        bbdesigner$(id + "_ZoomBtn").css({ "border-color": "#B7B7B7", "background-color": "#B7B7B7" });
        bbdesigner$(id + "_PanBtn").css({ "border-color": "#14B9FF", "background-color": "#14B9FF" });
		bbdesigner$("#"+chartObj._id + "_canvas").css({ "cursor": "pointer" });
        this._cursorToPointer();
        chartObj.panning = true;
        chartObj.disableTrackBall();

    },
    zoomButton: function (index, currentItem) {
        if (currentItem == "zoom")
            var currentItemId = "_Zoom";
        else if (currentItem == "zoomIn")
            currentItemId = "_ZoomIn";
        else
            currentItemId = "_ZoomOut";

        var padding = index * 5 + 5;
        var transX = this.model.m_AreaBounds.X + (this.model.m_AreaBounds.Width - (index * 32) - padding); //32 path bouding box for pan,reset, zoom button 
        var transY = (this.model.m_AreaBounds.Y + this.model.m_AreaBounds.Height) + (this.model.elementSpacing - (this.model.m_AreaBounds.Height));
        var iconColor = this.model.theme.toLowerCase().indexOf("dark") >= 0 ? "#000000" : " #FFFFFF";
        var gEle = this.svgRenderer.createGroup({ 'id': this.svgObject.id + currentItemId + "Btn", 'transform': 'translate(' + transX + ',' + transY + ')', 'selected': 'true' });

        var pathOptions = {
            'id': this.svgObject.id + currentItemId + 'Path',
            'd': "M32,27c0,2.75-2.25,5-5,5H5c-2.75,0-5-2.25-5-5V5c0-2.75,2.25-5,5-5h22c2.75,0,5,2.25,5,5V27z",
            'fill': this.panning || currentItem == "zoomIn" ||  currentItem == "zoomOut"? '#b7b7b7' : '#14B9FF',
            'zoomId': this._id + currentItemId + "Btn",
            'width': 27,
            'height': 27,
            'left': transX,
            'top': transY
        };

        if (currentItem == "zoom") {
            var direction = "M26.101,22.893l-6.605-6.174c1.414-2.781,0.897-6.267-1.496-8.504c-2.901-2.711-7.448-2.56-10.161,0.341    c-2.712,2.9-2.56,7.45,0.341,10.163c2.426,2.266,6,2.523,8.694,0.853l6.579,6.151L26.101,22.893z M10.186,16.571    c-1.715-1.604-1.805-4.293-0.203-6.009c1.605-1.715,4.295-1.805,6.009-0.201c1.715,1.603,1.805,4.293,0.202,6.007    C14.59,18.084,11.901,18.175,10.186,16.571";
            var transform = "";
        } else if (currentItem == "zoomIn") {
            direction = "M9.0983096,4.2999878L9.0983096,9.3999634 3.9983783,9.3999634 3.9983783,12.699951 9.0983096,12.699951 9.0983096,17.799988 12.398249,17.799988 12.398249,12.699951 17.49818,12.699951 17.49818,9.5 12.398249,9.5 12.398249,4.2999878z M10.998276,0C14.298215,0 17.49818,1.3999634 19.69813,4.1999512 22.79809,8.0999756 22.79809,13.5 19.998144,17.399963L28.597992,28.299988 23.898081,32 15.398205,21.199951C10.898271,23.099976 5.5983606,21.899963 2.3983956,17.899963 -1.4015366,13.099976 -0.60156059,6.0999756 4.1983567,2.3999634 6.1983276,0.79998779 8.5983163,0 10.998276,0z";
            transform = "translate(7,7) scale(0.6)";
        } else {
            direction = "M3.9983433,9.5L3.9983433,12.799988 17.598165,12.799988 17.598165,9.5z M10.998234,0C14.298169,0 17.498131,1.3999634 19.698108,4.1999512 22.798034,8.0999756 22.798034,13.5 19.998092,17.399963L28.597994,28.299988 23.898054,32 15.398188,21.199951C10.898259,23.099976 5.5983546,21.899963 2.398393,17.899963 -1.4015351,13.099976 -0.60155994,6.0999756 4.1983522,2.3999634 6.1983207,0.79998779 8.5983074,0 10.998234,0z";
            transform = "translate(7,7) scale(0.6)";
        }

        if (this.model.enableCanvasRendering) {
            this.svgRenderer.zoomButton(pathOptions, currentItem);
            if (currentItem == "zoom")
                this._on(bbdesigner$("#" + this.svgObject.id + currentItemId + "Btn"), "touchstart click", this.startZoom);
            else
                this._on(bbdesigner$("#" + this.svgObject.id + currentItemId + "Btn"), "touchstart click", this.startZoomInOut);
        } else {
            this.svgRenderer.drawPath(pathOptions, gEle);
            var options = {
                'id': this._id + currentItemId + 'Icon',
                'd': direction,
                "transform": transform,
                'fill': this.panning || currentItem == "zoomIn" ||  currentItem == "zoomOut" ? iconColor : '#FFFFFF'
            };
            this.svgRenderer.drawPath(options, gEle);
            this.svgRenderer.append(gEle, this.svgObject);

            if (currentItem == "zoom")
                this._on(bbdesigner$(gEle), "touchstart click", this.startZoom);
            else
                this._on(bbdesigner$(gEle), "touchstart click", this.startZoomInOut);
        }
    },
    panButton: function (index) {
        var padding = index * 5 + 5;
        var transX = this.model.m_AreaBounds.X + (this.model.m_AreaBounds.Width - (index * 32) - padding); //32 path bounding box for pan and resetzoom button
        var transY = (this.model.m_AreaBounds.Y + this.model.m_AreaBounds.Height) + (this.model.elementSpacing - (this.model.m_AreaBounds.Height));
        var iconColor = this.model.theme.toLowerCase().indexOf("dark") >= 0 ? "#000000" : " #FFFFFF";
        var gEle = this.svgRenderer.createGroup({ 'id': this.svgObject.id + '_PanBtn', 'transform': 'translate(' + transX + ',' + transY + ')', 'selected': 'false' });

        var pathOptions = {
            'id': this.svgObject.id + '_PanPath',
            'd': "M 32 27 c 0 2.75 -2.25 5 -5 5 H 5 c -2.75 0 -5 -2.25 -5 -5 V 5 c 0 -2.75 2.25 -5 5 -5 h 22 c 2.75 0 5 2.25 5 5 V 27 Z",
            'fill': !this.panning ? '#b7b7b7' : '#14B9FF',
            'panId': this._id + '_PanBtn',
            'width': 27,
            'height': 27,
            'left': transX,
            'top': transY
        };
        if (this.model.enableCanvasRendering) {
            this.svgRenderer.panButton(pathOptions);
            this._on(bbdesigner$("#" + this.svgObject.id + '_PanBtn'), "touchstart click", this.startPan);
        } else {
            this.svgRenderer.drawPath(pathOptions, gEle);

            var options = {
                'id': this._id + '_panIcon',
                'points': "26.105,16 21.053,12.211 21.053,14.737 17.263,14.737 17.263,10.947 19.834,10.947 16.044,5.895 12.255,10.947 14.737,10.947 14.737,14.737 10.947,14.737 10.947,12.211 5.895,16 10.947,19.789 10.947,17.263 14.737,17.263 14.737,21.053 12.255,21.053 16.044,26.105 19.834,21.053 17.263,21.053 17.263,17.263 21.053,17.263 21.053,19.789",
                'fill': !this.panning ? iconColor : '#FFFFFF'
            };
            this.svgRenderer.drawPolygon(options, gEle);
            this.svgRenderer.append(gEle, this.svgObject);

            this._on(bbdesigner$(gEle), "touchstart click", this.startPan);

        }
    },
    resetZoomButton: function (index) {
        var padding = index * 5 + 5;
        var transX = this.model.m_AreaBounds.X + (this.model.m_AreaBounds.Width - (index*32 + padding)); //32 path bouding box
        var transY = (this.model.m_AreaBounds.Y + this.model.m_AreaBounds.Height) + (this.model.elementSpacing - (this.model.m_AreaBounds.Height));
        var gEle = this.svgRenderer.createGroup({ 'id': this.svgObject.id + '_ResetZoom', 'transform': 'translate(' + transX + ',' + transY + ')', 'selected': 'false' });
        var iconColor = this.model.theme.toLowerCase().indexOf("dark") >= 0 ? "#000000" : " #FFFFFF";
        var options = {
            'id': this.svgObject.id + '_ResetZoomPath',
            'd': "M 32 27 c 0 2.75 -2.25 5 -5 5 H 5 c -2.75 0 -5 -2.25 -5 -5 V 5 c 0 -2.75 2.25 -5 5 -5 h 22 c 2.75 0 5 2.25 5 5 V 27 Z",
            'fill': '#b7b7b7',
            'resetZoomId': this._id + '_ResetZoom',
            'width': 27,
            'height': 27,
            'left': transX,
            'top': transY
        };
        if (this.model.enableCanvasRendering) {
            this.svgRenderer.resetZoom(options);
            this._on(bbdesigner$("#" + this.svgObject.id + '_ResetZoom'), "touchstart click", this.resetZoom);
        } else {
           
            this.svgRenderer.drawPath(options, gEle);

            var ptOptions = {
                'id': this._id + '_ptIcon',
                'points': "11.895,18.398 8.061,22.23 5.796,19.967 5.796,26.283 12.112,26.283 9.848,24.018 13.682,20.186",
                'fill': iconColor
            };

            this.svgRenderer.drawPolygon(ptOptions, gEle);
            var pt1Options = {
                'id': this._id + '_ptIcon1',
                'points': "19.691,6.072 21.955,8.337 18.121,12.172 19.908,13.959 23.742,10.123 26.007,12.389 26.007,6.072",
                'fill': iconColor
            };

            this.svgRenderer.drawPolygon(pt1Options, gEle);

            var pt2Options = {
                'id': this._id + '_ptIcon2',
                'points': "11.895,13.958 13.682,12.172 9.848,8.337 12.112,6.072 5.796,6.072 5.796,12.389 8.061,10.123",
                'fill': iconColor
            };

            this.svgRenderer.drawPolygon(pt2Options, gEle);

            var pt3Options = {
                'id': this._id + '_ptIcon3',
                'points': "19.908,18.396 18.121,20.186 21.955,24.018 19.691,26.283 26.007,26.283 26.007,19.967 23.741,22.23",
                'fill': iconColor
            };

            this.svgRenderer.drawPolygon(pt3Options, gEle);

            this.svgRenderer.append(gEle, this.svgObject);

            this._on(bbdesigner$(gEle), "touchstart click", this.resetZoom);
        }

    },

    doZoom: function (zoomRect, zoomRectWidth, zoomRectHeight) {
        var chart = this;
        this.model._chartAreaZoom = true;
        bbdesigner$(".tooltipDiv").remove(); //To remove tooltip template
        if (chart.model.enableCanvasRendering) {
            var zoomArea = bbdesigner$("#" + this.svgObject.id + "_ZoomArea")[0].getClientRects()[0];
            var chartArea = bbdesigner$("#" + this.svgObject.id)[0].getClientRects()[0];
            var zoomX = zoomArea.left - chartArea.left - bbdesigner$(document).scrollLeft(); 
            var zoomY = zoomArea.top - chartArea.top - bbdesigner$(document).scrollTop(); 
        } else {
            var zoomX = parseFloat(chart.svgRenderer._getAttrVal(bbdesigner$(zoomRect), "x"));
            var zoomY = parseFloat(chart.svgRenderer._getAttrVal(bbdesigner$(zoomRect), "y"));
        }
        bbdesigner$("#" + this.svgObject.id + "_ZoomArea").remove();
        this.drag = false;
        this.zoomed = true;
        for (var k = 0; k < this.model._axes.length; k++) {
            var axis = this.model._axes[k];
            var previousZoomFactor = axis.zoomFactor;
            var previousZoomPosition = axis.zoomPosition;
            if (axis.orientation.toLowerCase() == "horizontal") {
                axis.zoomFactor = chart.model.zooming.type.toLowerCase() != "y"
                    ? previousZoomFactor * (zoomRectWidth / (chart.model.m_AreaBounds.Width)) : axis.zoomFactor;
                axis.zoomPosition = chart.model.zooming.type.toLowerCase() != "y"
                    ? previousZoomPosition + Math.abs((zoomX - chart.model.m_AreaBounds.X) / (chart.model.m_AreaBounds.Width)) * previousZoomFactor : axis.zoomPosition;
                if (parseFloat(axis.zoomFactor.toFixed(3)) <= 0.001) {
                    axis.zoomFactor = previousZoomFactor;
                    axis.zoomPosition = previousZoomPosition;

                }
            } else {
                axis.zoomFactor = chart.model.zooming.type.toLowerCase() != "x"
                    ? previousZoomFactor * zoomRectHeight / chart.model.m_AreaBounds.Height : axis.zoomFactor;
                axis.zoomPosition = chart.model.zooming.type.toLowerCase() != "x"
                    ? previousZoomPosition + (1 - Math.abs((zoomRectHeight + (zoomY - chart.model.m_AreaBounds.Y)) / (chart.model.m_AreaBounds.Height))) * previousZoomFactor : axis.zoomPosition;
                if (parseFloat(axis.zoomFactor.toFixed(3)) <= 0.001) {
                    axis.zoomFactor = previousZoomFactor;
                    axis.zoomPosition = previousZoomPosition;

                }
            }
        }

        //Getting zoomed region data when zoomedData event fired                    
        var series = this.model._visibleSeries;
        var seriesLength = series.length;
        var zoomedData = [];
        var selectedData = [];
        var points = [];
        var type;
        var axisValueType;
        var xVisibleRange;
        var yVisibleRange;
        var pointsLength;
        for (var j = 0; j < seriesLength; j++) {
            if (series[j].visibility == "visible") {
                points = series[j].points;
                pointsLength = points.length;
                type = series[j].type.toLowerCase();
                axisValueType = new BoldBIDashboard.axisTypes[series[j].xAxis._valueType.toLowerCase()]();
                axisValueType._calculateVisibleRange(series[j].xAxis, chart);
                axisValueType = new BoldBIDashboard.axisTypes[series[j].yAxis._valueType.toLowerCase()]();
                axisValueType._calculateVisibleRange(series[j].yAxis, chart);
                xVisibleRange = series[j].xAxis.visibleRange;
                yVisibleRange = series[j].yAxis.visibleRange;
                for (var k = 0; k < pointsLength; k++) {
                    if ((xVisibleRange.min <= points[k].xValue && xVisibleRange.max >= points[k].xValue) && (yVisibleRange.min <= points[k].y && yVisibleRange.max >= points[k].y)) {
                        if (series[j]._hiloTypes) {
                            if (type == "rangearea" || type == "rangecolumn" || type == "waterfall" || type == "hilo")
                                zoomedData.push({ XValue: points[k].x, High: points[k].high, Low: points[k].low });
                            else
                                zoomedData.push({ XValue: points[k].x, High: points[k].high, Low: points[k].low, Open: points[k].open, Close: points[k].close });
                        }
                        else
                            zoomedData.push({ XValue: points[k].x, YValue: points[k].y });
                    }
                }
            }
            if (zoomedData.length != 0)
                selectedData.push({ selectedData: zoomedData });
            zoomedData = [];
        }

        var commonEventArgs = bbdesigner$.extend({}, BoldBIDashboard.EjSvgRender.commonChartEventArgs);
        commonEventArgs.data = {};
        commonEventArgs.data.series = selectedData;
        this._trigger("zoomed", commonEventArgs);

        this.disableAnimation();
        this.model.legendCollapsed = false;
        this.redraw(true);

        this._enableZoomingButtons();
    },
    _cursorToDefault: function () {
        var id = "#" + this.svgObject.id;
        this.svgRenderer._setAttr(bbdesigner$(this.svgObject).find(id + "_XAxis," + id + "_ChartArea," + id + "_YAxis," + id + "_SeriesCollection," + id + "_StriplineBehind," + id + '_StriplineOver'), { "cursor": "default" });
    },
    _cursorToPointer: function () {
        var id = "#" + this.svgObject.id;
        this.svgRenderer._setAttr(bbdesigner$(this.svgObject).find(id + "_XAxis," + id + "_ChartArea," + id + "_YAxis," + id + "_SeriesCollection," + id + "_StriplineBehind," + id + '_StriplineOver'), { "cursor": "pointer" });
    },
    //to remove the select region on redraw
    removeMultiRect: function () {
        bbdesigner$(this.parentgEle).empty();
        this.model.selectedDataCollection = [];
    },
    multiSelectDataCalculation: function () {
        var chart = this, selectedData = [], selectedRectIndex = this.selectedRectIndex,
         rectX = this.oldRectX[selectedRectIndex],
         rectY = this.oldRectY[selectedRectIndex],
         rectWidth = this.oldRectWidth[selectedRectIndex],
         rectHeight = this.oldRectHeight[selectedRectIndex],
         selectFactor = 1,
         selectPosition = 0,
         seriesCollection = this.model.series,
         seriesCollectionLength = seriesCollection.length,
         axes = this.multiAxis,
         axesLength = axes.length,
         multiSelectType = this.multiSelectType,
         axis, previousSelectFactor, previousSelectPosition,
         xMin, xMax, yMin, yMax,
         visiblePoints, type, baseRange,
         start, end, isEmpty, xOriginalVisibleRange, yOriginalVisibleRange,
         areaType = this.model.AreaType.toLowerCase(),
         xValue, y, isInversed, stackYValue,
         isTransposed, selectionSettings, series;
        for (var i = 0; i < seriesCollectionLength; i++) {
            series = seriesCollection[i];
            xOriginalVisibleRange = series.xAxis.visibleRange;
            yOriginalVisibleRange = series.yAxis.visibleRange;
            var xAxisName = axes.some((function (val) {
                return val.name.toLowerCase() == series._xAxisName.toLowerCase();
            }));
            var yAxisName = axes.some((function (val) {
                return val.name.toLowerCase() == series._yAxisName.toLowerCase();
            }));

            selectionSettings = series.selectionSettings;
            if ((xAxisName && yAxisName) && series.visibility.toLowerCase() == 'visible') {
                for (var k = 0; k < axesLength; k++) {
                    axis = axes[k];
                    previousSelectFactor = selectFactor;
                    previousSelectPosition = selectPosition;
                    if (axis.orientation.toLowerCase() == "horizontal") {
                        this.selectFactor = selectionSettings.rangeType.toLowerCase() != "y"
                            ? previousSelectFactor * (rectWidth / (this.multiAxis[k].width)) : selectFactor;
                        this.selectPosition = selectionSettings.rangeType.toLowerCase() != "y"
                            ? previousSelectPosition + Math.abs((rectX - this.multiAxis[k].x) / (this.multiAxis[k].width)) * previousSelectFactor : selectPosition;
                        if (parseFloat(selectFactor.toFixed(3)) <= 0.001) {
                            this.selectFactor = previousSelectFactor;
                            this.selectPosition = previousSelectPosition;
                        }
                    }
                    else {
                        this.selectFactor = selectionSettings.rangeType.toLowerCase() != "x"
                            ? previousSelectFactor * rectHeight / this.multiAxis[k].height : selectFactor;
                        this.selectPosition = selectionSettings.rangeType.toLowerCase() != "x"
                            ? previousSelectPosition + (1 - Math.abs((rectHeight + (rectY - this.multiAxis[k].y)) / (this.multiAxis[k].height))) * previousSelectFactor : selectPosition;
                        if (parseFloat(selectFactor.toFixed(3)) <= 0.001) {
                            this.selectFactor = previousSelectFactor;
                            this.selectPosition = previousSelectPosition;
                        }
                    }
                    axis.visibleRange = bbdesigner$.extend(true, {}, axis.actualRange);
                    if (this.selectFactor < 1 || this.selectPosition > 0) {
                        if (axis.valueType == "logarithmic") baseRange = axis.visibleRange;
                        else baseRange = axis.actualRange;
                        this.selectFactor = this.selectFactor > 1 ? 1 : (this.selectFactor < 0 ? 0 : this.selectFactor);
                        this.selectPosition = this.selectPosition < 0 ? 0 : (this.selectPosition > 1 ? 1 : this.selectPosition);
                        if (axis.isInversed) {
                            start = axis.actualRange.max - this.selectPosition * axis.actualRange.delta;
                            end = start - this.selectFactor * axis.actualRange.delta;
                            isInversed = true;
                        }
                        else {
                            start = Math.abs(axis.actualRange.min + this.selectPosition * axis.actualRange.delta);
                            end = start + this.selectFactor * axis.actualRange.delta;
                        }
                        if (start < baseRange.min) {
                            end = end + (baseRange.min - start);
                            start = baseRange.min;
                        }
                        if (end > baseRange.max) {
                            start = start - (end - baseRange.max);
                            end = baseRange.max;
                        }
                        if (axis.valueType == "logarithmic") {
                            start = Math.pow(10, start);
                            end = Math.pow(10, end);
                        }
                        axis.visibleRange.min = Math.min(start, end);
                        axis.visibleRange.max = Math.max(start, end);
                    }
                }
                visiblePoints = series._visiblePoints;
                type = series.type.toLowerCase(), isTransposed = series.isTransposed;
                xMin = series.xAxis.visibleRange.min; xMax = series.xAxis.visibleRange.max;
                yMin = series.yAxis.visibleRange.min; yMax = series.yAxis.visibleRange.max;
                if (BoldBIDashboard.util.isNullOrUndefined(selectedData)) selectedData = [];
                switch (multiSelectType) {
                    case 'x':
                        for (var k = 0; k < visiblePoints.length; k++) {
                            visiblePoints[k].seriesIndex = i;
                            isEmpty = visiblePoints[k].isEmpty;
                            xValue = visiblePoints[k].xValue;
                            y = visiblePoints[k].y;
                            if (series.xAxis.isInversed || series.yAxis.isInversed) {
                                if (type.indexOf('bar') >= 0) {
                                    if (type.indexOf('stacking') >= 0) {
                                        stackYValue = series.stackedValue.EndValues[k];
                                        if (!isEmpty && yMax >= stackYValue && yMin <= stackYValue)
                                            selectedData.push(visiblePoints[k]);
                                    }
                                    else {
                                        if (type == 'waterfall' && !isEmpty && yMax >= visiblePoints[k].YValues[0] && yMin <= visiblePoints[k].YValues[0])
                                            selectedData.push(visiblePoints[k]);
                                        else if (!isEmpty && yMax >= y && yMin <= y)
                                            selectedData.push(visiblePoints[k]);
                                    }
                                }
                                else {
                                    if (!isEmpty && xMax >= xValue && xMin <= xValue)
                                        selectedData.push(visiblePoints[k]);
                                }
                            }
                            else {
                                if (isTransposed && (type.indexOf('bar') >= 0)) {
                                    if (!isEmpty && xMin <= xValue && xMax >= xValue)
                                        selectedData.push(visiblePoints[k]);
                                }
                                else if ((type.indexOf('bar') >= 0) || ((series.isTransposed) && (!(type.indexOf('bar') >= 0)))) {
                                    if (type.indexOf('stacking') >= 0) {
                                        stackYValue = series.stackedValue.EndValues[k];
                                        if (!isEmpty && yMin <= stackYValue && yMax >= stackYValue)
                                            selectedData.push(visiblePoints[k]);
                                    }
                                    else {
                                        if (type == 'waterfall' && !isEmpty && yMin <= visiblePoints[k].YValues[0] && yMax >= visiblePoints[k].YValues[0])
                                            selectedData.push(visiblePoints[k]);
                                        else if (!isEmpty && yMin <= y && yMax >= y)
                                            selectedData.push(visiblePoints[k]);
                                    }
                                }
                                else {
                                    if (!isEmpty && xMin <= xValue && xMax >= xValue)
                                        selectedData.push(visiblePoints[k]);
                                }
                            }
                        }
                        break;
                    case 'y':
                        for (var k = 0; k < visiblePoints.length; k++) {
                            visiblePoints[k].seriesIndex = i;
                            isEmpty = visiblePoints[k].isEmpty;
                            xValue = visiblePoints[k].xValue;
                            y = visiblePoints[k].y;
                            if (series.xAxis.isInversed || series.yAxis.isInversed) {
                                if (type.indexOf('bar') >= 0) {
                                    if (!isEmpty && xMax >= xValue && xMin <= xValue)
                                        selectedData.push(visiblePoints[k]);
                                }
                                else {
                                    if (type.indexOf('stacking') >= 0) {
                                        stackYValue = series.stackedValue.EndValues[k];
                                        if (!isEmpty && yMin <= stackYValue && yMax >= stackYValue)
                                            selectedData.push(visiblePoints[k]);
                                    }
                                    else {
                                        if (type == 'waterfall' && !isEmpty && yMax >= visiblePoints[k].YValues[0] && yMin <= visiblePoints[k].YValues[0])
                                            selectedData.push(visiblePoints[k]);
                                        else if (!isEmpty && yMax >= y && yMin <= y)
                                            selectedData.push(visiblePoints[k]);
                                    }
                                }
                            }
                            else {
                                if (isTransposed && (type.indexOf('bar') >= 0)) {
                                    if (type.indexOf('stacking') >= 0) {
                                        stackYValue = series.stackedValue.EndValues[k];
                                        if (!isEmpty && yMin <= stackYValue && yMax >= stackYValue)
                                            selectedData.push(visiblePoints[k]);
                                    }
                                    else {
                                        if (type == 'waterfall' && !isEmpty && yMin <= visiblePoints[k].YValues[0] && yMax >= visiblePoints[k].YValues[0])
                                            selectedData.push(visiblePoints[k]);
                                        else if (!isEmpty && yMin <= y && yMax >= y)
                                            selectedData.push(visiblePoints[k]);
                                    }
                                }
                                else if ((type.indexOf('bar') >= 0) || ((series.isTransposed) && (!(type.indexOf('bar') >= 0)))) {
                                    if (!isEmpty && xMin <= xValue && xMax >= xValue)
                                        selectedData.push(visiblePoints[k]);
                                }
                                else {
                                    if (type.indexOf('stacking') >= 0) {
                                        stackYValue = series.stackedValue.EndValues[k];
                                        if (!isEmpty && yMin <= stackYValue && yMax >= stackYValue)
                                            selectedData.push(visiblePoints[k]);
                                    }
                                    else {
                                        if (type == 'waterfall' && !isEmpty && yMin <= visiblePoints[k].YValues[0] && yMax >= visiblePoints[k].YValues[0])
                                            selectedData.push(visiblePoints[k]);
                                        else if (!isEmpty && yMin <= y && yMax >= y)
                                            selectedData.push(visiblePoints[k]);
                                    }
                                }
                            }
                        }
                        break;
                    case 'xy':
                        for (var k = 0; k < visiblePoints.length; k++) {
                            visiblePoints[k].seriesIndex = i;
                            isEmpty = visiblePoints[k].isEmpty;
                            xValue = visiblePoints[k].xValue;
                            y = visiblePoints[k].y;
                            if (type.indexOf('stacking') >= 0) {
                                stackYValue = series.stackedValue.EndValues[k];
                                if (!isEmpty && xMax >= xValue && xMin <= xValue && yMin <= stackYValue && yMax >= stackYValue)
                                    selectedData.push(visiblePoints[k]);
                            }
                            else {
                                if (type == 'waterfall' && !isEmpty && xMax >= xValue && xMin <= xValue && yMin <= visiblePoints[k].YValues[0] && yMax >= visiblePoints[k].YValues[0])
                                    selectedData.push(visiblePoints[k]);
                                else if (!isEmpty && xMax >= xValue && xMin <= xValue && yMin <= y && yMax >= y)
                                    selectedData.push(visiblePoints[k]);
                            }
                        }
                        break;
                }
            }
            series.xAxis.visibleRange = xOriginalVisibleRange;
            series.yAxis.visibleRange = yOriginalVisibleRange;
        }
        var currentIndex = this.currentIndex;
        if (BoldBIDashboard.util.isNullOrUndefined(this.model.selectedDataCollection)) this.model.selectedDataCollection = [];
        if (this.removeRect) this.model.selectedDataCollection.splice(currentIndex, 1);
        else if (this.rectPan || this.resize) {
            this.model.selectedDataCollection[currentIndex] = 0;
            this.model.selectedDataCollection[currentIndex] = selectedData;
        }
        else this.model.selectedDataCollection[this.model.selectedDataCollection.length] = selectedData;
        //trigger rangeSelected event to get the selected region's data
        var commonloadEventArgs = bbdesigner$.extend({}, BoldBIDashboard.EjSvgRender.commonChartEventArgs);
        commonloadEventArgs.data = {};
        commonloadEventArgs.data.selectedData = selectedData;
        commonloadEventArgs.data.selectedDataCollection = this.model.selectedDataCollection;
        this._trigger("rangeSelected", commonloadEventArgs);
    },
    multiSelectMouseUp: function (evt) {
        if (this._isMultiSelect && (this.multiSelectMode == 'range')) {
            var selectRectWidth, selectRectHeight, selectRectX, selectRectY, cx, cy, index,
            containerSvg = this.svgObject.id, selectedRectIndex = this.selectedRectIndex,
            selectRectId = "#" + containerSvg + "_selectRect",
            selectRectWidth = parseInt(bbdesigner$(selectRectId + selectedRectIndex).attr("width")),
            selectRectHeight = parseInt(bbdesigner$(selectRectId + selectedRectIndex).attr("height")),
            selectRectX = parseInt(bbdesigner$(selectRectId + selectedRectIndex).attr("x")),
            selectRectY = parseInt(bbdesigner$(selectRectId + selectedRectIndex).attr("y"));
            if ((this.multiSelectDraw || !this.removeRect || !this.resize || !this.rectPan) && (selectRectWidth > 0 && selectRectHeight > 0)) {
                var rightRectOptions = {
                    'id': containerSvg + '_resize_rightRect' + selectedRectIndex,
                    'x': selectRectX + selectRectWidth - 5,
                    'y': selectRectY + 10,
                    'width': 10,
                    'height': selectRectHeight - 20 > 0 ? selectRectHeight - 20 : 0,
                    'fill': "transparent",
                    'stroke': "transparent",
                    'stroke-width': 2,
                    'cursor': 'e-resize'
                };
                this.svgRenderer.drawRect(rightRectOptions, this.gEle);
                var bottomRectOptions = {
                    'id': containerSvg + '_resize_bottomRect' + selectedRectIndex,
                    'x': selectRectX,
                    'y': selectRectY + selectRectHeight - 5,
                    'width': selectRectWidth - 10 > 0 ? selectRectWidth - 10 : 0,
                    'height': 10,
                    'fill': "transparent",
                    'stroke': "transparent",
                    'stroke-width': 2,
                    'cursor': 's-resize'
                };
                this.svgRenderer.drawRect(bottomRectOptions, this.gEle);
                var leftRectOptions = {
                    'id': containerSvg + '_resize_leftRect' + selectedRectIndex,
                    'x': selectRectX - 5,
                    'y': selectRectY,
                    'width': 10,
                    'height': selectRectHeight,
                    'fill': "transparent",
                    'stroke': "transparent",
                    'stroke-width': 2,
                    'cursor': 'w-resize'
                };
                this.svgRenderer.drawRect(leftRectOptions, this.gEle);
                var topRectOptions = {
                    'id': containerSvg + '_resize_topRect' + selectedRectIndex,
                    'x': selectRectX,
                    'y': selectRectY - 5,
                    'width': selectRectWidth - 10 > 0 ? selectRectWidth - 10 : 0,
                    'height': 10,
                    'fill': "transparent",
                    'stroke': "transparent",
                    'stroke-width': 2,
                    'cursor': 'n-resize'
                };
                this.svgRenderer.drawRect(topRectOptions, this.gEle);
                var bottomRightCornerCircleOptions = {
                    'id': containerSvg + '_resize_bottomRightCornerCircle' + selectedRectIndex,
                    'cx': selectRectX + selectRectWidth,
                    'cy': selectRectY + selectRectHeight,
                    'r': 10,
                    'fill': "transparent",
                    'stroke': "transparent",
                    'stroke-width': 2,
                    'cursor': 'se-resize'
                };
                this.svgRenderer.drawCircle(bottomRightCornerCircleOptions, this.gEle);
                var topRightCornerCircleOptions = {
                    'id': containerSvg + '_closeTopRightCornerCircle' + selectedRectIndex,
                    'cx': selectRectX + selectRectWidth,
                    'cy': selectRectY,
                    'r': 10,
                    'fill': "white",
                    'stroke': "#2988d6",
                    'stroke-width': 2,
                    'cursor': 'pointer'
                };
                this.svgRenderer.drawCircle(topRightCornerCircleOptions, this.gEle);
                var closingPathOptions = {
                    'id': containerSvg + '_closePath' + selectedRectIndex,
                    'x1': selectRectX + selectRectWidth - 4,
                    'y1': selectRectY - 4,
                    'x2': selectRectX + selectRectWidth + 4,
                    'y2': selectRectY + 4,
                    'stroke': "#2988d6",
                    'stroke-width': 2,
                    'cursor': 'pointer'
                };
                this.svgRenderer.drawLine(closingPathOptions, this.gEle);
                var closingPathOppositeOptions = {
                    'id': containerSvg + '_closePathOpposite' + selectedRectIndex,
                    'x1': selectRectX + selectRectWidth + 4,
                    'y1': selectRectY - 4,
                    'x2': selectRectX + selectRectWidth - 4,
                    'y2': selectRectY + 4,
                    'stroke': "#2988d6",
                    'stroke-width': 2,
                    'cursor': 'pointer'
                };
                this.svgRenderer.drawLine(closingPathOppositeOptions, this.gEle);
                cx = [16, 10, 4, 10, 4, 4];
                cy = [4, 4, 4, 10, 10, 16];
                index = ["a", "b", "c", "d", "e", "f"];
                for (var t = 0; t < 6; t++) {
                    var gripOptions = {
                        'id': containerSvg + '_gripCircle_' + index[t] + selectedRectIndex,
                        'cx': selectRectX + selectRectWidth - cx[t],
                        'cy': selectRectY + selectRectHeight - cy[t],
                        'r': 0.4,
                        'stroke': "#5B5B5B",
                        'stroke-width': 2,
                    }
                    this.svgRenderer.drawCircle(gripOptions, this.gripCollection);
                }
                if ((this.gripCollection != null))
                    bbdesigner$(this.gripCollection).appendTo(this.gEle);
                bbdesigner$("#" + containerSvg + "_gripCollection" + selectedRectIndex).css({ 'visibility': 'hidden' });
            }
            if (BoldBIDashboard.util.isNullOrUndefined(this.oldRectX)) {
                this.oldRectX = []; this.oldRectY = []; this.oldRectWidth = []; this.oldRectHeight = [];
                this.oldReRightRectX = []; this.oldReTopRectY = []; this.oldReBottomRectY = [];
            }
            this.oldRectX[selectedRectIndex] = parseInt(bbdesigner$(selectRectId + selectedRectIndex).attr('x'));
            this.oldRectY[selectedRectIndex] = parseInt(bbdesigner$(selectRectId + selectedRectIndex).attr('y'));
            this.oldRectWidth[selectedRectIndex] = parseInt(bbdesigner$(selectRectId + selectedRectIndex).attr('width'));
            this.oldRectHeight[selectedRectIndex] = parseInt(bbdesigner$(selectRectId + selectedRectIndex).attr('height'));
            this.oldReRightRectX[selectedRectIndex] = parseInt(bbdesigner$("#" + containerSvg + "_resize_rightRect" + selectedRectIndex).attr('x'));
            this.oldReTopRectY[selectedRectIndex] = parseInt(bbdesigner$("#" + containerSvg + "_resize_topRect" + selectedRectIndex).attr('y'));
            this.oldReBottomRectY[selectedRectIndex] = parseInt(bbdesigner$("#" + containerSvg + "_resize_bottomRect" + selectedRectIndex).attr('y'));
            this.oldMultiSelectType = this.multiSelectType;
            if (this.resize || this.rectPan) {
                //to remove the grip after resizing at the bottom right corner
                if (this.resize)
                    bbdesigner$("#" + this.svgObject.id + "_gripCollection" + selectedRectIndex).attr({ 'transform': "" });
                bbdesigner$("#" + containerSvg + "_closeTopRightCornerCircle" + selectedRectIndex).css({ 'display': 'inline' });
                bbdesigner$("#" + containerSvg + "_closePath" + selectedRectIndex).css({ 'display': 'inline' });
                bbdesigner$("#" + containerSvg + "_closePathOpposite" + selectedRectIndex).css({ 'display': 'inline' });
                bbdesigner$("#" + containerSvg + '_resize_rightRect' + selectedRectIndex).css({ 'cursor': 'e-resize' });
                bbdesigner$("#" + containerSvg + '_resize_leftRect' + selectedRectIndex).css({ 'cursor': 'w-resize' });
                bbdesigner$("#" + containerSvg + '_resize_bottomRect' + selectedRectIndex).css({ 'cursor': 's-resize' });
                bbdesigner$("#" + containerSvg + '_resize_topRect' + selectedRectIndex).css({ 'cursor': 'n-resize' });
            }
            this.drag = false;
            if (this.removeRect) {
                bbdesigner$("#" + containerSvg + "_selectedRectGroup" + selectedRectIndex).remove();
                if (this.parentgEle.childNodes.length <= 0) bbdesigner$(this.parentgEle).remove();
            }
            if ((this.multiSelectDraw || this.removeRect || this.resize || this.rectPan) && (selectRectWidth > 0 && selectRectHeight > 0)) {
                this.multiSelectDraw = false;
                this.multiSelectDataCalculation(evt);
            }
            if (this.resize) this.resize = false;
            if (this.rectPan) this.rectPan = false;
            this.removeRect = false;
            this.enableTrackBall();
        }
    },
     chartMouseUp: function (evt) {
         // this.cancelEvent(evt);
         var model = this.model;
         var data = this.GetSeriesPoint(evt);
         if (this.isTouch(evt)) {
             this.chartMouseUpTouch(evt);
         }

         if (this._scrollBarEnabled) {
             if (this.model.disableZoom)
                 this._scrollRedraw();
             this._scrollBarEnabled = false;
             var commonAxesEventArgs,
                 axis;
             for (var i = 0; i < this.model._axes.length; i++) {
                 axis = this.model._axes[i];
                 commonAxesEventArgs = bbdesigner$.extend({}, BoldBIDashboard.EjSvgRender.commonChartEventArgs);
                 commonAxesEventArgs.data = { axis: axis, zoomFactor: axis.zoomFactor, zoomPosition: axis.zoomPosition, oldRange: axis.previousRange, newRange: axis.visibleRange };
                 this._trigger("scrollEnd", commonAxesEventArgs);
             }

         }
         if (this.multiSelectAreaType == 'cartesianaxes' && (!model.zooming.enable) && (!model.enableCanvasRendering))
             this.multiSelectMouseUp(evt);
         var chart = this;
         if (model.zooming.enable && model.AreaType == "cartesianaxes") {
             var zoomRect = bbdesigner$("#" + this.svgObject.id + "_ZoomArea");
             if (zoomRect[0]) {
                 if (model.enableCanvasRendering) {
                     var zoomArea = zoomRect[0].getClientRects()[0];
                     var zoomRectWidth = zoomArea.width;
                     var zoomRectHeight = zoomArea.height;
                 } else {
                     var bbdesigner$zoomRect = bbdesigner$(zoomRect);
                     var zoomRectWidth = parseFloat(this.svgRenderer._getAttrVal(bbdesigner$zoomRect, "width"));
                     var zoomRectHeight = parseFloat(this.svgRenderer._getAttrVal(bbdesigner$zoomRect, "height"));
                 }
             }
             if (zoomRectWidth > 0 && zoomRectHeight > 0) {
                 chart.doZoom(zoomRect, zoomRectWidth, zoomRectHeight);
             }
             else
                 this.drag = false;
             if (!chart.panning)
                 this.enableTrackBall();
         }
         // Panning is done on mouse up for other devices and when deferredZoom is set to true
         var id = this.svgObject.id;
         var parentId = BoldBIDashboard.util.isNullOrUndefined(evt.target.parentNode) ? "" : evt.target.parentNode.id;

         //condition to find the buttons
         if (parentId == id + "_ResetZoom" || parentId == id + '_ZoomBtn' || evt.target.id == id + "_ResetZoom" || evt.target.id == id + '_ZoomBtn') {
             this.panning = false;
             this.model._chartAreaZoom = false;
         }

         //Panning for other devices
         if ((BoldBIDashboard.isTouchDevice() || model.zooming.enableDeferredZoom) && this.panning && this.doPan && model.AreaType == "cartesianaxes") {
             var oDelta;
             oDelta = {
                 'x': this.oPreviousCoords.x - this.currentPageX,
                 'y': this.oPreviousCoords.y - this.currentPageY
             };

             this.oPreviousCoords = {
                 'x': this.currentPageX,
                 'y': this.currentPageY
             };
             bbdesigner$.each(model._axes, function (index, axis) {
                 var currentScale = Math.max(1 / BoldBIDashboard.EjSvgRender.utils._minMax(axis.zoomFactor, 0, 1), 1);
                 chart.translate(axis, (oDelta.x), (oDelta.y), currentScale);
             });
             this.model.legendCollapsed = false;
             this.redraw(true);
             this._cursorToPointer();
             this._enableZoomingButtons();
         }

         if (this.doPan)
             this.doPan = false;
         this.rotateActivate = false;
         var milliSeconds = evt.originalEvent.pointerType == 'touch' ? 1500 : 300;
         if (BoldBIDashboard.isTouchDevice() && evt.originalEvent.pointerType == 'touch' && this.model.chartDoubleClick != '' && evt.button != 2) {
             end = new Date();
             if (chart.model._tapTimer != null && end - chart.model._tapTimer < milliSeconds) {
                 clearTimeout(this.timer);
                 var targetId = evt.target.id;
                 if (!data && targetId.indexOf("Point") != -1) {
                     for (var i = chart.model._visibleSeries.length - 1; i >= 0; i--) {
                         chartSeries = chart.model._visibleSeries[i];
                         var type = chartSeries.type.toLowerCase();
                         if (chart.model.AreaType == "cartesianaxes" && chartSeries.visibility.toLowerCase() == 'visible' && type !== "scatter" && type !== "bubble" && type !== "column" && type.indexOf("bar") == -1 && type !== "stackingcolumn" && type !== "stackingcolumn100" && !chartSeries._hiloTypes) {
                             var serY = [];
                             var serX = [];
                             var location = null;
                             var closestXyPoint = this.getClosesPointXY(serX, serY, chartSeries, this.mousemoveX, this.mousemoveY, evt);
                             if (!BoldBIDashboard.util.isNullOrUndefined(closestXyPoint.point)) {
                                 seriesIndex = i;
                                 pointIndex = closestXyPoint.index;
                                 var commonEventArgs = bbdesigner$.extend({}, BoldBIDashboard.EjSvgRender.commonChartEventArgs);
                                 commonEventArgs.data = { location: { x: this.mousemoveX, y: this.mousemoveY }, region: { SeriesIndex: i, Region: { PointIndex: closestXyPoint.index } }, size: { height: this.model.svgHeight, width: this.model.svgWidth }, id: evt.target.id, pageX: evt.pageX, pageY: evt.pageY };
                                 this._trigger("chartDoubleClick", commonEventArgs);
                                 break;
                             }
                         }
                     }
                 }
                 else if (data) {
                     var commonEventArgs = bbdesigner$.extend({}, BoldBIDashboard.EjSvgRender.commonChartEventArgs);
                     commonEventArgs.data = { location: { x: this.mousemoveX, y: this.mousemoveY }, region: data ? data.region : null, size: { height: this.model.svgHeight, width: this.model.svgWidth }, id: evt.target.id, pageX: evt.pageX, pageY: evt.pageY };
                     this._trigger("chartDoubleClick", commonEventArgs);
                 }
             }
             else {
                 this.timer = setTimeout(function () {
                     chart._doClick(evt);
                 }, milliSeconds + 1);
             }
             chart.model._tapTimer = end;
         }
     },
    chartMouseUpTouch: function (evt) {        
        var chart = this;
        if (!chart.drag) chart.singleTap(evt);

        return false;
    },
    isTouch: function (evt) {
        var browserInfo = this.model.browserInfo,
            event = evt.originalEvent ? evt.originalEvent : evt;
        if ((event.pointerType == "touch") || (event.pointerType == 2) || (event.type.indexOf("touch") > -1))
            return true;
        return false;
    },

    // Method invoking userinteraction in single Tap.
    singleTap: function (evt) {
        var chart = this;
	    
        if ((!chart.panning)) {
            chart.cancelEvent(evt);
            bbdesigner$("#" + chart.svgObject.id + "_TrackToolTip").remove();
            if (!chart.model.crosshair.visible || chart.model.AreaType != "cartesianaxes") {
                chart.chartInteractiveBehavior(evt);
            }
			var data = chart.GetSeriesPoint(evt);
			if ((!this.model.chartDoubleClick || !evt.originalEvent.pointerType) && (this.model.selectionEnable || this.isDevice())) {
				chart._isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
				if(this._isSafari)
                    this.chartMouseClick(evt);
				else if(data)
					this._doClick(evt);
			}
        }
    },
    _pointerTouchEnd: function (e) {
        var event = e.originalEvent,
            mouseLeave = (event.type.indexOf("leave")!=-1 || event.type.indexOf("out")!= -1 || event.type.indexOf("Out")!=-1);
			 this.chartMouseUp(e);
            mouseLeave && this.chartMouseLeave(e); //Trigger mouse leave event
				
	},
	  
    multiSelectMouseDown: function (evt) {
        this.disableTrackBall();
        var seriesCollection = this.model.series,
            seriesCollectionLength = seriesCollection.length,
            id, mouseDownCords,
            containerSvg = this.svgObject.id,
         selectMode = seriesCollection.some((function (val) {
             return val.selectionSettings.mode.toLowerCase() == 'range';
         }));
        this._isMultiSelect = seriesCollection.some((function (val) {
            return val.selectionSettings.enable == true;
        }));
        if (selectMode) this.multiSelectMode = 'range';
        for (var i = 0; i < seriesCollectionLength; i++) {
            if ((seriesCollection[i].selectionSettings.enable == true) && (seriesCollection[i].selectionSettings.mode.toLowerCase() == 'range'))
                this.multiSelectType = seriesCollection[i].selectionSettings.rangeType.toLowerCase();
        }
        var matched = bbdesigner$.uaMatch(navigator.userAgent);
        if (this._isMultiSelect && this.multiSelectMode == 'range') {
			if (matched.browser == 'chrome' || matched.browser == 'mozilla') evt.preventDefault();
            mouseDownCords = this.calMousePosition(evt);
            this.mouseDownX = mouseDownCords.X;
            this.mouseDownY = mouseDownCords.Y;
            this.drag = true;
            if ((bbdesigner$(this.parentgEle).find("g").length < 1))
                this.selectedRectIndex = 0;
            else {
                id = bbdesigner$(this.parentgEle).find("g").last().attr("id");
                matchStr = containerSvg + "_gripCollection";
                id = parseInt(id.substr(matchStr.length));
                this.selectedRectIndex = id + 1;
            }
            if (bbdesigner$(this.parentgEle).find("g").length == 0) {
                this.parentgEle = this.svgRenderer.createGroup({ 'id': containerSvg + '_rectSelectionGroup' });
            }
            this.gEle = this.svgRenderer.createGroup({ 'id': containerSvg + '_selectedRectGroup' + this.selectedRectIndex });
            if (bbdesigner$(this.gripCollection).find("g").length == 0)
            this.gripCollection = this.svgRenderer.createGroup({ 'id': containerSvg + '_gripCollection' + this.selectedRectIndex });
            if (evt.target.id.indexOf("resize") >= 0) {
                id = evt.target.id.split("resize")[1].match(/\d+/)[0];
                this.selectedRectIndex = eval(id);
                this.multiSelectMouseDownId = evt.target.id;
                this.resize = true;
            }
            if (evt.target.id.indexOf("close") >= 0) {
                id = evt.target.id.split("close")[1].match(/\d+/)[0];
                this.selectedRectIndex = eval(id);
                this.removeRect = true;
            }
            if ((evt.target.id.indexOf(this.svgObject.id + "_selectRect") >= 0)) {
                matchStr = this.svgObject.id + "_selectRect";
                this.selectedRectIndex = parseInt(evt.target.id.substr(matchStr.length));
            }
            if (evt.target.id == containerSvg + '_selectRect' + this.selectedRectIndex) {
                this.rectPan = true;
                this.PreviousCoords = {
                    'X': evt.pageX, 'Y': evt.pageY
                }
            }
            this.currentIndex = bbdesigner$(evt.target.parentNode).index();
            var axes = this.model._axes,
            axesLength = axes.length, axis,
            mouseMoveCords = this.calMousePosition(evt),
            mouseMoveX = mouseMoveCords.X,
            mouseMoveY = mouseMoveCords.Y;
            this.multiAxis = []
            for (var k = 0; k < axesLength; k++) {
                axis = axes[k];
                if ((mouseMoveX > axis.Location.X1) && (mouseMoveX < axis.Location.X2))
                    this.multiAxis.push(axis);
                if ((mouseMoveY < axis.Location.Y1) && (mouseMoveY > axis.Location.Y2))
                    this.multiAxis.push(axis);
            }
        }
    },

    chartMouseDown: function (e) {
        // this.cancelEvent(e);
        var model = this.model;
        var className = (e.target.classList) ? e.target.classList[0] : "";
        if (className && (className.indexOf("e-v") || className.indexOf("e-h"))) {
            this._scrollBarEnabled = true;
            this.panning = (this.zoomed) ? this.zoomed : this.panning;
            var commonAxesEventArgs,
            axis;
            for (var i = 0; i < this.model._axes.length; i++) {
                axis = this.model._axes[i];
                if (axis.enableScrollbar || !this.model.disableZoom) {                   
                commonAxesEventArgs = bbdesigner$.extend({}, BoldBIDashboard.EjSvgRender.commonChartEventArgs);
                commonAxesEventArgs.data = { axis: axis, zoomFactor: axis.zoomFactor, zoomPosition: axis.zoomPosition, currentRange: axis.visibleRange };
                this._trigger("scrollStart", commonAxesEventArgs);
                axis.previousRange = bbdesigner$.extend(true, {}, axis.visibleRange);
            }
        }
        }
        if (!this.svgRenderer.vmlNamespace) {
            this.oPreviousCoords = {};
            this.multiSelectAreaType = this.model.AreaType.toLowerCase();
            var mouseDownCords = this.calMousePosition(e),
                chartX = model.m_AreaBounds.X, chartWidth = model.m_AreaBounds.Width,
                chartY = model.m_AreaBounds.Y, chartHeight = model.m_AreaBounds.Height;
           //to check whether the click is made within the chart area
           if (this.multiSelectAreaType == 'cartesianaxes' && (!model.zooming.enable) && (!model.enableCanvasRendering)
                && mouseDownCords.X >= chartX && mouseDownCords.X < (chartX + chartWidth) && mouseDownCords.Y < (chartY + chartHeight) && mouseDownCords.Y >= chartY)
                this.multiSelectMouseDown(e);
            var parent = this.svgRenderer._getAttrVal(bbdesigner$(e.target).parent(), "id");
            if (parent != this.svgObject.id + "_ResetZoom" && parent != this.svgObject.id + "_PanBtn" && parent != undefined && this.model.zooming.enable && !this.model.disableZoom && !(this.panning) && this.model.AreaType == "cartesianaxes") {
                this.mouseDownX = mouseDownCords.X;
                this.mouseDownY = mouseDownCords.Y;
                if (this.mouseDownX >= this.model.m_AreaBounds.X && this.mouseDownX < (model.m_AreaBounds.X + model.m_AreaBounds.Width) && this.mouseDownY < (model.m_AreaBounds.Y + model.m_AreaBounds.Height) && this.mouseDownY >= model.m_AreaBounds.Y) {
                    this.drag = true;
                    this.disableTrackBall();
                }


            }
            else if (this.panning || bbdesigner$(e.target)[0].className == "e-hhandle e-box") {
                var mousePanCords = this.calMousePosition(e);
                this.mousePanX = mousePanCords.X;
                this.mousePanY = mousePanCords.Y;                
                if (this.mousePanX >= model.m_AreaBounds.X && this.mousePanX < (model.m_AreaBounds.X + model.m_AreaBounds.Width) && this.mousePanY < (model.m_AreaBounds.Y + model.m_AreaBounds.Height + 18) && this.mousePanY >= model.m_AreaBounds.Y) {
                    this.doPan = true;
                    this.oPreviousCoords = {
                        'x': e.pageX,
                        'y': e.pageY
                    };
                }
            }


        }
        if (this.model.enable3D && this.model.enableRotation)
            this.rotateActivate = true;
    },
    chartMouseLeave: function (evt) {
        var chart = this;
        chart.cancelEvent(evt);
        // Changes the visibility to hidden
        if (chart.isTouch(evt)) {
            window.clearTimeout(chart.model.timer);
            chart.model.timer = setTimeout(function () {
                bbdesigner$("#" + chart.svgObject.id + "_TrackToolTip").fadeOut(500);
            }, 1200);
        }
        else
            bbdesigner$("#" + this.svgObject.id + "_TrackToolTip").hide();
        if ((bbdesigner$(".tooltipDiv").hasClass(this.svgObject.id)))
            bbdesigner$(".tooltipDiv").remove();
		bbdesigner$("[id*=" + "_TrackSymbol" + "]").remove();
        this._removeTrackBall();
        this._removeHighlight();
		bbdesigner$("#" + this._id + "_tooltip").remove();
		 // chartMouseLeave event
        var commonEventArgs = bbdesigner$.extend({}, BoldBIDashboard.EjSvgRender.commonChartEventArgs);
        commonEventArgs.data = { location: { x: this.mousemoveX, y: this.mousemoveY },size:{height:this.model.svgHeight,width:this.model.svgWidth}, id: evt.target.id, pageX: evt.pageX, pageY: evt.pageY };
        this._trigger("chartMouseLeave", commonEventArgs);
        
    },
    chartTouchClick: function (evt) {
	    this.cancelEvent(evt);
         evt = evt.originalEvent.touches[0];
        this._doClick(evt);
    },
    chartRightClick: function (evt) {
        evt.preventDefault();
        this.cancelEvent(evt);
        var commonEventArgs = bbdesigner$.extend({}, BoldBIDashboard.EjSvgRender.commonChartEventArgs);
        commonEventArgs.data = { location: { x: this.mousemoveX, y: this.mousemoveY }, size: { height: this.model.svgHeight, width: this.model.svgWidth }, id: evt.target.id, pageX: evt.pageX, pageY: evt.pageY };
        this._trigger("chartRightClick", commonEventArgs);
    },
    _doClick: function (evt) {
        this._removeHighlight();
        if (!this.model.selectedDataPointIndexes)
            this.model.selectedDataPointIndexes = [];
        this.model.clusterPoints = [];
        this.model._isStateChaged = false;
        var seriesIndex,
            pointIndex,
            seriesLenth,
			chartSeries,
			data,
			targetId = evt.target.id,
			svgObjectId = this.svgObject.id,
            seriesCollection = this.model._visibleSeries,
			isZoom = this.isZoomButtonHovered(evt.target);
			targetid = evt.target.id;
			 
           //Set current seriesCollection Selection type for selection state maintains            
           seriesLength = seriesCollection.length;
           for (var k = 0; k < seriesLength; k++)
               this.model._visibleSeries[k].selectionSettings._currentType = this.model._visibleSeries[k].selectionSettings.type;
           var isMultiSelection, mode, isSelectionSetting, commonEventArgs, text, getIndex;
           data = this.GetSeriesPoint(evt);
           if (data) {
               seriesIndex = data.region.SeriesIndex;
               pointIndex = data.region.Region.PointIndex;
           }else {
               //Getting SeriesIndex and PointIndex for Path element type series when marker and dataLabels visible
               if (this.model.selectionEnable) {
                   if (!this.model.enable3D && !(evt.target.id.indexOf('LegendItem') != -1) && this.model.AreaType != 'none') {
                       text = evt.target.id;
                       getIndex = text.match(/(\d+)/g);
                       if (getIndex && (text.indexOf('symbol') != -1 || text.indexOf('Series') != -1) && !(text.indexOf('Text') != -1)) {
                           seriesIndex = parseInt(getIndex[0]);
                           pointIndex = isNaN(parseInt(getIndex[1])) ? 0 : parseInt(getIndex[1]);
                       } else if (getIndex && (text.indexOf('Text') != -1 || text.indexOf('dataLabel') != -1)) {
                           seriesIndex = parseInt(getIndex[0].charAt(0));
                           pointIndex = isNaN(parseInt(getIndex[0].charAt(1))) ? parseInt(getIndex[1].charAt(0)) : parseInt(getIndex[0].charAt(1));
                       }
                   }
               }
           }
		   if (!isZoom || this.model.enableCanvasRendering) {
				for (var i = this.model._visibleSeries.length - 1; i >= 0; i--) {
					chartSeries = this.model._visibleSeries[i];
					chartSeries.seriesIndex = i;
					var type = chartSeries.type.toLowerCase();
					if (this.model.AreaType == "cartesianaxes" && chartSeries.visibility.toLowerCase() == 'visible' && type !== "scatter" && type !== "bubble" && type !== "column" && type.indexOf("bar") == -1 && type !== "stackingcolumn" && type !== "stackingcolumn100" && !chartSeries._hiloTypes) {
						var serY = [];
						var serX = [];
						var location = null;
						var mouseMoveCords = this.calMousePosition(evt);
						this.mousemoveX = mouseMoveCords.X;
						this.mousemoveY = mouseMoveCords.Y;
						var closestXyPoint = this.getClosesPointXY(serX, serY, chartSeries, this.mousemoveX, this.mousemoveY, evt);
						if (!BoldBIDashboard.util.isNullOrUndefined(closestXyPoint.point)) {
						    seriesIndex = i;
						    pointIndex = closestXyPoint.index;
							var commonPointEventArgs = bbdesigner$.extend({}, BoldBIDashboard.EjSvgRender.commonChartEventArgs);
							commonPointEventArgs.data = { id: evt.target.id, pageX: evt.pageX, pageY: evt.pageY ,location: { x: this.mousemoveX, y: this.mousemoveY }, region: { SeriesIndex: i, Region: { PointIndex: closestXyPoint.index } } };
							if (evt.type == "contextmenu" && this.model.enableRightClick)
							    commonPointEventArgs.rightClick = true;
							else
							    commonPointEventArgs.rightClick = false;
							this._trigger("pointRegionClick", commonPointEventArgs);
                            break;
						}
					}
				}			  
				if (data && !isZoom) {
					data.id = evt.target.id;
					data.pageX = evt.pageX;
					data.pageY = evt.pageY;
					commonEventArgs = bbdesigner$.extend({}, BoldBIDashboard.EjSvgRender.commonChartEventArgs);
				    if (evt.type == "contextmenu" && this.model.enableRightClick)
				        commonEventArgs.rightClick = true;
				    else
				        commonEventArgs.rightClick = false;
                    commonEventArgs.data = data;
					this._trigger("pointRegionClick", commonEventArgs);
				}				
			}
			
         if (this.model.enableRightClick && evt.which == 3) //evt.which is 3 for right click, 1 for normal click
		       return;
         if (this.model.AreaType == "none" && this.model.enable3D && bbdesigner$(evt.target)[0].nodeName == "path" && !this.model.enableRightClick) {
            index = bbdesigner$(evt.target)[0].id.match(/(\d+)/g);
            seriesIndex = parseInt(index[index.length - 2]);
            pointIndex = parseInt(index[index.length - 1]);
            var currentexplodeindex = this.model._visibleSeries[seriesIndex].explodeIndex;
			 var actualIndex = this.model._visibleSeries[seriesIndex]._visiblePoints[pointIndex].actualIndex;
            if (currentexplodeindex == actualIndex)
                this.model._visibleSeries[seriesIndex].explodeIndex = null;           
            else
                this.model._visibleSeries[seriesIndex].explodeIndex = actualIndex;
            if (!this.vmlRendering && !this.model.enableCanvasRendering)
                var selection = this.selectedStyle(this);
            bbdesigner$(this.svgObject).empty();
			bbdesigner$(this.legendSvgContainer).empty();
            this.draw();
            if (this.model.AreaType == 'none') {
                this.model._isStateChaged = false;
				var className,elementsLenth,
				styleLength=selection.length,
                pathId = "_Region_Series_" + seriesIndex + "_Point_" + pointIndex,
                gElement = bbdesigner$(this.svgObject).find('[idbbdesigner$=' + pathId + '],[id*=' + pathId + 'back],[id*=' + pathId + 'front]');
				 elementsLength=gElement.length;
                for (var k = 0; k < styleLength; k++) {                    
                    for (var i = 0; i < elementsLength; i++) {
                        if (selection[k].id == gElement[i].id) {
                            className = selection[k].className;
                            if (className.indexOf('SelectionStyle') < 0 && (className.indexOf('Selection' + name + 'Style') < 0)) {
                                bbdesigner$("[id=" + gElement[i].id + "]").attr('class', className);
                            }
                        }
                    }              
                }
                if (selection.pattern)
                    this.svgRenderer.append(selection.pattern, this.svgObject);
            }
            else {
                bbdesigner$('[id*=' + this.svgObject.id + '_LegendItemShape],[id*=_Region_Series_]').each(function () {
                    bbdesigner$(this).attr('class', '');
                });
            }
            }  
        var legenddata = this.getLegendData(evt);
        if (legenddata) {
            bbdesigner$('#template_group_' + this._id).remove();
            var commonEventArgs = bbdesigner$.extend({}, BoldBIDashboard.EjSvgRender.commonChartEventArgs);
            commonEventArgs.data = legenddata;
            this._trigger("legendItemClick", commonEventArgs);
            var seriesIndex = legenddata.legendItem.LegendItem.SeriesIndex;
            // legend selection logic perform here
            if (!this.model.legend.toggleSeriesVisibility && legenddata.series.selectionSettings.enable) {                 
                this.model._isStateChaged = false;
                this.legendSelection(this, legenddata, evt, data);
            }
            if (!commonEventArgs.cancel && this.model.legend.toggleSeriesVisibility) {
				bbdesigner$('[id*=' + this._id + '_Selection_' + ']').remove();
				var length = this.model._visibleSeries.length;
				var legendMode = this.model.legend.mode.toLowerCase();
				var enableMultiRange = this.model.legend.enableMultiRange;
				if ((this.model.AreaType != "none" || (this.model.AreaType == "none" && length > 1)) && legendMode != "point" && ((legendMode == "range" && !enableMultiRange) || (legendMode == "series"))) {
                    var seriesIndex = legenddata.legendItem.LegendItem.SeriesIndex;
                    var trendlineIndex = legenddata.legendItem.LegendItem.TrendLineIndex;
                    if (BoldBIDashboard.util.isNullOrUndefined(trendlineIndex)) {
                        legenddata.series.visibility = legenddata.series.visibility.toLowerCase() === 'visible' ? 'hidden' : 'visible';
                        if (legendMode == "range" && !enableMultiRange) {
                            for (var s = 0; s < this.model.series.length ; s++)
                                this.model.series[s].visibility = legenddata.series.visibility;
                        }
                        else {                            
                            this.model.series[seriesIndex].visibility = legenddata.series.visibility;
                            if (this._notifyArrayChange)
                                this._notifyArrayChange("series[" + seriesIndex + "]visibility", legenddata.series.visibility);
                        }
                    } else {
                        var trendlineVisible = legenddata.series.trendlines[trendlineIndex].visibility.toLowerCase();
                        trendlineVisible = trendlineVisible === 'visible' ? 'hidden' : 'visible';
                        this.model.series[seriesIndex].trendlines[trendlineIndex].visibility = trendlineVisible;
                        if (this._notifyArrayChange)
                            this._notifyArrayChange("series[" + seriesIndex + "].trendlines[" + trendlineIndex + "].visibility", trendlineVisible);
                }
                }
                else {
				    if (this.model.AreaType == "none" && length == 1 || legendMode == "point" || legendMode == "range") {
				        if (enableMultiRange && legendMode == "range" && this.model.rangeColorMapping.length > 0) {
				            var rangePointIndex = legenddata.legendItem.LegendItem.PointIndex;
				            var ptLength = legenddata.legendItem.LegendItem.PointIndexes.length;
				            for (var k = 0; k < this.model._visibleSeries.length; k++) {
				                var visibleSeries = this.model.series[k];
				                for (var p = 0; p < ptLength; p++) {
				                    var index = legenddata.legendItem.LegendItem.PointIndexes[p];
				                    var point = visibleSeries.visiblePoints[index]._visibility;
				                    var pointIndex = visibleSeries.visiblePoints[index].actualIndex;
				                    visibleSeries.points[pointIndex]._visibility = point === 'visible' ? 'hidden' : 'visible';

				                }
				                for (var l = 0; l < visibleSeries.points.length; l++) {
				                    if (visibleSeries.points[l]._visibility == "visible")
				                        visibleSeries.points[l].visible = true;
				                }
				            }
				            
				        }
				        else {
				            var visibleSeries, legendPointIndex;
				            if (length > 1 && legendMode == "point") {
				                for (var p = 0; p < length; p++) {
				                    visibleSeries = this.model.series[p];
				                    this._checkPointVisibility(visibleSeries, legenddata);
				                }
				            }
				            else {
				                visibleSeries = legenddata.series;
				                this._checkPointVisibility(visibleSeries, legenddata);
				            }
				        }
				    }
                }
                if (this.model.enableCanvasRendering) {
                    /** Canvas Chart image is cleared when click the legend item to show/hide the series**/
                    var chartRect = document.getElementById(this._id).getClientRects()[0];
                    this.svgRenderer.ctx.clearRect(0, 0, chartRect.width, chartRect.height);
                    //Canvas series marker element removed
					bbdesigner$("#" + this._id).find('[id*="canvas_symbol"]').remove();
                }
                bbdesigner$(this.svgObject).empty();
            	bbdesigner$(this.legendSvgContainer).empty();
                for (var j = 0; j < this.model.series.length; j++)
                    this.model.series[j].regionAdded = false;
                this.model.legendCollapsed = true;                
                this.disableAnimation();
                this.draw();
                this.enableAnimation();
                if (this.model.AreaType != "none" && this.zoomed)
                    this._enableZoomingButtons();
            }
        }

        //axisLabelClick event
        var axisData = this.getAxisLabelData(evt);
        if (axisData) {
            var commonEventArgs = bbdesigner$.extend({}, BoldBIDashboard.EjSvgRender.commonChartEventArgs);
            commonEventArgs.data = axisData;
            this._trigger("axisLabelClick", commonEventArgs);

        }
        
        //annotationClick event
        if (targetid.indexOf("annotation_") >= 0) {
		     var len = targetid.lastIndexOf("_");
            var str = targetid.substr(len + 1, targetid.length);
            var index = parseInt(str);
            var commonEventArgs = bbdesigner$.extend({}, BoldBIDashboard.EjSvgRender.commonChartEventArgs);
            commonEventArgs.data = { location: { x: this.mousemoveX, y: this.mousemoveY }, contentData: this.model.annotations[index], pageX: evt.pageX, pageY: evt.pageY };
            this._trigger("annotationClick", commonEventArgs);
  
  
        }

        //Selection started here
        isSelectionSetting = !BoldBIDashboard.isNullOrUndefined(seriesIndex) && !BoldBIDashboard.isNullOrUndefined(this.model._visibleSeries[seriesIndex]) ? 
			this.model._visibleSeries[seriesIndex].selectionSettings.enable : false;
        if (!BoldBIDashboard.isNullOrUndefined(seriesIndex) && !legenddata && isSelectionSetting) {           
            isMultiSelection = seriesCollection[seriesIndex].selectionSettings._currentType.toLowerCase() == 'multiple' ? true : false;
            mode = seriesCollection[seriesIndex].selectionSettings.mode;
            if (mode.toLowerCase() != 'range')
            this.segmentSelection(evt, legenddata, seriesIndex, pointIndex, data, seriesCollection);
        }
		 //chartClick event
        var commonEventArgs = bbdesigner$.extend({}, BoldBIDashboard.EjSvgRender.commonChartEventArgs);
        commonEventArgs.data = { location: { x: this.mousemoveX, y: this.mousemoveY },size:{height:this.model.svgHeight,width:this.model.svgWidth}, id: targetid, pageX: evt.pageX, pageY: evt.pageY };
        this._trigger("chartClick", commonEventArgs);

    },
    _checkPointVisibility: function (visibleSeries, legenddata) {
        var legendPointIndex = legenddata.legendItem.LegendItem.PointIndex;
        var point = visibleSeries.visiblePoints[legendPointIndex]._visibility;
        var pointIndex = visibleSeries.visiblePoints[legendPointIndex].actualIndex;
        visibleSeries.points[pointIndex]._visibility = point === 'visible' ? 'hidden' : 'visible';
        for (var l = 0; l < visibleSeries.points.length; l++) {
            if (visibleSeries.points[l]._visibility == "visible")
                visibleSeries.points[l].visible = true;
        }
    },

   //Getting targetId when selection state changed by redraw,setmodel
   getTargetId:function(seriesIndex,pointIndex, mode, legendMode){
      var getSelectionId,
      type = this.model._visibleSeries[seriesIndex].type.toLowerCase(),
      isAreaType = (type.indexOf("area") != -1 || type.indexOf("line") != -1 || type.indexOf("scatter")!=-1 ? true:false) ? true : false;
      if (this.model.enable3D)
          bbdesigner$("[id*=" + '_Region_Series_' + seriesIndex + '_Point_' + pointIndex + "]").each(function () {
                  getSelectionId = this.id;
              });
      else {
         if (mode != 'series' || (this.model.AreaType=='none' || legendMode == "point"))
             !isAreaType? bbdesigner$("#" + this.svgObject.id + '_Series' + seriesIndex + '_Point' + pointIndex ).each(function () {
                    getSelectionId = this.id;
                 }): bbdesigner$("[id*=" + this.svgObject.id + '_Series' + seriesIndex + '_Point' + pointIndex + '_symbol' + "]").each(function () {
                         getSelectionId = this.id;
                     });
         else 
           bbdesigner$("[id*=" + this.svgObject.id + '_Series' + seriesIndex + "]").each(function () {
                   getSelectionId = this.id;
               });
      }
         return getSelectionId;
   },

  findCanvasSelection: function (seriesIndex, pointIndex, mode) {
      var isSelectionFound;
      if (mode == 'point' || mode == 'single')
          isSelectionFound = bbdesigner$('#' + this._id + '_Selection_series' + seriesIndex + '_point_' + pointIndex + '_canvas').length;
      else if (mode == 'series')
          isSelectionFound = bbdesigner$('#' + this._id + '_Selection_series' + seriesIndex + '_canvas').length;
      else
          isSelectionFound = bbdesigner$('#' + this._id + '_Selection_Cluster' + '_point_' + pointIndex + '_canvas').length;
      return isSelectionFound==1 ? true : false;
  },

  //Selection logic started here
  segmentSelection: function (evt, legendData, seriesIndex, pointIndex, data) {
      var seriesCollection = this.model._visibleSeries,
          series = seriesCollection[seriesIndex],
          clusterName = series.clusterName;
      var legendMode = this.model.legend.mode.toLowerCase();
      if (BoldBIDashboard.isNullOrUndefined(series)) return 0;
      var selectionSettings = series.selectionSettings,
        isSelectionSettings = selectionSettings.enable,
        selectionType = !BoldBIDashboard.isNullOrUndefined(selectionSettings._currentType) ? selectionSettings._currentType : selectionSettings.type,
        isMultiSelection = selectionType.toLowerCase() == 'multiple' ? true : false,
        mode = selectionSettings.mode,
        isTrackball = false, chart = this,
        targetId, parentNodeId, isSelectionFound, isElement, sIndex, pIndex, data, dataLength, seriesFlag, accPointFlag, clusterFlag, accSeriesClusterFlag, className;
        
       //Calculating cluster points
        if (!BoldBIDashboard.isNullOrUndefined(pointIndex) && mode == 'cluster') {
            var clusterPoints = [],
            points, pointsLength,
            xvalue = seriesCollection[seriesIndex]._visiblePoints[pointIndex].xValue;
            for (var i = 0, len = seriesCollection.length; i < len ; i++) {
                points = seriesCollection[i].points;
                pointsLength = points.length;
                for (var j = 0; j < pointsLength; j++)
                    if (xvalue == points[j].xValue && points[j].isEmpty == false && points[j].visible == true && clusterName == seriesCollection[i].clusterName)
                        clusterPoints[clusterPoints.length] = { seriesIndex: i, pointIndex: j };
            }
			if(BoldBIDashboard.isNullOrUndefined(this.model.prevClusterPoints))
				this.model.prevClusterPoints = clusterPoints;
            this.model.clusterPoints = clusterPoints;
        }

        //Get Target and parent node Id's by using seriesIndex and pointIndex
        if (!this.model.enableCanvasRendering) {
            targetId = this.getTargetId(seriesIndex,pointIndex,mode, legendMode);
            if (targetId) {
                parentNodeId = bbdesigner$('#' + targetId)[0].parentNode.id;
                var parentNode = bbdesigner$('#' + parentNodeId)[0];
                //Checking wether target parent or tracker symbols  present or not
                if (parentNode != null) {
                   if (parentNodeId) {
                           isElement = (parentNodeId.indexOf(this.svgObject.id + "_TextGroup_") >= 0 ||  parentNodeId.indexOf(this.svgObject.id + "_symbolGroup") >= 0) ? true : false;
                           if (parentNodeId.indexOf(this.svgObject.id + "_TrackSymbol_") >= 0) {
                                   isElement = true;
                                   isTrackball = true;
                               }
                       }
                  }
            }
        }        
       
        if (this.model.enableCanvasRendering)
            isSelectionFound = this.findCanvasSelection(seriesIndex, pointIndex, mode);
        else {
            className = bbdesigner$("#" + targetId).attr('class') ? bbdesigner$("#" + targetId).attr('class') : '';
            isSelectionFound = className.indexOf('Selection') != -1 ? true : false;
            if (this.model.enable3D) {
                className = bbdesigner$("[id*=" + '_Region_Series_' + seriesIndex + '_Point_' + pointIndex + "]").attr('class') ? bbdesigner$("[id*=" + '_Region_Series_' + seriesIndex + '_Point_' + pointIndex + "]").attr('class') : '';
                isSelectionFound = className.indexOf('Selection') != -1 ? true : false;
            }
        }
      //Selection Removal Logic 
      if ((isSelectionFound || !isMultiSelection) || isMultiSelection) {
          this.removeSelection(seriesIndex, pointIndex, seriesCollection, mode, isMultiSelection, legendData, isSelectionFound);          
          data = this.model.selectedDataPointIndexes;
          dataLength = data.length;         
          if (dataLength > 0 && !this.model._isStateChaged) {
              if (!isMultiSelection) {
                 for (var k = 0; k < dataLength; k++) {
                     sIndex = data[k].SeriesIndex;
                     pIndex = data[k].PointIndex;
                     seriesFlag = (mode == 'series' && ((sIndex == seriesIndex && pIndex == pointIndex) || (sIndex != seriesIndex || pIndex != pointIndex)));
                     accPointFlag = (((mode == 'point' || mode == 'single')|| this.model.AreaType=='none') && (sIndex == seriesIndex && pIndex == pointIndex));
                     clusterFlag = (mode == 'cluster' && (pIndex == pointIndex));
                     if (seriesFlag || accPointFlag || clusterFlag) {
                         this.model.selectedDataPointIndexes.splice(k, 1); dataLength = this.model.selectedDataPointIndexes.length;k=-1;
                     }
                 }                    
              } else if (isSelectionFound) {
                      for (var k = 0; k < dataLength; k++) {
                          sIndex = data[k].SeriesIndex;
                          pIndex = data[k].PointIndex;
                          seriesFlag = (mode == 'series' && (sIndex == seriesIndex));
                          accPointFlag = ((mode == 'point'|| mode == 'single' ||this.model.AreaType=='none') && (sIndex == seriesIndex && pIndex == pointIndex));
                          clusterFlag = (mode == 'cluster' && (pIndex == pointIndex));
                          if (((seriesFlag || clusterFlag) && this.model.AreaType != 'none') || accPointFlag ) {
                              this.model.selectedDataPointIndexes.splice(k, 1); dataLength = this.model.selectedDataPointIndexes.length; k = -1;
                          }
                      }
              }
          }
      }
     //Selection Started for 2D,3D,Canvas
      if (!isSelectionFound) {
          this.model.enableCanvasRendering ? this.canvasSelection(this, evt, series, legendData, seriesIndex, pointIndex, data, selectionSettings) : this.selection(chart, evt, series, isTrackball, legendData, seriesIndex, pointIndex, parentNodeId, targetId, data);
          data = this.model.selectedDataPointIndexes;
          dataLength = data.length;
          if (!this.model._isStateChaged) {
              if (dataLength > 0) {
                  if (!isMultiSelection) {
                      for (var k = 0; k < dataLength; k++) {
                          sIndex = data[k].SeriesIndex;
                          pIndex = data[k].PointIndex;
                          accSeriesClusterFlag = ((mode == 'series' || mode == 'cluster' || this.model.AreaType == 'none') && (data[k].SeriesIndex != seriesIndex || data[k].PointIndex != pointIndex));
                          pointFlag = ((mode == 'point' || mode == 'single') && (data[k].SeriesIndex == seriesIndex));
                          if (accSeriesClusterFlag || pointFlag) {
                              this.model.selectedDataPointIndexes.splice(k, 1); dataLength = this.model.selectedDataPointIndexes.length; k = -1;
                          }
                      }
                      this.model.selectedDataPointIndexes.push({ 'event': evt, 'legendData': legendData, 'seriesIndex': seriesIndex, 'pointIndex': pointIndex, 'data': data });
                  } else {
                      this.model.selectedDataPointIndexes.push({ 'event': evt, 'legendData': legendData, 'seriesIndex': seriesIndex, 'pointIndex': pointIndex, 'data': data });
                  }
              } else
                  this.model.selectedDataPointIndexes.push({ 'event': evt, 'legendData': legendData, 'seriesIndex': seriesIndex, 'pointIndex': pointIndex, 'data': data });
          }
      }

      //Getting selected data here
      var selectedData = { selectedData: this.model.selectedDataPointIndexes };
      this._trigger("seriesRegionClick", selectedData);
    },


     //legend Selection logic perform here
  legendSelection: function (chart, legenddata, evt, data) {
      var selectedData = this.model.selectedDataPointIndexes ? this.model.selectedDataPointIndexes : [],
	  length = this.model._visibleSeries.length,
      legend = this.model.legend,
      legendMode = legend.mode.toLowerCase(),
      enableMultiRange = legend.enableMultiRange,
        index = ((chart.model.AreaType == 'none'|| (legendMode =="range" && enableMultiRange)) && length == 1) ? legenddata.legendItem.LegendItem.PointIndex : legenddata.legendItem.LegendItem.SeriesIndex;
        seriesIndex = legenddata.legendItem.LegendItem.SeriesIndex;
        pointIndex = legendMode !="series" ? legenddata.legendItem.LegendItem.PointIndex : index;
        legendItem = chart.svgObject.id + '_LegendItemShape' + (legendMode !="series" ? legenddata.legendItem.LegendItem.PointIndex : index),
        legendClass = bbdesigner$('#' + legendItem).attr('class') ? bbdesigner$('#' + legendItem).attr('class') : '';                  
        if (bbdesigner$('#' + chart._id + '_Selection_Legend' + index + '_canvas').length == 1 || legendClass.indexOf('Selection')!=-1) {
             bbdesigner$('#' + chart._id + '_Selection_Legend' + index + '_canvas').remove();
             bbdesigner$("[id*=" + chart._id + '_Selection_series' + index + "]").remove();
             bbdesigner$('#' + this._id + '_Selection_series' + seriesIndex + '_point_' + pointIndex + '_canvas').remove();
             bbdesigner$('#' + legendItem).attr('class', '');
             if (legendMode != "series") {
                 for(var s =0;s< length;s++)
                     bbdesigner$("[id*=" + chart.svgObject.id + '_Series' + s + "]").attr('class', '');
             }
             bbdesigner$("[id*=" + chart.svgObject.id + '_Series' + seriesIndex + "]").attr('class', '');
             bbdesigner$("[id*=" + '_Region_Series_' + seriesIndex + "]").attr('class', '');
             for (var k = 0; k < selectedData.length; k++) {
                 if (selectedData[k].SeriesIndex == index || (this.model.AreaType == 'none' && selectedData[k].PointIndex == index)) {
                     this.model.selectedDataPointIndexes.splice(k, 1); break;
                 }
             }
         }             
        else                                    
           chart.segmentSelection(evt, legenddata, seriesIndex, pointIndex, data);       
    },

    chartMouseClick: function (evt) {
        var end, chart;
        var data = this.GetSeriesPoint(evt);

	    if (this.model.enableRightClick && evt.type == "contextmenu")
            evt.preventDefault();
        this.cancelEvent(evt);
        if (window.navigator.msPointerEnabled) {
            evt = evt.originalEvent;
        }    
        chart = this;     
        if(evt.originalEvent && !evt.originalEvent.pointerType && this.model.chartDoubleClick != '' && evt.button != 2){
            end = new Date();
            if(this._doubleTapTimer != null && end - this._doubleTapTimer < 300){
                //chartDoubleClick event
                if (this.timer != null || this.timer != undefined) {
                   clearTimeout(this.timer);
                   this.timer == null;
                }
				var targetId = evt.target.id;
				if(!data && targetId.indexOf("Point")!=-1){
					for (var i = this.model._visibleSeries.length - 1; i >= 0; i--) {
						chartSeries = this.model._visibleSeries[i];
						var type = chartSeries.type.toLowerCase();
						if (this.model.AreaType == "cartesianaxes" && chartSeries.visibility.toLowerCase() == 'visible' && type !== "scatter" && type !== "bubble" && type !== "column" && type.indexOf("bar") == -1 && type !== "stackingcolumn" && type !== "stackingcolumn100" && !chartSeries._hiloTypes) {
							var serY = [];
							var serX = [];
							var location = null;
							var closestXyPoint = this.getClosesPointXY(serX, serY, chartSeries, this.mousemoveX, this.mousemoveY, evt);
							if (!BoldBIDashboard.util.isNullOrUndefined(closestXyPoint.point)) {
								seriesIndex = i;
								pointIndex = closestXyPoint.index;
								var commonEventArgs = bbdesigner$.extend({}, BoldBIDashboard.EjSvgRender.commonChartEventArgs);
								commonEventArgs.data = { location: { x: this.mousemoveX, y: this.mousemoveY },region: { SeriesIndex: i, Region: { PointIndex: closestXyPoint.index } }, size:{height:this.model.svgHeight,width:this.model.svgWidth}, id: evt.target.id, pageX: evt.pageX, pageY: evt.pageY };
								this._trigger("chartDoubleClick", commonEventArgs);
								break;
							}
						}
					}
				}
				else {
					var commonEventArgs = bbdesigner$.extend({}, BoldBIDashboard.EjSvgRender.commonChartEventArgs);
					commonEventArgs.data = { location: { x: this.mousemoveX, y: this.mousemoveY },region: data ? data.region : null, size:{height:this.model.svgHeight,width:this.model.svgWidth}, id: evt.target.id, pageX: evt.pageX, pageY: evt.pageY };
					this._trigger("chartDoubleClick", commonEventArgs);
                }
            } else {
                this.timer = setTimeout(function(){ 
                    chart._doClick(evt);
                 }, 301);
            }
            this._doubleTapTimer = end;           
           
        } else {
            if (chart._isSafari || !chart._isMobile)
				this._doClick(evt);
        }
		chart._isMobile = false;
    },
    drawTrackerSymbol: function (series, seriesIndex, ptIndex, tracker, point, id) {

        var type = series.type.toLowerCase();
        var chartSeriesObj = new BoldBIDashboard.seriesTypes[type]();

        var trans = BoldBIDashboard.EjSvgRender.utils._getTransform(series.xAxis, series.yAxis, this.model.requireInvertedAxes);
		 var clipRectOptions = {
            'id': this.svgObject.id + '_TrackSymbolClipRect' + '_' + seriesIndex + '_' + ptIndex,
            'x': 0,
            'y': 0,
            'width': trans.width,
            'height': trans.height,
            'fill': 'white',
            'stroke-width': 1,
            'stroke': 'Gray'
        };
        if (bbdesigner$(this.svgObject).find("#" + this.svgObject.id + '_TrackSymbolClipRect' + '_' + seriesIndex + '_' + ptIndex).length == 0 && !this.vmlRendering) {
            this.svgRenderer.drawClipPath(clipRectOptions, this.svgObject);
        }
        if (this.model.AreaType != "none") {
            if (this.model.AreaType == 'cartesianaxes' && ((point.X + trans.x) <= (trans.x + trans.width)) && ((point.X + trans.x) >= trans.x || point.X == 0) &&
                 ((point.Y + trans.y) >= (trans.y) || point.Y == 0)) {
                if (this.model.crosshair.visible || type == "bubble" || type == "scatter") {
                    bbdesigner$('#' + this.svgObject.id + '_TrackSymbol' + '_' + seriesIndex + '_' + ptIndex).remove();
                    var trackId = "canvas_trackSymbol_" + seriesIndex + "_" + ptIndex;
                    bbdesigner$("#" + this._id).find('[id*=' +trackId + ']').remove();
                    var transSymbolOptions = { 'clip-path': 'url(#' + this.svgObject.id + '_TrackSymbolClipRect' + '_' + seriesIndex + '_' + ptIndex + ')', 'id': this.svgObject.id + '_TrackSymbol' + '_' + seriesIndex + '_' + ptIndex, 'transform': 'translate(' + trans.x + ',' + trans.y + ')' };
                    this.gTrackerEle = this.svgRenderer.createGroup(transSymbolOptions);
                } else
				    this.gTrackerEle = null; // empty the previously created tracker group if no tracker is drawn now
                }
            else {
                bbdesigner$('#' + this.svgObject.id + '_TrackSymbol' + '_' + seriesIndex + '_' + ptIndex).remove();
                var transSymbolOptions = { 'id': this.svgObject.id + '_TrackSymbol' + '_' + seriesIndex + '_' + ptIndex };
                this.gTrackerEle = this.svgRenderer.createGroup(transSymbolOptions);
                if(!this.model.enableCanvasRendering) {
                    if (this.model.AreaType == 'polaraxes')
                        this.gTrackerEle.setAttribute('clip-path', 'url(#' + this.svgObject.id + '_SeriesGroup_' + seriesIndex + '_ClipRect)');
                    else {
                        this.gTrackerEle.setAttribute('clip-path', 'url(#' + this.svgObject.id + '_TrackSymbolClipRect' + '_' + seriesIndex + ')');
                        this.gTrackerEle.setAttribute('transform', 'translate(' + trans.x + ',' + trans.y + ')');
                    }
               }
            }
           
            if (this.model.crosshair.marker.visible && !series.isIndicator&& series._visiblePoints[ptIndex].visible)
                chartSeriesObj.drawSymbol(seriesIndex, series, ptIndex, (point.X), (point.Y), this, tracker);
            if (this.gTrackerEle && bbdesigner$("#" + this.gTrackerEle.id).length < 1)
                this.svgRenderer.append(this.gTrackerEle, this.svgObject);
        }
            
        
    },
    getClosesPointXY: function (serX, serY, series, x, y, evt) {
        var closestPoint,
            valAxis = BoldBIDashboard.EjSvgRender.utils._getTransform(series.xAxis, series.yAxis, this.model.requireInvertedAxes),
            ptIndex, chartPoint, location, pointIndex, pointVisible,closestX,
            visiblePointsLength = series._visiblePoints ? series._visiblePoints.length : 0, closestY,
            size = series.marker ? series.marker.size : { height: 6, width: 6 };
        var isCanvas = this.model.enableCanvasRendering;
        if(this.model.AreaType == "cartesianaxes" && !isCanvas)
        var chartArea = document.getElementById(this.svgObject.id + "_ChartArea").getBoundingClientRect();
		var clientX, clientY;
		if(evt.originalEvent)
		{
			clientX = evt.originalEvent.clientX;
			clientY = evt.originalEvent.clientY;
		}
		else
		{
			clientX = evt.clientX;
			clientY = evt.clientY;
		}
        var valX = !isCanvas ? clientX : valAxis.x;
        var valY = !isCanvas ? clientY : valAxis.y;
        var valWidth = !isCanvas ? chartArea.width: valAxis.width;
        var valHeight = !isCanvas ? chartArea.height: valAxis.height;
        if (((y <= (valY + valHeight) && valY <= y) && (valX <= x && x <= (valX + valWidth))) || !isCanvas) {
            for (var i = 0; i < visiblePointsLength; i++) {
                chartPoint = series._visiblePoints[i];
                location = chartPoint.location;
                pointVisible = false;
                pointIndex = i;
                closestX = null;
                closestY = null;
                if (!isCanvas && evt) {
                    if ((this.svgObject.id + "_Series" + series.seriesIndex + "_Point" + i + '_symbol') == evt.target.id) {
                        var markerSize = document.getElementById(evt.target.id).getBoundingClientRect();
                        chartPoint.height = markerSize.height;
                        chartPoint.width = markerSize.width;
                        closestPoint = chartPoint;
                        ptIndex = i;
                    }
                }
                else if (location) {
                    if (x > location.X + valX - (size.width / 2) && x < location.X + valX + (size.width / 2)) {
                        closestX = chartPoint.x;
                        if (BoldBIDashboard.util.isNullOrUndefined(closestX))
                            pointVisible = chartPoint.visible;
                    }
                    if (y > location.Y + valY - (size.height / 2) && y < location.Y + valY + (size.height / 2)) {
                        closestY = chartPoint.YValues[0];
                    }
                    if ((!BoldBIDashboard.util.isNullOrUndefined(closestX) || pointVisible) && !BoldBIDashboard.util.isNullOrUndefined(closestY)) {
                        closestPoint = chartPoint;
                        ptIndex = i;
                    }
                }
            }         
        }
        return { point: closestPoint, index: ptIndex };
    },
    getClosestPointX: function (serX, series, x, y) {
        var closestPoint = [];
        var valAxis = BoldBIDashboard.EjSvgRender.utils._getTransform(series.xAxis, series.yAxis, this.model.requireInvertedAxes);
        if (this.model.requireInvertedAxes) {
            x = Math.abs(y - (valAxis.y + valAxis.height));
            y = Math.abs(x - valAxis.x);
        }
        else {
            x = Math.abs(x - valAxis.x);
            y = Math.abs(y - (valAxis.y + valAxis.height));
        }
        var mousePoint = BoldBIDashboard.EjSvgRender.utils._getValuebyPoint(x, y, series);
        var pointX = (this.model.requireInvertedAxes) ? mousePoint.PointX : mousePoint.PointX;
        var ptIndex = [];
        bbdesigner$.each(series.points, function (pointIndex, chartPoint) {
            serX.push(chartPoint.xValue);
        });
        var closest = this.getClosest(serX, pointX);
		if (!BoldBIDashboard.util.isNullOrUndefined(closest)) {
            if (typeof closest == 'number') {
                bbdesigner$.each(series._visiblePoints, function (pointIndex, cPoint) {
                    if (cPoint.xValue == closest) {
                        closestPoint.push(cPoint);
                        ptIndex.push(pointIndex);

                    }
                });
            } else {
                closest = closest.getTime();
                bbdesigner$.each(series._visiblePoints, function (pointIndex, cPoint) {
                    if (cPoint.xValue.getTime() == closest) {
                        closestPoint.push(cPoint);
                        ptIndex.push(pointIndex);

                    }
                });
            }
        }
        return { point: closestPoint, index: ptIndex };
    },
    getClosest: function (obj, val) {
        var closest = null;

        // Work out min and max
        var min = Math.min.apply(null, obj);
        var max = Math.max.apply(null, obj);

        // Only calculate closest if point is within array
        if (val >= min - 0.5 && val <= max + 0.5) {
            var i;
            for (i = 0; i < obj.length; i++) {
                if (closest == null || Math.abs(obj[i] - val) < Math.abs(closest - val)) {
                    closest = obj[i];
                }
            }
        }
        return closest;
    },
    createTooltip: function (region, evt, series) {
        if(!series)
          series = this.model._visibleSeries[region.SeriesIndex];
        var seriesPoint = series.type == "pie" || series.type == "doughnut" ? series._visiblePoints[region.Region.Index] : series._visiblePoints[region.Region.PointIndex];
        var point = bbdesigner$.extend(true, {}, seriesPoint);
		var tooltipMargin=10;
        var isRTL = series.tooltip.isReversed;
		var isCanvas = this.model.enableCanvasRendering;
        if (point.visible) {
		     var format = series.tooltip.format;
		     var dataPoints = this.getTooltipFormat(point, series, region.SeriesIndex, region.Region.PointIndex, format);
		     point.x = dataPoints.data.x;
		     point.y = dataPoints.data.y;
		     var tooltip = null;
            var commonEventArgs = bbdesigner$.extend({}, BoldBIDashboard.EjSvgRender.commonChartEventArgs);
            commonEventArgs.data = { currentText: tooltip, seriesIndex: region.SeriesIndex, pointIndex: region.Region.PointIndex, series: series };
            this._trigger("toolTipInitialize", commonEventArgs);
            var tooltipdiv = bbdesigner$('.tooltipDiv');
            if (bbdesigner$('.tooltipDiv').length == 0) {
                this.tooltipFirst = true;
                tooltipdiv = bbdesigner$("<div class='tooltipDiv' style='position: absolute; z-index: 13000; display: block;'></div>");
                bbdesigner$(document.body).append(tooltipdiv);
                bbdesigner$('.tooltipDiv').addClass(this.svgObject.id);
            } else {
                bbdesigner$(".tooltipDiv").css("display", "block");
                this.tooltipFirst = false;
            }
            if (series.tooltip.template != null) {
                var cloneNode = bbdesigner$("#" + series.tooltip.template).clone();
                bbdesigner$('.tooltipDiv')[0].innerHTML = "";
                bbdesigner$(cloneNode).css("display", "block").appendTo(tooltipdiv);
                series.count = 1;
                point.count = 1;
                var seriesColor = this.getSeriesColor(point, region.SeriesIndex, series);
				if (seriesColor)
                    bbdesigner$(tooltipdiv).css("background-color", bbdesigner$.type(seriesColor) == "array" ? seriesColor[0].color : seriesColor);
				else
                   bbdesigner$(tooltipdiv).css("background-color", this.model.pointColors[region.Region.PointIndex]);
				var data = { series: series, point: point };
				if (!BoldBIDashboard.util.isNullOrUndefined(commonEventArgs.data.currentText))
				    bbdesigner$(tooltipdiv).html(commonEventArgs.data.currentText);
                else
                bbdesigner$(tooltipdiv).html(bbdesigner$(tooltipdiv).html().parseTemplate(data));
            } else {
                bbdesigner$(tooltipdiv).html(commonEventArgs.data.ToolTip);
            }
			var areaBounds = this.model.m_AreaBounds;
            var xPos = evt.pageX  + tooltipMargin;
            var yPos = evt.pageY  + tooltipMargin;
            var tooltipWidth = bbdesigner$(tooltipdiv).width();
            var tooltipHeight = bbdesigner$(tooltipdiv).height();
            var position = document.getElementById(this.svgObject.id).getClientRects()[0];
            
            var chartArea = this.model.AreaType != "none" ? document.getElementById(this.svgObject.id + "_ChartArea").getBoundingClientRect() : document.getElementById(this.svgObject.id).getBoundingClientRect();
            if (xPos === undefined || xPos === null)
                xPos = evt.pageX  + tooltipMargin;
            if (yPos === undefined || yPos === null)
                yPos = evt.pageY  + tooltipMargin;
            bbdesigner$(tooltipdiv).css("left", xPos);
            bbdesigner$(tooltipdiv).css("top", yPos);
            //Checking top position whether tooltip display outside of the area bounds
            var templateRect = bbdesigner$(tooltipdiv)[0].getBoundingClientRect();
            var boundsWidth = !isCanvas ? chartArea.right : areaBounds.X + areaBounds.Width + position.left;
            var boundsHeight = !isCanvas? chartArea.bottom: areaBounds.Y + areaBounds.Height + position.top;
            if (templateRect.right > (boundsWidth)) {
                var diff = (xPos - tooltipWidth);
                bbdesigner$(tooltipdiv).css('left', diff + bbdesigner$(document).scrollLeft());
            }
            if (templateRect.bottom > boundsHeight) {
                var diff = templateRect.bottom - (boundsHeight)
                bbdesigner$(tooltipdiv).css('top', templateRect.top - diff + bbdesigner$(document).scrollTop());
            }
			var tooltipOptions = series.tooltip;
            if (tooltipOptions.enableAnimation) {
                bbdesigner$(tooltipdiv).css({
                    'transition-property': 'left,top',
                    '-moz-transition-property': 'left,top', /* Firefox 4 */
                    '-webkit-transition-property': 'left,top', /* Safari and Chrome */
                    '-o-transition-property': 'left,top',
                    'transition-duration': tooltipOptions.duration,
                    '-moz-transition-duration': tooltipOptions.duration, /* Firefox 4 */

                    '-webkit-transition-duration': this.tooltipFirst ? '0s' : tooltipOptions.duration, /* Safari and Chrome */
                    '-o-transition-duration': tooltipOptions.duration /* Opera */
                });
            }
            templateRect = bbdesigner$(tooltipdiv)[0].getBoundingClientRect();
            if(templateRect.top < areaBounds.Y + position.top)
                bbdesigner$(tooltipdiv).css('top', areaBounds.Y + position.top + bbdesigner$(document).scrollTop());
            if(isRTL){
                var padding = 20;
                bbdesigner$(tooltipdiv).css('left', xPos - (tooltipWidth + padding));
                if(xPos - (tooltipWidth + padding) < series.xAxis.x)
                    bbdesigner$(tooltipdiv).css('left', xPos);
        }
        }
    },

    translate: function (axis, translateX, translateY, currentScale) {
        var offset = axis.orientation.toLowerCase() == "horizontal"
                                              ? translateX / axis.width / currentScale
                                              : translateY / axis.height / currentScale;

        axis.zoomPosition = axis.orientation.toLowerCase() == "horizontal"
            ? BoldBIDashboard.EjSvgRender.utils._minMax(axis.zoomPosition + offset, 0, (1 - axis.zoomFactor))
            : BoldBIDashboard.EjSvgRender.utils._minMax(axis.zoomPosition - offset, 0, (1 - axis.zoomFactor));
    },
    highlightFill: function (highlight, chart, seriesIndex, pointIndex, legendData) {
        var seriesColors = chart.model.seriesColors;
        var pointColors = chart.model.pointColors;
        var color = highlight.color;
		var length =this.model._visibleSeries.length;
        if (legendData && chart.model.AreaType == 'none') {
            if(length == 1)
            pointIndex = legendData.legendItem.LegendItem.PointIndex;
            else
            seriesIndex = legendData.legendItem.LegendItem.SeriesIndex;
        }
        var pointColor = legendData ? seriesColors[seriesIndex] : pointIndex ? chart.model.series[seriesIndex].points[pointIndex] ? chart.model.series[seriesIndex].points[pointIndex].fill: null : null;
        var fill = (color != "" ? color : chart.model.AreaType == 'none' ? pointColor : legendData ? seriesColors[seriesIndex] : pointColor ? pointColor : seriesColors[seriesIndex]);
        if (Object.prototype.toString.call(fill) === '[object Array]')
            fill = fill[1].color;
        return fill;
    },
	
	
   
     // Canvas highlight and selection started here
     // Canvas highlight started here
    canvasHighlight: function (chart, evt, series, legendData) {

        var legend = chart.model.legend;
        var enableMultiRange = legend.enableMultiRange;
        var legendMode = legend.mode;
        var highlight = series.highlightSettings;
        var data = series.data;
        var color = highlight.color;
        var opacity = legendMode =="range" && !enableMultiRange ? 1 :highlight.opacity;
        var borderColor = highlight.border.color;
        var borderWidth = legendMode == "range" && !enableMultiRange ? '1' : highlight.border.width;
        var patternName = legendMode == "range" && !enableMultiRange ? "diagonalforward" : highlight.pattern.toLowerCase();
        var legendVisible = chart.model.legend.visible;
        var mode = highlight.mode;
        var seriesIndex = series.seriesIndex;
        var pointIndex = series.pointIndex;
        var clusterName = series.clusterName;
        var seriesType = series.type.toLowerCase();
        var containerStyle = document.getElementById(chart._id + '_canvas').getBoundingClientRect();
        var regions = [];
        var points = [];
        var clusterPoints = [];
		var length =this.model._visibleSeries.length;
        var fill = this.highlightFill(highlight, chart, seriesIndex, pointIndex,legendData);
        if (chart.model.AreaType != 'none' || (chart.model.AreaType == 'none' && length > 1 && (mode == 'series' || legendData))) {
            for (var i = 0, len = chart.model.chartRegions.length; i < len ; i++) {
                if ((mode == 'series' || legendData) && (seriesIndex == chart.model.chartRegions[i].SeriesIndex && !(this.selectedPoint == chart.model.chartRegions[i].Region.PointIndex || !BoldBIDashboard.util.isNullOrUndefined(this.selectedPoint))))
                        regions.push(chart.model.chartRegions[i].Region);
                    }
                   
               
        } else {
          for (var i = 0,len = chart.model.chartRegions.length; i < len; i++) {
              if (seriesIndex==chart.model.chartRegions[i].SeriesIndex && pointIndex == chart.model.chartRegions[i].Region.PointIndex)
                    regions.push(chart.model.chartRegions[i].Region[pointIndex]);
            }
        }
        if (mode == 'cluster' && chart.model.Areatype != 'none' && typeof pointIndex !== "undefined") {
            var xvalue = chart.model._visibleSeries[seriesIndex]._visiblePoints[pointIndex].xValue;
            for (var i = 0, len = chart.model._visibleSeries.length; i < len ; i++) {
                for (var j = 0; j < chart.model._visibleSeries[i]._visiblePoints.length; j++) {
                    if (xvalue == chart.model._visibleSeries[i]._visiblePoints[j].xValue && clusterName == chart.model._visibleSeries[i].clusterName)
                        clusterPoints[clusterPoints.length] = { seriesIndex: i, pointIndex: j };

                }
            }
        }
        for (var k = 0; k < clusterPoints.length; k++) {
            clusterseriesIndex = clusterPoints[k].seriesIndex;
            clusterpointIndex = clusterPoints[k].pointIndex;
            for (var l = 0; l < chart.model.chartRegions.length; l++) {
                if (clusterseriesIndex == chart.model.chartRegions[l].SeriesIndex && clusterpointIndex == chart.model.chartRegions[l].Region.PointIndex)
                    if (mode != "cluster")
                    regions.push(chart.model.chartRegions[l].Region);
                    else
                        regions.push(chart.model.chartRegions[l]);
            }
        }
      var index = (chart.model.AreaType == 'none' && length == 1) ? pointIndex : seriesIndex;
        if ( (mode == 'series' || legendData) && (bbdesigner$('#' + chart._id + '_Selection_series' + index + '_canvas').length == 0) && bbdesigner$('#' + chart._id + '_Selection_' + 'Cluster' + '_point_' + pointIndex + '_canvas').length == 0 && bbdesigner$('#' + chart._id + '_Selection_' + seriesIndex + '_point_' + pointIndex + '_canvas').length == 0) {             
            points = series._visiblePoints
            ctx = this.createCanvasElement(chart._id + '_Highlight_series' + seriesIndex + '_canvas', chart.svgWidth, chart.svgHeight, containerStyle);
            color = (patternName == "none" || patternName == "") ? fill : this.canvasPattern(ctx, chart, evt, fill, highlight);
            this.createRect(chart, ctx);
            if (seriesType.indexOf("column") != -1 || seriesType.indexOf("bar") != -1) {
                for (i = 0; i < regions.length; i++) {
                    var isUnSelected = bbdesigner$('#' + chart._id + '_Selection_' + seriesIndex + '_point_' + i + '_canvas').length == 0 ? true : false;
                    this.canvasSeriesRect(regions[i], opacity, borderColor, borderWidth, color, isUnSelected);
                }
            }
            else if (seriesType == 'pie' || seriesType == 'doughnut')
			{
               regions = (length == 1) ? regions : regions[0];
                this.canvasHighlightCircle(chart, highlight, pointIndex, opacity, borderColor, borderWidth, color, regions, seriesType, ctx);
				}
            else if (seriesType == 'pyramid' || seriesType == 'funnel')
                this.canvasHighlightPyramid(chart, regions[0], highlight, ctx, opacity, borderColor, borderWidth, color, seriesType);
            else if (seriesType == 'bubble')
                this.canvasBubbleHighlight(highlight, regions, chart, seriesIndex, color, borderWidth, opacity, borderColor);
            else if (seriesType == 'scatter')
                this.canvasScatterHighlight(regions, color, borderWidth, opacity, borderColor);
        }
		else if (legendMode !="range" && mode == 'cluster' && bbdesigner$('#' + chart._id + '_Selection_' + 'Cluster' + '_point_' + pointIndex + '_canvas').length == 0 && this.model.AreaType != 'none' && bbdesigner$('#' + chart._id + '_Selection_' + seriesIndex + '_point_' + pointIndex + '_canvas').length == 0 && bbdesigner$('#' + chart._id + '_Selection_series' + seriesIndex + '_canvas').length == 0) {
                for (var i = 0, len = this.model._visibleSeries.length; i < len; i++) {
                    var series = this.model._visibleSeries[i];
                    series.seriesIndex = i;
                    points.push(series._visiblePoints[pointIndex]);

                }
            var sbRegion = [], colors = [];// scatter & bubble region calculation
                ctx = this.createCanvasElement(chart._id + '_Highlight_' + '_Cluster' + '_point_' + pointIndex + '_canvas', chart.svgWidth, chart.svgHeight, containerStyle);
                this.createRect(chart, ctx);
                for (var i = 0, len = this.model._visibleSeries.length; i < len; i++) {
                sbRegion = [];
                    highlight = chart.model._visibleSeries[i].highlightSettings;
                    color = highlight.color;
                    opacity = highlight.opacity;
                    borderColor = highlight.border.color;
                    borderWidth = highlight.border.width;
                    patternName = highlight.pattern.toLowerCase();
                    fill = this.highlightFill(highlight, chart, i, pointIndex, index, legendData);
                    color = (patternName == "none" || patternName == "") ? fill : this.canvasPattern(ctx, chart, evt, fill, highlight);
                colors.push(color);
                for (var r = 0, rlen = regions.length; r < rlen; r++) {
                    if (regions[r].SeriesIndex == i) {
                        sbRegion.push(regions[r].Region);
                    }
                }
                    if (seriesType.indexOf("column") != -1 || seriesType.indexOf("bar") != -1) {
                        var isUnSelected = bbdesigner$('#' + chart._id + '_Selection_' + i + '_point_' + pointIndex + '_canvas').length == 0 ? true : false;
                    for (var r = 0, rlen = sbRegion.length; r < rlen; r++) {
                        this.canvasSeriesRect(sbRegion[r], opacity, borderColor, borderWidth, color, isUnSelected);
                    }
                }
                    else if (seriesType == 'bubble') {
                    this.canvasBubbleHighlight(highlight, sbRegion, chart, i, color, borderWidth, opacity, borderColor);
                    }
                    else if (seriesType == 'scatter') {
                    this.canvasScatterHighlight(sbRegion, color, borderWidth, opacity, borderColor);
                    }

                }
            }
		else if ((mode=="cluster" &&this.model.AreaType == 'none') || mode == 'point' && bbdesigner$('#' + chart._id + '_Selection_' + seriesIndex + '_point_' + pointIndex + '_canvas').length == 0 && bbdesigner$('#' + chart._id + '_Selection_series' + seriesIndex + '_canvas').length == 0 && bbdesigner$('#' + chart._id + '_Selection_' + 'Cluster' + '_point_' + pointIndex + '_canvas').length == 0) {
            points[0] = series._visiblePoints[pointIndex];
            ctx = this.createCanvasElement(chart._id + '_Highlight_' + seriesIndex + '_point_' + pointIndex + '_canvas', chart.svgWidth, chart.svgHeight, containerStyle);
            this.createRect(chart, ctx);
            color = (patternName == "none" || patternName == "") ? fill : this.canvasPattern(ctx, chart, evt, fill, highlight);
            if (seriesType.indexOf("column") != -1 || seriesType.indexOf("bar") != -1) {
                regions = []; regions[0] = data.region.Region;
                this.canvasSeriesRect(regions[0], opacity, borderColor, borderWidth, color, true);
            }
            else if (seriesType == 'pie' || seriesType == 'doughnut') {
                regions = []; regions[0] = data.pointData[0];
                this.canvasHighlightCircle(chart, highlight, pointIndex, opacity, borderColor, borderWidth, color, regions, seriesType, ctx);
            }
            else if (seriesType == 'pyramid' || seriesType == 'funnel') {
                this.canvasHighlightPyramid(chart, regions[0], highlight, ctx, opacity, borderColor, borderWidth, color, seriesType);
            }
            else if (seriesType == 'bubble') {
                regions = []; regions[0] = data.region.Region;
                this.canvasBubbleHighlight(highlight, regions, chart, seriesIndex, color, borderWidth, opacity, borderColor);
            }
            else if (seriesType == 'scatter') {
                regions = []; regions[0] = data.region.Region;
                this.canvasScatterHighlight(regions, color, borderWidth, opacity, borderColor);
            }
        }
        // legend highlight (legend symbol)
        if (legendMode != "range" && legendVisible && bbdesigner$('#' + chart._id + '_Selection_Legend' + index + '_canvas').length == 0) {
            if (mode == 'cluster' && !legendData && this.model.AreaType != 'none') {
                var serIndex;
                for (var i = 0, len = clusterPoints.length; i < len; i++) {
                    serIndex = clusterPoints[i].seriesIndex;
                    chartSeries = this.model._visibleSeries[serIndex];                   
                    this.canvasHighlightLegend(chart, chartSeries, highlight, 'Highlight', containerStyle, colors[serIndex]);
                }
            }
            else
                this.canvasHighlightLegend(chart, series, highlight, 'Highlight', containerStyle, color);
            
        }
        if (series.marker.visible == true && this.model.AreaType != 'none')
            this.canvasHighlightMarker(chart, series, points, highlight, ctx, evt, colors);
    },

     // canvas rect operations perform here
    canvasSeriesRect: function (regions, opacity, borderColor, borderWidth, color, isUnSelected) {
        var options = {
            'opacity': opacity,
            'stroke': borderColor,
            'stroke-width': borderWidth,
            'fill': color
        }

      
            options.x = regions.Bounds.X;
            options.y = regions.Bounds.Y;
            options.width = regions.Bounds.Width;
            options.height = regions.Bounds.Height;
            if (isUnSelected)
                this.drawRect(options, ctx);
        
    },

     // // canvas selection logic started here
    canvasSelection: function (chart, evt, series, legendData, seriesIndex, pointIndex, data, selectionSettings) {
        series.seriesIndex = seriesIndex;
        series.pointIndex = pointIndex;
        var seriesCollection = this.model._visibleSeries,
        color = selectionSettings.color,
        opacity = selectionSettings.opacity,
        borderColor = selectionSettings.border.color,
        borderWidth = selectionSettings.border.width,
        patternName = selectionSettings.pattern.toLowerCase(),
        legendVisible = chart.model.legend.visible,
        mode = selectionSettings.mode,
        seriesType = series.type.toLowerCase(),
        containerStyle = document.getElementById(chart._id + '_canvas').getBoundingClientRect(),
        regions = [],
        points = [],
        length = this.model._visibleSeries.length,
        chartRegions = chart.model.chartRegions,
        clusterPoints = this.model.clusterPoints,
        seriesData = { seriesIndex: seriesIndex, series: series },
         index = (chart.model.AreaType == 'none' && length == 1) ? pointIndex : seriesIndex,
        fill = this.highlightFill(selectionSettings, chart, seriesIndex, pointIndex, legendData ,data),regionsLength,cRlength;
		regionsLength = chartRegions.length;
           if (chart.model.AreaType != 'none' || (chart.model.AreaType == 'none' && length > 1)) {        
            for (var i = 0; i < regionsLength; i++) {
                if (((mode == 'series' || legendData) && seriesIndex == chartRegions[i].SeriesIndex) || (((mode == 'point'|| mode == 'single') || legendData) && (seriesIndex == chartRegions[i].SeriesIndex && pointIndex == chartRegions[i].Region.PointIndex))) {
                        if (chart.model.AreaType == 'none' && (mode == 'point' || mode == 'single') && !legendData)
                            regions.push(chartRegions[i].Region[pointIndex])
                        else
                            regions.push(chartRegions[i].Region);
                    }           
                }
        } else if (regionsLength > 0) {
            cRlength = chartRegions[0].Region.length;
            for (var i = 0; i < cRlength; i++) {
                if (pointIndex == chartRegions[0].Region[i].PointIndex)
                    regions.push(chartRegions[0].Region[i]);
            }
        }
        if ((mode == 'series' || legendData) && (this.model.AreaType!='none' || this.model.AreaType == 'none' && length >1) ) {
            points = series._visiblePoints;
            ctx = this.createCanvasElement(chart._id + '_Selection_series' + index + '_canvas', chart.svgWidth, chart.svgHeight, containerStyle);
            color = (patternName == "none" || patternName == "") ? fill : this.canvasPattern(ctx, chart, evt, fill, selectionSettings);
            this.createRect(chart, ctx);
            if (seriesType.indexOf("column") != -1 || seriesType.indexOf("bar") != -1) {
                for (i = 0; i < regions.length; i++)
                    this.canvasSeriesRect(regions[i], opacity, borderColor, borderWidth, color, true);
            }
            else if (seriesType == 'pie' || seriesType == 'doughnut')
                this.canvasHighlightCircle(chart, selectionSettings, pointIndex, opacity, borderColor, borderWidth, color, regions[0], seriesType, ctx);
            else if (seriesType == 'bubble')
                this.canvasBubbleHighlight(selectionSettings, regions, chart, seriesIndex, color, borderWidth, opacity, borderColor);
            else if (seriesType == 'scatter')
                this.canvasScatterHighlight(regions, color, borderWidth, opacity, borderColor);
        }
	    else if (mode == 'cluster' && this.model.AreaType != 'none' && bbdesigner$('#' + chart._id + '_Selection_' + 'Cluster' + '_point_' + pointIndex + '_canvas').length == 0) {
	        var clength = clusterPoints.length, clusterseriesIndex, clusterpointIndex, region, rlength;
	        for (var k = 0; k < clength; k++) {
	                clusterseriesIndex = clusterPoints[k].seriesIndex;
	                clusterpointIndex = clusterPoints[k].pointIndex;
	                region = bbdesigner$.grep(chartRegions, function (x) { return x.SeriesIndex == clusterseriesIndex && x.Region.PointIndex == clusterpointIndex });
	                rlength = region.length;
	                if (rlength > 0) {
	                    regions.push(region[0]);
	                    points.push(seriesCollection[region[0].SeriesIndex]._visiblePoints[pointIndex]);
	                }else
	                    points.push(seriesCollection[k]._visiblePoints[pointIndex]);
	            }
	            this.selectedPoint = pointIndex;
	            var sbRegion=[], colors=[];
	            ctx = this.createCanvasElement(chart._id + '_Selection_' + 'Cluster' + '_point_' + pointIndex + '_canvas', chart.svgWidth, chart.svgHeight, containerStyle);
	            this.createRect(chart, ctx);
                for (i = 0, len = seriesCollection.length; i < len; i++) {
	                sbRegion=[];// scatter & bubble region calculation
                    highlight = seriesCollection[i].selectionSettings;
                    color = highlight.color;
                    opacity = highlight.opacity;
                    borderColor = highlight.border.color;
                    borderWidth = highlight.border.width;
                    patternName = highlight.pattern.toLowerCase();
                    fill = this.highlightFill(highlight, chart, i, pointIndex,  legendData);
                    color = (patternName == "none" || patternName == "") ? fill : this.canvasPattern(ctx, chart, evt, fill, highlight);
                    colors.push(color);
                    for (var r = 0, rlen = regions.length; r < rlen; r++) {
                        if (regions[r].SeriesIndex == i) {
                            sbRegion.push(regions[r].Region);
                        }
                    }
                    if (seriesType.indexOf("column") != -1 || seriesType.indexOf("bar") != -1) {
                        for (var sr = 0, srlen = sbRegion.length; sr < srlen; sr++) {
                            this.canvasSeriesRect(sbRegion[sr], opacity, borderColor, borderWidth, color, true);
                        }
                    }
                    else if (seriesType == 'bubble') 
                        this.canvasBubbleHighlight(highlight, sbRegion, chart, i, color, borderWidth, opacity, borderColor);
                    else if (seriesType == 'scatter') 
                        this.canvasScatterHighlight(sbRegion, color, borderWidth, opacity, borderColor);
                    if (!legendData && this.model.AreaType != 'none' && legendVisible) {
                        series = seriesCollection[i];
                        series.seriesIndex = i;
                        this.canvasHighlightLegend(chart, series, selectionSettings, 'SelectionCluster', containerStyle, color);
                    }
                }
            }
	    else if (((mode == 'point'|| mode == 'single') && bbdesigner$('#' + chart._id + '_Selection_' + seriesIndex + '_point_' + pointIndex + '_canvas').length == 0) || this.model.AreaType == 'none') {
            this.selectedPoint = pointIndex;
	        
	        points[0] = series._visiblePoints[pointIndex];
            ctx = this.createCanvasElement(chart._id + '_Selection_series' + seriesIndex + '_point_' + pointIndex + '_canvas', chart.svgWidth, chart.svgHeight, containerStyle);
            this.createRect(chart,ctx);
            color = (patternName == "none" || patternName == "") ? fill : this.canvasPattern(ctx, chart, evt, fill, selectionSettings);
            if (seriesType.indexOf("column") != -1 || seriesType.indexOf("bar") != -1) 
                this.canvasSeriesRect(regions[0], opacity, borderColor, borderWidth, color, true);
            else if (seriesType == 'pie' || seriesType == 'doughnut')
                this.canvasHighlightCircle(chart, selectionSettings, pointIndex, opacity, borderColor, borderWidth, color, regions, seriesType, ctx);
            else if (seriesType == 'pyramid' || seriesType == 'funnel') 
                this.canvasHighlightPyramid(chart, regions[0], selectionSettings, ctx, opacity, borderColor, borderWidth, color, seriesType);
            else if (seriesType == 'bubble')  
                this.canvasBubbleHighlight(selectionSettings, regions, chart, seriesIndex, color, borderWidth, opacity, borderColor);
            else if (seriesType == 'scatter') 
                this.canvasScatterHighlight(regions, color, borderWidth, opacity, borderColor);
        }   
        // legend highlight (legend symbol)
        if (legendVisible && (mode != 'cluster' || legendData))
            this.canvasHighlightLegend(chart, series, selectionSettings, 'Selection', containerStyle, color);
        if (series.marker.visible == true && this.model.AreaType != 'none')
            this.canvasHighlightMarker(chart, series, points, selectionSettings, ctx, evt, colors);
    },

     // clip rect logic calculated here
    createRect: function (chart,ctx) {
        if (chart.model.AreaType != 'none') {
            ctx.lineWidth = 0;
            ctx.strokeStyle = 'transparent';
            ctx.rect(chart.model.m_AreaBounds.X, chart.model.m_AreaBounds.Y, chart.model.m_AreaBounds.Width, chart.model.m_AreaBounds.Height);
            ctx.clip();
            ctx.stroke();
            ctx.save();
        }
    },

     //canvas pyramid and funnel draw
    canvasHighlightPyramid: function (chart, regions, highlight, ctx, opacity, borderColor, borderWidth, color, seriesType) {
        var fill = (highlight.color != "" ? highlight.color : chart.model.pointColors[regions.PointIndex]);
        var measureTitle = (chart.model.title.text) ? BoldBIDashboard.EjSvgRender.utils._measureText(chart.model.title.text, bbdesigner$(this.svgObject).width() - chart.model.margin.left - chart.model.margin.right, chart.model.title.font) : 0;
        var pyrX = chart.pyrX = ((chart.model.legend.position.toLowerCase() === "left") ? (chart.model.LegendViewerBounds.Width) : 0) + chart.model.elementSpacing + chart.model.margin.left;
        var pyrY = chart.pyrY = ((chart.model.legend.position.toLowerCase() === "top") ? (chart.model.LegendViewerBounds.Height) : 0) + ((chart.model.title.text && !BoldBIDashboard.util.isNullOrUndefined(chart.model._titleLocation)) ? (chart.model._titleLocation.Y + measureTitle.height) : (chart.model.margin.top + chart.model.elementSpacing));
        var options = {
            'opacity': opacity,
            'stroke': borderColor,
            'stroke-width': borderWidth,
            'fill': color,
            'type': seriesType,
            'd': "M" + " " + (pyrX + regions.Line1.x) + " " + (pyrY + regions.Line1.y) + " " + "L" + " " + (pyrX + regions.Line2.x) + " " + (pyrY + regions.Line2.y) + " " + "L" + " " + (pyrX + regions.Line3.x) + " " + (pyrY + regions.Line3.y) + " " + "L" + " " + (pyrX + regions.Line4.x) + " " + (pyrY + regions.Line4.y) + " " + "z"
        }
        if (seriesType == 'funnel')
            options.d = "M" + " " + (pyrX + regions.Line1.x) + " " + (pyrY + regions.Line1.y) + " " + "L" + " " + (pyrX + regions.Line2.x) + " " + (pyrY + regions.Line2.y) + " " + "L" + " " + (pyrX + regions.Line3.x) + " " + (pyrY + regions.Line3.y) + " " + "L" + " " + (pyrX + regions.Line4.x) + " " + (pyrY + regions.Line4.y) + " " + "L" + " " + (pyrX + regions.Line5.x) + " " + (pyrY + regions.Line5.y) + " " + "L" + " " + (pyrX + regions.Line6.x) + " " + (pyrY + regions.Line6.y) + " " + "z";
        BoldBIDashboard.EjCanvasRender.prototype.drawPath(options, ctx);
    },

     // canvas scatter logic
    canvasScatterHighlight: function (regions, color, borderWidth, opacity, borderColor) {
        var location, options = {}, size = {};
        for (var i = 0; i < regions.length; i++) {
            location = { startX: regions[i].Bounds.X + regions[i].Bounds.Height/2, startY: regions[i].Bounds.Y + regions[i].Bounds.Width/2 };
            size.height = regions[i].Bounds.Height;
            size.width = regions[i].Bounds.Width;
            options = {};
            options.ShapeSize = size;
            options.cx = location.startX;
            options.cy = location.startY;
            options.Style = {};
            options.Style.BorderColor = borderColor;
            options.Style.Color = color;
            options.Style.Opacity = opacity;
            options.Style.BorderWidth = borderWidth;
            BoldBIDashboard.EjSvgRender.chartSymbol['_drawCircle'](location, options, this, ctx);
        }
    },

     // canvas bubble logic perform here
    canvasBubbleHighlight: function (highlight, regions, chart, seriesIndex, color, borderWidth, opacity, borderColor) {
        var size = 10, radius, fill, bubbleOptions = {};
        for (var i = 0; i < regions.length; i++) {
            radius = regions[i].Bounds.Height / 2;
            fill = (highlight.color != "" ? highlight.color : chart.model.seriesColors[seriesIndex]);
            bubbleOptions = {
                'cx': regions[i].Bounds.X - this.model.series[seriesIndex].xAxis.x + radius + this.canvasX,
                'cy': regions[i].Bounds.Y - this.model.series[seriesIndex].yAxis.y + radius+ this.canvasY,
                'r': radius,
                'fill': color,
                'stroke-width': borderWidth,
                'opacity': opacity,
                'stroke': borderColor
            };
            BoldBIDashboard.EjCanvasRender.prototype.drawCircle(bubbleOptions, ctx);
        }
    },

     // canvas circle draw
    canvasHighlightCircle: function (chart, highlight, pointIndex, opacity, borderColor, borderWidth, color, regions, seriesType, ctx) {
        for (var i = 0; i < regions.length; i++) {
            var fill = (highlight.color != "" ? highlight.color : (highlight.mode == "series" && chart.model._visibleSeries.length > 1)?chart.model.pointColors[i]:chart.model.pointColors[pointIndex]);
            var options = {
                'opacity': opacity,
                'stroke': borderColor,
                'lineWidth': borderWidth,
                'color': color,
                'x': regions[i].StartX,
                'y': regions[i].StartY,
                'radius': chart.model.circularRadius[regions[i].SeriesIndex],
                'innerRadius': chart.model.innerRadius[regions[i].SeriesIndex],
                'startAngle': regions[i].StartAngle,
                'endAngle': regions[i].EndAngle,
                'type': seriesType
            }
            this.highlightSegment(ctx, options);
        }
    },

     // canvas marker logic
    canvasHighlightMarker: function (chart, series, points, settings, ctx, evt,colors) {
        var highlight = settings;
        var patternName = highlight.pattern.toLowerCase();
        var seriesType = series.type.toLowerCase();
        var options = {};
        var fill = (highlight.color != "" ? highlight.color : chart.model.seriesColors[series.seriesIndex]);
        color = (patternName == "none" || patternName == "") ? fill : this.canvasPattern(ctx, chart, evt, fill, highlight);
        options.Style = {};
        options.Style.BorderColor = highlight.border.color;
        options.Style.Opacity = highlight.opacity;
        options.Style.BorderWidth = highlight.border.width;
        var symbolLocation, location, markerOptions, symbolName;
        for (var i = 0; i < points.length; i++) {
            symbolLocation = points[i].symbolLocation;
            symbolLocation = (seriesType.indexOf("line") != -1 || seriesType.indexOf("area") != -1) ? points[i].location : points[i].symbolLocation;
            if (symbolLocation) {
                location = this.model.AreaType == "cartesianaxes" ? { startX: symbolLocation.X + this.canvasX, startY: symbolLocation.Y + this.canvasY } : { startX: symbolLocation.X, startY: symbolLocation.Y };
                markerOptions = series.marker;
                symbolName;
                bbdesigner$.each(chart.model.symbolShape, function (name) {
                    if (markerOptions.shape.toLowerCase() == name.toLowerCase())
                        symbolName = name;
                });
                options.ShapeSize = markerOptions.size;
                options.r = Math.sqrt(markerOptions.size.height * markerOptions.size.height + markerOptions.size.width * markerOptions.size.width) / 2;
                options.cx = location.startX;
                options.cy = location.startY;
                options.Style.Color = colors?colors[i]:color;
                BoldBIDashboard.EjSvgRender.chartSymbol['_draw' + symbolName](location, options, chart, ctx);
            }
        }

    },

     // canvas selction legend logic perform here
    canvasHighlightLegend: function (chart, series, settings, name, containerStyle, color) {
	var length =this.model._visibleSeries.length;
        var legendMode = chart.model.legend.mode.toLowerCase();
        var index =( chart.model.AreaType == 'none' && length == 1) ? series.pointIndex : series.seriesIndex,
        id = chart._id + '_' + name + '_Legend' + index + '_canvas';
        if (bbdesigner$('#' + id).length == 0) {
            legendCtx = this.createCanvasElement(chart._id + '_' + name + '_Legend' + index + '_canvas', chart.svgWidth, chart.svgHeight, containerStyle);
            if ((chart.model.AreaType != 'none' && (legendMode !="point" || length > 1) ) || (chart.model.AreaType == "none" && length > 1))
                legendRegion = chart.model.legendRegion[series.seriesIndex];
            else
                legendRegion = chart.model.legendRegion[series.pointIndex];
            var legendBounds = { startX: legendRegion.Bounds.LegendBound.X + legendRegion.Location.startX, startY: legendRegion.Bounds.LegendBound.Y + legendRegion.Location.startY },
            svgData = { svgRenderer: chart.svgRenderer, svgObject: chart.svgObject },
            symbolStyle = { 'SeriesIndex': index, 'Style': { 'Color': color, 'Opacity': settings.opacity, 'Visibility': true, 'BorderWidth': 0, BorderColor: color }, 'context': true, 'ShapeSize': legendRegion.Style.ShapeSize }
            if (legendRegion.SymbolShape.toLowerCase() == 'seriestype') {
                chart.legendItem = legendRegion.LegendItem;
                BoldBIDashboard.EjSvgRender.chartSymbol["_draw" + legendRegion.SymbolShape](legendBounds, symbolStyle, chart);
            }else                      
              BoldBIDashboard.EjSvgRender.chartSymbol["_draw" + legendRegion.SymbolShape](legendBounds, symbolStyle, svgData, legendCtx);
        }
    },

     // canvas create element 
    createCanvasElement: function (id, width, height, style) {
        svgObj = document.createElement('canvas');
        _rootId = bbdesigner$(this.element).attr("id");
        svgObj.setAttribute('id', id);
        svgObj.height = height;
        svgObj.width = width;
        this.svgRenderer.append(svgObj, this.element);
        var main = document.getElementById(id);
        main.style.left = style.left + bbdesigner$(document).scrollLeft() + 'px';
        main.style.top = style.top + bbdesigner$(document).scrollTop() + 'px';
        main.style.position = "absolute";

        return svgObj.getContext("2d");
    },

     // canvas pie doughnut logic
    highlightSegment: function (ctx, options) {
        ctx.save();
        ctx.beginPath();
        if (options.type == 'pie') {
            ctx.moveTo(options.x, options.y);
            ctx.arc(options.x, options.y, options.radius, options.startAngle - 1.57, options.endAngle - 1.57, false);
        } else {
            ctx.arc(options.x, options.y, options.radius, options.startAngle - 1.57, options.endAngle - 1.57, false);
            ctx.arc(options.x, options.y, options.innerRadius, options.endAngle - 1.57, options.startAngle - 1.57, true);
        }
        ctx.fillStyle = options.color;
        ctx.globalAlpha = options.opacity;
        ctx.fill();
        ctx.lineWidth = options.lineWidth;
        ctx.strokeStyle = options.stroke;
        ctx.clip();
        ctx.stroke();
        ctx.closePath();
        ctx.restore();        
    },

    // Canvas pattern started here
    canvasPattern: function (ctx, chart, evt, fill, settings) {

        var hoverStyle = settings;
        var name = hoverStyle.name;
        var style = hoverStyle.pattern.toLowerCase();
        var color = fill;
        var opacity = hoverStyle.opacity;
        var backgroundColor = "#ffffff";
        var borderColor = hoverStyle.border.color;
        var borderWidth = hoverStyle.border.width;
        var patternStyle = document.createElement('canvas');
        var patternContext = patternStyle.getContext('2d');
        var pathOptions = [], translate = [];
        switch (style) {
            case "chessboard":
                pathOptions[0] = { 'x': 0, 'y': 0, 'width': 10, 'height': 10, 'fill': 'white', 'stroke': 'white', 'opacity': opacity, 'name': 'rect' };
                pathOptions[1] = { 'x': 0, 'y': 0, 'width': 5, 'height': 5, 'fill': color, 'opacity': opacity, 'name': 'rect' };
                pathOptions[2] = { 'x': 5, 'y': 5, 'width': 5, 'height': 5, 'fill': color, 'opacity': opacity, 'name': 'rect' };
                patternStyle.width = 10;
                patternStyle.height = 10;
                this.loadPattern(chart, pathOptions, '', patternContext);
                break;
            case "pacman":
                pathOptions[0] = { 'name': 'rect', 'x': 0, 'y': 0, 'width': 18, 'height': 18, 'transform': "translate(0,0)", 'fill': 'white', 'opacity': opacity };
                pathOptions[1] = { 'name': 'path', 'd': 'M 9.081 9.194 L 14.887 6.114 C 14.075000000000001 4.618 12.484 3.0620000000000007 10.596 3.0620000000000007 L 8.835 3.0620000000000007 C 6.138 3.063 3 6.151 3 8.723 L 3 10.402000000000001 C 3 12.974 6.138 16.063000000000002 8.835 16.063000000000002 L 10.596 16.063000000000002 C 12.681000000000001 16.063000000000002 14.431000000000001 14.303000000000003 15.131 12.549000000000003 L 9.081 9.194 z', 'stroke-width': 1, 'stroke': color, 'fill': color };
                patternStyle.width = 18;
                patternStyle.height = 18;
                this.loadPattern(chart, pathOptions, '', patternContext);
                break;
            case "crosshatch":
                pathOptions[0] = { 'x': 0, 'y': 0, 'width': 8, 'height': 8, 'fill': 'white', 'stroke': fill, 'opacity': opacity, 'name': 'rect' };
                pathOptions[1] = {
                    'd': 'M 0 0 L 8 8 Z',
                    'stroke-width': 1,
                    'stroke': color,
                    'name': 'path'
                };
                pathOptions[2] = {
                    'd': 'M 8 0 L 0 8 Z',
                    'stroke-width': 1,
                    'stroke': color,
                    'name': 'path'
                };
                patternStyle.width = 8;
                patternStyle.height = 8;
                this.loadPattern(chart, pathOptions, '', patternContext);
                break;
             case "dots":
                pathOptions[0] = { 'x': 0, 'y': 0, 'width': 7, 'height': 7, 'transform': "translate(0,0)", 'fill': 'white', 'opacity': opacity, 'name': 'rect' };
                pathOptions[1] = {
                    'cx': 3,
                    'cy': 3,
                    'r': 2,
                    'stroke-width': 1,
                    'fill': color,
                    'name': 'circle'
                };
                patternStyle.width = 7;
                patternStyle.height = 7;
                this.loadPattern(chart, pathOptions, '', patternContext);
                break;
            case "diagonalforward":
                pathOptions[0] = { 'x': 0, 'y': 0, 'width': 6, 'height': 6, 'fill': 'white', 'stroke': fill, 'opacity': opacity, 'name': 'rect' };
                pathOptions[1] = {
                    'd': 'M 3 -3 L 9 3 M 6 6 L 0 0 M 3 9 L -3 3',
                    'stroke-width': 2,
                    'stroke': color,
                    'name': 'path'
                };
                patternStyle.width = 6;
                patternStyle.height = 6;
                this.loadPattern(chart, pathOptions, '', patternContext);
                break;
            case "diagonalbackward":
                pathOptions[0] = { 'x': 0, 'y': 0, 'width': 6, 'height': 6, 'stroke-width': 2, 'fill': 'white', 'stroke': fill, 'opacity': opacity, 'name': 'rect' };
                pathOptions[1] = {
                    'd': 'M 3 -3 L -3 3 M 0 6 L 6 0 M 9 3 L 3 9',
                    'stroke-width': 2,
                    'stroke': color,
                    'name': 'path'
                };
                patternStyle.width = 6;
                patternStyle.height = 6;
                this.loadPattern(chart, pathOptions, '', patternContext);
                break;
            case "grid":
                pathOptions[0] = { 'name': 'rect', 'x': 0, 'y': 0, 'width': 6, 'height': 6, 'transform': "translate(0,0)", 'fill': 'white', 'opacity': opacity };
                pathOptions[1] = {
                    'name': 'path',
                    'd': 'M 1 3.5 L 11 3.5 M 0 3.5 L 11 3.5 M 0 7.5 L 11 7.5 M 0 11.5 L 11 11.5 M 5.5 0 L 5.5 12 M 11.5 0 L 11.5 12 Z',
                    'stroke-width': 1,
                    'stroke': color
                };
                patternStyle.width = 6;
                patternStyle.height = 6;
                this.loadPattern(chart, pathOptions, '', patternContext);
                break;
            case "turquoise":
                pathOptions[0] = { 'name': 'rect', 'x': 0, 'y': 0, 'width': 17, 'height': 17, 'transform': "translate(0,0)", 'fill': 'white', 'opacity': opacity };
                pathOptions[1] = { 'name': 'path', 'd': 'M 2.697 0.5319999999999996 C 3.8695005238907747 0.5319999999999996 4.82 1.4771268931071944 4.82 2.643 C 4.82 3.808873106892805 3.8695005238907747 4.754 2.697 4.754 C 1.5244994761092252 4.754 0.5739999999999998 3.808873106892805 0.5739999999999998 2.643 C 0.5739999999999998 1.4771268931071944 1.5244994761092252 0.5319999999999996 2.697 0.5319999999999996 Z', 'stroke-width': 1, 'stroke-miterlimit': 10, 'stroke': color, 'fill': color };
                pathOptions[2] = { 'name': 'path', 'd': 'M 13.928 0.5319999999999996 C 15.100500523890776 0.5319999999999996 16.051000000000002 1.4771268931071944 16.051000000000002 2.643 C 16.051000000000002 3.808873106892805 15.100500523890776 4.754 13.928 4.754 C 12.755499476109225 4.754 11.805 3.808873106892805 11.805 2.643 C 11.805 1.4771268931071944 12.755499476109225 0.5319999999999996 13.928 0.5319999999999996 Z', 'stroke-width': 1, 'stroke-miterlimit': 10, 'stroke': color, 'fill': color };
                pathOptions[3] = { 'name': 'path', 'd': 'M 8.313 0.5319999999999996 C 9.485500523890776 0.5319999999999996 10.436 1.4771268931071944 10.436 2.643 C 10.436 3.808873106892805 9.485500523890776 4.754 8.313 4.754 C 7.140499476109226 4.754 6.19 3.808873106892805 6.19 2.643 C 6.19 1.4771268931071944 7.140499476109226 0.5319999999999996 8.313 0.5319999999999996 Z', 'stroke-width': 1, 'stroke-miterlimit': 10, 'stroke': color, 'fill': color };
                pathOptions[4] = { 'name': 'path', 'd': 'M 13.928 6.16 C 15.100500523890776 6.16 16.051000000000002 7.105126893107196 16.051000000000002 8.271 C 16.051000000000002 9.436873106892806 15.100500523890776 10.382000000000001 13.928 10.382000000000001 C 12.755499476109225 10.382000000000001 11.805 9.436873106892806 11.805 8.271 C 11.805 7.105126893107196 12.755499476109225 6.16 13.928 6.16 Z', 'stroke-width': 1, 'stroke-miterlimit': 10, 'stroke': color, 'fill': color };
                pathOptions[5] = { 'name': 'path', 'd': 'M 8.313 6.16 C 9.485500523890776 6.16 10.436 7.105126893107196 10.436 8.271 C 10.436 9.436873106892806 9.485500523890776 10.382000000000001 8.313 10.382000000000001 C 7.140499476109226 10.382000000000001 6.19 9.436873106892806 6.19 8.271 C 6.19 7.105126893107196 7.140499476109226 6.16 8.313 6.16 Z', 'stroke-width': 1, 'stroke-miterlimit': 10, 'stroke': color, 'fill': color };
                pathOptions[6] = { 'name': 'path', 'd': 'M 13.928 11.787999999999998 C 15.100500523890776 11.787999999999998 16.051000000000002 12.733126893107194 16.051000000000002 13.899 C 16.051000000000002 15.064873106892804 15.100500523890776 16.009999999999998 13.928 16.009999999999998 C 12.755499476109225 16.009999999999998 11.805 15.064873106892804 11.805 13.899 C 11.805 12.733126893107194 12.755499476109225 11.787999999999998 13.928 11.787999999999998 Z', 'stroke-width': 1, 'stroke-miterlimit': 10, 'stroke': color, 'fill': color };
                pathOptions[7] = { 'name': 'path', 'd': 'M 8.313 11.787999999999998 C 9.485500523890776 11.787999999999998 10.436 12.733126893107194 10.436 13.899 C 10.436 15.064873106892804 9.485500523890776 16.009999999999998 8.313 16.009999999999998 C 7.140499476109226 16.009999999999998 6.19 15.064873106892804 6.19 13.899 C 6.19 12.733126893107194 7.140499476109226 11.787999999999998 8.313 11.787999999999998 Z', 'stroke-width': 1, 'stroke-miterlimit': 10, 'stroke': color, 'fill': color };
                patternStyle.width = 17;
                patternStyle.height = 17;
                this.loadPattern(chart, pathOptions, '', patternContext);
                break;
            case "star":
                pathOptions[0] = { 'name': 'rect', 'x': 0, 'y': 0, 'width': 21, 'height': 21, 'transform': "translate(0,0)", 'fill': 'white', 'opacity': opacity };
                pathOptions[1] = {
                    'name': 'path',
                    'd': 'M 15.913 18.59 L 10.762 12.842 L 5.613 18.75 L 8.291 11.422 L 0.325 9.91 L 8.154 8.33 L 5.337 0.91 L 10.488 6.658 L 15.637 0.75 L 12.959 8.078 L 20.925 9.59 L 13.096 11.17 z',
                    'stroke-width': 1,
                    'stroke': color,
                    'fill': color
                };
                patternStyle.width = 21;
                patternStyle.height = 21;
                this.loadPattern(chart, pathOptions, '', patternContext);
                break;
            case "triangle":
                pathOptions[0] = { 'name': 'rect', 'x': 0, 'y': 0, 'width': 10, 'height': 10, 'fill': 'white', 'opacity': opacity };
                pathOptions[1] = {
                    'name': 'path',
                    'd': 'M 4.987 0 L 7.48 4.847 L 9.974 9.694 L 4.987 9.694 L 0 9.694 L 2.493 4.847 z',
                    'stroke-width': 1,
                    'stroke': color,
                    'fill': color
                };
                patternStyle.width = 10;
                patternStyle.height = 10;
                this.loadPattern(chart, pathOptions, '', patternContext);
                break;
            case "circle":
                pathOptions[0] = { 'name': 'rect', 'x': 0, 'y': 0, 'width': 9, 'height': 9, 'transform': "translate(0,0)", 'fill': 'white', 'opacity': opacity };
                pathOptions[1] = {
                    'name': 'circle',
                    'cx': 5.125,
                    'cy': 3.875,
                    'r': 3.625,
                    'stroke-width': 1,
                    'fill': color
                };
                patternStyle.width = 9;
                patternStyle.height = 9;
                this.loadPattern(chart, pathOptions, '', patternContext);
                break;
            case "tile":
                pathOptions[0] = { 'name': 'rect', 'x': 0, 'y': 0, 'width': 18, 'height': 18, 'transform': "translate(0,0)", 'fill': 'white', 'opacity': opacity };
                pathOptions[1] = { 'name': 'path', 'd': 'M 0 9 L 0 0 L 9 0 z', 'stroke-width': 1, 'stroke': color, 'fill': color };
                pathOptions[2] = { 'name': 'path', 'd': 'M 9 9 L 9 0 L 18 0 z', 'stroke-width': 1, 'stroke': color, 'fill': color };
                pathOptions[3] = { 'name': 'path', 'd': 'M 0 18 L 0 9 L 9 9 z', 'stroke-width': 1, 'stroke': color, 'fill': color };
                pathOptions[4] = { 'name': 'path', 'd': 'M 9 18 L 9 9 L 18 9 z', 'stroke-width': 1, 'stroke': color, 'fill': color };
                patternStyle.width = 18;
                patternStyle.height = 18;
                this.loadPattern(chart, pathOptions, '', patternContext);
                break;
            case "horizontaldash":
                pathOptions[0] = { 'name': 'rect', 'x': 0, 'y': 0, 'width': 12, 'height': 12, 'transform': "translate(0,0)", 'fill': 'white', 'opacity': opacity };
                pathOptions[1] = { 'name': 'path', 'd': 'M 0 1.5 L 10 1.5 M 0 5.5 L 10 5.5 M 0 9.5 L 10 9.5 z', 'stroke-width': 1, 'stroke': color, 'fill': color };
                patternStyle.width = 12;
                patternStyle.height = 12;
                this.loadPattern(chart, pathOptions, '', patternContext);
                break;
            case "verticaldash":
                pathOptions[0] = { 'name': 'rect', 'x': 0, 'y': 0, 'width': 12, 'height': 12, 'transform': "translate(0,0)", 'fill': 'white', 'opacity': opacity };
                pathOptions[1] = { 'name': 'path', 'd': 'M 1.5 0 L 1.5 10 M 5.5 0 L 5.5 10 M 9.5 0 L 9.5 10 z', 'stroke-width': 1, 'stroke': color, 'fill': color };
                patternStyle.width = 12;
                patternStyle.height = 12;
                this.loadPattern(chart, pathOptions, '', patternContext);
                break;
            case "rectangle":
                pathOptions[0] = { 'x': 0, 'y': 0, 'name': 'rect', 'width': 12, 'height': 12, 'fill': 'white', 'opacity': opacity };
                pathOptions[1] = { 'name': 'rect', 'x': 1, 'y': 2, 'width': 4, 'height': 9, 'fill': color, 'opacity': opacity };
                pathOptions[2] = { 'name': 'rect', 'x': 7, 'y': 2, 'width': 4, 'height': 9, 'fill': color, 'opacity': opacity };
                patternStyle.width = 12;
                patternStyle.height = 12;
                this.loadPattern(chart, pathOptions, '', patternContext);
                break;
            case "box":
                pathOptions[0] = { 'x': 0, 'y': 0, 'name': 'rect', 'width': 13, 'height': 13, 'fill': 'white', 'opacity': opacity };
                pathOptions[1] = { 'name': 'rect', 'x': 1.5, 'y': 1.5, 'width': 10, 'height': 9, 'fill': color, 'opacity': opacity };
                patternStyle.width = 10;
                patternStyle.height = 10;
                this.loadPattern(chart, pathOptions, '', patternContext);
                break;
            case "horizontalstripe":
                pathOptions[0] = { 'name': 'rect', 'x': 0, 'y': 0, 'width': 10, 'height': 12, 'transform': "translate(0,0)", 'fill': 'white', 'opacity': opacity };
                pathOptions[1] = { 'name': 'path', 'd': 'M 0 0.5 L 10 0.5 M 0 4.5 L 10 4.5 M 0 8.5 L 10 8.5 z', 'stroke-width': 1, 'stroke': color, 'fill': color };
                patternStyle.width = 10;
                patternStyle.height = 12;
                this.loadPattern(chart, pathOptions, '', patternContext);
                break;
            case "verticalstripe":
                pathOptions[0] = { 'name': 'rect', 'x': 0, 'y': 0, 'width': 12, 'height': 10, 'transform': "translate(0,0)", 'fill': 'white', 'opacity': opacity };
                pathOptions[1] = { 'name': 'path', 'd': 'M 0.5 0 L 0.5 10 M 4.5 0 L 4.5 10 M 8.5 0 L 8.5 10 z', 'stroke-width': 1, 'stroke': color, 'fill': color };
                patternStyle.width = 12;
                patternStyle.height = 10;
                this.loadPattern(chart, pathOptions, '', patternContext);
                break;
            case "bubble":
                pathOptions[0] = { 'name': 'rect', 'x': 0, 'y': 0, 'width': 20, 'height': 20, 'transform': "translate(0,0)", 'fill': backgroundColor, 'opacity': opacity };
                pathOptions[1] = { 'name': 'circle', 'cx': 5.217, 'cy': 11.325, 'r': 3.429, 'stroke-width': 1, 'fill': '#D0A6D1' };
                pathOptions[2] = { 'name': 'circle', 'cx': 13.328, 'cy': 6.24, 'r': 4.884, 'stroke-width': 1, 'fill': color };
                pathOptions[3] = { 'name': 'circle', 'cx': 13.277, 'cy': 14.66, 'r': 3.018, 'stroke-width': 1, 'fill': '#D0A6D1' };
                patternStyle.width = 20;
                patternStyle.height = 20;
                this.loadPattern(chart, pathOptions, '', patternContext);
                break;
              
           
           
            case "custom":
                patternStyle = document.getElementById(hoverStyle.customPattern);
                break;
        }
        var pattern = ctx.createPattern(patternStyle, 'repeat');
        return pattern;
    },
     // Canvas pattern end
     // Canvas highlight and selection end
    
    //Get selected class for removing lengeds selection in multiselection mode
    foundClasses: function (id) {
        var pointClasses = [];
        bbdesigner$("[id*=" + id + "]").each(function () {
            var pointClass = bbdesigner$(this).attr('class') ? bbdesigner$(this).attr('class') : '';
            if (pointClass.indexOf('Selection') >= 0) {
                pointClasses.push(pointClass);
            }
        });
        return pointClasses;
    },
     // SVG selection started here
    selection: function (chart, evt, series, tracker, legendData, seriesIndex, pointIndex, parentNodeId, targetId, data) {
		if (chart.model.series[0].highlightSettings.mode == "cluster") {
		    var values = this.model._visibleSeries;
		    var clusterName = series.clusterName;
			if (!BoldBIDashboard.isNullOrUndefined(pointIndex && values[seriesIndex]._visiblePoints[pointIndex])) {
            var clusterPoints = [],
            points, pointsLength,
            xvalue = values[seriesIndex]._visiblePoints[pointIndex].xValue;
            for (var i = 0, len = values.length; i < len ; i++) {
                points = values[i].points;
                pointsLength = points.length;
                for (var j = 0; j < pointsLength; j++)
                    if (xvalue == points[j].xValue && points[j].isEmpty == false && points[j].visible == true && clusterName == values[i].clusterName)
                        clusterPoints[clusterPoints.length] = { seriesIndex: i, pointIndex: j };
            }
            this.model.clusterPoints = clusterPoints;
        } 
		}
        var clusterPoints = this.model.clusterPoints,
        clusterPointslength = clusterPoints ? clusterPoints.length : 0,
        seriesCollection = this.model._visibleSeries,
        seriesLenth = seriesCollection.length,
        legend = chart.model.legend,
        legendMode = legend.mode.toLowerCase(),
        enableMultiRange = legend.enableMultiRange,
        index = (this.model.AreaType == 'none'|| legendMode == "point" && seriesLenth == 1 ) ? pointIndex : seriesIndex,
        highlight = series.selectionSettings,
        selectionSettings = this.model._visibleSeries[seriesIndex].selectionSettings,
		type = !BoldBIDashboard.util.isNullOrUndefined(selectionSettings._currentType) ? selectionSettings._currentType : selectionSettings.type,
        isMultiSelection = type.toLowerCase() == 'multiple' ? true : false,
        name = 'series' + seriesIndex,
        found_class = false,
        pathName = bbdesigner$('#' + targetId).attr('name'),
        patternName = highlight.pattern.toLowerCase(),
        mode = highlight.mode, isElement;
        if (parentNodeId)
             isElement = (parentNodeId.indexOf(this.svgObject.id + "_SeriesGroup_") >= 0 ||parentNodeId.indexOf(this.svgObject.id + "_Chart3D") >= 0) ? true : false;
              
        if (this.model.AreaType != 'none' ||( this.model.AreaType == 'none' && mode == "series" && seriesLenth > 1)) {
            bbdesigner$('style').each(function () {
                if (bbdesigner$(this).html().indexOf('.' + chart._id + 'SelectionStyle' + name) > -1) {
                    found_class = true;
                }
            });
        }    
        if (!chart.vmlRendering && this.model.enable3D) {
            if ((mode == 'series' || legendData) && (this.model.AreaType != 'none'|| (this.model.AreaType == 'none' && seriesLenth != 1))) {
                this.highlightSeries(chart, seriesIndex, pointIndex, 'Selection', name, highlight, evt, legendData,data)
                bbdesigner$('#' + this.svgObject.id + '_LegendItemShape' + index).attr('class', 'Selection' + name + 'Style' + name + '1');
            }
            else if (mode == 'cluster' && chart.model.AreaType != 'none') 
                this.highlightCluster(chart, seriesIndex,pointIndex, 'Selection', name, highlight, evt, data)
            else {
                if (this.model.AreaType == 'none') {
                    this.highlightPoint(chart, seriesIndex, pointIndex, 'Selection', name + index, highlight, evt, data);
                    bbdesigner$('#' + this.svgObject.id + '_LegendItemShape' + index).attr('class', 'Selection' + name + index + 'Style' + name + index + '1');
                }else
                {
                    this.highlightPoint(chart, seriesIndex, pointIndex, 'Selection', name, highlight, evt,data)
                    bbdesigner$('#' + this.svgObject.id + '_LegendItemShape' + index).attr('class', 'Selection' + name + 'Style' + name + '1');
                }                                               
            }
        }
        else {
            if ((mode != 'cluster' || legendData) || chart.model.AreaType == 'none') {
                var colorStyle = {};
                colorStyle.name = "2D",
                colorStyle.index =this.model.AreaType=='none'? index : seriesIndex; colorStyle.api = "Selection" + chart._id,
                colorStyle.color = highlight.color != "" ? highlight.color : legendData ? (this.model.AreaType == 'none' || ((legendMode == "point" || legendMode =="range") && seriesLenth == 1) ? this.model._visibleSeries[seriesIndex].visiblePoints[pointIndex].fill : this.model.seriesColors[index]) : bbdesigner$('#' + targetId).attr('fill');
                if (((legendMode == "range") || legendMode == "point") && legendData)
                    colorStyle.color = legendData.legendItem.LegendItem.LegendStyle.Color;
                if (Object.prototype.toString.call(colorStyle.color) === '[object Array]')
                    colorStyle.color = colorStyle.color[1].color;
                var fill = ((patternName == "none" || chart.vmlRendering) || patternName == "") ? highlight.color : this.pattern(chart, evt, colorStyle, highlight),
                opacity = highlight.opacity,
                strokeColor = highlight.border.color,
                strokeWidth = highlight.border.width;
                if (!found_class) {
                    if (this.model.AreaType == 'none' &&(((mode == 'series' || legendData) && seriesLenth == 1)||( mode != 'series' && !legendData))) {
                        bbdesigner$('style').each(function () {
                            if (bbdesigner$(this).html().indexOf('.SelectionStyle' + name + 'Point' + index) > -1) {
                                found_class = true;
                            }
                        });
                        if (!found_class) {
                              this.createStyle(chart, chart._id + 'Selection', name + 'Point' + index, opacity, fill, strokeColor, strokeWidth);
                                this.createStyle(chart, chart._id + 'SelectionLegend', name + 'Point' + index, opacity, fill, 'transparent', 0);
                        }
                    } else if (this.model.AreaType == 'none' && seriesLenth > 1 ||this.model.AreaType != 'none') {
                            this.createStyle(chart, chart._id + 'Selection', name, opacity, fill, strokeColor, strokeWidth);
                            this.createStyle(chart, chart._id + 'SelectionLegend', name, opacity, fill, 'transparent', 0);
                    }
                    
                }
            }        
            if ((mode == 'series' || legendData) && (seriesLenth > 1)) {
                if (!isElement) {
                    var otherElements = bbdesigner$('#' +parentNodeId).childNodes?bbdesigner$('#' +parentNodeId).childNodes:[];
                    for (var i = 0; i < otherElements.length; i++)
                     bbdesigner$('#' + otherElements[i].id).attr('class', chart._id + 'SelectionStyle');
                }
                if (legendMode == "point" || legendMode == "range") {
                    for (var s = 0; s < chart.model.series.length; s++) {
                        if (!enableMultiRange && legendMode == "range") {
                            for (var p = 0; p < chart.model.series[s].points.length; p++) {
                                if (targetId.indexOf("symbol") == -1)
                                    bbdesigner$('#' + this.svgObject.id + '_Series' + s + '_Point' + p + '_symbol').attr('class', chart._id + 'SelectionStyle' + name);
                                bbdesigner$('#' + this.svgObject.id + '_Series' + s + '_Point' + p).attr('class', chart._id + 'SelectionStyle' + name);
                            }
                        } else {
                            if (targetId.indexOf("symbol") == -1)
                                bbdesigner$('#' + this.svgObject.id + '_Series' + s + '_Point' + pointIndex + '_symbol').attr('class', chart._id + 'SelectionStyle' + name);
                            bbdesigner$('#' + this.svgObject.id + '_Series' + s + '_Point' + pointIndex).attr('class', chart._id + 'SelectionStyle' + name);
                        }
                        
                    }
                }
                else {
                    bbdesigner$("[id*=" + this.svgObject.id + '_Series' + index + "]").each(function () {
                        if (this.parentNode.id == chart.svgObject.id + '_SeriesGroup_' + index || this.parentNode.id == chart.svgObject.id + '_symbolGroup_' + index) {
                            var className = bbdesigner$(this).attr("name") ? chart._id + 'SelectionPathStyle' + name : chart._id + 'SelectionStyle' + name;
                            bbdesigner$(this).attr('class', className);
                        }
                    });
                }

              //for legend selection sets here              
              bbdesigner$('#' + this.svgObject.id + '_LegendItemShape' + (legendMode == "series" ?index : pointIndex)).attr('class', chart._id +'SelectionLegendStyle' + name);

                // removed tracker symbol
                if (tracker) bbdesigner$('#' + parentNodeId).remove();
                 
            }

            else if (mode == "cluster" && (chart.model.AreaType != 'none') && !BoldBIDashboard.isNullOrUndefined(targetId)) {
                var matchString, clustername, indexVal, text, colorStyle, opacity, strokeColor, fill, strokeWidth;
                matchString = this.svgObject.id + "_Series";
                var clusterPoints = chart.model.clusterPoints;
                index = targetId.match(/(\d+)/g);
                pointIndex = parseInt(index[index.length - 1]);
                if (targetId.indexOf('SeriesText') >= 0) {
                    var datas = this.GetSeriesPoint(evt);
                    pointIndex = datas.region.Region.PointIndex;
                }
                var findClass, seriesSelectionIndex;
                for (k = 0; k < clusterPoints.length; k++) {
                    seriesSelectionIndex = clusterPoints[k].seriesIndex;
                    name = 'ClusterSeries' + seriesSelectionIndex;
                    //creating individual styles for the points in different series
                    colorStyle = {};
                    colorStyle.index = seriesSelectionIndex;
                    colorStyle.name = "2D"; colorStyle.api = "Selection"+ chart._id + name;
                    highlight = seriesCollection[seriesSelectionIndex].selectionSettings;
                    colorStyle.color = highlight.color != "" ? highlight.color : this.model.seriesColors[seriesSelectionIndex];
                    if (Object.prototype.toString.call(colorStyle.color) === '[object Array]')
                        colorStyle.color = colorStyle.color[1].color;
                    opacity = highlight.opacity;
                    var strokeColor = highlight.border.color;
                    var strokeWidth = highlight.border.width;
                    var fill = ((patternName == "none" || chart.vmlRendering) || patternName == "") ? colorStyle.color : this.pattern(chart, evt, colorStyle, highlight);                   
                    bbdesigner$('style').each(function () {
                        if (bbdesigner$(this).html().indexOf('.' + chart._id + 'SelectionStyle' + name) > -1) {
                            findClass = true;
                        }
                    });
                    if (!findClass) {
                        this.createStyle(chart, chart._id+'Selection', name, opacity, fill, strokeColor, strokeWidth);
                        this.createStyle(chart, chart._id +'SelectionLegend', name, opacity, fill, 'transparent', 0);
                    }                    
                    var className = bbdesigner$('#' + matchString + clusterPoints[k].seriesIndex + '_Point' + clusterPoints[k].pointIndex).attr("name") ? chart._id +'SelectionPathStyle' + name :chart._id + 'SelectionStyle' + name;
                    bbdesigner$('#' + matchString + clusterPoints[k].seriesIndex + '_Point' + clusterPoints[k].pointIndex).attr('class', className);
                    bbdesigner$('#' + matchString + clusterPoints[k].seriesIndex + '_Point' + clusterPoints[k].pointIndex + '_symbol').attr('class', className);
                    if (chart.model._visibleSeries[seriesSelectionIndex].visibility != "hidden")
                        bbdesigner$('#' + this.svgObject.id + '_LegendItemShape' + seriesSelectionIndex).not("[class*='Highlight']").attr('class', chart._id+'SelectionLegendStyle' + name);
                }
                if (tracker) {
                    bbdesigner$('#' + this.svgObject.id + '_Series' + seriesSelectionIndex + '_Point' + pointIndex).attr('class', chart._id +'SelectionStyle' + name);
                    bbdesigner$('#' + this.svgObject.id + '_Series' + seriesSelectionIndex + '_Point' + pointIndex + '_symbol').attr('class', chart._id+'SelectionStyle' + name);
                    bbdesigner$('#' + parentNodeId).remove();
                }
            }


            else {
                // checked condition for whether target id is area related or not
                if ((!bbdesigner$('#' + targetId).attr("name") && targetId != chart.svgObject.id + '_Series' + index) && chart.model.AreaType != 'none' && legendMode !="point") {
                    bbdesigner$('#' + targetId).attr('class',chart._id + 'SelectionStyle' + name);
					if (!BoldBIDashboard.util.isNullOrUndefined(this.model.legendCollection[index]) && this.model.legendCollection[index].visibility == "visible")
						bbdesigner$('#' + this.svgObject.id + '_LegendItemShape' + (legendMode == "series" ? index : (enableMultiRange && legendMode == "range" ? pointIndex : index))).attr('class', chart._id +'SelectionLegendStyle' + name);
                    bbdesigner$('#' + targetId + '_symbol').attr('class', chart._id +'SelectionStyle' + name);

                    if (tracker) {
                        bbdesigner$('#' + targetId + '_symbol').attr('class', chart._id +'SelectionStyle' + name);
                        bbdesigner$('#' + parentNodeId).remove();
                    }
                } else{       
                    if (series.points[index].visible) {
                        bbdesigner$('#' + targetId + '_symbol').attr('class', chart._id + 'SelectionStyle' + name);
                        if ((legendMode == "point" || legendMode == "range") && chart.model.AreaType != 'none') {
                            bbdesigner$('#' + targetId).attr('class', chart._id + 'SelectionStyle' + name);
                            bbdesigner$('#' + this.svgObject.id + '_LegendItemShape' + (legendMode == "series" ? index : pointIndex)).attr('class', chart._id + 'SelectionLegendStyle' + name);
                        }
                        else {
                            bbdesigner$('#' + targetId).attr('class', chart._id + 'SelectionStyle' + name + 'Point' + index);
                            bbdesigner$('#' + this.svgObject.id + '_LegendItemShape' + index).attr('class', chart._id + 'SelectionLegendStyle' + name + 'Point' + index);
                        }
						if (tracker) bbdesigner$('#' + parentNodeId).remove();
					}
                }

                // checked condition for financial series
                var finName = bbdesigner$('#' + targetId).attr("name");
                if (finName != undefined && (finName == 'candle' || finName.indexOf('hilo') >= 0)) {
                    bbdesigner$('[id*=' + targetId + ']').attr('class', chart._id +'SelectionStyle' + name);
                    bbdesigner$('#' + this.svgObject.id + '_LegendItemShape' + index).attr('class', chart._id +'SelectionLegendStyle' + name);
                }
            }
        }
    },

     //Selection Removing Logic
    removeSelection: function (seriesIndex, pointIndex, seriesCollection, mode, isMultiSelection, legendData, isSelected) {
       var seriesLength = seriesCollection.length,
       clusterPoints=this.model.clusterPoints,
       legendMode = this.model.legend.mode.toLowerCase(),
	   selectionSettings, selectionType,
       clusterPointslength = clusterPoints ? clusterPoints.length : 0;       
       //Removing selectiond mode series
       if ((mode == 'series' || legendData) && ((this.model.AreaType != 'none') || (this.model.AreaType == 'none' && seriesLength > 1 ))) {
              for (i = 0; i < seriesLength; i++) {
                  selectionSettings = seriesCollection[i].selectionSettings;
				  selectionType = !BoldBIDashboard.isNullOrUndefined(selectionSettings._currentType) ? selectionSettings._currentType.toLowerCase() : selectionSettings.type.toLowerCase();
                  if ((selectionSettings.mode != 'point' && selectionType == 'single') || (legendData && selectionType == 'single') ) {
                      bbdesigner$(this.svgObject).find('[id*=' + this.svgObject.id + '_SeriesGroup_' + i + '],[id*=' + this.svgObject.id + '_symbolGroup_' + i + '],[id*=_Region_Series_' + i + '_]').each(function () {
                          bbdesigner$(this).find("*").attr('class', '');
                          bbdesigner$(this).attr('class', '');
                      });
                      bbdesigner$('#' + this._id + '_Selection_Legend' + i + '_canvas').remove();
                      bbdesigner$('#' + this._id + '_Selection_series' + i + '_canvas').remove();
                      bbdesigner$("[id*=" + '_Region_Series_' + i + "]").attr('class', '');
                      bbdesigner$('#' + this.svgObject.id + '_LegendItemShape' + i).attr('class', '');
                  } else if (isSelected && selectionType == 'multiple') {
                      bbdesigner$('#' + this._id + '_Selection_series' + seriesIndex + '_canvas').remove();
                      bbdesigner$('#' + this._id + '_Selection_Legend' + seriesIndex + '_canvas').remove();
                      bbdesigner$("[id*=" + '_Region_Series_' + seriesIndex + "]").attr('class', '');
                      bbdesigner$("[id*=" + this.svgObject.id + '_Series' + seriesIndex + "]").attr('class', '');
                      bbdesigner$('#' + this.svgObject.id + '_LegendItemShape' + seriesIndex).attr('class', '');
                  }
              }
       }
       //Removing selection mode Cluster
       if (mode == 'cluster' && this.model.AreaType != 'none' && !legendData) {
           if (!isMultiSelection) {
               if (this.model.enableCanvasRendering) {
                   bbdesigner$('[id*=' + this._id + '_Selection_Cluster' + ']').remove();
                   bbdesigner$('[id*=' + this._id + '_SelectionCluster_Legend' + ']').remove();
                   this.selectedPoint = null;
               }else{
                 for (var k = 0; k < clusterPointslength; k++) {
                     bbdesigner$("[id*=" + '_Region_Series_' + clusterPoints[k].seriesIndex + '_Point_' + "]").attr('class', '');
                     bbdesigner$("[id*=" + this.svgObject.id + '_Series' + clusterPoints[k].seriesIndex + '_Point' + "]").attr('class', '');
                     bbdesigner$('#' + this.svgObject.id + '_LegendItemShape' + clusterPoints[k].seriesIndex).attr('class', '');
                 }	
				var prevClusterPoints = this.model.prevClusterPoints, prevClusterPointslength = prevClusterPoints.length;
				for (var k = 0; k < prevClusterPointslength; k++) {
                     bbdesigner$("[id*=" + '_Region_Series_' + prevClusterPoints[k].seriesIndex + '_Point_' + "]").attr('class', '');
                     bbdesigner$("[id*=" + this.svgObject.id + '_Series' + prevClusterPoints[k].seriesIndex + '_Point' + "]").attr('class', '');
                     bbdesigner$('#' + this.svgObject.id + '_LegendItemShape' + prevClusterPoints[k].seriesIndex).attr('class', '');
                 }					 
			   }
           }
           else {
               if (!this.model.enableCanvasRendering) {
                   for (var k = 0; k < clusterPointslength; k++) {
                       bbdesigner$("[id*=" + "_Region_Series_" + clusterPoints[k].seriesIndex + "_Point_" + clusterPoints[k].pointIndex + "]").attr('class', '');
                       bbdesigner$("[id*=" + this.svgObject.id + '_Series' + clusterPoints[k].seriesIndex + '_Point' + clusterPoints[k].pointIndex + "]").attr('class', '');
                   }
                   pointClasses = this.model.enable3D ? this.foundClasses('_Region_Series_' + seriesIndex) : this.foundClasses(this.svgObject.id + '_Series' + seriesIndex);
                   (pointClasses.length == 0) ? bbdesigner$("[id*=" + this.svgObject.id + '_LegendItemShape' + "]").attr('class', '') : 0;
               } else {
                   bbdesigner$('[id*=' + this._id + '_Selection_Cluster' + '_point_' + pointIndex + ']').remove();
                   bbdesigner$('[id*=' + this._id + '_Selection_Cluster' + ']').length == 0 ? bbdesigner$('[id*=' + this._id + '_SelectionCluster_Legend' + ']').remove() : 0;
               }
          }
		  this.model.prevClusterPoints  = this.model.clusterPoints;
       }

      //Removing selection mode point
       if ((mode == 'point'|| mode == 'single') && this.model.AreaType != 'none' && !legendData) {
           if (!isMultiSelection) {
               bbdesigner$('[id*=' + this._id + '_Selection_series' + seriesIndex + '_point_' + ']').remove();
               bbdesigner$('[id*=' + this._id + '_Selection_Legend' + seriesIndex + ']').remove();
               bbdesigner$("[id*=" + '_Region_Series_' + seriesIndex + '_Point_' + "]").attr('class', '');
			   bbdesigner$("[id*=" + this.svgObject.id + '_Series' + seriesIndex + '_Point' + "]").attr('class', '');
			   bbdesigner$('#' + this.svgObject.id + '_LegendItemShape' + seriesIndex).attr('class', '');
			   if(mode == 'single'){
				   bbdesigner$("#" + this._id).find(bbdesigner$("[class*=" + "SelectionStyle" + "]")).attr('class', '');
			       bbdesigner$("#" + this._id).find(bbdesigner$("[class*=" + "SelectionLegendStyle" + "]")).attr('class', '');
				   if(this.model.enableCanvasRendering){
					   bbdesigner$('#' + this._id).find(bbdesigner$("[id*=" + "_Selection_series" + "]")).remove();
					   bbdesigner$('#' + this._id).find(bbdesigner$("[id*=" + "_Selection_Legend" + "]")).remove();
				   }
			   }
           }
           else {               
               bbdesigner$('#' + this._id + '_Selection_series' + seriesIndex + '_point_' + pointIndex + '_canvas').remove();               
               bbdesigner$("[id*=" + '_Region_Series_' + seriesIndex + '_Point_' + pointIndex + "]").attr('class', '');
               bbdesigner$("[id*=" + this.svgObject.id + '_Series' + seriesIndex + '_Point' + pointIndex + "]").attr('class', '');
               bbdesigner$("[id*=" + this._id + '_Selection_series' + seriesIndex + "]").length == 0 ? bbdesigner$('#' + this._id + '_Selection_Legend' + seriesIndex + '_canvas').remove() : 0;
               pointClasses = this.model.enable3D ? this.foundClasses('_Region_Series_' + seriesIndex) : this.foundClasses(this.svgObject.id + '_Series' + seriesIndex);
               (pointClasses.length == 0) ? bbdesigner$('#' + this.svgObject.id + '_LegendItemShape' + seriesIndex).attr('class', '') : 0;
           }
       }

       //Removing accoumulation series types selections
       if ((mode == 'point' || mode == 'single' || mode == 'cluster')||(mode == "series" && this.model._visibleSeries.length == 1) && (this.model.AreaType == 'none' || legendMode == "point") ) {
           if (!isMultiSelection) {              
               bbdesigner$("[id*=" + this._id + '_Selection_series' + ']').remove();
               bbdesigner$("[id*=" + this._id + '_Selection_Legend' + ']').remove()
               bbdesigner$("[id*=" + '_Region_Series_' + seriesIndex + '_Point_' + "]").attr('class', '');
               bbdesigner$("[id*=" + this.svgObject.id + '_Series' + seriesIndex + '_Point' + "]").attr('class', '');
              (this.model._visibleSeries.length > 1)?bbdesigner$("[id*=" + this.svgObject.id + '_LegendItemShape' + seriesIndex + "]").attr('class', ''): bbdesigner$("[id*=" + this.svgObject.id + '_LegendItemShape' + "]").attr('class', '');
			  if(mode == 'single'){
				   bbdesigner$("#" + this._id).find(bbdesigner$("[class*=" + "SelectionStyle" + "]")).attr('class', '');
			       bbdesigner$("#" + this._id).find(bbdesigner$("[class*=" + "SelectionLegendStyle" + "]")).attr('class', '');
				   if(this.model.enableCanvasRendering){
					   bbdesigner$('#' + this._id).find(bbdesigner$("[id*=" + "_Selection_series" + "]")).remove();
					   bbdesigner$('#' + this._id).find(bbdesigner$("[id*=" + "_Selection_Legend" + "]")).remove();
				   }
			   }
           } else {
               bbdesigner$('#' + this._id + '_Selection_series' + seriesIndex + '_point_' + pointIndex + '_canvas').remove();
               bbdesigner$("[id*=" + '_Region_Series_' + seriesIndex + '_Point_' + pointIndex + "]").attr('class', '');               
               bbdesigner$("[id*=" + this.svgObject.id + '_Series' + seriesIndex + '_Point' + pointIndex + "]").attr('class', '');
               (this.model._visibleSeries.length > 1)? bbdesigner$('#' + this.svgObject.id + '_LegendItemShape' + seriesIndex).attr('class', ''): bbdesigner$('#' + this.svgObject.id + '_LegendItemShape' + pointIndex).attr('class', '');
               (this.model._visibleSeries.length > 1) ? bbdesigner$('#' + this._id + '_Selection_Legend' + seriesIndex + '_canvas').remove() : bbdesigner$('#' + this._id + '_Selection_Legend' + pointIndex + '_canvas').remove();
           }
       }        
    },
     // style append operation perform here
    createStyle: function (chart, api,name, opacity, fill, strokeColor, strokeWidth) {
        if (chart.vmlRendering) {
            var style = document.createElement('style');
            style.id = api + "Segment";
            opacity = opacity * 100;
            var text = "." +api+"Style" + name + " {filter: alpha(opacity=" + opacity + ");}."+api+"PathStyle" + name + "  {filter: alpha(opacity=" + opacity + ");}";
            style.setAttribute("type", "text/css");
            if (style.styleSheet) {   // for IE
                style.styleSheet.cssText = text;
            } else {                // others
                var textnode = document.createTextNode(text);
                style.appendChild(textnode);
            }
            var header = document.getElementsByTagName('head')[0];
            header.appendChild(style);
        } else {
            bbdesigner$("<style id="+api+"Segment" + name + " type='text/css'> ."+api+"Style" + name + "{ fill:" + fill + ";opacity:" + opacity + ";stroke:" + strokeColor + ";stroke-width:" + strokeWidth + "}</style>").appendTo("body");
            bbdesigner$("<style id=" + api + "Path" + name + " type='text/css'> ." + api + "PathStyle" + name + "{ opacity:" + opacity + ";stroke:" + strokeColor + ";stroke-width:" + strokeWidth + "} </style>").appendTo("body");
        }
    },

     // point highlight 3D perform here
    highlightPoint: function (chart, seriesIndex, pointIndex,api,name,highlight,evt ) {
        var pathId = "_Region_Series_" + seriesIndex + "_Point_" + pointIndex,
        gElement = bbdesigner$(this.svgObject).find('[idbbdesigner$=' + pathId + '],[id*=' + pathId + 'back],[id*=' + pathId + 'front]');
        for (var i = 0; i < gElement.length; i++) {
            var style3D = [];
            style3D.api = api+name; style3D.seriesName = name;
            style3D.name = bbdesigner$("[id=" + gElement[i].id + "]").attr('name');
            style3D.index = i;
            var color = this.highlightFill(highlight, chart, seriesIndex, pointIndex);
            var className = (bbdesigner$('#' + gElement[i].id).attr('class'));
            className = className ? className : '';
            if (className.indexOf('Selection') < 0 ) {
                bbdesigner$("[id=" + gElement[i].id + "]").attr('class', this.dStyle(style3D, color, chart, evt, highlight));
            }
        }
    },
       //cluster highlight of 3D is perfomed here
    highlightCluster: function (chart, seriesIndex, pointIndex, api, name, highlight, evt) {
        if (chart.model.AreaType != 'none') {
            var name, pathId, gElement, style3D, color, classname, clusterPoints = [];
            var clusterName = chart.model._visibleSeries[seriesIndex].clusterName;
            var xvalue = chart.model._visibleSeries[seriesIndex]._visiblePoints[pointIndex].x;
            for (var i = 0, len = chart.model._visibleSeries.length; i < len ; i++) {
                for (var j = 0; j < chart.model._visibleSeries[i]._visiblePoints.length; j++) {
                    if (xvalue == chart.model._visibleSeries[i]._visiblePoints[j].x && clusterName == chart.model._visibleSeries[i].clusterName)
                        clusterPoints[clusterPoints.length] = { seriesIndex: i, pointIndex: j };
                }
            }
            for (k = 0; k < clusterPoints.length; k++) {
                name = 'series' + k;
                pathId = "_Region_Series_" + clusterPoints[k].seriesIndex + "_Point_" + clusterPoints[k].pointIndex;
                 gElement = bbdesigner$(this.svgObject).find('[idbbdesigner$=' + pathId + '],[id*=' + pathId + 'back],[id*=' + pathId + 'front]');
                 for (var j = 0; j < gElement.length; j++) {
                        style3D = [];
                        style3D.api = api + name; style3D.seriesName = 'series' + k;
                        style3D.name = bbdesigner$("[id=" + gElement[j].id + "]").attr('name');
                        style3D.index = j;
                        seriesIndex = k;
                        highlight = (api == 'Highlight') ? chart.model._visibleSeries[k].highlightSettings : chart.model._visibleSeries[k].selectionSettings;
                        color = this.highlightFill(highlight, chart, seriesIndex, pointIndex);
                        className = (bbdesigner$('#' + gElement[j].id).attr('class'));
                        className = className ? className : '';
                        if ((className.indexOf('Selection' + name + 'Style') < 0) && (className.indexOf('SelectionStyle') < 0)) {
                            bbdesigner$("[id=" + gElement[j].id + "]").attr('class', this.dStyle(style3D, color, chart, evt, highlight));
                        }

                    }
                    if (api == 'Highlight')
                        bbdesigner$('#' + this.svgObject.id + '_LegendItemShape' + k).not("[class*='Selection']").attr('class', 'Highlight' + name + 'Style' + name + '1');
                    else
                        bbdesigner$('#' + this.svgObject.id + '_LegendItemShape' +k).attr('class', 'Selection' + name + 'Style' + name + '1');
                }

       }
    },  
     // point series 3D perform here
    highlightSeries: function (chart, seriesIndex, index, api, name, highlight, evt, legendData){      
        var seriesIndex = seriesIndex,
        pointIndex = index,
	   length =chart.model._visibleSeries.length,
        pathId = (chart.model.AreaType == 'none' && length == 1) ? "_Region_Series_" + seriesIndex + "_Point_" + index : "_Region_Series_" + seriesIndex + "_Point_",
        gElement = bbdesigner$(this.svgObject).find('[id*=' + pathId + ']'), style3D,color,
        className = legendData ? bbdesigner$('#' + this.svgObject.id + '_LegendItemShape' + index).attr('class') : (bbdesigner$('#' + evt.target.id).attr('class'));
        className = className ? className : '';
        if (className.indexOf('SelectionStyle') < 0 || legendData) {
            for (var i = 0; i < gElement.length; i++) {
                style3D = [];
                style3D.api = api + name, style3D.seriesName = name,
                style3D.name = bbdesigner$("[id=" + gElement[i].id + "]").attr('name'),
                style3D.index = i;
                color = this.highlightFill(highlight, chart, seriesIndex, pointIndex, legendData);
				className = bbdesigner$('#' + gElement[i].id).attr('class');
                className = className ? className : '';
                if (className.indexOf('SelectionStyle') < 0&& (className.indexOf('Selection' + name + 'Style') < 0)) {
                    bbdesigner$("[id=" + gElement[i].id + "]").attr('class', this.dStyle(style3D, color, chart, evt, highlight));
                }
            }
        }
    },

     //SVG highlight logic started here
    highlight: function (chart, evt, series, legendData) {
        var data = this.GetSeriesPoint(evt);
        var highlight = series.highlightSettings;
        var legend = chart.model.legend;
        var legendVisibility = legend.visible;
        var legendMode = legend.mode.toLowerCase();
		var legendPosition = legend.position.toLowerCase();
        var enableMultiRange = legend.enableMultiRange;
        var seriesIndex = bbdesigner$.inArray(series, chart.model._visibleSeries);
        var name = 'series' + seriesIndex;//series.name.replace(/ /g, ''); // removed space for series name
        var found_class = false;
        var index = seriesIndex;
        var targetId = evt.target.id;
        var parentNodeId = evt.target.parentNode.id;
        var isElement = (parentNodeId.indexOf(this.svgObject.id + "_SeriesGroup_") >= 0 || parentNodeId.indexOf(this.svgObject.id + "_Chart3D") >= 0) ? true : false;
        var pathName = bbdesigner$('#' + targetId).attr('name');
        var patternName = legendMode == "range" && !enableMultiRange ? "diagonalforward":highlight.pattern.toLowerCase();
        var length = chart.model._visibleSeries.length;
		if ((chart.model.AreaType == 'none' || legendMode == "point" || (legendMode == "range")) )
        {
            if (!chart.model.enable3D) {
                var matchStr = legendData ? this.svgObject.id + '_LegendItemShape' : this.svgObject.id + "_Series" + seriesIndex + "_Point";
                var id = legendData ? this.svgObject.id + '_LegendItemShape' + legendData.legendItem.LegendItem.PointIndex : targetId;
                pointIndex = id.substr(matchStr.length);
                index = legendMode == "range" && !enableMultiRange && legendData ? 0 :pointIndex;
            } else {
                index = legendData ? legendData.legendItem.LegendItem.PointIndex:data.region.Region.PointIndex;
            }
        }
        bbdesigner$('style').each(function () {
            if (bbdesigner$(this).html().indexOf('.HighlightStyle'+ name) > -1) {
                found_class = true;
            }
        });
        if (chart.model.enable3D && !chart.vmlRendering) {
            if ((highlight.mode == 'series' || legendData) && ((chart.model.AreaType == 'none' && length != 1) || chart.model.AreaType != 'none')) {
                this.highlightSeries(chart, seriesIndex, index, 'Highlight', name , highlight, evt, legendData)
                bbdesigner$('#' + this.svgObject.id + '_LegendItemShape' + index).not("[class*='Selection']").attr('class', 'Highlight' + name  + 'Style' + name  + '1');
            } else if (highlight.mode == 'cluster' && chart.model.AreaType != 'none') {
                this.highlightCluster(chart, seriesIndex, data.pointData.pointIndex, 'Highlight', name, highlight, evt);
                
            } else {
                pointIndex = data ? data.pointData.pointIndex: index ;
                this.highlightPoint(chart, seriesIndex, pointIndex, 'Highlight', name + pointIndex, highlight, evt)
                bbdesigner$('#' + this.svgObject.id + '_LegendItemShape' + index).not("[class*='Selection']").attr('class', 'Highlight' + name + pointIndex + 'Style' + name + pointIndex + '1');
            }
        } else {
            if (highlight.mode || this.model.AreaType=='none') {
                var colorStyle = {};
                colorStyle.name = "2D";
                colorStyle.index = seriesIndex; colorStyle.api = "Highlight";
                colorStyle.color = highlight.color != "" ? highlight.color : legendData ? (this.model.AreaType == 'none' || ((legendMode == "point" || legendMode == "range")) ? (enableMultiRange ? this.model.pointColors[index] : chart.svgRenderer._getAttrVal(bbdesigner$('#' + this.svgObject.id + '_LegendItemShape' + index), "fill")) : this.model.seriesColors[index]) : bbdesigner$('#' + targetId).attr('fill');
                if ((legendMode == "point" || legendMode =="range") && length > 1 && legendData)
                    colorStyle.color = legendData.legendItem.LegendItem.LegendStyle.Color;
                if (Object.prototype.toString.call(colorStyle.color) === '[object Array]')
                    colorStyle.color = colorStyle.color[1].color;
                var fill = ((patternName == "none" || chart.vmlRendering) || patternName == "") ? (legendMode == "range" && !enableMultiRange ? this.pattern(chart, evt, colorStyle, highlight) : highlight.color) : this.pattern(chart, evt, colorStyle, highlight);
                var opacity = highlight.opacity;
                var strokeColor = highlight.border.color;
                var strokeWidth = highlight.border.width;
                if (!found_class) {
                    this.createStyle(chart, 'Highlight', name, opacity, fill, strokeColor, strokeWidth);
                    this.createStyle(chart, 'HighlightLegend', name, opacity, fill, 'transparent', 0);
                }
            }

            // sets the style for the segment or path started here
            var className = legendData ? bbdesigner$('#' + this.svgObject.id + '_LegendItemShape' + index).attr('class') : bbdesigner$('#' + targetId).attr('class');
            className = className ? className : '';
            if (className.indexOf("Selection")==-1) {
                // checked mode of the highlight series
                if (highlight.enable && (highlight.mode == 'series' || legendData) && (legendMode != "point" || length != 1) && ((chart.model.AreaType == 'none' && length != 1) || chart.model.AreaType != 'none')) {
                    if ((legendMode == "point" || (legendMode == "range" && enableMultiRange) || legendData) && legendMode != "series" ) {
                        for (var s = 0; s < chart.model.series.length; s++) {
                            if (legendData && !enableMultiRange && legendMode == "range") {
                                var points = chart.model.series[s].points;
                                for (var p = 0; p < points.length; p++) {
                                    if (targetId.indexOf("symbol") == -1)
                                        bbdesigner$('#' + this.svgObject.id + '_Series' + s + '_Point' + p + '_symbol').not("[class*='Selection']").attr('class', 'HighlightStyle' + name);
                                    bbdesigner$('#' + this.svgObject.id + '_Series' + s + '_Point' + p).not("[class*='Selection']").attr('class', 'HighlightStyle' + name);
                                }
                             }
                            else{
                                if (targetId.indexOf("symbol") == -1)
                                    bbdesigner$('#' + this.svgObject.id + '_Series' + s + '_Point' + pointIndex + '_symbol').not("[class*='Selection']").attr('class', 'HighlightStyle' + name);
                                bbdesigner$('#' + this.svgObject.id + '_Series' + s + '_Point' + pointIndex).not("[class*='Selection']").attr('class', 'HighlightStyle' + name);
                            }
                         }
                    }
                    else {
                        bbdesigner$("[id*=" + this.svgObject.id + '_Series' + index + "]").each(function () {
                            if (this.parentNode.id == chart.svgObject.id + '_SeriesGroup_' + index || this.parentNode.id == chart.svgObject.id + '_symbolGroup_' + index) {
                                var selectClass = bbdesigner$(this).attr('class');
                                var className = bbdesigner$(this).attr("name") ? 'HighlightPathStyle' + name : 'HighlightStyle' + name;
                                // this condition is checked for whether already selected and it's symbol
                                if (selectClass != 'SelectionStyle' + name && selectClass != 'SelectionStyleClusterSeries' + seriesIndex && selectClass != 'SelectionPathStyle' + name && parentNodeId.indexOf(chart.svgObject.id + '_symbolGroup_' + index) <= 0) {
                                    bbdesigner$(this).attr('class', className);
                                }
                            }
                        });
                    }
                    //for legend highlight sets here
                    bbdesigner$('#' + this.svgObject.id + '_LegendItemShape' + index).not("[class*='Selection']").attr('class', 'HighlightLegendStyle' + name);
                }
                 else if (highlight.mode == "cluster" && chart.model.AreaType != 'none') {
                    var matchString;
                    matchString = this.svgObject.id + "_Series";
                    var clusterPoints = [],seriesHighlightIndex, pointHighlightIndex;
                    index = targetId.match(/(\d+)/g);
                    pointIndex = parseInt(index[index.length - 1]);
                    var clusterName = chart.model._visibleSeries[seriesIndex].clusterName;
					// condition checked if mouse over only on the point region not on path
                    if (targetId.toLowerCase().indexOf("point") > 0 || legendMode == "point") {
                    var xvalue = chart.model._visibleSeries[seriesIndex]._visiblePoints[pointIndex].xValue, point;
                    for (var i = 0, len = chart.model._visibleSeries.length; i < len ; i++) {
                        for (var j = 0; j < chart.model._visibleSeries[i]._visiblePoints.length; j++) {
                            point = chart.model._visibleSeries[i]._visiblePoints[j];
                            if (xvalue == point.xValue && point.isEmpty == false && point.visible == true && clusterName == chart.model._visibleSeries[i].clusterName)
                                clusterPoints[clusterPoints.length] = { seriesIndex: i, pointIndex: j };
                        }
                    }
                    }
                    for (k = 0; k < clusterPoints.length; k++) {
                        seriesHighlightIndex = clusterPoints[k].seriesIndex;
                        pointHighlightIndex = clusterPoints[k].pointIndex;
                        name = 'series' + seriesHighlightIndex;
						found_class = false;
						 bbdesigner$('style').each(function () {//Check if the styles exists in the DOM for each series point
                            if (bbdesigner$(this).html().indexOf('.HighlightStyle' + name) > -1) {
                                found_class = true;
                            }
                        });
                        //creating individual styles for the points in different series
                        colorStyle = {};
                        colorStyle.name = "2D"; colorStyle.api = "Highlight" + name;
                        highlight = chart.model._visibleSeries[seriesHighlightIndex].highlightSettings;
                        colorStyle.color = highlight.color != "" ? highlight.color : this.model.seriesColors[seriesHighlightIndex];
                        if (Object.prototype.toString.call(colorStyle.color) === '[object Array]')
                            colorStyle.color = colorStyle.color[1].color;
                        opacity = highlight.opacity;
                        strokeColor = highlight.border.color;
                        strokeWidth = highlight.border.width;
                        fill = ((patternName == "none" || chart.vmlRendering) || patternName == "") ? colorStyle.color : this.pattern(chart, evt, colorStyle, highlight);
                        if (!found_class) {
                            this.createStyle(chart, 'Highlight', name, opacity, fill, strokeColor, strokeWidth);
                            this.createStyle(chart, 'HighlightLegend', name, opacity, fill, 'transparent', 0);
                        }
                        
                        //applying the created style to the selected element 
                        var selectClass = bbdesigner$('#' + matchString + clusterPoints[k].seriesIndex + '_Point' + clusterPoints[k].pointIndex).attr('class');
                        var symbol = bbdesigner$('#' + matchString + clusterPoints[k].seriesIndex + '_Point' + clusterPoints[k].pointIndex + '_symbol').attr('class');
                        var className = bbdesigner$('#' + matchString + clusterPoints[k].seriesIndex + '_Point' + clusterPoints[k].pointIndex).attr("name") ? 'HighlightPathStyle' + name : 'HighlightStyle' + name;
                        // this condition is checked for whether already selected and it's symbol
                        if (selectClass != 'SelectionStyle' + 'series' + k && selectClass != 'SelectionPathStyle' + name && parentNodeId.indexOf(chart.svgObject.id + '_symbolGroup_' + k) <= 0) {
                            bbdesigner$('#' + matchString + clusterPoints[k].seriesIndex + '_' + 'Point' + clusterPoints[k].pointIndex).attr('class', className);
                            bbdesigner$('#' + matchString + clusterPoints[k].seriesIndex + '_' + 'Point' + clusterPoints[k].pointIndex + '_symbol').attr('class', className);
                        }
                        if (chart.model._visibleSeries[seriesHighlightIndex].visibility != "hidden") {
                            if (legendMode == "point")
                                bbdesigner$('#' + this.svgObject.id + '_LegendItemShape' + pointHighlightIndex).not("[class*='Selection']").attr('class', 'HighlightLegendStyle' + name);
                            else
                            bbdesigner$('#' + this.svgObject.id + '_LegendItemShape' + seriesHighlightIndex).not("[class*='Selection']").attr('class', 'HighlightLegendStyle' + name);
                        }
                    }

                }

				else {
					// checked condition for whether target id is area related or not
					if (!bbdesigner$('#' + targetId).attr("name") && targetId != chart.svgObject.id + '_Series' + index) {
						selectClass = bbdesigner$('#' + targetId).attr('class') ? bbdesigner$('#' + targetId).attr('class') : '';
						if ((selectClass.indexOf('Selection') != 0 && parentNodeId.indexOf(chart.svgObject.id + '_symbolGroup_' + index) <= 0 && (data||legendData))) {
                            if(isElement)
                                bbdesigner$('#' + targetId).attr('class', 'HighlightStyle' + name);                            
                            if(chart.model.AreaType != 'none'){
                                pointIndex = data ? data.region.Region.PointIndex:legendData.legendItem.LegendItem.PointIndex;
                            }
                            if (legendMode == "point" && targetId.indexOf("symbol") == -1 && series.type != "column" && series.type != "bar" && series.type != "bubble" && series.type != "scatter" && series.type != "pie" && series.type != "doughnut" && series.type != "pyramid" && series.type != "funnel") {
                                bbdesigner$('#' + this.svgObject.id + '_Series' + seriesIndex + '_Point' + pointIndex + '_symbol').not("[class*='Selection']").attr('class', 'HighlightStyle' + name);
                                bbdesigner$('#' + this.svgObject.id + '_LegendItemShape' + pointIndex).not("[class*='Selection']").attr('class', 'HighlightLegendStyle' + name);
                            }
                            else {
                                bbdesigner$('#' + targetId + '_symbol').attr('class', 'HighlightStyle' + name);
                                bbdesigner$('#' + this.svgObject.id + '_Series' + seriesIndex + '_Point' + pointIndex).not("[class*='Selection']").attr('class', 'HighlightStyle' + name);
                                if(highlight.enable) bbdesigner$('#' + this.svgObject.id + '_LegendItemShape' + (legendMode == "series" ? index : (enableMultiRange && legendMode == "range" ? pointIndex : index))).not("[class*='Selection']").attr('class', 'HighlightLegendStyle' + name);
                                if (legendMode == "range" && !enableMultiRange && legendVisibility) {
                                    var legendSize = bbdesigner$('#' + this.svgObject.id + '_LegendItemShape0')[0].getBoundingClientRect();
                                    var arrowPosition = BoldBIDashboard.EjSvgRender.utils._getPointXY(series.points[pointIndex].y, { min : series.minY, max: series.maxY, delta : series.maxY - series.minY }, chart.model._axes[1].isInversed) * ((legendPosition == "top" || legendPosition == "bottom") ? legendSize.width : legendSize.height);
                                    bbdesigner$('#' + this.svgObject.id + '_LegendItemShape0Icon')[0].style.transform = (legendPosition == "top" || legendPosition == "bottom") ? 'translateX(' + arrowPosition + 'px)' : 'translateY(' + arrowPosition + 'px)'; 
                                }
                            }
                            }
						if (targetId.indexOf("symbol") > -1) {
							if(legendMode != "series")
								pointIndex = typeof index == "string" ? index.replace("_symbol", '') : pointIndex;
						    bbdesigner$('#' + targetId).attr('class', 'HighlightStyle' + name);
						    if (legendMode == "point" || (legendMode == "range" && enableMultiRange)) 
						        bbdesigner$('#' + this.svgObject.id + '_LegendItemShape' + pointIndex).not("[class*='Selection']").attr('class', 'HighlightLegendStyle' + name);						    
						    if (legendMode == "range" && !enableMultiRange && legendVisibility) {						       
						        var legendSize = bbdesigner$('#' + this.svgObject.id + '_LegendItemShape0')[0].getBoundingClientRect();
						        var arrowPosition = BoldBIDashboard.EjSvgRender.utils._getPointXY(series.points[pointIndex].y, { min : series.minY, max: series.maxY, delta : series.maxY - series.minY }, chart.model._axes[1].isInversed) * ((legendPosition == "top" || legendPosition == "bottom") ? legendSize.width : legendSize.height);
						        bbdesigner$('#' + this.svgObject.id + '_LegendItemShape0Icon')[0].style.transform = (legendPosition == "top" || legendPosition == "bottom") ? 'translateX(' + arrowPosition + 'px)' : 'translateY(' + arrowPosition + 'px)';
						    }
						}
                    }
					// checked condition for financial series
                    var finName = bbdesigner$('#' + targetId).attr("name");
                    if (finName != undefined && (finName == 'candle' || finName.indexOf('hilo') >= 0)) {
                        bbdesigner$('[id*=' + targetId + ']').attr('class', 'HighlightStyle' + name);
						bbdesigner$('#' + this.svgObject.id + '_LegendItemShape' + index).not("[class*='Selection']").attr('class', 'HighlightLegendStyle' + name);
					}

				}
			}
        }

    },

     // 3D style class created here
    dStyle: function (style3D, color, chart, evt, settings) {
        var vector = BoldBIDashboard.Ej3DRender.prototype.polygon3D.prototype;
        var highlight = settings;
        var name = style3D.api;
        var seriesName = style3D.seriesName;
        var opacity = highlight.opacity;
        color = chart.colorNameToHex(color);
        if (style3D.name == "XLight")
            color = vector.applyXLight(color, chart);
        else if (style3D.name == "ZLight")
            color = vector.applyZLight(color, chart);
        else
            color = color;
        var colorStyle = {};
        colorStyle.name = style3D.name; colorStyle.color = color; colorStyle.api = name;
        color = (highlight.pattern == "none") ? color : this.pattern(chart, evt, colorStyle, highlight);
        if (document.getElementById(name + "Segment" + seriesName)) {
            var style = document.getElementById(name + "Segment" + seriesName);
            style.innerHTML = style.innerHTML + '.' + name + 'Style' + seriesName+ style3D.index + ' { fill:' + color + ";opacity:" + opacity + ' }';
        } else {
            var style = document.createElement('style');
            style.id = name + "Segment" + seriesName;
            style.type = 'text/css';
            style.innerHTML = '.' + name + 'Style' + seriesName + style3D.index + ' { fill:' + color + ";opacity:" + opacity + ' }';
            document.getElementsByTagName('head')[0].appendChild(style);
        }
        return name + "Style" + seriesName + style3D.index;

    },

     // 3D style class end

     // pattern of the SVG started here
    pattern: function (chart, evt, colorStyle, settings) {
        var hoverStyle = settings;
        var name = colorStyle.api;
        var legendMode = chart.model.legend.mode;
        var enableMultiRange = chart.model.legend.enableMultiRange;
        var style = !enableMultiRange && legendMode == "range" ? "diagonalforward" : hoverStyle.pattern.toLowerCase();
        var color = colorStyle.color;
        var opacity = !enableMultiRange && legendMode == "range" ? 1 : hoverStyle.opacity != "" ? hoverStyle.opacity : bbdesigner$('#' + evt.target.id).attr('opacity');
        var backgroundColor = "#ffffff";
        if (bbdesigner$(chart.svgObject).find('[id*="' + name + 'Def"]').length > 0) {
            var svg = bbdesigner$("#" + name + "Def")[0];
        } else {
            var svgid = { 'id': name + "Def" }
            var svg = chart.svgRenderer.createPattern(svgid, 'svg');
            chart.svgRenderer.append(svg, chart.svgObject);
        }
        if (chart.model.enable3D) {
            if (colorStyle.name == "XLight")
                backgroundColor = "#595959";
            else if (colorStyle.name == "ZLight")
                backgroundColor = "#737373";
            else
                backgroundColor = "#808080";
        }        
        if (("#" + style + '_' + name + '_' + colorStyle.name + '_' + colorStyle.index))
            bbdesigner$("#" + style + '_' + name + '_' + colorStyle.name + '_' + colorStyle.index).remove();

        var pathOptions = [];
        switch (style) {
            case "chessboard":
                var patternGroup = { 'id': style + "_" + name + "_" + colorStyle.name + "_" + colorStyle.index, 'patternUnits': 'userSpaceOnUse', 'x': 0, 'y': 0, 'width': 10, 'height': 10 }
                var pattern = chart.svgRenderer.createPattern(patternGroup, 'pattern');
                pathOptions[0] = { 'x': 0, 'y': 0, 'width': 10, 'height': 10, 'fill': backgroundColor, 'opacity': opacity, 'name': 'rect' };
                pathOptions[1] = { 'x': 0, 'y': 0, 'width': 5, 'height': 5, 'fill': color, 'opacity': opacity, 'name': 'rect' };
                pathOptions[2] = { 'x': 5, 'y': 5, 'width': 5, 'height': 5, 'fill': color, 'opacity': opacity, 'name': 'rect' };
                this.loadPattern(chart, pathOptions, pattern);
                svg.appendChild(pattern);
                return "url(#" + style + "_" + name + "_" + colorStyle.name + "_" + colorStyle.index + ")";
                break;
            case "pacman":
                var patternGroup = { 'id': style + "_" + name + "_" + colorStyle.name + "_" + colorStyle.index, 'patternUnits': 'userSpaceOnUse', 'width': '17.917', 'height': '18.384' }
                var pattern = chart.svgRenderer.createPattern(patternGroup, 'pattern');
                pathOptions[0] = { 'name': 'rect', 'x': 0, 'y': 0, 'width': 17.917, 'height': 18.384, 'transform': "translate(0,0)", 'fill': backgroundColor, 'opacity': opacity };
                pathOptions[1] = { 'name': 'path', 'd': 'M9.081,9.194l5.806-3.08c-0.812-1.496-2.403-3.052-4.291-3.052H8.835C6.138,3.063,3,6.151,3,8.723v1.679   c0,2.572,3.138,5.661,5.835,5.661h1.761c2.085,0,3.835-1.76,4.535-3.514L9.081,9.194z', 'stroke-width': 1, 'stroke': color, 'fill': color };
                this.loadPattern(chart, pathOptions, pattern);
                svg.appendChild(pattern);
                return "url(#" + style + "_" + name + "_" + colorStyle.name + "_" + colorStyle.index + ")";
                break;
            case "crosshatch":
                var patternGroup = { 'id': style + "_" + name + "_" + colorStyle.name + "_" + colorStyle.index, 'patternUnits': 'userSpaceOnUse', 'width': '8', 'height': '8' }
                var pattern = chart.svgRenderer.createPattern(patternGroup, 'pattern');
                pathOptions[0] = { 'x': 0, 'y': 0, 'width': 8, 'height': 8, 'transform': "translate(0,0)", 'fill': backgroundColor, 'opacity': opacity, 'name': 'rect' };
                pathOptions[1] = {
                    'd': 'M0 0L8 8ZM8 0L0 8Z',
                    'stroke-width': 1,
                    'stroke': color,
                    'name': 'path'
                };
                this.loadPattern(chart, pathOptions, pattern);
                svg.appendChild(pattern);
                return "url(#" + style + "_" + name + "_" + colorStyle.name + "_" + colorStyle.index + ")";
                break;
            case "dots":
                var patternGroup = { 'id': style + "_" + name + "_" + colorStyle.name + "_" + colorStyle.index, 'patternUnits': 'userSpaceOnUse', 'width': '6', 'height': '6' }
                var pattern = chart.svgRenderer.createPattern(patternGroup, 'pattern');
                pathOptions[0] = { 'x': 0, 'y': 0, 'width': 7, 'height': 7, 'transform': "translate(0,0)", 'fill': backgroundColor, 'opacity': opacity, 'name': 'rect' };
                pathOptions[1] = {
                    'cx': 3,
                    'cy': 3,
                    'r': 2,
                    'stroke-width': 1,
                    'fill': color,
                    'name': 'circle'
                };
                this.loadPattern(chart, pathOptions, pattern);
                svg.appendChild(pattern);
                return "url(#" + style + "_" + name + "_" + colorStyle.name + "_" + colorStyle.index + ")";
                break;
            case "diagonalforward":
                var patternGroup = { 'id': style + "_" + name + "_" + colorStyle.name + "_" + colorStyle.index, 'patternUnits': 'userSpaceOnUse', 'width': '6', 'height': '6' }
                var pattern = chart.svgRenderer.createPattern(patternGroup, 'pattern');
                pathOptions[0] = { 'x': 0, 'y': 0, 'width': 6, 'height': 6, 'transform': "translate(0,0)", 'fill': backgroundColor, 'opacity': opacity, 'name': 'rect' };
                pathOptions[1] = {
                    'd': 'M 3 -3 L 9 3 M 6 6 L 0 0 M 3 9 L -3 3',
                    'stroke-width': 2,
                    'stroke': color,
                    'name': 'path'
                };
                this.loadPattern(chart, pathOptions, pattern);
                svg.appendChild(pattern);
                return "url(#" + style + "_" + name + "_" + colorStyle.name + "_" + colorStyle.index + ")";
                break;
            case "diagonalbackward":
                var patternGroup = { 'id': style + "_" + name + "_" + colorStyle.name + "_" + colorStyle.index, 'patternUnits': 'userSpaceOnUse', 'width': '6', 'height': '6' }
                var pattern = chart.svgRenderer.createPattern(patternGroup, 'pattern');
                pathOptions[0] = { 'x': 0, 'y': 0, 'width': 6, 'height': 6, 'transform': "translate(0,0)", 'fill': backgroundColor, 'opacity': opacity, 'name' : 'rect' };
                pathOptions[1]= {
                    'd': 'M 3 -3 L -3 3 M 0 6 L 6 0 M 9 3 L 3 9',
                    'stroke-width': 2,
                    'stroke': color,
                    'name':'path'
                };
                this.loadPattern(chart, pathOptions, pattern);
                svg.appendChild(pattern);
                return "url(#" + style + "_" + name + "_" + colorStyle.name + "_" + colorStyle.index + ")";
                break;
            case "grid":
                var patternGroup = { 'id': style + "_" + name + "_" + colorStyle.name + "_" + colorStyle.index, 'patternUnits': 'userSpaceOnUse', 'width': '6', 'height': '6' }
                var pattern = chart.svgRenderer.createPattern(patternGroup, 'pattern');
                pathOptions[0] = { 'name': 'rect', 'x': 0, 'y': 0, 'width': 6, 'height': 6, 'transform': "translate(0,0)", 'fill': backgroundColor, 'opacity': opacity };
                pathOptions[1] = {
                    'name': 'path',
                    'd': 'M1 3.5L11 3.5 M0 3.5L11 3.5 M0 7.5L11 7.5 M0 11.5L11 11.5 M5.5 0L5.5 12 M11.5 0L11.5 12Z',
                    'stroke-width': 1,
                    'stroke': color
                };
                this.loadPattern(chart, pathOptions, pattern);
                svg.appendChild(pattern);
                return "url(#" + style + "_" + name + "_" + colorStyle.name + "_" + colorStyle.index + ")";
                break;
            case "turquoise":
                var patternGroup = { 'id': style + "_" + name + "_" + colorStyle.name + "_" + colorStyle.index, 'patternUnits': 'userSpaceOnUse', 'width': '17', 'height': '17' }
                var pattern = chart.svgRenderer.createPattern(patternGroup, 'pattern');
                pathOptions[0] = { 'name': 'rect', 'x': 0, 'y': 0, 'width': 17, 'height': 17, 'transform': "translate(0,0)", 'fill': backgroundColor, 'opacity': opacity };
                pathOptions[1] = { 'name': 'path', 'd': 'M0.5739999999999998,2.643a2.123,2.111 0 1,0 4.246,0a2.123,2.111 0 1,0 -4.246,0', 'stroke-width': 1, 'stroke-miterlimit': 10, 'stroke': color, 'fill': color };
                pathOptions[2] = { 'name': 'path', 'd': 'M11.805,2.643a2.123,2.111 0 1,0 4.246,0a2.123,2.111 0 1,0 -4.246,0', 'stroke-width': 1, 'stroke-miterlimit': 10, 'stroke': color, 'fill': color };
                pathOptions[3] = { 'name': 'path', 'd': 'M6.19,2.643a2.123,2.111 0 1,0 4.246,0a2.123,2.111 0 1,0 -4.246,0', 'stroke-width': 1, 'stroke-miterlimit': 10, 'stroke': color, 'fill': color };
                pathOptions[4] = { 'name': 'path', 'd': 'M11.805,8.217a2.123,2.111 0 1,0 4.246,0a2.123,2.111 0 1,0 -4.246,0', 'stroke-width': 1, 'stroke-miterlimit': 10, 'stroke': color, 'fill': color };
                pathOptions[5] = { 'name': 'path', 'd': 'M6.19,8.217a2.123,2.111 0 1,0 4.246,0a2.123,2.111 0 1,0 -4.246,0', 'stroke-width': 1, 'stroke-miterlimit': 10, 'stroke': color, 'fill': color };
                pathOptions[6] = { 'name': 'path', 'd': 'M11.805,13.899a2.123,2.111 0 1,0 4.246,0a2.123,2.111 0 1,0 -4.246,0', 'stroke-width': 1, 'stroke-miterlimit': 10, 'stroke': color, 'fill': color };
                pathOptions[7] = { 'name': 'path', 'd': 'M6.19,13.899a2.123,2.111 0 1,0 4.246,0a2.123,2.111 0 1,0 -4.246,0', 'stroke-width': 1, 'stroke-miterlimit': 10, 'stroke': color, 'fill': color };
                this.loadPattern(chart, pathOptions, pattern);
                svg.appendChild(pattern);
                return "url(#" + style + "_" + name + "_" + colorStyle.name + "_" + colorStyle.index + ")";
                break;
            case "star":
                var patternGroup = { 'id': style + "_" + name + "_" + colorStyle.name + "_" + colorStyle.index, 'patternUnits': 'userSpaceOnUse', 'width': '21', 'height': '21' }
                var pattern = chart.svgRenderer.createPattern(patternGroup, 'pattern');
                pathOptions[0] = { 'name': 'rect', 'x': 0, 'y': 0, 'width': 21, 'height': 21, 'transform': "translate(0,0)", 'fill': backgroundColor, 'opacity': opacity };
                pathOptions[1] = {
                    'name': 'path',
                    'd': 'M15.913,18.59L10.762 12.842 5.613 18.75 8.291 11.422 0.325 9.91 8.154 8.33 5.337 0.91 10.488 6.658 15.637 0.75 12.959 8.078 20.925 9.59 13.096 11.17 z',
                    'stroke-width': 1,
                    'stroke': color,
                    'fill': color
                };
                this.loadPattern(chart, pathOptions, pattern);
                svg.appendChild(pattern);
                return "url(#" + style + "_" + name + "_" + colorStyle.name + "_" + colorStyle.index + ")";
                break;
            case "triangle":
                var patternGroup = { 'id': style + "_" + name + "_" + colorStyle.name + "_" + colorStyle.index, 'patternUnits': 'userSpaceOnUse', 'width': '10', 'height': '10' }
                var pattern = chart.svgRenderer.createPattern(patternGroup, 'pattern');
                pathOptions[0] = { 'name': 'rect', 'x': 0, 'y': 0, 'width': 10, 'height': 10, 'transform': "translate(0,0)", 'fill': backgroundColor, 'opacity': opacity };
                pathOptions[1] = {
                    'name': 'path',
                    'd': 'M4.987,0L7.48 4.847 9.974 9.694 4.987 9.694 0 9.694 2.493 4.847 z',
                    'stroke-width': 1,
                    'stroke': color,
                    'fill': color
                };
                this.loadPattern(chart, pathOptions, pattern);
                svg.appendChild(pattern);
                return "url(#" + style + "_" + name + "_" + colorStyle.name + "_" + colorStyle.index + ")";
                break;
            case "circle":
                var patternGroup = { 'id': style + "_" + name + "_" + colorStyle.name + "_" + colorStyle.index, 'patternUnits': 'userSpaceOnUse', 'width': '9', 'height': '9' }
                var pattern = chart.svgRenderer.createPattern(patternGroup, 'pattern');
                pathOptions[0] = { 'name': 'rect', 'x': 0, 'y': 0, 'width': 9, 'height': 9, 'transform': "translate(0,0)", 'fill': backgroundColor, 'opacity': opacity };
                pathOptions[1] = {
                    'name': 'circle',
                    'cx': 5.125,
                    'cy': 3.875,
                    'r': 3.625,
                    'stroke-width': 1,
                    'fill': color
                };
                this.loadPattern(chart, pathOptions, pattern);
                svg.appendChild(pattern);
                return "url(#" + style + "_" + name + "_" + colorStyle.name + "_" + colorStyle.index + ")";
                break;
            case "tile":
                var patternGroup = { 'id': style + "_" + name + "_" + colorStyle.name + "_" + colorStyle.index, 'patternUnits': 'userSpaceOnUse', 'width': '18', 'height': '18' }
                var pattern = chart.svgRenderer.createPattern(patternGroup, 'pattern');
                pathOptions[0] = { 'name': 'rect', 'x': 0, 'y': 0, 'width': 18, 'height': 18, 'transform': "translate(0,0)", 'fill': backgroundColor, 'opacity': opacity };
                pathOptions[1] = { 'name': 'path', 'd': 'M0,9L0 0 9 0 z', 'stroke-width': 1, 'stroke': color, 'fill': color };
                pathOptions[2] = { 'name': 'path', 'd': 'M9,9L9 0 18 0 z', 'stroke-width': 1, 'stroke': color, 'fill': color };
                pathOptions[3] = { 'name': 'path', 'd': 'M0,18L0 9 9 9 z', 'stroke-width': 1, 'stroke': color, 'fill': color };
                pathOptions[4] = { 'name': 'path', 'd': 'M9,18L9 9 18 9 z', 'stroke-width': 1, 'stroke': color, 'fill': color };
                this.loadPattern(chart, pathOptions, pattern);
                svg.appendChild(pattern);
                return "url(#" + style + "_" + name + "_" + colorStyle.name + "_" + colorStyle.index + ")";
                break;
            case "horizontaldash":
                var patternGroup = { 'id': style + "_" + name + "_" + colorStyle.name + "_" + colorStyle.index, 'patternUnits': 'userSpaceOnUse', 'width': '12', 'height': '12' }
                var pattern = chart.svgRenderer.createPattern(patternGroup, 'pattern');
                pathOptions[0] = { 'name': 'rect', 'x': 0, 'y': 0, 'width': 12, 'height': 12, 'transform': "translate(0,0)", 'fill': backgroundColor, 'opacity': opacity };
                pathOptions[1] = { 'name': 'path', 'd': 'M0,1.5 L10 1.5 M0,5.5 L10 5.5 M0,9.5 L10 9.5 z', 'stroke-width': 1, 'stroke': color, 'fill': color };
                this.loadPattern(chart, pathOptions, pattern);
                svg.appendChild(pattern);
                return "url(#" + style + "_" + name + "_" + colorStyle.name + "_" + colorStyle.index + ")";
                break;
            case "verticaldash":
                var patternGroup = { 'id': style + "_" + name + "_" + colorStyle.name + "_" + colorStyle.index, 'patternUnits': 'userSpaceOnUse', 'width': '12', 'height': '12' }
                var pattern = chart.svgRenderer.createPattern(patternGroup, 'pattern');
                pathOptions[0] = { 'name': 'rect', 'x': 0, 'y': 0, 'width': 12, 'height': 12, 'transform': "translate(0,0)", 'fill': backgroundColor, 'opacity': opacity };
                pathOptions[1] = { 'name': 'path', 'd': 'M1.5,0 L1.5 10 M5.5,0 L5.5 10 M9.5,0 L9.5 10 z', 'stroke-width': 1, 'stroke': color, 'fill': color };
                this.loadPattern(chart, pathOptions, pattern);
                svg.appendChild(pattern);
                return "url(#" + style + "_" + name + "_" + colorStyle.name + "_" + colorStyle.index + ")";
                break;
            case "rectangle":
                var patternGroup = { 'id': style + "_" + name + "_" + colorStyle.name + "_" + colorStyle.index, 'patternUnits': 'userSpaceOnUse', 'x': 0, 'y': 0, 'width': 12, 'height': 12 }
                var pattern = chart.svgRenderer.createPattern(patternGroup, 'pattern');
                pathOptions[0] = { 'name': 'rect', 'width': 12, 'height': 12, 'fill': backgroundColor, 'opacity': opacity };
                pathOptions[1] = { 'name': 'rect', 'x': 1, 'y': 2, 'width': 4, 'height': 9, 'fill': color, 'opacity': opacity };
                pathOptions[2] = { 'name': 'rect', 'x': 7, 'y': 2, 'width': 4, 'height': 9, 'fill': color, 'opacity': opacity };
                this.loadPattern(chart, pathOptions, pattern);
                svg.appendChild(pattern);
                return "url(#" + style + "_" + name + "_" + colorStyle.name + "_" + colorStyle.index + ")";
                break;
            case "box":
                var patternGroup = { 'id': style + "_" + name + "_" + colorStyle.name + "_" + colorStyle.index, 'patternUnits': 'userSpaceOnUse', 'x': 0, 'y': 0, 'width': 10, 'height': 10 }
                var pattern = chart.svgRenderer.createPattern(patternGroup, 'pattern');
                pathOptions[0] = { 'name': 'rect', 'width': 13, 'height': 13, 'fill': backgroundColor, 'opacity': opacity };
                pathOptions[1] = { 'name': 'rect', 'x': 1.5, 'y': 1.5, 'width': 10, 'height': 9, 'fill': color, 'opacity': opacity };
                this.loadPattern(chart, pathOptions, pattern);
                svg.appendChild(pattern);
                return "url(#" + style + "_" + name + "_" + colorStyle.name + "_" + colorStyle.index + ")";
                break;
            case "horizontalstripe":
                var patternGroup = { 'id': style + "_" + name + "_" + colorStyle.name + "_" + colorStyle.index, 'patternUnits': 'userSpaceOnUse', 'width': '10', 'height': '12' }
                var pattern = chart.svgRenderer.createPattern(patternGroup, 'pattern');
                pathOptions[0] = { 'name': 'rect', 'x': 0, 'y': 0, 'width': 10, 'height': 12, 'transform': "translate(0,0)", 'fill': backgroundColor, 'opacity': opacity };
                pathOptions[1] = { 'name': 'path', 'd': 'M0,0.5 L10 0.5 M0,4.5 L10 4.5 M0,8.5 L10 8.5 z', 'stroke-width': 1, 'stroke': color, 'fill': color };
                this.loadPattern(chart, pathOptions, pattern);
                svg.appendChild(pattern);
                return "url(#" + style + "_" + name + "_" + colorStyle.name + "_" + colorStyle.index + ")";
                break;
            case "verticalstripe":
                var patternGroup = { 'id': style + "_" + name + "_" + colorStyle.name + "_" + colorStyle.index, 'patternUnits': 'userSpaceOnUse', 'width': '12', 'height': '10' }
                var pattern = chart.svgRenderer.createPattern(patternGroup, 'pattern');
                pathOptions[0] = { 'name': 'rect', 'x': 0, 'y': 0, 'width': 12, 'height': 10, 'transform': "translate(0,0)", 'fill': backgroundColor, 'opacity': opacity };
                pathOptions[1] = { 'name': 'path', 'd': 'M0.5,0 L0.5 10 M4.5,0 L4.5 10 M8.5,0 L8.5 10 z', 'stroke-width': 1, 'stroke': color, 'fill': color };
                this.loadPattern(chart, pathOptions, pattern);
                svg.appendChild(pattern);
                return "url(#" + style + "_" + name + "_" + colorStyle.name + "_" + colorStyle.index + ")";
                break;
            case "bubble":
                var patternGroup = { 'id': style + "_" + name + "_" + colorStyle.name + "_" + colorStyle.index, 'patternUnits': 'userSpaceOnUse', 'width': '20', 'height': '20' }
                var pattern = chart.svgRenderer.createPattern(patternGroup, 'pattern');
                pathOptions[0] = {'name':'rect', 'x': 0, 'y': 0, 'width': 20, 'height': 20, 'transform': "translate(0,0)", 'fill': backgroundColor, 'opacity': opacity };
                pathOptions[1] = { 'name': 'circle', 'cx': 5.217, 'cy': 11.325, 'r': 3.429, 'stroke-width': 1, 'fill': '#D0A6D1' };
                pathOptions[2] = { 'name': 'circle', 'cx': 13.328, 'cy': 6.24, 'r': 4.884, 'stroke-width': 1, 'fill': color };
                pathOptions[3] = { 'name': 'circle', 'cx': 13.277, 'cy': 14.66, 'r': 3.018, 'stroke-width': 1, 'fill': '#D0A6D1' };
                this.loadPattern(chart, pathOptions, pattern);
                svg.appendChild(pattern);
                return "url(#" + style + "_" + name + "_" + colorStyle.name + "_" + colorStyle.index + ")";
                break;
             case "custom":
                return "url(#" + hoverStyle.customPattern + ")"
                break;
        }

    },
	loadPattern: function (chart, options, pattern, ctx) {
        var path;
        for (var i = 0; i < options.length; i++) {
            if (!ctx) {
                path = chart.svgRenderer.createPattern(options[i], options[i].name);
                pattern.appendChild(path);
            } else {
                if (options[i].name == 'rect'){
					options[i].stroke = 'transparent';
					this.drawRect(options[i], ctx);
				}
                else if (options[i].name == 'path')
                    BoldBIDashboard.EjCanvasRender.prototype.drawPath(options[i], ctx);
                else if(options[i].name == 'circle'){
					options[i].stroke = 'transparent';
					BoldBIDashboard.EjCanvasRender.prototype.drawCircle(options[i], ctx);
				}
            }
        }
    },
	drawRect: function (options, element) {
        element.save();
        element.beginPath();
        element.globalAlpha = options.opacity;
        element.lineWidth = options["stroke-width"];
        element.strokeStyle = options.stroke;
	    element.rect(options.x, options.y, options.width, options.height);
        if (options.fill == "none") options.fill = "transparent";
        element.fillStyle = options.fill;
        if (options.transform) element.translate(options.transform[0], options.transform[1]);
        element.rotate(options.rotate * Math.PI / 180);        
        element.fillRect(options.x, options.y, options.width, options.height);
        element.clip();
        element.stroke();
        element.restore();
    },
     // pattern of the SVG end
     // SVG highlight and selection end

    tooltip: function (chart, evt) {
        var tooltipShowing = false;
        var chartSeries;
        var seriesIndex;
        var data = this.GetSeriesPoint(evt);
        var isCanvas = this.model.enableCanvasRendering;
        bbdesigner$("#" + "canvas" + "_trackSymbol").remove();
		if (BoldBIDashboard.util.isNullOrUndefined(data)) { // To hide the tooltip when it is moved on chartArea other than series
             bbdesigner$("#" + chart.svgObject.id + "_TrackToolTip").remove();
            //Removing tooltip Template when mouse is moved on chart area other than series
            bbdesigner$(".tooltipDiv").remove();
		}	
		if (!this.model.crosshair.visible && this.model.AreaType == "cartesianaxes") {
		    var indicators = this.model.indicators,
		    seriesCollection = this.model._visibleSeries,
		    currentIndicator, l, k, trendLines,
		    length = seriesCollection.length;
		    for (k = 0; k < length; k++) {
		        trendLines = seriesCollection[k].trendlines;
		        for (l = 0; l < trendLines.length; l++) {
		            if (trendLines[l].visibility.toLowerCase() == "visible" && !trendLines[l].isNull) {
						trendLines[l]._visiblePoints = trendLines[l].points;
		                seriesCollection = seriesCollection.concat(trendLines[l]);
		            }
		        }
		    }

		    for (var j = 0; j < indicators.length && indicators[j].segment; j++) {
			    currentIndicator = indicators[j]; 
			    if (currentIndicator.visible)
			        seriesCollection = seriesCollection.concat(currentIndicator.segment);
			    }
		    var seriesCollectionLength = seriesCollection.length;
		    for (var i = 0; i < seriesCollectionLength ; i++) {
		        chartSeries = seriesCollection[i];
                seriesIndex = i;
		        chartSeries.seriesIndex = seriesIndex;
				
				var type = chartSeries.type.toLowerCase();		
				if (chartSeries.visibility.toLowerCase() == 'visible' && type !== "scatter" && type !== "bubble" && type !== "column" && (type.indexOf("bar")==-1) && type !== "stackingcolumn" && type !== "stackingcolumn100" && !chartSeries._hiloTypes) {
                    bbdesigner$("#" + chart.svgObject.id + "_TrackToolTipTemplate_" + seriesIndex).remove();
                    if (!(bbdesigner$(".tooltipDiv").hasClass(chart.svgObject.id)))
                        bbdesigner$(".tooltipDiv").remove();
                    bbdesigner$("#" + chart.svgObject.id).find("#" + chart.svgObject.id + "_TrackSymbol" + '_' + seriesIndex).remove();
                    bbdesigner$('#' + chart.svgObject.id + '_TrackSymbol' + '_' + seriesIndex).remove();
                    var serY = [];
                    var serX = [];
                    location = null;
                    var closestXyPoint = chart.getClosesPointXY(serX, serY, chartSeries, chart.mousemoveX, chart.mousemoveY, evt);
                    if (closestXyPoint.point) {
                        location = BoldBIDashboard.EjSvgRender.utils._getPoint(closestXyPoint.point, chartSeries);
                        var commonPointEventArgs = bbdesigner$.extend({}, BoldBIDashboard.EjSvgRender.commonChartEventArgs);
                        commonPointEventArgs.data = { location: { x: this.mousemoveX, y: this.mousemoveX }, region: { SeriesIndex: i, Region: { PointIndex: closestXyPoint.index } } };
                        chart._trigger("pointRegionMouseMove", commonPointEventArgs);
                    }
                    var pointData = this.model.prevPoint;
                    if (pointData && pointData.seriesIndex == i && !closestXyPoint.point) {
                        var pointLocation = BoldBIDashboard.EjSvgRender.utils._getPoint(pointData.point, pointData.series);
                        chart.drawTrackerSymbol(pointData.series, pointData.seriesIndex, pointData.pointIndex, null, pointLocation);
                        this.model.prevPoint = null;
                    }
                    
                    if (!chartSeries.isIndicator && !chartSeries.isTrendLine && !chartSeries.selectionSettings.enable && !chartSeries.highlightSettings.enable && chartSeries.marker.visible && closestXyPoint.point && !commonPointEventArgs.cancel) {
                        if (BoldBIDashboard.util.isNullOrUndefined(closestXyPoint.point.marker) || BoldBIDashboard.util.isNullOrUndefined(closestXyPoint.point.marker.visible) || (closestXyPoint.point.marker && closestXyPoint.point.marker.visible))
                        chart.drawTrackerSymbol(chartSeries, seriesIndex, closestXyPoint.index, false, location);

                        if (pointData && closestXyPoint.point != pointData.point){
                            var prevLocation = BoldBIDashboard.EjSvgRender.utils._getPoint(pointData.point, pointData.series);
                            chart.drawTrackerSymbol(pointData.series, pointData.seriesIndex, pointData.pointIndex, null, prevLocation, id);
                        }
                        if (BoldBIDashboard.util.isNullOrUndefined(closestXyPoint.point.marker) || BoldBIDashboard.util.isNullOrUndefined(closestXyPoint.point.marker.visible) || (closestXyPoint.point.marker && closestXyPoint.point.marker.visible))
                        this.model.prevPoint = { point: closestXyPoint.point, pointIndex: closestXyPoint.index, series: chartSeries, seriesIndex: seriesIndex };
                    }


                    if (chartSeries.tooltip.visible && (closestXyPoint.point) && (!data || (i > data.region.SeriesIndex && !(chartSeries._zOrder < this.model._visibleSeries[data.region.SeriesIndex]._zOrder)))) {
                        trans = BoldBIDashboard.EjSvgRender.utils._getTransform(chartSeries.xAxis, chartSeries.yAxis, chart.model.requireInvertedAxes);
                        if(chart.model.AreaType == "cartesianaxes")
                        var chartArea = document.getElementById(this.svgObject.id + "_ChartArea").getBoundingClientRect();
                        transX = !isCanvas ? evt.originalEvent.clientX : trans.x;
                        transY = !isCanvas ? evt.originalEvent.clientY : trans.y;
                        transWidth = !isCanvas? chartArea.width:trans.width;
                        transHeight = !isCanvas ? chartArea.height : trans.height;
                        locX = !isCanvas ? evt.originalEvent.clientX : location.X;
                        locY = !isCanvas ? evt.originalEvent.clientY : location.Y;
                        if (((locX) <= (transX + transWidth) && ((locX) >= transX || locX == 0) && (Math.abs(locY) <= (transY + transHeight))
                                     && (Math.abs(locY) >= transY || locY == 0))) {                         
                            if (!commonPointEventArgs.cancel) {
                                if (bbdesigner$(chart.svgObject).find("#" + chart.svgObject.id + "_TrackToolTip").length == 0) {
                                    var transOptions = { 'id': chart.svgObject.id + '_TrackToolTip', 'transform': 'translate(' + transX + ',' + transY + ')' };
                                    chart.gTransToolEle = chart.svgRenderer.createGroup(transOptions);
                                }
                                chart.svgRenderer._setAttr(bbdesigner$(chart.svgObject).find("#" + chart.svgObject.id + "_TrackToolTip"), { 'transform': 'translate(' + transX + ',' + transY + ')', 'visibility': 'visible' });
                                if (BoldBIDashboard.util.isNullOrUndefined(chartSeries.tooltip.template)) {
                                    tooltipShowing = true;
                                    bbdesigner$(".tooltipDiv").remove();
                                    location.X = locX;
                                    location.Y = locY;                                   
                                    chart.displayShowTooltip(location, closestXyPoint.point, chartSeries, closestXyPoint.index);
                                }
                                else {
                                    tooltipShowing = true;
                                    bbdesigner$("#" + chart.svgObject.id).find("#" + chart.svgObject.id + "_TrackToolTip").attr('visibility', 'hidden');
                                    var region = { SeriesIndex: seriesIndex, Region: { PointIndex: closestXyPoint.index } };
                                    chart.createTooltip(region, evt, chartSeries);
                                }

                                //Comment the below code for VML -The line series tooltip color not displayed due to attach and detach the element to DOM
                                // var detachEle = bbdesigner$(chart.svgObject).find("#" + chart.svgObject.id + "_TrackToolTip").detach();
                                //detachEle.appendTo(chart.svgObject);
                            }
                           
                        }
                    }
                }
            }
        }
	   else {
            bbdesigner$("#" + this.svgObject.id).find("#" + this.svgObject.id + "_TrackToolTip").hide();
        }
       
        if (!(bbdesigner$(".tooltipDiv").hasClass(this.svgObject.id)))
            bbdesigner$(".tooltipDiv").remove();
        if (data && BoldBIDashboard.util.isNullOrUndefined(data.region.isStripLine)) {
            var seriesType = this.model._visibleSeries[data.region.SeriesIndex].type.toLowerCase();
            if ((seriesType == "pie" || seriesType == "doughnut") && this.model._visibleSeries[data.region.SeriesIndex].explode) {
                if (this.model._visibleSeries[data.region.SeriesIndex].enableAnimation && (!this.model.enable3D)) {
                    if (this.model.AnimationComplete || this.model.enableCanvasRendering)
                        this.pieExplosion(data, evt);
                }
                else if(!this.model.enable3D)
                    this.pieExplosion(data, evt);
            }
            if (data.region.isIndicator) {
                series = this.model.indicators[data.region.SeriesIndex];
                var seriesPoint = series.segment[0]._visiblePoints[data.region.Region.PointIndex];
                series.fill = series.segment[0].fill;
            } else {
                series = this.model._visibleSeries[data.region.SeriesIndex];
                for (var v = 0; v < series._visiblePoints.length; v++) {
                    if (data.region.Region.PointIndex == series._visiblePoints[v].actualIndex) {
                        var seriesPoint = this.model._visibleSeries[data.region.SeriesIndex]._visiblePoints[v];
                        break;
                    }
                }
            }

            if (seriesPoint && this.model.AreaType=='polaraxes') {
                for (var i = 0; i < this.model._visibleSeries.length; i++) {
                    bbdesigner$("[id*=" + "_TrackSymbol" + "]").remove();
                    var trackId = "canvas_trackSymbol_" + i;
                    bbdesigner$("#" + this._id).find('[id*=' + trackId + ']').remove();
                }
                var pointlocation = (this.model.AreaType != "polaraxes")
                    ? BoldBIDashboard.EjSvgRender.utils._getPoint(seriesPoint, series)
                    : (BoldBIDashboard.EjSvgRender.utils.TransformToVisible(series, seriesPoint.xValue, seriesPoint.y, this))
                    var prevPoint = this.model.prevPoint;
                    if (!BoldBIDashboard.util.isNullOrUndefined(prevPoint) && prevPoint!= data && series.marker.visible)
                    {
                        series = this.model._visibleSeries[prevPoint.region.SeriesIndex];
                        seriesPoint = this.model._visibleSeries[prevPoint.region.SeriesIndex]._visiblePoints[prevPoint.region.Region.PointIndex];
                        pointlocation = BoldBIDashboard.EjSvgRender.utils.TransformToVisible(series, seriesPoint.xValue, seriesPoint.y, this);
                        this.drawTrackerSymbol(series, prevPoint.region.SeriesIndex, prevPoint.region.Region.PointIndex, null, pointlocation);
                        this.model.prevPoint = null;
                    }
                    if (series.marker.visible && series.drawType.toLowerCase() != "column") {
                        this.drawTrackerSymbol(series, data.region.SeriesIndex, data.region.Region.PointIndex, true, pointlocation);
                        this.model.prevPoint = data;                        
                    }
            }

            if (series.tooltip.visible && !tooltipShowing) {

                if (series.visibility.toLowerCase() == 'visible') {
                    if (BoldBIDashboard.util.isNullOrUndefined(series.tooltip.template)) {
                        var location;
                        if (this.model.AreaType == "cartesianaxes") {

                            var trans = BoldBIDashboard.EjSvgRender.utils._getTransform(series.xAxis, series.yAxis, this.model.requireInvertedAxes);
                            if (bbdesigner$(this.svgObject).find("#" + this.svgObject.id + "_TrackToolTip").length == 0) {
                                var transToolOptions = { 'id': this.svgObject.id + '_TrackToolTip', 'transform': 'translate(' + trans.x + ',' + trans.y + ')' };
                                this.gTransToolEle = this.svgRenderer.createGroup(transToolOptions);
                            }
                            this.svgRenderer._setAttr(bbdesigner$(this.svgObject).find("#" + this.svgObject.id + "_TrackToolTip"), { 'transform': 'translate(' + trans.x + ',' + trans.y + ')' });
                            bbdesigner$('#' + this.svgObject.id + "_TrackToolTip").attr("visibility", "visible");
                            var isCanvas = this.model.enableCanvasRendering;
                            location = { X: !isCanvas ? evt.originalEvent.clientX : (data.location.x - this.model.m_AreaBounds.X), Y: !isCanvas ? evt.originalEvent.clientY :Math.abs(data.location.y - (this.model.m_AreaBounds.Y)) };
                        } else {
                            if (bbdesigner$(this.svgObject).find("#" + this.svgObject.id + "_TrackToolTip").length == 0) {
                                var transToolTipOptions = { 'id': this.svgObject.id + '_TrackToolTip' };
                                this.gTransToolEle = this.svgRenderer.createGroup(transToolTipOptions);
                            }
                            location = { X: (data.location.x), Y: Math.abs(data.location.y) };
                        }


                         bbdesigner$(".tooltipDiv").remove();
                        this.displayShowTooltip(location, seriesPoint, series, data.region.Region.PointIndex);
                            
                        //Comment the below code for VML -The line series tooltip color not displayed due to attach and detach the element to DOM
                        // if (series.type.toLowerCase() == "bubble" || series.type.toLowerCase() == "scatter") {
                        //     var detachEle = bbdesigner$(this.svgObject).find("#" + this.svgObject.id + "_TrackToolTip").detach();
                        //    detachEle.appendTo(this.svgObject);
                        // }
                    } else {
                        bbdesigner$("#" + chart.svgObject.id).find("#" + chart.svgObject.id + "_TrackToolTip").attr('visibility', 'hidden');
                        this.createTooltip(data.region, evt);
                    }
                }
            }
            var commonEventArgs = bbdesigner$.extend({}, BoldBIDashboard.EjSvgRender.commonChartEventArgs);
            commonEventArgs.data = data;
            this._trigger("pointRegionMouseMove", commonEventArgs);
        }
		else if (!BoldBIDashboard.util.isNullOrUndefined(this.model.prevPoint)&& this.model.AreaType == "polaraxes") {
            var prevPoint = this.model.prevPoint;
            series = this.model._visibleSeries[prevPoint.region.SeriesIndex];
            seriesPoint = this.model._visibleSeries[prevPoint.region.SeriesIndex]._visiblePoints[prevPoint.region.Region.PointIndex];
            pointlocation = BoldBIDashboard.EjSvgRender.utils.TransformToVisible(series, seriesPoint.xValue, seriesPoint.y, this);
            this.drawTrackerSymbol(series, prevPoint.region.SeriesIndex, prevPoint.region.Region.PointIndex, null, pointlocation);
            this.model.prevPoint = null;
        }
        else {
            if (!BoldBIDashboard.util.isNullOrUndefined(this.model.explodeValue)) {
                var type = this.model.series[this.model.explodeValue.SeriesIndex].type.toLowerCase();
                var series = this.model._visibleSeries[this.model.explodeValue.SeriesIndex];
                    var seriesType = new BoldBIDashboard.seriesTypes[type]();
                    var targetElement;
                    var id;
                    var _labelPosition = series.labelPosition.toLowerCase();
                    var seriesIndex = this.model.explodeValue.SeriesIndex;
                    var result = seriesType._calculateArcData(this, this.model.explodeValue.Index, series._visiblePoints[this.model.explodeValue.Index], series,seriesIndex);
                    if (this.model.enableCanvasRendering) {
                        this.model.series[seriesIndex].explodeIndex = null;
                        var chartRect = document.getElementById(this.svgObject.id).getClientRects()[0];
                        this.svgRenderer.ctx.clearRect(chartRect.left, chartRect.top, chartRect.width, chartRect.height);
                        bbdesigner$("#" + this._id).BoldBIDashboardChart("redraw");
                    }
                    id = this.svgObject.id + '_SeriesGroup' + '_'+seriesIndex;
                    targetElement = bbdesigner$(this.gSeriesEle).children('#' + id)[0];
                    var elements = bbdesigner$(targetElement).children();
                    for (var i = 0; i < elements.length; i++) {
                        var element = elements[i];
                        var index = this.svgRenderer._getAttrVal(bbdesigner$(element)[0], "pointIndex");
                        if (parseInt(index) == this.model.explodeValue.PointIndex) {
                            this.svgRenderer._setAttr(bbdesigner$(element), { 'd': result.Direction });
                            break;
                        }
                    }

                    this.model.explodeOut = true;
                    seriesType.drawDataLabelAcc(this, series, this.model.explodeValue.Index, series._visiblePoints[this.model.explodeValue.Index], seriesIndex);
                    this.model.explodeValue = null;
                    this.model.explode = false;
                    this.model.explodeOut = false;
            }
        }
    },

    chartCrossHair: function (chart, mouseLocation) {
       var requireInvertedAxes = chart.model.requireInvertedAxes, point, seriesIndex, series, dir, indicators = this.model.indicators, seriesCollection = this.model._visibleSeries, showTrackLine = false, seriesIndex, serX, insideBounds, closestPoint, visibleRange, chartPos, pathOptions, leftPos, topPos, chartAreaStartPos, chartAreaEndPos, pointPos, crossHairTrans, tToolOptions, prePoint, initialPoint, rectxt, tooltipfont, textarea,tgap=0, currentLength, tX, tY, chartLocation, element, visiblepts = [], tooltipRanges = [], DisplayTooltipOptions = [], totalVisible = 0,maxWidth=0,heightwidth=0;
        if ((!this.model.enable3D) && this.model.crosshair.visible && this.model.crosshair.type.toLowerCase()=="trackball") {
            //Hiding previous trackball and tooltip when moving from one column to another
            bbdesigner$("#secondCanvas").remove(), bbdesigner$("#" + this._id).find('[id*="_gTooltip_"]').remove();
            if (this.model.enableCanvasRendering) {
                bbdesigner$("#" + this._id).find('[id*="canvas_trackSymbol"]').css("visibility", "hidden");
            }
            else {                
                element = bbdesigner$(this.svgObject).find('[id*="_TrackToolTip"]');
                this.svgRenderer._setAttr(bbdesigner$(element), { "visibility": 'hidden' });
                element = bbdesigner$(this.svgObject).find('[id*="_TrackToolTip"]').children();
                this.svgRenderer._setAttr(bbdesigner$(element), { "visibility": 'hidden' });
                bbdesigner$(element).css({ 'visibility': 'hidden' });
                element = bbdesigner$(this.svgObject).find('[id*="_trackSymbol_"]');
                this.svgRenderer._setAttr(bbdesigner$(element), { "visibility": 'hidden' });
            }
            for (var j = 0; j < indicators.length && indicators[j].segment; j++) {
                seriesCollection = seriesCollection.concat(indicators[j].segment);
            }
           for (var i = 0; i < seriesCollection.length; i++) {
                if (seriesCollection[i].visibility == "visible") {
                    seriesIndex = i;
                     serX = [];
            
                    if (!requireInvertedAxes)
                        insideBounds = chart.mousemoveX > seriesCollection[i].xAxis.x && chart.mousemoveX < seriesCollection[i].xAxis.x + seriesCollection[i].xAxis.width;
                    else
                        insideBounds = chart.mousemoveY > seriesCollection[i].xAxis.y && chart.mousemoveY < seriesCollection[i].xAxis.y + seriesCollection[i].xAxis.height;
                    if (this.model.enableCanvasRendering)
                        this.canvasX = seriesCollection[i].xAxis.x;
                     closestPoint = chart.getClosestPointX(serX, seriesCollection[i], chart.mousemoveX, chart.mousemoveY);
                     visibleRange = seriesCollection[i].xAxis.visibleRange;   // condition to check the closestPoint is inside the visible range
                    if (closestPoint.point != "" &&(closestPoint.point[0].YValues[0] >= seriesCollection[i].yAxis.visibleRange.min) && (closestPoint.point[0].xValue >= visibleRange.min) && (closestPoint.point[0].xValue <= visibleRange.max)) {
                        if (insideBounds) {
                            for (var t = 0; t < closestPoint.point.length; t++) {
                                if (closestPoint.point[t].visible) {
                                    if (!seriesCollection[i].isIndicator) {
                                        totalVisible++;
                                    }
                                }
                            }
                        }
                    }
                }

           }
            for (var i = 0; i < seriesCollection.length; i++) {
			 //   if(seriesCollection[0].xAxis.name == seriesCollection[i].xAxis.name)
                seriesIndex = i;
                series = seriesCollection[i];
                if (series.visibility.toLowerCase() == 'visible') {
                    serX = [];
                    if (!requireInvertedAxes)
                        insideBounds = chart.mousemoveX > series.xAxis.x && chart.mousemoveX < series.xAxis.x + series.xAxis.width;                    
                    else
                        insideBounds = chart.mousemoveY > series.xAxis.y && chart.mousemoveY < series.xAxis.y + series.xAxis.height;
                    if(this.model.enableCanvasRendering)
                        this.canvasX = series.xAxis.x;
                    closestPoint = chart.getClosestPointX(serX, series, chart.mousemoveX, chart.mousemoveY);
				    visibleRange = series.xAxis.visibleRange;   // condition to check the closestPoint is inside the visible range
				    if (closestPoint.point != "" && (closestPoint.point[0].YValues[0] >= series.yAxis.visibleRange.min) && (closestPoint.point[0].xValue >= visibleRange.min) && (closestPoint.point[0].xValue <= visibleRange.max)) {						
                        if (insideBounds) {
                          for (var t = 0; t < closestPoint.point.length; t++) {
                              if (closestPoint.point[t].visible) {
                                  if (!series.isIndicator) {
                                  if (requireInvertedAxes) {
                                      point = BoldBIDashboard.EjSvgRender.utils._getPoint(closestPoint.point[t], series);
                                      dir = "M" + " " + (series.yAxis.x) + " " + (point.Y + series.xAxis.y) + " " + "L" + " " + (series.yAxis.x + series.yAxis.width) + " " + (point.Y + series.xAxis.y);
                                          visiblepts.push({ X: (closestPoint.point[t].location.X + series.yAxis.x), Y: (closestPoint.point[t].location.Y + series.xAxis.y) });
                                  }
                                  else {
                                      point = BoldBIDashboard.EjSvgRender.utils._getPoint(closestPoint.point[t], series);
                                          dir = "M" + " " + (point.X + series.xAxis.x) + " " + (chart.model.m_AreaBounds.Y) + " " + "L" + " " + (point.X + series.xAxis.x) + " " + (chart.model.m_AreaBounds.Y + chart.model.m_AreaBounds.Height);
                                          visiblepts.push({ X: (closestPoint.point[t].location.X + series.xAxis.x), Y: (closestPoint.point[t].location.Y + series.yAxis.y) });
                                  }
                                
                                      chartPos = { left: chart.svgObject.offsetLeft, top: chart.svgObject.offsetTop };

                                      pathOptions = {
                                    'id': chart.svgObject.id + "_Tracker",
                                    'fill': 'none',
                                    'stroke-width': chart.model.crosshair.line.width,
                                    'clip-path': 'url(#' + chart.svgObject.id + '_ChartAreaClipRect)',
                                    'stroke': chart.model.crosshair.line.color,
                                    'd': dir
                                };
                                if (bbdesigner$("#" + chart.svgObject.id + "_Tracker").length == 0) {
                                    if (!chart.model.enableCanvasRendering) {
                                        chart.svgRenderer.drawPath(pathOptions, chart.svgObject);
                                        showTrackLine = true;
                                    }
                                    else {
                                        pathOptions.width = (requireInvertedAxes) ? this.model.m_AreaBounds.Width : 0,
                                        pathOptions.height = (requireInvertedAxes) ? 0 : this.model.m_AreaBounds.Height,
                                        pathOptions.top = this.model.m_AreaBounds.Y + chartPos.top,
                                        pathOptions.left = this.model.m_AreaBounds.X + chartPos.left,
                                        chart.svgRenderer.drawCrosshairLine(pathOptions, chart.svgObject);
                                    }
                                }
                                else {
								    showTrackLine = true;
                                    chart.svgRenderer._setAttr(bbdesigner$(chart.svgObject).find("#" + chart.svgObject.id + "_Tracker"), { "d": dir });
                                    if (chart.model.enableCanvasRendering) {
										 if (requireInvertedAxes) {
                                                  chartAreaStartPos = chartPos.top + series.xAxis.y + bbdesigner$(document).scrollTop();
                                                  chartAreaEndPos = series.xAxis.height + chartPos.top + series.xAxis.y + bbdesigner$(document).scrollTop();
                                                  pointPos = point.Y + series.xAxis.y + chartPos.top + bbdesigner$(document).scrollTop();
                                              //Condition checked whether trackball line position is within the chartArea
                                              topPos = (pointPos < chartAreaEndPos && pointPos > chartAreaStartPos) ? pointPos : pointPos >= chartAreaEndPos ? chartAreaEndPos : chartAreaStartPos;//check trackball line within the chartArea
                                              +bbdesigner$("#" + chart.svgObject.id + "_Tracker").css("top", topPos);
                                         }
                                         else {
                                                  chartAreaStartPos = chartPos.left + series.xAxis.x;
                                                  chartAreaEndPos = series.xAxis.width + chartPos.left + series.xAxis.x;
                                                  pointPos = point.X + series.xAxis.x + chartPos.left;
                                             //Condition checked whether trackball line position is within the chartArea
                                                  leftPos = (pointPos <= chartAreaEndPos && pointPos > chartAreaStartPos) ? pointPos : pointPos > chartAreaEndPos ? chartAreaEndPos : chartAreaStartPos;//check trackball line within the chartArea
                                             bbdesigner$("#" + chart.svgObject.id + "_Tracker").css("left", leftPos);
										  }
                                    }
                                    bbdesigner$("#" + this._id).find('[id*="canvas_Tracker"]').css("visibility", "visible");
                                }

                                      crossHairTrans = BoldBIDashboard.EjSvgRender.utils._getTransform(series.xAxis, series.yAxis, requireInvertedAxes);
                                      tToolOptions = { 'transform': 'translate(' + crossHairTrans.x + ',' + crossHairTrans.y + ')', 'id': chart.svgObject.id + '_TrackToolTip' + '_' + seriesIndex };
                                chart.gTransToolEle = chart.svgRenderer.createGroup(tToolOptions);
                                      prePoint = this.model.prePoint;

                                //To check the current closestPoint and previous point is same
                                if (BoldBIDashboard.util.isNullOrUndefined(prePoint) || prePoint.pointIndex[0] != closestPoint.index[0] || !bbdesigner$('#' + chart.svgObject.id + "_trackSymbol_" + seriesIndex + '_' + closestPoint.index)) {

                                    //Remove the track elements only once on point change
                                    if (BoldBIDashboard.util.isNullOrUndefined(initialPoint)) {
                                        if (this.model.crosshair.tooltipTemplate != null) {
                                            bbdesigner$(document).find('[id*="_TrackToolTipTemplate_"]').attr("visibility", "hidden");
                                        }
                                        if (chart.gTransToolEle && chart.gTrackerEle) {
                                            bbdesigner$(this.svgObject).find('[id*="_TrackSymbol_"],[id*="_TrackToolTip"]').attr("visibility", "hidden");
                                            bbdesigner$("#" + this._id).find('[id*="canvas_trackSymbol"]').css("visibility", "hidden");
                                        }
                                              initialPoint = closestPoint;
                                    }
                                    chart.drawTrackerSymbol(series, seriesIndex, closestPoint.index[t], true, point);
                                     
                                    // Condition to find the crosshair is specified with tooltip template
                                    if (!chart.model.crosshair.tooltipTemplate) {
                                              var rectxt = this.getTooltipFormat(closestPoint.point[t], series, seriesIndex, i, series.tooltip.format, i), tooltipfont = (series.tooltip.font) ? series.tooltip.font : series.font, textarea = BoldBIDashboard.EjSvgRender.utils._measureText(rectxt.text, null, tooltipfont), currentLength = visiblepts.length - 1, padding, heightwidth = (requireInvertedAxes) ? textarea.height : textarea.width, maxWidth = (maxWidth > heightwidth) ? maxWidth : heightwidth, newLines = Math.ceil(rectxt.text.toString().split("<br/>").length / 2);
                                              this.model.tooltipPadding = Number(tooltipfont.size.toString().replace(/px/i, '')) / 3;
                                              padding = this.model.tooltipPadding + series.tooltip.border.width*2;
                                              if (!requireInvertedAxes) {
                                                  tooltipRanges.push({ Start: visiblepts[currentLength].Y -padding*newLines- textarea.height / 2, End: visiblepts[currentLength].Y +padding*newLines+ textarea.height / 2 });
                                              }
                                              else {
                                                  tooltipRanges.push({ Start: visiblepts[currentLength].X -padding - (textarea.width / 2), End: visiblepts[currentLength].X +padding + (textarea.width / 2) });
                                              }
                                              DisplayTooltipOptions.push({ Point: visiblepts[currentLength], ClosestPoint: closestPoint.point[t], Series: series, ClosestPointIndex: closestPoint.index[t], Tgap: tgap, StEnd: tooltipRanges[currentLength], TextArea: textarea, ReqInvertAxis: requireInvertedAxes });
                                             if (DisplayTooltipOptions.length == totalVisible) {
                                                  maxWidth+=(2*padding);
                                                  if (requireInvertedAxes) {
                                                      DisplayTooltipOptions = DisplayTooltipOptions.sort(function (a, b) { return a.Point.X - b.Point.X });
                                                  }
                                                  else {
                                                     DisplayTooltipOptions = DisplayTooltipOptions.sort(function (a, b) { return a.Point.Y - b.Point.Y });
                                                  }
                                                  this.SmartTooltipPosition(DisplayTooltipOptions);
                                                  for (var i = 0; i < DisplayTooltipOptions.length; i++) {
                                                      chart.displayTooltip(DisplayTooltipOptions[i].Point, DisplayTooltipOptions[i].ClosestPoint, DisplayTooltipOptions[i].Series, DisplayTooltipOptions[i].ClosestPointIndex, DisplayTooltipOptions[i].Tgap,maxWidth);
                                                  }

                                              }
                                        bbdesigner$('#' + this.svgObject.id + '_TrackToolTip_' + seriesIndex).css("visibility", "visible");
                                        bbdesigner$('#' + this.svgObject.id + '_TrackToolTip_' + seriesIndex).attr("visibility", "visible");
                                    }
                                    else {
                                              tX, tY;
                                              chartLocation = document.getElementById(this.svgRenderer.svgObj.id).getClientRects()[0];
                                        chart.displayTemplateTooltip(tX, tY, point, closestPoint.point[t], series, seriesIndex, closestPoint.index[t], chartLocation);
                                    }
                                } else {
                                    // If both are same points, then viibility is set to visible
                                          element = bbdesigner$(this.svgObject).find('[id*="_TrackSymbol_"],[id*="_TrackToolTip"]');
                                    this.svgRenderer._setAttr(bbdesigner$(element), { "visibility": 'visible' });
                                    bbdesigner$("#" + this._id).find('[id*="canvas_trackSymbol"]').css("visibility", "visible");
                                    element = bbdesigner$(this.svgObject).find('[id*="_TrackToolTip"]').children();
                                    this.svgRenderer._setAttr(bbdesigner$(element), { "visibility": 'visible' });
                                    
                                    element = bbdesigner$(this.svgObject).find('[id*="_trackSymbol_"]');
                                    this.svgRenderer._setAttr(bbdesigner$(element), { "visibility": 'visible' });

                                    bbdesigner$(chart.svgObject).find('[id*="_TrackAxisToolTip"]').attr("visibility", "visible");
                                    
                                    // Sets the tooltip template visibility to visible
                                    if (this.model.crosshair.tooltipTemplate != null) {
                                        element = bbdesigner$(document).find('[id*="_TrackToolTipTemplate_"]');
                                        this.svgRenderer._setAttr(bbdesigner$(element), { "visibility": 'visible' });
                                    }
                                }
                                  }
                            } else {
                                bbdesigner$('#' + this.svgObject.id + '_TrackToolTip_' + seriesIndex).remove();
                                bbdesigner$('#' + this.svgObject.id + '_TrackSymbol_' + seriesIndex).remove();
                            }
                        }
						}
						else{
						bbdesigner$("#" + chart.svgObject.id + "_TrackToolTip_" + i).remove();
						bbdesigner$("#" + chart.svgObject.id + "_TrackSymbol_" + i).remove();
						bbdesigner$("#" + chart.svgObject.id + "_TrackAxisToolTip").remove();
						}
                    } else {
                        if (!showTrackLine) // //condition checked to display Track line for single series when chart have more than one series. 
                            bbdesigner$(chart.svgObject).find('[id*="_Tracker"]').remove();
						bbdesigner$("#" + chart.svgObject.id + "_TrackToolTip_" + i).remove();
						bbdesigner$("#" + chart.svgObject.id + "_TrackSymbol_" + i).remove();
						bbdesigner$("#" + chart._id).find('[id*=' + "_canvas_trackSymbol_" + i + ']').css("visibility", "hidden");
                    }
                }
            }
           // To get the previous point values
            if (this.model.closestPoint != null)
            {
                this.model.prePoint = { point: closestPoint.point, pointIndex: closestPoint.index, series: series, seriesIndex: seriesIndex };
            }
             if (bbdesigner$("#" +this.svgObject.id + "_TrackAxisToolTip").length == 0) {     // condition to check track axis tooltip is existing in DOM
                var gTrackAxisOptions = { 'id': chart.svgObject.id + '_TrackAxisToolTip', 'visibility': 'visible' };
                chart.gTrackAxisEle = chart.svgRenderer.createGroup(gTrackAxisOptions);
                chart.svgRenderer.append(chart.gTrackAxisEle, chart.svgObject);
            }
           
             if (point) {
                 var pointValue = closestPoint.point[0];
				 //Hide unnecessary crosshair labels. SVG and Canvas renders crosshair labels differently
				 if(chart.model.enableCanvasRendering)
					bbdesigner$(chart.svgObject.parentElement).find('[id*="AxisToolTipRect"]').css({"visibility": "hidden", "display":"none"});
				else
					bbdesigner$(chart.svgObject).find('[id*="_TrackAxisToolTip"]').attr("visibility", "visible").children().attr({"display": "none"});
                bbdesigner$.each(chart.model._axes, function (axisIndex, axis) {					
                    var areaX = axis.x;
                    var opposedPosition = axis._opposed;
                    if (!requireInvertedAxes) {
                        if (axis.orientation.toLowerCase() == "horizontal" && axis.crosshairLabel.visible) {
                            if ((point.X + areaX) <= (axis.x + axis.width) && axis.x <= (visiblepts[visiblepts.length - 1].X)) {
                                var valueType = axis._valueType.toLowerCase(), xVal, pointLocation;
                                xVal = ((point.X / (axis.width)) * (axis.visibleRange.delta) + axis.visibleRange.min).toFixed(2).replace(new RegExp("\\.0{" + 2 + "}"), "");
                                if (valueType == "logarithmic") xVal = Math.pow(axis.logBase, xVal);
                                if (valueType == "datetime") xVal = (BoldBIDashboard.format(new Date(Math.floor(xVal)), ((BoldBIDashboard.util.isNullOrUndefined(axis.labelFormat)) ? BoldBIDashboard.EjSvgRender.utils._dateTimeLabelFormat(axis._intervalType) : axis.labelFormat)));
                               if (valueType == "category" || valueType == "datetimecategory") {
                                    xVal = pointValue.xValue;
                                    xVal = BoldBIDashboard.EjSvgRender.utils._getLabelContent(Math.floor(xVal), axis); xVal = xVal ? xVal : "undefined";
                                }
                                pointLocation = { X: (visiblepts[visiblepts.length-1].X), Y: (opposedPosition) ? (axis.y + axis.height - axis.majorTickLines.size) : (axis.y + axis.height + axis.majorTickLines.size + 10) };
                                chart.displayAxisTooltip(pointLocation, xVal, axis, axisIndex, mouseLocation);
                            }
                        }
                    }
                    else {
                        if (axis.orientation.toLowerCase() == "vertical" && axis.crosshairLabel.visible) {
                            if ((chart.mousemoveY) <= (axis.y + axis.height) && axis.y <= (chart.mousemoveY)) {
                                var valueType = axis._valueType.toLowerCase(), yVal = pointValue.xValue, ypointLocation=[];
                                if (valueType == "logarithmic") yVal = Math.pow(axis.logBase, yVal).toFixed(2).replace(new RegExp("\\.0{" + 2 + "}"), "");
                                if (valueType == "datetime") yVal = (BoldBIDashboard.format(new Date(Math.floor(yVal)), ((BoldBIDashboard.util.isNullOrUndefined(axis.labelFormat)) ? BoldBIDashboard.EjSvgRender.utils._dateTimeLabelFormat(axis._intervalType) : axis.labelFormat)));
                                if (valueType == "category") yVal = BoldBIDashboard.EjSvgRender.utils._getLabelContent(yVal, axis);
                                ypointLocation = { X: axis.x, Y: (point.Y + axis.y) };
                                chart.displayAxisTooltip(ypointLocation, yVal, axis, axisIndex, mouseLocation);                                
                            }
                        }
                    }

                });
            }


        }
    },
    chartAreaCrossHair: function (chart, mouseLocation) {
        var round = ((BoldBIDashboard.util.isNullOrUndefined(this.model.primaryYAxis.roundingPlaces)) ? 2 : this.model.primaryYAxis.roundingPlaces);
        if ((!this.model.enable3D) && this.model.crosshair.visible && this.model.crosshair.type.toLowerCase() == "crosshair") {
            var minX, maxX, minY, maxY, axisX, axisY, axisWidth, axisHeight;
            var isCanvas = this.model.enableCanvasRendering;
            var isCartesian = this.model.AreaType == "cartesianaxes" ? true : false;
            if(!isCanvas)
                var chartArea = isCartesian ? document.getElementById(this.svgObject.id + "_ChartArea").getBoundingClientRect() : document.getElementById(this.svgObject.id).getBoundingClientRect();
            for (var i = 0; i < this.model._axes.length; i++) {
                var axis = this.model._axes[i];
                axisY = chartArea ? chartArea.top : axis.y;
                axisX = chartArea ? chartArea.left : axis.x;
                axisWidth = chartArea ? chartArea.width : axis.width;
                axisHeight = chartArea ? chartArea.height : axis.height;
                if (axis.orientation.toLowerCase() == 'vertical') {
                    if (mouseLocation.y >= axisY && mouseLocation.y <= axisY + axisHeight)
                        if (axisX < mouseLocation.x)
                            minX = Math.min(minX || axisX, axisX);
                        else
                            maxX = Math.max(maxX || axisX, axisX);
                }
                else
                    if (mouseLocation.x >= axisX && mouseLocation.x <= axisX + axisWidth)
                        if (axisY < mouseLocation.y)
                            minY = Math.min(minY || axisY, axisY);
                        else
                            maxY = Math.max(maxY || axisY, axisY);
            }
            var areaBoundsX = chartArea ? chartArea.left : this.model.m_AreaBounds.X;
            var areaBoundsY = chartArea ? chartArea.top : this.model.m_AreaBounds.Y;
            var areaBoundsWidth = chartArea ? chartArea.width :this.model.m_AreaBounds.Width;
            var areaBoundsHeight = chartArea ? chartArea.height : this.model.m_AreaBounds.Height;
            var left = minX || areaBoundsX,
            width = maxX ? maxX - left : areaBoundsX + areaBoundsWidth - left,
            top = minY || areaBoundsY,
            height = maxY ? maxY - top : areaBoundsY + areaBoundsHeight - top;
			
            var d = "M" + " " + (this.mousemoveX) + " " + (top) + " " + "L" + " " + (this.mousemoveX) + " " + (top + height),
            dhor = "M" + " " + (left) + " " + (this.mousemoveY) + " " + "L" + " " + (left + width) + " " + (this.mousemoveY),
            chartOffset = bbdesigner$("#" + this._id).offset(),
            svgObject = chart.svgObject, options, optionsHor,
            chartPos = { left: svgObject.offsetLeft > chartOffset.left ? svgObject.offsetLeft : chartOffset.left,
                   		      top: svgObject.offsetTop > chartOffset.top ? svgObject.offsetTop : chartOffset.top};
            if (bbdesigner$("#" + chart.svgObject.id + "_CrosshairVertical").length == 0) {
                options = {
                    'id': chart.svgObject.id + "_CrosshairVertical",
                    'fill': 'none',
                    'stroke-width': chart.model.crosshair.line.width,
                    'stroke': chart.model.crosshair.line.color,
                    'clip-path': 'url(#' + this.svgObject.id + '_ChartAreaClipRect)',
                    'd': d
                };
                if (chart.model.enableCanvasRendering) {
                    options.width = 0,
                    options.height = height,
                    options.top = top + chartPos.top,
                    options.left = left + chartPos.left,
                    chart.svgRenderer.drawCrosshairLine(options, chart.svgObject);
                }
                else
                    chart.svgRenderer.drawPath(options, chart.svgObject);                    
            } else {
                chart.svgRenderer._setAttr(bbdesigner$(chart.svgObject).find("#" + chart.svgObject.id + "_CrosshairVertical"), { "d": d });
                if (chart.model.enableCanvasRendering)
                    bbdesigner$("#" + chart.svgObject.id + "_CrosshairVertical").css("left", this.mousemoveX + chartPos.left).css("top", top + chartPos.top).css("height",height);
                bbdesigner$("#" + chart.svgObject.id + "_CrosshairVertical").css("visibility", "visible");
            }
            
            if (bbdesigner$("#" + chart.svgObject.id + "_CrosshairHorizontal").length == 0) {
                optionsHor = {
                    'id': chart.svgObject.id + "_CrosshairHorizontal",
                    'fill': 'none',
                    'stroke-width': chart.model.crosshair.line.width,
                    'stroke': chart.model.crosshair.line.color,
                    'clip-path': 'url(#' + this.svgObject.id + '_ChartAreaClipRect)',
                    'd': dhor
                };
                if (chart.model.enableCanvasRendering) {
                    optionsHor.top = top + chartPos.top,
                    optionsHor.left = left + chartPos.left,
                    optionsHor.width = width,
                    optionsHor.height = 0,
                    chart.svgRenderer.drawCrosshairLine(optionsHor, chart.svgObject);
                }
                else
                    chart.svgRenderer.drawPath(optionsHor, chart.svgObject);
            } else {
                chart.svgRenderer._setAttr(bbdesigner$(chart.svgObject).find("#" + chart.svgObject.id + "_CrosshairHorizontal"), { "d": dhor });
                bbdesigner$("#" + chart.svgObject.id + "_CrosshairHorizontal").css("visibility", "visible");
                if (chart.model.enableCanvasRendering) {
                    bbdesigner$("#" + chart.svgObject.id + "_CrosshairHorizontal").css("top", this.mousemoveY + chartPos.top).css("left", left + chartPos.left).css("width",width);                    
                }
            }
            if ( bbdesigner$('#' + chart.svgObject.id + '_AxisCrossToolTip').length ==0) {
                var gAxisCrossOptions = { 'id': chart.svgObject.id + '_AxisCrossToolTip', 'visibility': 'visible' };
                chart.gTrackAxisEle = chart.svgRenderer.createGroup(gAxisCrossOptions);
                chart.svgRenderer.append(chart.gTrackAxisEle, chart.svgObject);
            }
            else {
                this.svgRenderer._setAttr(bbdesigner$(chart.gTrackAxisEle), { "visibility": 'visible' });
            }

            bbdesigner$.each(chart.model._axes, function (axisIndex, axis) {
                var valueType = axis._valueType.toLowerCase();
                if (axis.orientation.toLowerCase() == "horizontal" && axis.crosshairLabel.visible) {
                    if ((chart.mousemoveX) <= (axisX + axisWidth) && axisX <= (chart.mousemoveX)) {
                        var labelplacement = (axis._valueType == "category" && axis.labelPlacement.toLowerCase()=='betweenticks') ? 0.5 : 0;
                        var xVal = ((Math.abs(chart.mousemoveX - (axis.isInversed ? axisX + axisWidth : axisX)) / (axisWidth)) * (axis.visibleRange.delta) + axis.visibleRange.min + labelplacement).toFixed(2).replace(new RegExp("\\.0{" + 2 + "}"), "");
                        if (valueType == "logarithmic") xVal = Math.pow(axis.logBase, xVal).toFixed(2).replace(new RegExp("\\.0{" + 2 + "}"), "");
                        if (valueType == "datetime") xVal = (BoldBIDashboard.format(new Date(Math.floor(xVal)), ((BoldBIDashboard.util.isNullOrUndefined(axis.labelFormat)) ? BoldBIDashboard.EjSvgRender.utils._dateTimeLabelFormat(axis._intervalType) : axis.labelFormat)));
                        if (valueType == "category" || valueType == "datetimecategory") xVal = BoldBIDashboard.EjSvgRender.utils._getLabelContent(xVal, axis);
                        var xPointLocation = { X: (chart.mousemoveX), Y: (axisY) };
                        chart.displayAxisTooltip(xPointLocation, xVal, axis, axisIndex, mouseLocation);
						 bbdesigner$("#" + chart.svgObject.id + '_AxisToolTipText' + '_' + axisIndex).show();
                        bbdesigner$("#" + chart.svgObject.id + '_AxisToolTipRect' + '_' + axisIndex).show();
                    }
					 else
					 {
                        bbdesigner$("#" + chart.svgObject.id + '_AxisToolTipText' + '_' + axisIndex).hide();
                        bbdesigner$("#" + chart.svgObject.id + '_AxisToolTipRect' + '_' + axisIndex).hide();
                    }
                } else if (axis.orientation.toLowerCase() == "vertical" && axis.crosshairLabel.visible) {
                    if ((chart.mousemoveY) <= (axisY + axisHeight) && axisY <= (chart.mousemoveY)) {
                        var yVal = ((Math.abs(1 - (Math.abs(chart.mousemoveY - (axis.isInversed ? axisY + axisHeight : axisY)) / (axisWidth)) / (axisHeight)) * (axis.visibleRange.delta) + axis.visibleRange.min).toFixed(round).replace(new RegExp("\\.0{" + round + "}"), ""));
                        if (valueType == "logarithmic") yVal = Math.pow(axis.logBase, yVal).toFixed(2).replace(new RegExp("\\.0{" + 2 + "}"), "");
                        if (valueType == "datetime") yVal = (BoldBIDashboard.format(new Date(Math.floor(yVal)), ((BoldBIDashboard.util.isNullOrUndefined(axis.labelFormat)) ? BoldBIDashboard.EjSvgRender.utils._dateTimeLabelFormat(axis._intervalType) : axis.labelFormat)));
                        if (valueType == "category" || valueType == "datetimecategory") yVal = BoldBIDashboard.EjSvgRender.utils._getLabelContent(yVal, axis);
                        var ypointLocation = { X: axisX, Y: (chart.mousemoveY) };
                        chart.displayAxisTooltip(ypointLocation, yVal, axis, axisIndex, mouseLocation);
						 bbdesigner$("#" + chart.svgObject.id + '_AxisToolTipText' + '_' + axisIndex).show();
                        bbdesigner$("#" + chart.svgObject.id + '_AxisToolTipRect' + '_' + axisIndex).show();
                    }
					 else
				     {
                        bbdesigner$("#" + chart.svgObject.id + '_AxisToolTipText' + '_' + axisIndex).hide();
                        bbdesigner$("#" + chart.svgObject.id + '_AxisToolTipRect' + '_' + axisIndex).hide();
                    }
                }
            });

        }
    },
    chartTouchMove: function (evt) {
	   this.cancelEvent(evt);
        evt = evt.originalEvent.touches[0];
        this.chartInteractiveBehavior(evt);

    },

    isZoomButtonHovered: function (target) {
        if (target.parentNode != null) {
            var parentId = target.parentNode.id;
            var id = target.id;
            if (id.indexOf('_ZoomInBtn ')==-1 && id.indexOf('ZoomOutBtn')==-1 && id.indexOf('_ZoomBtn') == -1 && id.indexOf('_ResetZoom') == -1 && id.indexOf('_PanBtn') == -1 && parentId.indexOf('_ZoomInBtn')==-1 && parentId.indexOf('_ZoomOutBtn')==-1&&parentId.indexOf('_ZoomBtn') == -1 && parentId.indexOf('_ResetZoom') == -1 && parentId.indexOf('_PanBtn') == -1)
                return false;
        }
        return true;
    },

    chartInteractiveBehavior: function (evt, data) {
        var mouseMoveCords = this.calMousePosition(evt);
        this.mousemoveX = evt.originalEvent.clientX;
        this.mousemoveY = evt.originalEvent.clientY;

        var id = "#" + this.svgObject.id;
        if (this.mouseWheelCoords) {
            var changeX = Math.abs(this.mouseWheelCoords.x - evt.pageX);
            var changeY = Math.abs(this.mouseWheelCoords.y - evt.pageY);
            if ((changeX > 0 || changeY > 0) && !(this.panning)) {
                this.enableTrackBall();
            } else {
                this.disableTrackBall();
            }
        }

        var chart = this;
        if (evt.target.parentNode != null) {
            var parentNodeId = evt.target.parentNode.id;
            var targetId = evt.target.id;
            var isElement = (parentNodeId.indexOf(this.svgObject.id + "_SeriesGroup_") >= 0 || parentNodeId.indexOf(this.svgObject.id + "_symbolGroup_") >= 0 || parentNodeId.indexOf(this.svgObject.id + "_TextGroup_") >= 0 ||
							 parentNodeId.indexOf(this.svgObject.id + "_TrackSymbol_") >= 0 || parentNodeId.indexOf(this.svgObject.id + "_Chart3D") >= 0) ? true : false;
        }
        if(!chart.model.enableCanvasRendering && this.model.AreaType == "cartesianaxes" && !this.model.enable3D)
        var chartArea = document.getElementById(this.svgObject.id + "_ChartArea").getBoundingClientRect();
        if (chart.model.AreaType == "cartesianaxes" && ((this.mousemoveX >= this.model.m_AreaBounds.X && this.mousemoveX < (this.model.m_AreaBounds.X + this.model.m_AreaBounds.Width) && this.mousemoveY < (this.model.m_AreaBounds.Y + this.model.m_AreaBounds.Height) && this.mousemoveY >= this.model.m_AreaBounds.Y) ||
            ( !chart.model.enableCanvasRendering && !chart.model.enable3D && (this.mousemoveX >= chartArea.left && this.mousemoveX < chartArea.right && this.mousemoveY < chartArea.bottom && this.mousemoveY >= chartArea.top))) && this.model.initSeriesRender) {
            var mouseLocation = { x: chart.mousemoveX, y: chart.mousemoveY };
            var targetId = chart.svgRenderer._getAttrVal(bbdesigner$(evt.target).parent(), "id");
            if ((targetId != undefined) && (targetId == chart.svgRenderer._getAttrVal(bbdesigner$(this.svgObject).find(id + '_ZoomBtn'), "id") || targetId == chart.svgRenderer._getAttrVal(bbdesigner$(this.svgObject).find(id + '_ResetZoom'), "id") || targetId == chart.svgRenderer._getAttrVal(bbdesigner$(this.svgObject).find(id + '_PanBtn'), "id"))) {
                this.disableTrackBall();
            }
            else {
                this.enableTrackBall();
            }

            //show tooltip and track ball
            if (!this.model.crosshair.visible && !this.isZoomButtonHovered(evt.target))
                this.tooltip(chart, evt);
            else {
                //Removing marker symbol when placing mouse outside chart area
                var pointData = this.model.prevPoint;
                if (pointData) {
                    if (this.model.enableCanvasRendering)
                        bbdesigner$("#canvas_trackSymbol").remove();
                    else {
                        var pointLocation = BoldBIDashboard.EjSvgRender.utils._getPoint(pointData.point, pointData.series);
                        chart.drawTrackerSymbol(pointData.series, pointData.seriesIndex, pointData.pointIndex, null, pointLocation);
                    }
                    this.model.prevPoint = null;
                }

                bbdesigner$("#" + chart.svgObject.id).find("#" + chart.svgObject.id + "_TrackToolTip").attr('visibility','hidden');
                bbdesigner$("#" + chart.svgObject.id + "_TrackToolTip").hide();
                bbdesigner$(".tooltipDiv").css("display", "none");
            }

            if (!this.model.enable3D) {
			    //crossHair of chart
			    this.chartCrossHair(chart, mouseLocation);

			    //crossHair for chart area
			    this.chartAreaCrossHair(chart, mouseLocation);
			}

        } else {
            if ((chart.model.AreaType == "none" || chart.model.AreaType == 'polaraxes') && !this.isZoomButtonHovered(evt.target))
                this.tooltip(chart, evt);
            else {
                bbdesigner$("#" + chart.svgObject.id).find("#" + chart.svgObject.id + "_TrackToolTip").attr('visibility','hidden');
                bbdesigner$("#" + chart.svgObject.id + "_TrackToolTip").hide();
                bbdesigner$(".tooltipDiv").css("display","none");
                this._removeTrackBall();
            }
        }
        // Checked condition for series highlighting
        if (!this.model.crosshair.visible) {
            if (this.model.enableCanvasRendering)
                this.highlightCanvas(this, evt, data);
            else
                this.highlightSvg(chart, parentNodeId,isElement, evt, data)
        }
		if(!isElement)
		bbdesigner$("#" + chart.svgObject.id + "_TrackToolTip").hide();
    },

    // highlight SVG logic started here
    highlightSvg: function (chart, parentNodeId, isElement, evt, data) {
        if (parentNodeId != undefined) {
            var matchStr = this.svgObject.id + "_SeriesGroup_";
            var serIndex = parentNodeId.substr(matchStr.length);
            if (parentNodeId.indexOf(this.svgObject.id + "_symbolGroup_") >= 0) {
                matchStr = this.svgObject.id + "_symbolGroup_";
                serIndex = parentNodeId.substr(matchStr.length);
            }
        }
        serIndex = data != undefined ? data.region.SeriesIndex : serIndex;
        var series = this.model.series[serIndex];
        var legend, legendMode, enableMultiRange;
        legend = this.model.legend;
        legendMode = legend.mode;
        enableMultiRange = legend.enableMultiRange;
        if (isElement && series) {
            if (series.highlightSettings.enable || (!enableMultiRange && legendMode == "range"))
                this.highlight(chart, evt, series);
        }

    },

     // canvas highlight logic started here
    highlightCanvas: function (chart, evt, data) {
        var legendMode = this.model.legend.mode;
        var enableMultiRange = this.model.legend.enableMultiRange;
        for (var i = 0; i < this.model._visibleSeries.length; i++) {
            var seriesIndex;
            var chartSeries;
            seriesIndex = i;
            chartSeries = this.model._visibleSeries[i];
            var type = chartSeries.type.toLowerCase();
            if (this.model.AreaType == "cartesianaxes" && chartSeries.visibility.toLowerCase() == 'visible' && type !== "scatter" && type !== "bubble" && type !== "column" && type.indexOf("bar") == -1 && type !== "stackingcolumn" && type !== "stackingcolumn100" && !chartSeries._hiloTypes) {
                var serY = [];
                var serX = [];
                var location = null;
                var mouseMoveCords = this.calMousePosition(evt);
                this.mousemoveX = mouseMoveCords.X;
                this.mousemoveY = mouseMoveCords.Y;
                var closestXyPoint = this.getClosesPointXY(serX, serY, chartSeries, this.mousemoveX, this.mousemoveY,evt);
                if (!BoldBIDashboard.util.isNullOrUndefined(closestXyPoint.point)) {
                    var commonPointEventArgs = bbdesigner$.extend({}, BoldBIDashboard.EjSvgRender.commonChartEventArgs);
                    commonPointEventArgs.data = { location: { x: this.mousemoveX, y: this.mousemoveY }, region: { SeriesIndex: i, Region: { PointIndex: closestXyPoint.index } } };
                }
            }
        }
        var data = commonPointEventArgs ? commonPointEventArgs.data : data;
        if (data && (this.model.series[data.region.SeriesIndex].highlightSettings.enable || (legendMode == "range" && !enableMultiRange))) {
            var series = bbdesigner$.extend({}, this.model.series[data.region.SeriesIndex]);
            series.pointIndex = data.region.Region.PointIndex;
            series.seriesIndex = data.region.SeriesIndex;
            series.data = data;
            if (bbdesigner$('#' + this._id + '_Selection_series' + series.seriesIndex + '_canvas').length == 0) {              
                // removed canvas highlight
                bbdesigner$("[id*=" + this._id + "_Highlight_" + "]").remove();
                if(!this.findCanvasSelection(series.seriesIndex,series.pointIndex,series.selectionSettings.mode.toLowerCase()))
                this.canvasHighlight(this, evt, series);
            }
        }
    },
    //change cursor symbols after resizing
    resizeCursor: function (containerSvg, mousemoveX, mousemoveY, chartAreaX, chartAreaY, chartAreaWidth, chartAreaHeight) {
        var selectedRectIndex = this.selectedRectIndex;
        if ((mousemoveX <= chartAreaX) || (mousemoveY <= chartAreaY) || (mousemoveX >= (chartAreaWidth + chartAreaX)) || (mousemoveY >= (chartAreaHeight + chartAreaY))) {
            bbdesigner$("#" + containerSvg + '_resize_rightRect' + selectedRectIndex).css({ 'cursor': 'default' });
            bbdesigner$("#" + containerSvg + '_resize_leftRect' + selectedRectIndex).css({ 'cursor': 'default' });
            bbdesigner$("#" + containerSvg + '_resize_bottomRect' + selectedRectIndex).css({ 'cursor': 'default' });
            bbdesigner$("#" + containerSvg + '_resize_topRect' + selectedRectIndex).css({ 'cursor': 'default' });
            bbdesigner$("#" + containerSvg + '_resize_bottomRightCornerCircle' + selectedRectIndex).css({ 'cursor': 'default' });
        }
        else if ((mousemoveX >= chartAreaX) || (mousemoveY >= chartAreaY) || (mousemoveX <= (chartAreaWidth + chartAreaX)) || (mousemoveY <= (chartAreaHeight + chartAreaY))) {
            bbdesigner$("#" + containerSvg + '_resize_rightRect' + selectedRectIndex).css({ 'cursor': 'e-resize' });
            bbdesigner$("#" + containerSvg + '_resize_leftRect' + selectedRectIndex).css({ 'cursor': 'w-resize' });
            bbdesigner$("#" + containerSvg + '_resize_bottomRect' + selectedRectIndex).css({ 'cursor': 's-resize' });
            bbdesigner$("#" + containerSvg + '_resize_topRect' + selectedRectIndex).css({ 'cursor': 'n-resize' });
            bbdesigner$("#" + containerSvg + '_resize_bottomRightCornerCircle' + selectedRectIndex).css({ 'cursor': 'se-resize' });
        }
    },
    multiSelectMouseMove: function (evt) {
        if (this._isMultiSelect && (this.multiSelectMode == 'range')) {
            var mouseMoveCords = this.calMousePosition(evt),
            mouseMoveX = mouseMoveCords.X,
            mouseMoveY = mouseMoveCords.Y,
            gripMouseMoveX, gripMouseMoveY, translate,
            selectionSettingsType = this.multiSelectType,
            width, height, x, y,
            rectX, rectY, rectWidth, rectHeight,
            x1, x2, y1, y2, xPlotOffset, yPlotOffset,
            modifiedX, modifiedY,
            mouseDownX = this.mouseDownX,
            mouseDownY = this.mouseDownY,
            selectedRectIndex = this.selectedRectIndex,
            containerSvg = this.svgObject.id,
            chartArea = '#' + containerSvg + '_ChartArea'
            chartAreaX = parseInt(bbdesigner$(chartArea).attr('x')),
            chartAreaY = parseInt(bbdesigner$(chartArea).attr('y')),
            chartAreaWidth = parseInt(bbdesigner$(chartArea).attr('width')),
            chartAreaHeight = parseInt(bbdesigner$(chartArea).attr('height')),
            multiSelectMouseDownId = this.multiSelectMouseDownId,
            selctRectId = '#' + containerSvg + '_selectRect';
            multiAxis = this.multiAxis; 
            for (var q = 0; q < multiAxis.length; q++) {
                if (multiAxis[q].orientation.toLowerCase() == 'horizontal') {
                    x1 = multiAxis[q].Location.X1; x2 = multiAxis[q].Location.X2;
                    xPlotOffset = multiAxis[q].plotOffset;
                }
                else {
                    y1 = multiAxis[q].Location.Y1; y2 = multiAxis[q].Location.Y2;
                    yPlotOffset = multiAxis[q].plotOffset;
                }
            }
            if ((this.drag) && (!this.resize) && (!this.rectPan) && (!this.removeRect)) {
                var currentX = mouseMoveX,
                currentY = mouseMoveY,
                areaBounds = this.model.m_AreaBounds;
                this.multiSelectDraw = true;
                if (mouseMoveX < areaBounds.X) {
                    currentX = areaBounds.X;
                }
                else if (mouseMoveX > (areaBounds.X + areaBounds.Width)) {
                    currentX = areaBounds.X + areaBounds.Width;
                }
                if (mouseMoveY < areaBounds.Y) {
                    currentY = areaBounds.Y;
                } else if (mouseMoveY > (areaBounds.Y + areaBounds.Height)) {
                    currentY = areaBounds.Y + areaBounds.Height;
                }
                else {
                    currentY = mouseMoveY;
                }
                switch (selectionSettingsType) {
                    case 'x':
                        width = Math.abs(currentX - mouseDownX);
                        height = y1 - y2 + yPlotOffset + yPlotOffset;
                        x = currentX > mouseDownX ? mouseDownX : currentX;
                        y = y2 - yPlotOffset;
                        break;
                    case 'y':
                        width = x2 - x1 + xPlotOffset + xPlotOffset;
                        height = Math.abs(currentY - mouseDownY);
                        x = x1 - xPlotOffset;
                        y = currentY > mouseDownY ? mouseDownY : currentY;
                        break;
                    case 'xy':
                        width = Math.abs(currentX - mouseDownX);
                        height = Math.abs(currentY - mouseDownY);
                        x = currentX > mouseDownX ? mouseDownX : currentX;
                        y = currentY > mouseDownY ? mouseDownY : currentY;
                        break;
                }
                if (width > 0 && height > 0) {
                    var rectOptions = {
                        'id': this.svgObject.id + '_selectRect' + this.selectedRectIndex,
                        'x': x,
                        'y': y,
                        'width': width,
                        'height': height,
                        'fill': 'rgba(41,136,214,0.2)',
                        'stroke-width': 2,
                        'stroke': 'rgba(41,136,214,0.5)',
                        'cursor': 'pointer',
                        'clip-path': 'url(#' + this.svgObject.id + '_ChartAreaClipRect)'
                    };
                if ((x >= x1 + xPlotOffset) && (mouseMoveX <= x2 - xPlotOffset) && (mouseMoveY <= y1 + yPlotOffset) && (y >= y2 - yPlotOffset))
                    this.svgRenderer.drawRect(rectOptions, this.gEle);
                if ((this.gEle != null)) {
                    bbdesigner$(this.gEle).appendTo(this.parentgEle);
                    if (this.selectedRectIndex == 0) {
                        this.model.gCurrentEle = this.gEle;
                        }
                        bbdesigner$(this.parentgEle).appendTo(this.svgObject);
                    }
                }
            }
            rectX = parseInt(bbdesigner$(selctRectId + selectedRectIndex).attr('x'));
            rectY = parseInt(bbdesigner$(selctRectId + selectedRectIndex).attr('y'));
            rectWidth = parseInt(bbdesigner$(selctRectId + selectedRectIndex).attr('width'));
            rectHeight = parseInt(bbdesigner$(selctRectId + selectedRectIndex).attr('height'));
            if (!this.drag && (evt.target.id.indexOf("selectRect") >= 0 || evt.target.id.indexOf("resize") >= 0)) {
                if (evt.target.parentNode.id.indexOf("selectedRect") >= 0) {
                    id = evt.target.parentNode.id.split("selectedRect")[1].match(/\d+/)[0];
                    this.gripIndex = eval(id);
                }
                var selectRectId = '#' + containerSvg + '_selectRect',
                selectRectWidth = parseInt(bbdesigner$(selectRectId + this.gripIndex).attr("width")),
                selectRectHeight = parseInt(bbdesigner$(selectRectId + this.gripIndex).attr("height")),
                selectRectX = parseInt(bbdesigner$(selectRectId + this.gripIndex).attr("x")),
                selectRectY = parseInt(bbdesigner$(selectRectId + this.gripIndex).attr("y"));
                bbdesigner$("#" + containerSvg + "_gripCollection" + selectedRectIndex).css({ 'visibility': 'hidden' });
                if (selectRectX + selectRectWidth - 16 >= selectRectX || selectRectY + selectRectHeight - 16 >= selectRectY)
                    bbdesigner$("#" + this.svgObject.id + "_gripCollection" + this.gripIndex).attr({ 'transform': "" });
                if (selectRectX + selectRectWidth - 16 < selectRectX || selectRectY + selectRectHeight - 16 < selectRectY) {
                    var translate = 'translate(' + 15 + ',' + 15 + ')';
                    bbdesigner$("#" + this.svgObject.id + "_gripCollection" + this.gripIndex).attr({ 'transform': translate });
                }
                if (this.oldId != evt.target.id)
                    bbdesigner$("#" + containerSvg + "_gripCollection" + this.oldGripIndex).css({ 'visibility': 'hidden' });
                bbdesigner$("#" + containerSvg + "_gripCollection" + this.gripIndex).css({ 'visibility': 'visible' });
                this.oldId = evt.target.id;
                this.oldGripIndex = this.gripIndex;
            }
            if ((evt.target.id.indexOf("selectRect") < 0) && (evt.target.id.indexOf("resize") < 0 ))
                bbdesigner$("#" + containerSvg + "_gripCollection" + this.gripIndex).css({ 'visibility': 'hidden' });
            if (this.resize) {
                bbdesigner$("#" + containerSvg + "_closeTopRightCornerCircle" + selectedRectIndex).hide();
                bbdesigner$("#" + containerSvg + "_closePath" + selectedRectIndex).hide();
                bbdesigner$("#" + containerSvg + "_closePathOpposite" + selectedRectIndex).hide();
                bbdesigner$("#" + containerSvg + "_gripCollection" + selectedRectIndex).css({ 'visibility': 'hidden' });
                var oldRectX = this.oldRectX[selectedRectIndex], oldRectY = this.oldRectY[selectedRectIndex],
                oldRectHeight = this.oldRectHeight[selectedRectIndex], oldRectWidth = this.oldRectWidth[selectedRectIndex],
                oldReBottomRectY = this.oldReBottomRectY[selectedRectIndex],
                oldReRightRectX = this.oldReRightRectX[selectedRectIndex];
                switch (selectionSettingsType) {
                    case 'x':
                        if (multiSelectMouseDownId == containerSvg + '_resize_rightRect' + selectedRectIndex) {
                            rectWidth = mouseMoveX - oldRectX;
                            bbdesigner$("#" + containerSvg + "_resize_rightRect" + selectedRectIndex).attr('x', mouseMoveX - 5);
                            if (mouseMoveX < oldRectX) {
                                rectX = mouseMoveX;
                                rectWidth = oldRectX - mouseMoveX;
                            }
                            else if (mouseMoveX >= oldRectX) rectX = oldRectX;
                        }
                        else if (multiSelectMouseDownId == containerSvg + '_resize_leftRect' + selectedRectIndex) {
                            rectX = mouseMoveX;
                            rectWidth = oldRectWidth + oldRectX - mouseMoveX;
                            bbdesigner$("#" + containerSvg + "_resize_leftRect" + selectedRectIndex).attr('x', mouseMoveX - 5);
                            if (mouseMoveX > (oldReRightRectX + 5)) {
                                rectX = oldReRightRectX + 5;
                                rectWidth = mouseMoveX - oldRectX - oldRectWidth;
                            }
                        }
                        this.resizeCursor(containerSvg, mouseMoveX, mouseMoveY, chartAreaX, chartAreaY, chartAreaWidth, chartAreaHeight);
                        break;
                    case 'y':
                        if (multiSelectMouseDownId == containerSvg + '_resize_topRect' + selectedRectIndex) {
                            rectHeight = oldRectHeight + oldRectY - mouseMoveY;
                            rectY = mouseMoveY;
                            bbdesigner$("#" + containerSvg + "_resize_topRect" + selectedRectIndex).attr('y', mouseMoveY - 5);
                            if (mouseMoveY > (oldReBottomRectY + 5)) {
                                rectY = oldReBottomRectY + 5;
                                rectHeight = mouseMoveY - oldRectY - oldRectHeight;
                            }
                        }
                        else if (multiSelectMouseDownId == (containerSvg + '_resize_bottomRect' + selectedRectIndex)) {
                            rectHeight = mouseMoveY - oldRectY;
                            bbdesigner$("#" + containerSvg + "_resize_bottomRect" + selectedRectIndex).attr('y', mouseMoveY - 5);
                            if (mouseMoveY < oldRectY) {
                                rectY = mouseMoveY;
                                rectHeight = oldRectY - mouseMoveY;
                            }
                            else if (mouseMoveY >= oldRectY) rectY = oldRectY;
                        }
                        this.resizeCursor(containerSvg, mouseMoveX, mouseMoveY, chartAreaX, chartAreaY, chartAreaWidth, chartAreaHeight);
                        break;
                    case 'xy':
                        if (multiSelectMouseDownId == containerSvg + '_resize_rightRect' + selectedRectIndex) {
                            rectWidth = mouseMoveX - oldRectX;
                            bbdesigner$("#" + containerSvg + "_resize_rightRect" + selectedRectIndex).attr('x', mouseMoveX - 5);
                            if (mouseMoveX < oldRectX) {
                                rectX = mouseMoveX;
                                rectWidth = oldRectX - mouseMoveX;
                            }
                            else if (mouseMoveX >= oldRectX)
                                rectX = oldRectX;
                        }
                        else if (multiSelectMouseDownId == containerSvg + '_resize_leftRect' + selectedRectIndex) {
                            rectX = mouseMoveX;
                            rectWidth = oldRectWidth + oldRectX - mouseMoveX;
                            bbdesigner$("#" + containerSvg + "_resize_leftRect" + selectedRectIndex).attr('x', mouseMoveX - 5);
                            if (mouseMoveX > (oldReRightRectX + 5)) {
                                rectX = oldReRightRectX + 5;
                                rectWidth = mouseMoveX - oldRectX - oldRectWidth;
                            }
                        }
                        else if (multiSelectMouseDownId == containerSvg + '_resize_topRect' + selectedRectIndex) {
                            rectHeight = oldRectHeight + oldRectY - mouseMoveY;
                            rectY = mouseMoveY;
                            bbdesigner$("#" + containerSvg + "_resize_topRect" + selectedRectIndex).attr('y', mouseMoveY - 5);
                            if (mouseMoveY > (oldReBottomRectY + 5)) {
                                rectY = oldReBottomRectY + 5;
                                rectHeight = mouseMoveY - oldRectY - oldRectHeight;
                            }
                        }
                        else if (multiSelectMouseDownId == (containerSvg + '_resize_bottomRect' + selectedRectIndex)) {
                            rectHeight = mouseMoveY - oldRectY;
                            bbdesigner$("#" + containerSvg + "_resize_bottomRect" + selectedRectIndex).attr('y', mouseMoveY - 5);
                            if (mouseMoveY < oldRectY) {
                                rectY = mouseMoveY;
                                rectHeight = oldRectY - mouseMoveY;
                            }
                            else if (mouseMoveY >= oldRectY)
                                rectY = oldRectY;
                        }
                        else if (multiSelectMouseDownId == containerSvg + '_resize_bottomRightCornerCircle' + selectedRectIndex) {
                            rectWidth = mouseMoveX - oldRectX;
                            rectHeight = mouseMoveY - oldRectY;
                            bbdesigner$("#" + containerSvg + "_resize_bottomRightCornerCircle" + selectedRectIndex).attr({ 'cx': mouseMoveX, 'cy': mouseMoveY });
                            if ((mouseMoveX < oldRectX) && (mouseMoveY < oldRectY)) {
                                rectX = mouseMoveX;
                                rectY = mouseMoveY;
                                rectWidth = oldRectX - mouseMoveX;
                                rectHeight = oldRectY - mouseMoveY;
                            }
                            else if (mouseMoveX < oldRectX) {
                                rectX = mouseMoveX;
                                rectWidth = oldRectX - mouseMoveX;
                            }
                            else if (mouseMoveY < oldRectY) {
                                rectY = mouseMoveY;
                                rectHeight = oldRectY - mouseMoveY;
                            }
                            else if ((mouseMoveX >= oldRectX) && (mouseMoveY >= oldRectY)) {
                                rectX = oldRectX;
                                rectY = oldRectY;
                            }
                        }
                        this.resizeCursor(containerSvg, mouseMoveX, mouseMoveY, chartAreaX, chartAreaY, chartAreaWidth, chartAreaHeight);
                        break;
                }
                switch (selectionSettingsType) {
                    case 'x':
                        if (rectX >= x1 - xPlotOffset && (rectWidth + rectX - x1 <= x2 - x1 - xPlotOffset))
                            bbdesigner$(selctRectId + selectedRectIndex).attr({ 'x': rectX, 'width': rectWidth });
                        break;
                    case 'y':
                        if (((rectHeight + rectY - y2) <= y1 - y2 + yPlotOffset) && (rectY >= y2 - yPlotOffset))
                            bbdesigner$(selctRectId + selectedRectIndex).attr({ 'y': rectY, 'height': rectHeight });
                        break;
                    case 'xy':
                        if (rectX >= x1 - xPlotOffset && (rectWidth + rectX - x1 <= x2 - x1 - xPlotOffset) && (rectHeight + rectY - y2 <= y1 - y2 + yPlotOffset) && rectY >= y2 - yPlotOffset)
                            bbdesigner$(selctRectId + selectedRectIndex).attr({ 'x': rectX, 'y': rectY, 'width': rectWidth, 'height': rectHeight });;
                        break;
                }
            }
            if ((this.rectPan)) {
                bbdesigner$("#" + containerSvg + "_closeTopRightCornerCircle" + selectedRectIndex).hide();
                bbdesigner$("#" + containerSvg + "_closePath" + selectedRectIndex).hide();
                bbdesigner$("#" + containerSvg + "_closePathOpposite" + selectedRectIndex).hide();
                bbdesigner$("#" + containerSvg + "_gripCollection" + selectedRectIndex).css({ 'visibility': 'hidden' });
                if ((mouseMoveX <= chartAreaX || mouseMoveY <= chartAreaY || (mouseMoveX >= chartAreaX + chartAreaWidth) || (mouseMoveY >= chartAreaY + chartAreaHeight)))
                    this.multiSelectMouseUp(evt);
                modifiedX = this.PreviousCoords.X - evt.pageX;
                modifiedY = this.PreviousCoords.Y - evt.pageY;
                rectX = rectX - modifiedX;
                rectY = rectY - modifiedY;
                this.PreviousCoords.X = evt.pageX;
                this.PreviousCoords.Y = evt.pageY;
                switch (selectionSettingsType) {
                    case 'x':
                        if (rectX >= x1 - xPlotOffset && (rectWidth + rectX - x1 <= x2 - x1 - xPlotOffset))
                            bbdesigner$(selctRectId + selectedRectIndex).attr({ 'x': rectX });
                        break;
                    case 'y':
                        if ((rectHeight + rectY - y2 <= y1 - y2 + yPlotOffset) && rectY >= y2 - yPlotOffset)
                            bbdesigner$(selctRectId + selectedRectIndex).attr({ 'y': rectY });
                        break;
                    case 'xy':
                        if (rectX >= x1 - xPlotOffset && (rectWidth + rectX - x1 <= x2 - x1 - xPlotOffset) && (rectHeight + rectY - y2 <= y1 - y2 + yPlotOffset) && rectY >= y2 - yPlotOffset)
                            bbdesigner$(selctRectId + selectedRectIndex).attr({ 'x': rectX, 'y': rectY });
                        break;
                }
            }
        }
    },
    chartMouseMove: function (evt) {         
        var mouseposition = this.mousePosition(evt);
        if (BoldBIDashboard.util.isNullOrUndefined(this.mousemoveX) || BoldBIDashboard.util.isNullOrUndefined(this.mousemoveY))
        {
            this.mousemoveX = mouseposition.x;
            this.mousemoveY = mouseposition.y;
        }
        var data = this.GetSeriesPoint(evt),
        model = this.model;
        var classList = evt.target.classList;
        if (this.multiSelectAreaType == 'cartesianaxes' && (!model.zooming.enable) && (!model.enableCanvasRendering))
            this.multiSelectMouseMove(evt);
        if (!model.enableCanvasRendering || !data ) {
            // removed highlight style
            bbdesigner$("[class*=" + "HighlightStyle" + "]").attr('class', '');
            bbdesigner$("[class*=" + "HighlightLegendStyle" + "]").attr('class', '');
            bbdesigner$("[class*=" + "HighlightLegendPathStyle" + "]").attr('class', '');
            bbdesigner$("[class*=" + "HighlightPathStyle" + "]").attr('class', '');
            bbdesigner$("[class*=" + "Highlightseries" + "]").attr('class', '');
            bbdesigner$("[id*=" + this._id + "_Highlight_" + "]").remove();// removed canvas highlight           
        }
        
	     if (this.rotateActivate && this.oPreviousCoords) {
            var difY = (this.oPreviousCoords.Y - this.mousemoveY);
            var difX = (this.oPreviousCoords.X - this.mousemoveX);          
            if (difX||difY) {
                this.model.tilt -= difY;
                this.model.rotation += difX;     
                // store the class name 
                var selection = this.selectedStyle(this);
                bbdesigner$(this.chart3D).empty();
                bbdesigner$('#template_group_' + this._id).empty();
                var size = { Width: bbdesigner$(this.svgObject).width(), Height: bbdesigner$(this.svgObject).height() };
                this.graphics.view(this.svgObject, this, this.model.rotation, this.model.tilt, size, this.model.perspectiveAngle, this.model.depth);
                this.svgRenderer.append(this.chart3D, this.svgObject);
                this.svgRenderer.append(this.gTransToolEle, this.svgObject);
                // Apply the class
                for (var i = 0; i < selection.length; i++) {
                    bbdesigner$('#' + selection[i].id).attr('class', selection[i].className);
                }
            }
            this.oPreviousCoords.Y = this.mousemoveY;
            this.oPreviousCoords.X = this.mousemoveX;
        }
		
		 var targetId = evt.target.id;
	     var svgObjectId = this.svgObject.id;
	     var isZoom = this.isZoomButtonHovered(evt.target);

        var chart = this;
        this.calMousePosition(evt)
		bbdesigner$("#" + this._id + "_tooltip").remove();
		if (!this.drag && !isZoom)
			this.chartInteractiveBehavior(evt, data);
        if (!this.panning) {     
            var id = "#" + this.svgObject.id;
            if (model.zooming.enable && model.AreaType == "cartesianaxes" && !model.enable3D) {
                if (this.drag) {
                    this.disableTrackBall();
                    bbdesigner$('#' + this.svgObject.id + '_ZoomArea').remove();
                    var width, height, x, y;
                    var currentX = this.mousemoveX;
                    var currentY = this.mousemoveY;
                    var areaBounds = this.model.m_AreaBounds;
                    if (this.mousemoveX < areaBounds.X) {
                        currentX = areaBounds.X;
                    } else if (this.mousemoveX > (areaBounds.X + areaBounds.Width)) {
                        currentX = areaBounds.X + areaBounds.Width;
                    } 
                    if (this.mousemoveY < areaBounds.Y) {                     
                        currentY = areaBounds.Y;
                    } else if (this.mousemoveY > (areaBounds.Y + areaBounds.Height)) {
                        currentY = areaBounds.Y + areaBounds.Height;
                    }
                    else {
                        currentY = this.mousemoveY;
                    }
                    if (model.zooming.type.toLowerCase() == "x") {                  
                        width = Math.abs(currentX - this.mouseDownX);
                        height = areaBounds.Height;
                        x = currentX > this.mouseDownX ? this.mouseDownX : currentX;
                        y = areaBounds.Y;
                    } else if (model.zooming.type.toLowerCase() == "y") {
                        width = areaBounds.Width;                      
                        height = Math.abs(currentY - this.mouseDownY);
                        x = areaBounds.X;
                        y = currentY > this.mouseDownY ? this.mouseDownY : currentY;

                    } else {                        
                        width = Math.abs(currentX - this.mouseDownX);
                        height = Math.abs(currentY - this.mouseDownY);
                        x = currentX > this.mouseDownX ? this.mouseDownX : currentX;
                        y = currentY > this.mouseDownY ? this.mouseDownY : currentY;

                    }                 
                    bbdesigner$(this.svgObject).css({
                        '-moz-user-select': '-moz-none',
                        '-khtml-user-select': 'none',
                        '-webkit-user-select': 'none',
                        '-ms-user-select': 'none',
                        'user-select': 'none'
                    });

                    this.zooming = true;

                    var rectOptions = {
                        'id': this.svgObject.id + '_ZoomArea',
                        'x': x,
                        'y': y,
                        'width': width,
                        'height': height,
                        'fill': 'rgba(69,114,167,0.25)',
                        'stroke-width': 1,
                        'stroke': 'rgba(69,114,167,0.25)',
                        'clip-path': 'url(#' + this.svgObject.id + '_ChartAreaClipRect)'
                    };
                    if (this.model.enableCanvasRendering)
                        this.svgRenderer.drawZoomRect(rectOptions, this);
                    else
                        this.svgRenderer.drawRect(rectOptions, this.svgObject);
                }

            }
        }
		var deferredZoom = model.zooming.enableDeferredZoom;
        // Panning
        if (this.panning && this.doPan && model.AreaType == "cartesianaxes" && !this._scrollBarEnabled) {
            this.currentPageX = evt.pageX;
            this.currentPageY = evt.pageY;
            bbdesigner$("#" + this._id + "_canvas").css({ "cursor": "pointer" });
            if (!BoldBIDashboard.isTouchDevice() && !deferredZoom) {
                var oDelta;
                oDelta = {
                    'x': this.oPreviousCoords.x - evt.pageX,
                    'y': this.oPreviousCoords.y - evt.pageY
                };

                this.oPreviousCoords = {
                    'x': evt.pageX,
                    'y': evt.pageY
                };
                bbdesigner$.each(this.model._axes, function(index, axis) {
                    var currentScale = Math.max(1 / BoldBIDashboard.EjSvgRender.utils._minMax(axis.zoomFactor, 0, 1), 1);
                    chart.translate(axis, (oDelta.x), (oDelta.y), currentScale);
                });

                this.redraw(true);
                this._cursorToPointer();
                this._enableZoomingButtons();
            }
            // Translate the series for other devices
            else if (BoldBIDashboard.isTouchDevice() || deferredZoom) {
                for (var k = 0; k < this.model._visibleSeries.length; k++) {
                    var series = this.model.series[k],
                    transform = BoldBIDashboard.EjSvgRender.utils._getTransform(series.xAxis, series.yAxis, this.model.requireInvertedAxes),
                    transX = (evt.pageX - this.oPreviousCoords.x) + transform.x,
                    transY = (evt.pageY - this.oPreviousCoords.y) + transform.y,
                    translate = 'translate(' + transX + ',' + transY + ')',
                    svgObjectId = this.svgObject.id;
                    bbdesigner$("#" + svgObjectId + "_SeriesGroup_" + k).attr("transform", translate);
                    bbdesigner$("#" + svgObjectId + "_symbolGroup_" + k).attr("transform", translate);
                    bbdesigner$("#" + svgObjectId + "_TextGroup_" + k).attr("transform", translate);
                    
                }
                for (var index = 0; index < model.indicators.length && model.indicators[index]._points.length>0; index++) {
                    var indicator = this.model.indicators[index];
                    transform = BoldBIDashboard.EjSvgRender.utils._getTransform(indicator.xAxis, indicator.yAxis, this.model.requireInvertedAxes);
                    transX = (evt.pageX - this.oPreviousCoords.x) + transform.x;
                    transY = (evt.pageY - this.oPreviousCoords.y) + transform.y;
                    translate = 'translate(' + transX + ',' + transY + ')';
                    bbdesigner$("#" + this.svgObject.id + "_indicatorGroup_" + index).attr("transform", translate);
                }
            }
        }
		
		//Declaration
            var targetid = evt.target.id;
            var id = this._id;
            var parentId = BoldBIDashboard.util.isNullOrUndefined(evt.target.parentNode) ? "" : evt.target.parentNode.id;
			
	//condition to find the buttons and display tooltip on hover
            if (parentId == id + '_svg_ResetZoom')
                createBtnTooltip("Reset");
            else if (parentId == id + '_svg_PanBtn')
                createBtnTooltip("Pan");
            else if (parentId == id + '_svg_ZoomBtn')
                createBtnTooltip("Zoom");
            else if (parentId == id + '_svg_ZoomInBtn')
                createBtnTooltip("Zoom In");
            else if (parentId == id + '_svg_ZoomOutBtn')
                createBtnTooltip("Zoom Out");

	// method to create tooltip for zooming and panning buttons
        function createBtnTooltip(text) {
            var id = chart._id;
            if (bbdesigner$("#" + id + "_tooltip").length <= 0) {
                var tooltipdiv = bbdesigner$("<div></div>").attr('id', id + "_tooltip");
                bbdesigner$(tooltipdiv).html("&nbsp" + text + "&nbsp");
                bbdesigner$(document.body).append(tooltipdiv);
                // adding css prop to the div
                bbdesigner$(tooltipdiv).css({
                    "left": evt.pageX + 10,
                    "top": evt.pageY + 10,
                    "display": "block",
                    "position": "absolute",
                    "z-index": "13000",
                    "cursor": "default",
                    "font-family": "Segoe UI",
                    "color": "#707070",
                    "font-size": "12px",
                    "background-color": "#FFFFFF",
                    "border": "1px solid #707070"
                });
            } else {
                bbdesigner$("#" + id + "_tooltip").css({
                    "left": evt.pageX + 10,
                    "top": evt.pageY + 10
                });
            }

        }
        // axisLabelMouseMove event
        var axisData = this.getAxisLabelData(evt);
        if (axisData) {
            var commonEventArgs = bbdesigner$.extend({}, BoldBIDashboard.EjSvgRender.commonChartEventArgs);
            commonEventArgs.data = axisData;
            this._trigger("axisLabelMouseMove", commonEventArgs);
        }
           var svgId = this.svgObject.id,
           hAxes = this.model.hAxes,
          vAxes = this.model.vAxes;
  
            if (targetid.indexOf("_YLabel_") >= 0) {
                var axis, vAxesName;
                // Loop to find the axis
                for (var j = 0; j < vAxes.length; j++) {
                    vAxesName = vAxes[j].name.replace(/[^a-zA-Z0-9]/g, "");
                    if (targetid.indexOf(svgId + '_' + vAxesName + '_YLabel_') >= 0) {
                        axis = vAxes[j];
                        break;
                    }
                }
				var labelIntersectAction = axis.labelIntersectAction.toLowerCase();
                if ((axis && (axis.enableTrim || labelIntersectAction == 'trim')) || this.model.adaptiveRendering) {
                    // Loop to find the labels in the axis
                    visibleLabelsLength = axis.visibleLabels.length;
                    for (var i = 0; i < visibleLabelsLength && this.model.AreaType == 'cartesianaxes'; i++) {
                        if (targetid == svgId  + '_' + vAxes[j].name + '_YLabel_' + i) {
                            var ele = axis.visibleLabels[i];                             
                            var str = ele.Text == ele.displayText ? "" : ((axis.labelFormat) ? axis.labelFormat.replace("{value}", ele.Text) : ele.Text);
                            if (str == "") break;
                            if (axis.labelPosition.toLowerCase() == 'inside') {
                                this._hideTooltip();
                                this._removeTrackBall();
                            }
                            this.showAxisTooltip(evt.pageX, evt.pageY, str, ele.displayText);
                        }
                    }
                }
            }
    
            if (targetid.indexOf("_XLabel_") >= 0) {
                var axis, hAxesName;
                // Loop to find the axis
                for (var j = 0; j < hAxes.length; j++) {
				    hAxesName = hAxes[j].name.replace(/[^a-zA-Z0-9]/g, "");
                    if (targetid.indexOf(svgId + '_' + hAxesName + '_XLabel_') >= 0) {
                        axis = hAxes[j];
                        break;
                    }
                }
                if ((axis && (axis.enableTrim || axis.labelIntersectAction.toLowerCase() == "trim")) || this.model.adaptiveRendering) {
                    // Loop to find the labels in the axis
                    visibleLabelsLength = axis.visibleLabels.length;
                    for (var i = 0; i < visibleLabelsLength && this.model.AreaType == 'cartesianaxes'; i++) {
                        if (targetid == svgId + '_' + hAxes[j].name + '_XLabel_' + i) {
                            var ele = axis.visibleLabels[i];
                            var str = ele.Text == ele.displayText ? "" : ele.Text;
                            if (str == "") break;
                            if (axis.labelPosition.toLowerCase() == 'inside') {
                                this._hideTooltip();
                                this._removeTrackBall();
                            }
                            this.showAxisTooltip(evt.pageX, evt.pageY, str, ele.displayText);
                }
            }
                }
            }
            for (i = 0; i < this.model.series.length; i++) {
                if (this.model.series[i]._enableSmartLabels && !this.model.enable3D) {
                    var template = this.model.series[i].marker.dataLabel.template;
                    var font = this.model.series[i].marker.dataLabel.font;
                    if (this.model.AreaType == "none" && BoldBIDashboard.util.isNullOrUndefined(template)) {
                        this.datalabelTooltip(evt, i, font);
                    }                    
                }
            }           
        if (bbdesigner$(this.svgObject).find(id + '_ResetZoom,' + id + '_PanBtn,' + id + '_ZoomBtn').length > 0) {
            bbdesigner$(this.svgObject).find(id + '_ResetZoom,' + id + '_PanBtn,' + id + '_ZoomBtn').appendTo(this.svgObject);
        }

        var legenddata = this.getLegendData(evt);
        if (legenddata) {
            var commonLegendMoveEventArgs = bbdesigner$.extend({}, BoldBIDashboard.EjSvgRender.commonChartEventArgs);
            commonLegendMoveEventArgs.data = legenddata;
            if (legenddata.series.highlightSettings.enable) {
                if (this.model.enableCanvasRendering) {
                    var series = bbdesigner$.extend({}, legenddata.series);
                    series.seriesIndex = legenddata.legendItem.LegendItem.SeriesIndex;
                    series.pointIndex = legenddata.legendItem.LegendItem.PointIndex;
                    var index = this.model.AreaType == 'none' ? series.pointIndex : series.seriesIndex;
                    if (bbdesigner$('#' + chart._id + '_Selection_Legend' + index + '_canvas').length == 0) {
                        //remove canvas legend highlight 
                        bbdesigner$("[id*=" + this._id + "_Highlight_" + "]").remove();
                        this.canvasHighlight(chart, evt, series, legenddata);                
                    }
                }
                else
                    this.highlight(chart, evt, legenddata.series, legenddata);
            }
            this._trigger("legendItemMouseMove", commonLegendMoveEventArgs);
            if (model.enableCanvasRendering){
                    var mouseMoveCords = this.calMousePosition(evt),
                        mousemoveX = mouseMoveCords.X,
                        mousemoveY = mouseMoveCords.Y;
                    bbdesigner$(this.legendContainer).children().css({ "cursor": "pointer" });
                    if ((mousemoveX >= model.LegendBounds.X) && (mousemoveX <= model.LegendBounds.X + model.LegendViewerBounds.Width)) {
                        if ((mousemoveY <= this.model.LegendBounds.Y + (model.LegendViewerBounds.Height)) && (mousemoveY >= model.LegendBounds.Y)) {
                             this._textTooltip(evt, model.legendTextRegion);
                        }
                    }
            }
            else
                this._textTooltip(evt, this.model.legendTextRegion);
        }
        else if (model.enableCanvasRendering)
            bbdesigner$(this.legendContainer).children().css('cursor', 'default');
        if (model.enableCanvasRendering) {

            //condition to find the buttons and display tooltip on hover for Canvas
            if (targetid.indexOf("_ResetZoom") != -1 || parentId.indexOf("_ResetZoom") != -1)
                createBtnTooltip("Reset");
            else if (targetid.indexOf("_PanBtn") != -1 || parentId.indexOf("_PanBtn") != -1)
                createBtnTooltip("Pan");
            else if (targetid.indexOf("_ZoomBtn") != -1 || parentId.indexOf("_ZoomBtn") != -1)
                createBtnTooltip("Zoom");
            else if (targetid.indexOf("_ZoomInBtn") != -1 || parentId.indexOf("_ZoomInBtn") != -1)
                createBtnTooltip("Zoom In");
            else if (targetid.indexOf("_ZoomOutBtn") != -1 || parentId.indexOf("_ZoomOutBtn") != -1)
                createBtnTooltip("Zoom Out");
            this._textTooltip(evt, this.model.xAxisLabelRegions);
            this._textTooltip(evt, this.model.yAxisLabelRegions);
        }
        
        var proxy = this;
        if (model.xAxisTitleRegion) {
            var currentX = this.mousemoveX;
            var currentY = this.mousemoveY;
            bbdesigner$.each(model.xAxisTitleRegion, function (index, regionItem) {
                if ((currentX >= regionItem.Bounds.X) && (currentX <= regionItem.Bounds.X + regionItem.Bounds.Width)) {
                    if ((currentY >= regionItem.Bounds.Y - (regionItem.Bounds.Height)) && (currentY <= regionItem.Bounds.Y)) {
					    if (regionItem.trimText != regionItem.labelText) {
                        proxy.showAxisTooltip(evt.pageX, evt.pageY, regionItem.labelText);
					   }
                    }
                }
            });
        }
        if (this.model.yAxisTitleRegion) {
            var currentX = this.mousemoveX;
            var currentY = this.mousemoveY;
            bbdesigner$.each(this.model.yAxisTitleRegion, function (index, regionItem) {
                 if ((currentX >= regionItem.Bounds.X) && (currentX <= regionItem.Bounds.X + regionItem.Bounds.Width)) {
                    if ((currentY >= regionItem.Bounds.Y - (regionItem.Bounds.Height)) && (currentY <= regionItem.Bounds.Y)) {
					    if (regionItem.trimText != regionItem.labelText) {
                        proxy.showAxisTooltip(evt.pageX, evt.pageY, regionItem.labelText);
						}
                    }
                }
            });
        }
	   //chartMouseMove event
	   var commonEventArgs = bbdesigner$.extend({}, BoldBIDashboard.EjSvgRender.commonChartEventArgs);
	   commonEventArgs.data = { location: { x: this.mousemoveX, y: this.mousemoveY },size:{height:this.model.svgHeight,width:this.model.svgWidth}, id: evt.target.id, pageX: evt.pageX, pageY: evt.pageY };
	   this._trigger("chartMouseMove", commonEventArgs);

        if (this.model.chartTitleRegion) {
            var currentX = this.mousemoveX;
            var currentY = this.mousemoveY
            regionItem = this.model.chartTitleRegion;
            if ((currentX >= regionItem.Bounds.X) && (currentX <= regionItem.Bounds.X + regionItem.Bounds.Width)) {
                if ((currentY >= regionItem.Bounds.Y - (regionItem.Bounds.Height)) && (currentY <= regionItem.Bounds.Y)) {
                    if (regionItem.trimText != regionItem.labelText) {
                        proxy.showAxisTooltip(evt.pageX, evt.pageY, regionItem.labelText, regionItem.trimText);
                    }
                }
            }
        }

        if (this.model.chartSubTitleRegion) {
            var currentX = this.mousemoveX;
            var currentY = this.mousemoveY
            regionItem = this.model.chartSubTitleRegion;
            if ((currentX >= regionItem.Bounds.X) && (currentX <= regionItem.Bounds.X + regionItem.Bounds.Width)) {
                if ((currentY >= regionItem.Bounds.Y - (regionItem.Bounds.Height)) && (currentY <= regionItem.Bounds.Y)) {
                    if (regionItem.trimText != regionItem.labelText) {
                        proxy.showAxisTooltip(evt.pageX, evt.pageY, regionItem.labelText);
                    }
                }
            }
        }
    },
    _hideTooltip: function () {
        bbdesigner$("#" + this.svgObject.id).find("#" + this.svgObject.id + "_TrackToolTip").attr('visibility','hidden');
        bbdesigner$("#" + this.svgObject.id + "_TrackToolTip").attr('visibility', 'hidden').hide();
        bbdesigner$('.tooltipDiv').css("display", "none");
    },
    _removeHighlight: function () {
        bbdesigner$("[id*=" + "HighlightSegment" + "]").remove();
        bbdesigner$("[id*=" + "HighlightPath" + "]").remove();
        bbdesigner$("[id*=" + "HighlightLegendSegment" + "]").remove();
        bbdesigner$("[id*=" + "HighlightLegendPath" + "]").remove();
        bbdesigner$("[id*=" + "HighlightDef" + "]").remove();
	     bbdesigner$("[id*=" + "Highlightseries" + "]").remove();
        bbdesigner$("[id*=" + this._id + "_Highlight_" + "]").remove();
    },
    _removeSelection: function () {
        bbdesigner$("[id*=" + this._id + '_SelectionCluster_Legend' + "]").remove();
        bbdesigner$("[id*=" + this._id + '_Selection_series' + "]").remove();
        bbdesigner$("[id*=" + this._id + '_Selection_Cluster' + "]").remove();
        bbdesigner$("[id*=" +this._id + "SelectionSegment" + "]").remove();
        bbdesigner$("[id*=" +this._id + "SelectionPath" + "]").remove();
        bbdesigner$("[id*=" +this._id + "SelectionLegend" + "]").remove();
        bbdesigner$("[id*=" +this._id + "SelectionDef" + "]").remove();
	     bbdesigner$("[id*=" + this._id +"Selectionseries" + "]").remove();
        bbdesigner$('[id*=' + this._id + '_Selection_' + ']').remove();
    },

     
     //tooltip for trimmed datalabel
    datalabelTooltip:function(evt, i, font){
        var mouseMoveCords = this.calMousePosition(evt);
        this.mousemoveX = mouseMoveCords.X;
        this.mousemoveY = mouseMoveCords.Y;
		var containerId = this._id;
        var currentX = this.mousemoveX;
        var currentY = this.mousemoveY;
        var vmlRendering = this.vmlRendering;
        var space = this.model.elementSpacing;
        var chart = this;
        var minX, minY, maxX, maxY, left;
        var tooltipdiv, tooltipLength;
        var remaining
		  if(!BoldBIDashboard.util.isNullOrUndefined(this.accDataLabelRegion[i]))
        {
      bbdesigner$.each(this.accDataLabelRegion[i], function (index, regionItem) {
            minX = regionItem.bounds.minX;
            minY = regionItem.bounds.minY;
            maxX = regionItem.bounds.maxX;
            maxY = regionItem.bounds.maxY;            
            if (vmlRendering) {
                minX = regionItem.bounds.minX + (regionItem.bounds.width / 2);
                maxX = regionItem.bounds.maxX + (regionItem.bounds.width / 2);
                minY = regionItem.bounds.minY;
                maxY = regionItem.bounds.maxY;
            }
            if (currentX >= minX && currentX <= maxX) {
                if (currentY >= minY && currentY <= maxY) {
                    tooltipdiv = bbdesigner$("<div></div>").attr('id', containerId + "_tooltip");
                    if (regionItem.trimmedText != regionItem.text) {
                     bbdesigner$("#"+chart.svgObject.id+"_TrackToolTip").hide();
                        bbdesigner$(tooltipdiv).html(regionItem.text);
                        bbdesigner$(document.body).append(tooltipdiv);
                        tooltipLength = BoldBIDashboard.EjSvgRender.utils._measureText(regionItem.text, regionItem.text.length, regionItem.font).width;
                        bbdesigner$(tooltipdiv).css({
                            "top": evt.pageY + space,
                            "display": "block",
                            "position": "absolute",
                            "z-index": "13000",
                            "cursor": "default",
                            "color": "#000000",
                            "font-size": font.size,
                            "background-color": "#FFFFFF",
                            "border": "1px solid #707070",
                            "white-space": "nowrap",
                            "padding": "5px"
                        });
                        if (regionItem.type == "pyramid" || regionItem.type == "funnel") {
                            remaining = chart.model.m_AreaBounds.Width + chart.model.m_AreaBounds.X - evt.pageX;
                            if (remaining > tooltipLength)
                                bbdesigner$(tooltipdiv).css({ "left": evt.pageX + space });
                            else {
                                left = evt.pageX - tooltipLength+(2*space);
                                bbdesigner$(tooltipdiv).css({ "left": left  });

                            }
                        }
                        if (regionItem.type == "pie" || regionItem.type == "doughnut") {
                            if (minX > regionItem.bounds.centerX) {
                                remaining = chart.svgWidth - chart.model.margin.left - chart.model.margin.right - currentX;
                                if (remaining < tooltipLength) {
                                    left = evt.pageX - tooltipLength;
                                    bbdesigner$(tooltipdiv).css({ "left": left + space });
                                }
                                else
                                    bbdesigner$(tooltipdiv).css({ "left": evt.pageX + space });
                            }
                            else {
                                
                                    bbdesigner$(tooltipdiv).css({ "left": evt.pageX + space });                               
                            }
                        }                       

                    }
                }
            }
        });
		}
    },
    // Tooltip in svg 
      showAxisTooltip: function (pageX, pageY, str,trimmedText) {
	        var id = this._id;
            var tooltipdiv = bbdesigner$("<div></div>").attr('id', id + "_tooltip");
            bbdesigner$(tooltipdiv).html("&nbsp" + str + "&nbsp");
            var font = this.model.title.font;
            var labelTextWidth = BoldBIDashboard.EjSvgRender.utils._measureText(str, null, font).width;
            var trimmedTextWidth = BoldBIDashboard.EjSvgRender.utils._measureText(trimmedText, null, font).width;
            var textWidth = trimmedTextWidth <= labelTextWidth ? labelTextWidth : trimmedTextWidth;
            bbdesigner$(document.body).append(tooltipdiv);
            // adding css prop to the div
            bbdesigner$(tooltipdiv).css({
                "left": this.model.title.isReversed || this.model.primaryXAxis.isInversed ? pageX - textWidth: pageX + 10,
                "top": pageY + 10,
                "display": "block",
                "position": "absolute",
                "z-index": "13000",
                "cursor": "default",
                "font-family": "Segoe UI",
                "color": "#707070",
                "font-size": "12px",
                "background-color": "#FFFFFF",
                "border": "1px solid #707070"
            });
        },
    _textTooltip: function(evt,region){
		var chart = this,
            mouseMoveCords = this.calMousePosition(evt),
            isEjScroll = this.model.legend._BoldBIDashboardScroller,
            scrolltop = isEjScroll ? bbdesigner$("#legend_" + this._id).BoldBIDashboardScroller('instance').model.scrollTop : bbdesigner$("#legend_" + this._id).scrollTop(),
            scrollleft = isEjScroll ? bbdesigner$("#legend_" + this._id).BoldBIDashboardScroller('instance').model.scrollLeft : bbdesigner$("#legend_" + this._id).scrollLeft(),    
            mousemoveX = mouseMoveCords.X,
            mousemoveY = mouseMoveCords.Y,
            currentX = mousemoveX,
            currentY = mousemoveY,
            containerId = this._id,
            chartModel = chart.model,
            legend = chartModel.legend,
			isRTL = legend.isReversed,
            isScroll = legend.enableScrollbar,
            textOverflow = legend.textOverflow.toLowerCase(),
            displayText, tooltipdiv;
        
            if (isScroll || isEjScroll) {
                currentX = mousemoveX + scrollleft;
                currentY = mousemoveY + scrolltop;
            }
           
        bbdesigner$.each(region, function (index, regionItem) {             
            
            if ((currentX >= regionItem.bounds.x) && (currentX <= regionItem.bounds.x + regionItem.bounds.width)) {
                if ((currentY >= regionItem.bounds.y - (regionItem.bounds.height/3)) && (currentY <= regionItem.bounds.y)) {                    
                   
                    bbdesigner$("#" + containerId + "_tooltip").remove();
                    tooltipdiv = bbdesigner$("<div></div>").attr('id', containerId + "_tooltip");
                    displayText = bbdesigner$.type(regionItem.trimText) == "array" ? regionItem.trimText.join(" ") : regionItem.trimText;
                    if (displayText != regionItem.labelText) {
                            bbdesigner$(tooltipdiv).html("&nbsp" + regionItem.labelText + "&nbsp");
                            bbdesigner$(document.body).append(tooltipdiv);
                            // adding css prop to the div
                            bbdesigner$(tooltipdiv).css({
                                "left": isRTL? evt.pageX - regionItem.bounds.width - 15 : evt.pageX + 10,
                                "top": evt.pageY + 10,
                                "display": "block",
                                "position": "absolute",
                                "z-index": "13000",
                                "cursor": "default",
                                "font-family": "Segoe UI",
                                "color": "#707070",
                                "font-size": "12px",
                                "background-color": "#FFFFFF",
                                "border": "1px solid #707070"
                            });
                    }       
                }
            }
        });
    },
    pieExplosion: function (data) {
        var region = data;
        var id;
        var targetElement;
        var symbolName;
        var series = region.region.Series;
        var seriesIndex = region.region.SeriesIndex;
        var seriesType = new BoldBIDashboard.seriesTypes[series.type.toLowerCase()]();
        var explodePoint = series.explodeIndex;
        var _labelPosition = series.labelPosition.toLowerCase();
        currentExplodePoint = { SeriesIndex: region.pointData[0].SeriesIndex, PointIndex: region.pointData[0].Index };
        if (!BoldBIDashboard.util.isNullOrUndefined(region.region.Series._visiblePoints[region.pointData[0].Index]) && explodePoint != region.region.Series._visiblePoints[region.pointData[0].Index].actualIndex && !region.region.Series.explodeAll) {
            series.explodeIndex = region.region.Series._visiblePoints[region.pointData[0].Index].actualIndex;

            if (!BoldBIDashboard.util.isNullOrUndefined(this.model.explodeValue)&& this.model.explodeValue != currentExplodePoint) {
                if (this.model.explodeValue.SeriesIndex != region.region.SeriesIndex)
                   series = this.model._visibleSeries[this.model.explodeValue.SeriesIndex];
                var result = seriesType._calculateArcData(this, this.model.explodeValue.Index, series._visiblePoints[this.model.explodeValue.Index], series, this.model.explodeValue.SeriesIndex);
                id = this.svgObject.id + '_SeriesGroup' + '_' + this.model.explodeValue.SeriesIndex;
                
                targetElement = bbdesigner$(this.gSeriesEle).children('#' + id)[0];
                var elements = bbdesigner$(targetElement).children();
                for (var i = 0; i < elements.length; i++) {
                    var element = elements[i];
                    var index = this.svgRenderer._getAttrVal(bbdesigner$(element)[0], "pointIndex");
                    if (parseInt(index) == this.model.explodeValue.PointIndex) {
                        this.svgRenderer._setAttr(bbdesigner$(element), { 'd': result.Direction });
                        break;
                    }
                }
                this.model.explodeOut = true;
              seriesType.drawDataLabelAcc(this,series, this.model.explodeValue.PointIndex, series._visiblePoints[this.model.explodeValue.Index], this.model.explodeValue.SeriesIndex)
              this.model.explodeOut = false;
            }
            this.model.explode = true;
            result = seriesType._calculateArcData(this, region.pointData[0].PointIndex,series._visiblePoints[region.pointData[0].Index], region.region.Series,seriesIndex);
            id = this.svgObject.id + '_SeriesGroup' + '_' + region.region.SeriesIndex;
            targetElement = bbdesigner$(this.gSeriesEle).children('#' + id)[0];
            var elements = bbdesigner$(targetElement).children();
            for (var i = 0; i < elements.length; i++) {
                var element = elements[i];
                var index = this.svgRenderer._getAttrVal(bbdesigner$(element)[0], "pointIndex");
                if (parseInt(index) == region.pointData[0].PointIndex) {
                    this.svgRenderer._setAttr(bbdesigner$(element), { 'd': result.Direction });
                    break;
                }
            }
            if (this.model.enableCanvasRendering) {
                var chartRect = document.getElementById(this.svgObject.id).getClientRects()[0];
                this.svgRenderer.ctx.clearRect(chartRect.left, chartRect.top, chartRect.width, chartRect.height);
                bbdesigner$("#" + this._id).BoldBIDashboardChart("redraw");
            }
            
            seriesType.drawDataLabelAcc(this, series, region.pointData[0].PointIndex, series._visiblePoints[region.pointData[0].Index],seriesIndex)
         
           
            this.model.explodeValue = { SeriesIndex: region.pointData[0].SeriesIndex, PointIndex: region.pointData[0].PointIndex, Index:region.pointData[0].Index };
        }
        region.region.Series.explodeIndex = explodePoint;
    },
    displayTemplateTooltip: function (x, y, location, seriesPoint, series, serIndex, ptIndex, chartLoc) {
        var point = bbdesigner$.extend(true, {}, seriesPoint);
        var padding = 5;
        point.x = point.X;
        if (series.xAxis._valueType.toLowerCase() == "datetime")
            point.x = (BoldBIDashboard.format(new Date(point.X), ((BoldBIDashboard.util.isNullOrUndefined(series.xAxis.labelFormat)) ? BoldBIDashboard.EjSvgRender.utils._dateTimeLabelFormat(series.xAxis.intervalType) : series.xAxis.labelFormat)));
        if (series.xAxis._valueType.toLowerCase() == "category") point.x = BoldBIDashboard.EjSvgRender.utils._getLabelContent(ptIndex, series.xAxis);
        // x and y is set to 0, if undefined
        x = BoldBIDashboard.util.isNullOrUndefined(x) ? 0 : x;
        y = BoldBIDashboard.util.isNullOrUndefined(y) ? 0 : y;
        var templateLocX = this.model.m_AreaBounds.X + chartLoc.left;
        var xLoc = location.X + x + templateLocX + this.model.crosshair.marker.size.width + padding;
        var yLoc = location.Y + y + this.model.m_AreaBounds.Y + chartLoc.top;
        var tooltipdiv;
        if (bbdesigner$("#" + this.svgObject.id + "_TrackToolTipTemplate_" + serIndex).length == 0) {
            tooltipdiv = bbdesigner$("<div class='TrackToolTipTemplate' style='position: absolute; z-index: 13000; display: block;'></div>");            
            bbdesigner$(document.body).append(tooltipdiv);
        }
        else {
            bbdesigner$(document).find('[id*="_TrackToolTipTemplate_"]').css("display", "block");
            tooltipdiv = bbdesigner$("#" + this.svgObject.id + "_TrackToolTipTemplate_" + serIndex)
            tooltipdiv.empty();
        }
        
        this.svgRenderer._setAttr(bbdesigner$(tooltipdiv), { "id": this.svgObject.id + "_TrackToolTipTemplate_" + serIndex });
        if (this.model.crosshair.tooltipTemplate != null) {            
            var cloneNode = bbdesigner$("#" + this.model.crosshair.tooltipTemplate).clone();
            bbdesigner$(cloneNode).css("display", "block").appendTo(tooltipdiv);
            series.count = 1;
            point.count = 1;
            var seriesColor = this.getSeriesColor(point, serIndex, series);
            bbdesigner$(tooltipdiv).css("background-color", bbdesigner$.type(seriesColor) == "array" ? seriesColor[0].color : seriesColor);
            var data = { series: series, point: point };
            bbdesigner$(tooltipdiv).html(bbdesigner$(tooltipdiv).html().parseTemplate(data));
        }
        yLoc -= parseFloat(bbdesigner$(tooltipdiv).css('height')) / 2;
        var templateWidth = parseFloat(bbdesigner$(tooltipdiv).css('width'));
        if (xLoc + templateWidth > templateLocX + this.model.m_AreaBounds.Width)
            xLoc = location.X + x + templateLocX - this.model.crosshair.marker.size.width - padding - templateWidth;
        bbdesigner$(tooltipdiv).css("left", xLoc);
        bbdesigner$(tooltipdiv).css("top", yLoc);
    },

    displayAxisTooltip: function (location, text, axis, index, mouseLoc) {

        if (axis._valueType.toLowerCase() == "double") {
            var customFormat = (!(axis.labelFormat)) ? null : axis.labelFormat.match('{value}');
            text = (!(axis.labelFormat)) ? text : (customFormat != null) ? (axis.labelFormat == "bbdesigner${value}") ? axis.labelFormat.replace('{value}', 'bbdesigner$' + Number(text)) : axis.labelFormat.replace('{value}', Number(text)) : (BoldBIDashboard.format(Number(text), axis.labelFormat));
        }
        var maxTickSize = 0;
        for (var i = 0; i < this.model._axes.length; i++) {
            if (this.model._axes[i].majorTickLines.size > maxTickSize) {
                maxTickSize = this.model._axes[i].majorTickLines.size;
            }
        }
        var opposedPosition = axis._opposed;
        var isCanvas = this.model.enableCanvasRendering;
        var isCartesian = this.model.AreaType == "cartesianaxes" ? true : false;
        if (!isCanvas)
            var chartArea = isCartesian ? document.getElementById(this.svgObject.id + "_ChartArea").getBoundingClientRect() : document.getElementById(this.svgObject.id).getBoundingClientRect();
        var axisX = chartArea ? chartArea.left : axis.x;
        var maxLocation = opposedPosition ? ((maxTickSize + 10) + (axisX + axis.width)) : (axisX + axis.width);
        var leftScroll = bbdesigner$("#ScrollerParent_" + 'vertical' + "_" + axis.rowIndex + "_" + this._id).length > 0;
        var bottomScroll = bbdesigner$("#ScrollerParent_" + 'horizontal' + "_" + axis.columnIndex + "_" + this._id).length > 0;
        if (location.X >= 0 && location.X <= maxLocation) {
            var x = (location.X);
            var y = location.Y;
            var padding = 5;
            var commonTrackTextArgs = bbdesigner$.extend({}, BoldBIDashboard.EjSvgRender.commonChartEventArgs);
            commonTrackTextArgs.data = { axisIndex: index, chartAxis: axis, currentTrackText: text, location: mouseLoc };
            this._trigger("trackAxisToolTip", commonTrackTextArgs);

            var trackAxisText = commonTrackTextArgs.data.currentTrackText;

            var textOffset = BoldBIDashboard.EjSvgRender.utils._measureText(trackAxisText, null, axis.crosshairLabel.font);
            if (axis.orientation.toLowerCase() == 'horizontal') {
                x = x - textOffset.width / 2;
                if (axis.labelPosition == 'inside' || (opposedPosition ? mouseLoc.y < axis.y : mouseLoc.y > axis.y)) {
                    if (opposedPosition == false) {
                        y = axis.y - textOffset.height + padding + maxTickSize - (bottomScroll ? this.model.scrollerSize : 0);
                    }
                    if (opposedPosition == true) {
                        y = axis.y + textOffset.height + padding - maxTickSize;
                    }
                }
                else{                   
                    if (opposedPosition == true) {
                      y = axis.y - textOffset.height/2 + padding - maxTickSize;  
                    }
                    if (opposedPosition == false) {
                        y = axis.y + textOffset.height - padding + maxTickSize;
                    }
                }
                y = y + ((bottomScroll && !axis.opposedPosition) ? this.model.scrollerSize : 0);

            }
            if (!(opposedPosition) && (x + textOffset.width) > (this.model.m_AreaBounds.Width + this.model.m_AreaBounds.X)) {
                x = ((this.model.m_AreaBounds.Width + this.model.m_AreaBounds.X) - textOffset.width) + padding + this.model.elementSpacing;
            }
            if (axis.orientation.toLowerCase() == 'vertical') {
			     y = location.Y + textOffset.height / 4;
			     if (axis.labelPosition == 'inside' || (!opposedPosition && mouseLoc.x < axisX)) {
                    if (opposedPosition == true) {
                        x = axisX - textOffset.width - maxTickSize;
                    }
                    if (opposedPosition == false) {
                        x = axisX + padding + (leftScroll ? this.model.scrollerSize : 0);
                    }
                } else {
                    if (opposedPosition == true) {
                         x = axisX + padding;
                    }
                    if (opposedPosition == false) {
                        x = axisX - textOffset.width - maxTickSize;
                    }
                }                
                x = x - ((leftScroll && !axis.opposedPosition) ? this.model.scrollerSize : 0);
            }

            var textAxisOptions = {
                'id': this.svgObject.id + '_AxisToolTipText' + '_' + index,
                'x': x,
                'y': y,
                'fill': axis.crosshairLabel.font.color,
                'font-size': axis.crosshairLabel.font.size,
                'font-family': axis.crosshairLabel.font.fontFamily,
                'font-style': axis.crosshairLabel.font.fontStyle,
                'font-weight': axis.crosshairLabel.font.fontWeight,
                'text-anchor': 'start',
                'opacity': axis.crosshairLabel.font.opacity
              
            };

            var fontSize = BoldBIDashboard.EjSvgRender.utils._measureText(commonTrackTextArgs.data.currentTrackText, this.model.m_AreaBounds.Width, axis.crosshairLabel.font);
            var crosshairLabel = axis.crosshairLabel;
             var toolAxisRectOptions = {
                'id': this.svgObject.id + '_AxisToolTipRect' + '_' + index,
                'x': (x - padding),
                'y': (y - (fontSize.height)),
                'width': (fontSize.width) + (2* padding),
                'height': (2*fontSize.height)-(2*padding),
                'rx': crosshairLabel.rx,
                'ry': crosshairLabel.ry,
                'fill': crosshairLabel.fill,
                'stroke-width': crosshairLabel.border.width,
                'stroke': crosshairLabel.border.color
            };
             var axes = this.model._axes[index];
            if ((mouseLoc.y < (axes.y +axes.height) && mouseLoc.y > axes.y)||(mouseLoc.x < (axes.x + axes.width) && mouseLoc.x > axes.x)) {
                     this.svgRenderer._setAttr(bbdesigner$('#' + this.svgObject.id + '_AxisToolTipRect' + '_' + index), { "display": 'block' });
                     this.svgRenderer._setAttr(bbdesigner$('#' + this.svgObject.id + '_AxisToolTipText' + '_' + index), { "display": 'block' });
                     toolAxisRectOptions.display = 'block';
                 }
            else {
                     this.svgRenderer._setAttr(bbdesigner$('#' + this.svgObject.id + '_AxisToolTipRect' + '_' + index), { "display": 'none' });
                     this.svgRenderer._setAttr(bbdesigner$('#' + this.svgObject.id + '_AxisToolTipText' + '_' + index), { "display": 'none' });
                     toolAxisRectOptions.display = 'none';
                 }
             if (!this.model.enableCanvasRendering) {
             this.svgRenderer.drawRect(toolAxisRectOptions, this.gTrackAxisEle);
             this.svgRenderer.drawText(textAxisOptions, commonTrackTextArgs.data.currentTrackText, this.gTrackAxisEle);
             }else
                 this.svgRenderer.drawCrosshairlabel(toolAxisRectOptions, textAxisOptions, commonTrackTextArgs.data.currentTrackText);
        }
    },
    displayTooltip: function (location, point, series, pointIndex, tgap,maxWidth) {
        var seriesIndex = bbdesigner$.inArray(series, this.model._visibleSeries),
            Axis = { X1: this.model.m_AreaBounds.X, Y1: (this.model.m_AreaBounds.Y + this.model.m_AreaBounds.Height), X2: (this.model.m_AreaBounds.X + this.model.m_AreaBounds.Width), Y2: this.model.m_AreaBounds.Y },
            axes = this.model._axes, pointXAxis = series._xAxisName, pointYAxis = series._yAxisName;
        var isRTL = this.model.crosshair.isReversed;
        for (var j = 0, len = axes.length; j < len; j++) {
            if (pointXAxis == axes[j].name) {
                if(!series._isTransposed)
                    Axis.X1 = axes[j].Location.X1, Axis.X2 = axes[j].Location.X2;
                else
                    Axis.Y1 = axes[j].Location.Y1, Axis.Y2 = axes[j].Location.Y2;
            }
            else if (pointYAxis == axes[j].name) {
                if (!series._isTransposed)
                    Axis.Y1 = axes[j].Location.Y1, Axis.Y2 = axes[j].Location.Y2;
                else
                    Axis.X1 = axes[j].Location.X1, Axis.X2 = axes[j].Location.X2;
            }
        }
       if(location.X>=Axis.X1 && location.X <=Axis.X2 && location.Y>= Axis.Y2 && location.Y<=Axis.Y1 ){
           var  requireInvertedAxes = this.model.requireInvertedAxes, x = location.X + (!series.isIndicator ? ((BoldBIDashboard.util.isNullOrUndefined(series._trackMarker)) ? series.marker.size.width : (series._trackMarker.size.width)) : 0) + padding + 1, y = (location.Y), format = series.tooltip.format, numberToFixed = ((BoldBIDashboard.util.isNullOrUndefined(series.yAxis.roundingPlaces)) ? 2 : series.yAxis.roundingPlaces), trackTooltipText = this.getTooltipFormat(point, series, seriesIndex, pointIndex, format, numberToFixed), seriesName = (series.name) ? (series.name).replace(' ', '') : "series" + seriesIndex, commonTrackTextArgs = bbdesigner$.extend({}, BoldBIDashboard.EjSvgRender.commonChartEventArgs);
            commonTrackTextArgs.data = { Location : {X: x, Y: y}, Series:series, serIndex: seriesIndex, pointIndex: pointIndex, currentText: trackTooltipText.text };
            this._trigger("trackToolTip", commonTrackTextArgs);
            if (!commonTrackTextArgs.cancel) {
                x = commonTrackTextArgs.data.Location.X;
                y = commonTrackTextArgs.data.Location.Y;
                var padding = this.model.tooltipPadding, tip_pos = tgap, rectOptions = series.tooltip, font = rectOptions.font ? bbdesigner$.extend(false, series.font, {}, rectOptions.font) : series.font, textOffset = BoldBIDashboard.EjSvgRender.utils._measureText(commonTrackTextArgs.data.currentText, series.xAxis.width, font), seriesColor = this.getSeriesColor(point, seriesIndex, series), toolTipOptions = this.getTooltipOptions(seriesColor, series), rectBorderColor = toolTipOptions.rectBColor, rectFillColor = toolTipOptions.rectFColor, textColor = toolTipOptions.rectTextColor, rectWidth = textOffset.width + (2 * padding), rectHeight = textOffset.height + (2 * padding), poly, tipOpen = (requireInvertedAxes) ? ((rectWidth * 10) / 100) : ((rectHeight * 30) / 100), marker_width = 3 + this.model.crosshair.marker.border.width + ((!requireInvertedAxes) ? this.model.crosshair.marker.size.width : this.model.crosshair.marker.size.height) / 2, swp = marker_width + 10, tipOpen = (Math.abs(tgap) == 0) ? (tipOpen) : tipOpen / 2, axisWidth = (requireInvertedAxes) ? series.yAxis.width : series.xAxis.width, tooltipStartPosition = (requireInvertedAxes) ? (tgap + location.X - rectWidth / 2) : (tgap + location.Y - rectHeight / 2), tooltipEndPosition = (requireInvertedAxes) ? (tgap + location.X + rectWidth / 2) : (tgap + location.Y + rectHeight / 2), boundryStart = (requireInvertedAxes) ? (this.model.m_AreaBounds.X) : (this.model.m_AreaBounds.Y), boundryEnd = (requireInvertedAxes) ? (this.model.m_AreaBounds.X + this.model.m_AreaBounds.Width) : (this.model.m_AreaBounds.Y + this.model.m_AreaBounds.Height), text_pos = [];
                if (tooltipStartPosition >= boundryStart && tooltipEndPosition <= (boundryEnd)) {
                    if (requireInvertedAxes) {
                        if (location.Y - swp - maxWidth< this.model.m_AreaBounds.Y) {
                            var x1 = location.X - tipOpen + tip_pos, y1 = location.Y + swp, x0 = location.X, y0 = location.Y, deg = Math.atan2((y1 - y0), (x1 - x0)), xn = x0 + (tgap == 0 ? 0 : (marker_width * Math.cos(deg))), yn = y0 + (tgap == 0 ? marker_width : (marker_width * Math.sin(deg)));
                            poly = (location.X - tipOpen + tip_pos) + " " + (location.Y + swp) + " " + (xn) + " " + (yn) + " " + (location.X + tipOpen + tip_pos) + " " + (location.Y + swp) + " " + (location.X + rectWidth / 2 + tip_pos) + " " + (location.Y + swp) + " " + (location.X + rectWidth / 2 + tip_pos) + " " + (location.Y + swp + rectHeight) + " " + (location.X - rectWidth / 2 + tip_pos) + " " + (location.Y + swp + rectHeight) + " " + (location.X - rectWidth / 2 + tip_pos) + " " + (location.Y + swp) + " " + (location.X - tipOpen + tip_pos) + " " + (location.Y + swp) + " " + (location.X - tipOpen + tip_pos) + " " + (location.Y + swp);
                            text_pos.push({ X: location.X - rectWidth / 2 + padding + tip_pos, Y: location.Y + swp+rectHeight/2-padding});
                        } else {
                            var x1 = location.X - tipOpen + tip_pos, y1 = location.Y - swp, x0 = location.X, y0 = location.Y, deg = Math.atan2((y1 - y0), (x1 - x0)), xn = x0 + (tgap == 0 ? 0 : (marker_width * Math.cos(deg))), yn = y0 + (tgap == 0 ? -marker_width : (marker_width * Math.sin(deg)));
                            poly = (location.X - tipOpen + tip_pos) + " " + (location.Y - swp) + " " + (xn) + " " + (yn) + " " + (location.X + tipOpen + tip_pos) + " " + (location.Y - swp) + " " + (location.X + rectWidth / 2 + tip_pos) + " " + (location.Y - swp) + " " + (location.X + rectWidth / 2 + tip_pos) + " " + (location.Y - swp - rectHeight) + " " + (location.X - rectWidth / 2 + tip_pos) + " " + (location.Y - swp - rectHeight) + " " + (location.X - rectWidth / 2 + tip_pos) + " " + (location.Y - swp) + " " + (location.X - tipOpen + tip_pos) + " " + (location.Y - swp) + " " + (location.X - tipOpen + tip_pos) + " " + (location.Y - swp);
                            text_pos.push({ X: location.X - rectWidth / 2 + padding + tip_pos, Y: location.Y - swp-rectHeight/2-padding});
                        }
                    }
                    else {
                        if (location.X + swp + maxWidth - this.model.m_AreaBounds.X >= axisWidth || isRTL) {                         
                            if (location.X - maxWidth - (2*padding) <= this.model.m_AreaBounds.X && isRTL) {
                                var x1 = location.X + swp, y1 = location.Y - tipOpen + tip_pos, x0 = location.X, y0 = location.Y, deg = Math.atan2((y1 - y0), (x1 - x0)), xn = x0 + (tgap == 0 ? marker_width : (marker_width * Math.cos(deg))), yn = y0 + (tgap == 0 ? 0 : (marker_width * Math.sin(deg)));
                                poly = (location.X + swp) + " " + (location.Y + tip_pos - tipOpen) + " " + (xn) + " " + yn + " " + (location.X + swp) + " " + (location.Y + tip_pos + tipOpen) + " " + (location.X + swp) + " " + (location.Y + tip_pos + (rectHeight / 2)) + " " + (location.X + swp + rectWidth) + " " + (location.Y + tip_pos + (rectHeight / 2)) + " " + (location.X + swp + rectWidth) + " " + (location.Y + tip_pos - rectHeight / 2) + " " + (location.X + swp) + " " + (location.Y + tip_pos - rectHeight / 2) + " " + (location.X + swp) + " " + (location.Y - tipOpen + tip_pos);
                                text_pos.push({ X: location.X + swp + padding, Y: location.Y + tip_pos + rectHeight / 2 });
                            }
                            else {
                            var x1 = location.X - swp, y1 = location.Y - tipOpen + tip_pos, x0 = location.X, y0 = location.Y, deg = Math.atan2((y1 - y0), (x1 - x0)), xn = x0 + (tgap == 0 ? -marker_width : (marker_width * Math.cos(deg))), yn = y0 + (tgap == 0 ? 0 : (marker_width * Math.sin(deg)));
                            poly = (location.X - swp) + " " + (location.Y - tipOpen + tip_pos) + " " + (xn) + " " + yn + " " + (location.X - swp) + " " + (location.Y + tipOpen + tip_pos) + " " + (location.X - swp) + " " + (location.Y + tip_pos + (rectHeight / 2)) + " " + (location.X - rectWidth - swp) + " " + (location.Y + tip_pos + (rectHeight / 2)) + " " + (location.X - rectWidth - swp) + " " + (location.Y + tip_pos - rectHeight / 2) + " " + (location.X - swp) + " " + (location.Y + tip_pos - rectHeight / 2) + " " + (location.X - swp) + " " + (location.Y - tipOpen + tip_pos);
                            text_pos.push({ X: location.X - swp - rectWidth + padding, Y: location.Y + tip_pos + rectHeight / 2 });
                         }
                          }
                        else {                          
                            var x1 = location.X + swp, y1 = location.Y - tipOpen + tip_pos, x0 = location.X, y0 = location.Y, deg = Math.atan2((y1 - y0), (x1 - x0)), xn = x0 + (tgap == 0 ? marker_width : (marker_width * Math.cos(deg))), yn = y0 + (tgap == 0 ? 0 : (marker_width * Math.sin(deg)));
                            poly = (location.X + swp) + " " + (location.Y + tip_pos - tipOpen) + " " + (xn) + " " + yn + " " + (location.X + swp) + " " + (location.Y + tip_pos + tipOpen) + " " + (location.X + swp) + " " + (location.Y + tip_pos + (rectHeight / 2)) + " " + (location.X + swp + rectWidth) + " " + (location.Y + tip_pos + (rectHeight / 2)) + " " + (location.X + swp + rectWidth) + " " + (location.Y + tip_pos - rectHeight / 2) + " " + (location.X + swp) + " " + (location.Y + tip_pos - rectHeight / 2) + " " + (location.X + swp) + " " + (location.Y - tipOpen + tip_pos);
                            text_pos.push({ X: location.X + swp + padding, Y: location.Y + tip_pos + rectHeight / 2 });
                        }
                    }
                    var tooltipfill = seriesColor;
                    if (typeof (tooltipfill) == "object") {
                        tooltipfill = seriesColor[1].color;
                    }
                 var toolPoly = {
                        'id': this.svgObject.id + '_gTooltip_' + seriesIndex + '_' + pointIndex,
                        'fill': tooltipfill,
                        "stroke-width":"0px",
                        "stroke":series.fill,
                    'fill-opacity': rectOptions.opacity ? rectOptions.opacity : 0.85,
                        'points': poly,
                        'visibility': "visible",
                };
                    var text = commonTrackTextArgs.data.currentText,fontText = text,fontSize = BoldBIDashboard.EjSvgRender.utils._measureText(text, series.xAxis.width, font).height,len;
                if (commonTrackTextArgs.data.currentText.indexOf("<br/>") >= 0) {
                    text = commonTrackTextArgs.data.currentText.split("<br/>");
                    fontText = text[0];
                        if (!requireInvertedAxes) {
                            if (location.X + swp + maxWidth - this.model.m_AreaBounds.X >= axisWidth) {
                                text_pos.push({ X: location.X - rectWidth - swp + padding, Y: ((location.Y + tip_pos) - (rectHeight / 2) + fontSize/text.length) });
                }
                            else {
                                text_pos.push({ X: location.X + swp + padding, Y: ((location.Y + tip_pos) - (rectHeight / 2) + fontSize/text.length) });
                            }
                        }
                        else {
                            if (location.Y - swp - maxWidth < this.model.m_AreaBounds.Y) {
                                text_pos.push({ X: location.X - rectWidth / 2 + padding + tip_pos, Y: location.Y + swp + (fontSize / text.length) });
                            }
                            else {
                                text_pos.push({ X: location.X - rectWidth / 2 + padding + tip_pos, Y: location.Y - swp - rectHeight + (fontSize / text.length)});
                            }
                        }
                        fontSize = 0;
                    }
                    len = text_pos.length - 1;
                    fontSize = (requireInvertedAxes) ? fontSize : -fontSize;
                var textOptions = {
                        'id': this.svgObject.id + '_ToolTipText' + '_' + seriesIndex + "_" + pointIndex,
                        'x': text_pos[len].X,
                        'y': text_pos[len].Y+fontSize/2,
                        'fill':"white",
                    'font-size': font.size,
                    'font-family': font.fontFamily,
                    'font-style': font.fontStyle,
                    'font-weight': font.fontWeight,
                        'text-anchor': 'start',
                };
                    if (this.model.enableCanvasRendering) {
                        this.svgRenderer.draw_tooltip(textOptions, text, padding, toolPoly, font);
                    }
                else {
                        var gTooltip = this.svgRenderer.createGroup({ 'id': this.svgObject.id + '_gTooltip_' + seriesIndex + "_" + pointIndex, });
                        this.svgRenderer.drawPolyline(toolPoly, gTooltip);
                        this.svgRenderer.drawText(textOptions, text, gTooltip, font);
                }              
                    bbdesigner$('#' + this.svgObject.id + '_gTooltip' + '_' + seriesIndex + '_' + pointIndex).attr("visibility", "visible");
                    bbdesigner$('#' + this.svgObject.id + '_gTooltip' + '_' + seriesIndex + '_' + pointIndex).css("visibility", "visible");
            }
            }
            else {              
                bbdesigner$('#' + this.svgObject.id + '_gTooltip' + '_' + seriesIndex + '_' + pointIndex).attr("visibility", "hidden");
                bbdesigner$('#' + this.svgObject.id + '_gTooltip' + '_' + seriesIndex + '_' + pointIndex).css("visibility", "hidden");
            }
            if (bbdesigner$('#' + this.svgObject.id + "_TrackToolTip_" + seriesIndex).length == 0)
                this.svgRenderer.append(bbdesigner$(gTooltip), this.svgObject);
        }
        else {
            bbdesigner$('#' + this.svgObject.id + '_TrackToolTip_' + seriesIndex).remove();
			//Set canvas Trackball tooltip and symbol visibility hidden when tooltip display out of the chartArea
            var trackSymbol="_trackSymbol_"+seriesIndex+"_"+pointIndex;
            bbdesigner$("#" + this._id).find('[id*='+trackSymbol+']').css("visibility", "hidden");
        }
    },
    SmartTooltipPosition: function (SmartTooltipOptions) {
        var InitialRanges = [], length_SmartTooltips = SmartTooltipOptions.length, visibleLocation = [];
        for (var a = 0; a < length_SmartTooltips; a++) {
            InitialRanges[a] = bbdesigner$.extend({}, SmartTooltipOptions[a].StEnd);
            if (SmartTooltipOptions[a].ReqInvertAxis) {
                visibleLocation[a] = SmartTooltipOptions[a].Point.X;
            }
            else {
                visibleLocation[a] = SmartTooltipOptions[a].Point.Y;
            }
        }
        this.ContinousOverlappingPoints(InitialRanges, visibleLocation);
        for (var a = 0; a < length_SmartTooltips; a++) {
            SmartTooltipOptions[a].Tgap = InitialRanges[a].Start - SmartTooltipOptions[a].StEnd.Start;
        }
    },
    ContinousOverlappingPoints: function (TooltipRanges, visibleLocation) {
        var padding = this.model.tooltipPadding, temp = 0, Count = 0, Start = 0, StartPoint = 0, endPoint = TooltipRanges.length - 1, Range = (TooltipRanges[0].End - TooltipRanges[0].Start) + padding, halfHeight, midPos, tRange, kRange;
        temp = TooltipRanges[0].Start + Range;
        Start = TooltipRanges[0].Start;
        for (var i = 0; i < endPoint; i++) {
            if (temp >= TooltipRanges[i + 1].Start) {
                Range = TooltipRanges[i + 1].End - TooltipRanges[i + 1].Start + padding;
                temp += Range;
                Count++;
                if (Count - 1 == endPoint - 1 || i == endPoint - 1) {
                     halfHeight = (temp - Start) / 2;
                     midPos = (visibleLocation[StartPoint] + visibleLocation[i + 1]) / 2;
                     tRange = TooltipRanges[StartPoint].End - TooltipRanges[StartPoint].Start;
                    TooltipRanges[StartPoint].Start = midPos - halfHeight;
                    TooltipRanges[StartPoint].End = TooltipRanges[StartPoint].Start + tRange;
                    for (var k = StartPoint; k > 0; k--) {
                        if (TooltipRanges[k].Start <= TooltipRanges[k - 1].End + padding) {
                            kRange = TooltipRanges[k - 1].End - TooltipRanges[k - 1].Start;
                            TooltipRanges[k - 1].Start = TooltipRanges[k].Start - kRange - padding;
                            TooltipRanges[k - 1].End = TooltipRanges[k - 1].Start + kRange;
                        }
                        else {
                            break;
                        }
                    }
                    for (var j = StartPoint + 1; j <= StartPoint + Count; j++) {
                        tRange = TooltipRanges[j].End - TooltipRanges[j].Start;
                        TooltipRanges[j].Start = TooltipRanges[j - 1].End + padding;
                        TooltipRanges[j].End = TooltipRanges[j].Start + tRange;

                    }
                }

            }
            else {
                Count = i > 0 ? Count : 0;
                if (Count > 0) {
                     halfHeight = (temp - Start) / 2;
                     midPos = (visibleLocation[StartPoint] + visibleLocation[i]) / 2;
                     tRange = TooltipRanges[StartPoint].End - TooltipRanges[StartPoint].Start;
                    TooltipRanges[StartPoint].Start = midPos - halfHeight;
                    TooltipRanges[StartPoint].End = TooltipRanges[StartPoint].Start + tRange;
                    for (var k = StartPoint; k > 0; k--) {
                        if (TooltipRanges[k].Start <= TooltipRanges[k - 1].End + padding) {
                            kRange = TooltipRanges[k - 1].End - TooltipRanges[k - 1].Start;
                            TooltipRanges[k - 1].Start = TooltipRanges[k].Start - kRange - padding;
                            TooltipRanges[k - 1].End = TooltipRanges[k - 1].Start + kRange;
                        }
                        else {
                            break;
                        }
                    }
                    for (var j = StartPoint + 1; j <= StartPoint + Count; j++) {
                        tRange = TooltipRanges[j].End - TooltipRanges[j].Start;
                        TooltipRanges[j].Start = TooltipRanges[j - 1].End + padding;
                        TooltipRanges[j].End = TooltipRanges[j].Start + tRange;
                    }
                    Count = 0;
                }
                Range = (TooltipRanges[i + 1].End - TooltipRanges[i + 1].Start + padding);
                temp = TooltipRanges[i + 1].Start + Range;
                Start = TooltipRanges[i + 1].Start;
                StartPoint = i + 1;
            }

        }
    },
    getTooltipOptions: function (seriesColor, series) {
        var rectBorderColor, rectFillColor, rX, rY, textColor;
        if (this.model.theme.indexOf("gradient") >= 0) {
            rectBorderColor = bbdesigner$.type(seriesColor) == "array" ? seriesColor[0].color : seriesColor;
            rectFillColor = 'white';
            textColor = "#333333";
            rX = 5;
            rY = 5;

        } else {
            var type = series.type.toLowerCase();
            if (type.indexOf("column") == -1 && type.indexOf("waterfall") == -1 && type.indexOf("bar") == -1 && type != "rangearea" && this.model.AreaType != "none") {
                rectFillColor = bbdesigner$.type(seriesColor) == "array" ? seriesColor[0].color : seriesColor;
                rectBorderColor = 'transparent';
                textColor = "white";
            } else {
                rectBorderColor = "#333333";
                rectFillColor = 'white';
                textColor = "#333333";
            }
            rX = 0;
            rY = 0;
        }
        return { rectBColor: rectBorderColor, rectFColor: rectFillColor, rectTextColor: textColor, rectX: rX, rectY: rY };
    },
    getSeriesColor: function (point, seriesIndex, series) {
        var seriesColor;
        if (series && !series.isIndicator && !series.isTrendLine) {
            if (point._hiloFill) {
                if (!point._hiloFill._gradientStop)
                    seriesColor = point._hiloFill;
                else {
                    seriesColor = point._hiloFill._gradientStop[0].color;
                }
            }
            else if (point.fill) {
                if (!point.fill._gradientStop)
                    seriesColor = point.fill;
                else {
                    seriesColor = point.fill._gradientStop[0].color;
                }
            }
            else {
                if (series.type.toLowerCase() == "waterfall" && series.positiveFill &&
                    ((point.y > 0 && !point.showIntermediateSum && !point.showTotalSum) || point.waterfallSum > 0))
                    seriesColor = series.positiveFill;
                else
                    seriesColor = this.model.seriesColors[seriesIndex];
                
            }
        } else {
            seriesColor = series.fill;
        }
        return seriesColor;
    },
    getTooltipFormat: function (seriesPoint, series, serIndex, ptIndex, format) {
         var point = bbdesigner$.extend(true, {}, seriesPoint),
            areaType = this.model.AreaType,
            xAxis = series.xAxis,
            yAxis = series.yAxis,
            xAxisValueType = xAxis._valueType.toLowerCase(),
            nullorundefined = BoldBIDashboard.util.isNullOrUndefined,
            xAxisLabelFormat = xAxis.labelFormat,
            yAxisLabelFormat = yAxis.labelFormat,
            dateTimeFormat = BoldBIDashboard.EjSvgRender.utils._dateTimeLabelFormat,
            decimalPlaces = BoldBIDashboard.EjSvgRender.utils._decimalPlaces,
            xGlobalize = false, yGlobalize = false,
            xFormat,yFormat,
            customFormat, data;
        series.count = 1;
        point.count = 1;
		while (format.indexOf('BoldBIDashboard.format(') >= 0) {
            substr = format.substring(format.indexOf('BoldBIDashboard.format('), format.indexOf(")") + 1);
            var calculate = substr.substring(substr.indexOf('(') + 1, substr.indexOf(","));
            if (calculate == "#point.x#") {
                xGlobalize = true,
                xFormat = substr.substring(substr.indexOf(',') + 1, substr.indexOf(")"));
            }
            else if (calculate == "#point.y#") {
                yGlobalize = true,
                yFormat = substr.substring(substr.indexOf(',') + 1, substr.indexOf(")"));
            } else {
                globalizeformat = substr.substring(substr.indexOf(',') + 1, substr.indexOf(")"));
                subStr1 = calculate.substring(calculate.indexOf('#') + 1);
                val = subStr1.substring(subStr1.indexOf('.') + 1, subStr1.indexOf('#'));
                if (point.hasOwnProperty(val) && point[val])
                    point[val] = BoldBIDashboard.format(point[val], globalizeformat);
            }
            format = format.replace(substr, calculate)
        }
		if (areaType == "cartesianaxes") {
            if (xAxisValueType.toLowerCase() == "datetime"){
                point.x = (BoldBIDashboard.format(new Date(point.xValue), ((nullorundefined(xAxisLabelFormat)) ? dateTimeFormat(series.xAxis._intervalType) : series.xAxis.labelFormat)));
                point.x = xGlobalize ? (BoldBIDashboard.format(new Date(point.xValue), xFormat)) : point.x;
            }
            else if (xAxisValueType.toLowerCase() == "datetimecategory") {
                series.xAxis.intervalType = (BoldBIDashboard.util.isNullOrUndefined(series.xAxis.intervalType) || series.xAxis.intervalType == "auto") ? "years" : series.xAxis.intervalType;
		        point.x = BoldBIDashboard.format(new Date(point.x), ((nullorundefined(xAxisLabelFormat)) ? dateTimeFormat(series.xAxis.intervalType) : series.xAxis.labelFormat));
		        point.x = xGlobalize ? (BoldBIDashboard.format(new Date(point.x), xFormat)) : point.x;
		    }   
            else if (xAxisValueType.toLowerCase() == "category") {
                if (this.model.primaryXAxis.isIndexed)
                    point.x = (point.x) ? point.x : "undefined";
		        else
                point.x = BoldBIDashboard.EjSvgRender.utils._getLabelContent(point.xValue, series.xAxis);
            }
		    else
            {               
                point.x = xGlobalize ? BoldBIDashboard.format(point.x, xFormat) : point.x;
                customFormat = (!(xAxisLabelFormat)) ? null : xAxisLabelFormat.match('{value}');
                point.x = (!(xAxisLabelFormat)) ? point.x : (customFormat != null) ? (xAxisLabelFormat == "bbdesigner${value}") ? xAxisLabelFormat.replace('{value}', 'bbdesigner$' + point.x) : xAxisLabelFormat.replace('{value}', point.x) : xGlobalize ? point.x : (BoldBIDashboard.format(Number(point.x), xAxisLabelFormat));
            }		
        }
        else {
            if (xAxisValueType == "date") {
                point.x = (BoldBIDashboard.format(new Date(point.xValue), (dateTimeFormat('days'))));
                point.x = xGlobalize ? (BoldBIDashboard.format(new Date(point.xValue), xFormat)) : point.x;
            }                
        }
        point.y = point.waterfallSum ? point.waterfallSum : point.y;
        point.y = yGlobalize ? BoldBIDashboard.format(point.y, yFormat) : point.y;
        customFormat = (!(yAxisLabelFormat)) ? null : yAxisLabelFormat.match('{value}');
        point.y = (!(yAxisLabelFormat)) ? point.y : (customFormat != null) ? (yAxisLabelFormat == "bbdesigner${value}") ? yAxisLabelFormat.replace('{value}', 'bbdesigner$' + point.y) : yAxisLabelFormat.replace('{value}', point.y) : yGlobalize ? point.y : (BoldBIDashboard.format(Number(point.y), yAxisLabelFormat));
       
        data = { series: series, point: point };
        format = format.parseTemplate(data);
        return {data: point,text:format};
    },
    displayShowTooltip: function (location, point, series, pointIndex) {
	    var requireInvertedAxes = this.model.requireInvertedAxes;
        var isRTL = series.tooltip.isReversed;
	    var isCanvas = this.model.enableCanvasRendering;
	    var isCartesian = this.model.AreaType;
       if (point.visible) {
            // fixed multiple tooltip issue in mobile
            bbdesigner$(".BoldBIDashboardTooltip").not("#" + this.svgObject.id + "_TrackToolTip").remove();
            var measureText;
			var parentZindex;
           var seriesIndex = (!series.isIndicator && !series.isTrendLine) ? bbdesigner$.inArray(series, this.model._visibleSeries) : 0,
            seriesColor,
            textOffset,
            padding = 7,
            x,
            y,
            trackTooltipText,
            format = series.tooltip.format;
            var position = document.getElementById(this.svgObject.id).getClientRects()[0];
            var chartPos = this.model.m_AreaBounds
            if (!isCanvas)
                var chartArea = isCartesian == "cartesianaxes" && !this.model.enable3D ? document.getElementById(this.svgObject.id + "_ChartArea").getBoundingClientRect() :
                document.getElementById(this.svgObject.id).getBoundingClientRect();
            var xAxisX = !isCanvas ? chartArea.left : chartArea.left;
            var xAxisY = !isCanvas ? chartArea.top : chartArea.top;
            var yAxisX = !isCanvas ? chartArea.left : chartArea.left;
            var yAxisY = !isCanvas ? chartArea.top : series.yAxis.y;
            var markerWidth = point.width ? point.width : series.marker.size.width;
            var type = series.type.toLowerCase();
            //Set tooltip position ,text and color
            switch (this.model.AreaType) {

                case "cartesianaxes":
                    x = isRTL ? location.X - ((!series.isIndicator && !series.isTrendLine) ? ((BoldBIDashboard.util.isNullOrUndefined(series._trackMarker)) ? markerWidth : (series._trackMarker.size.width)) : 0) + (type == "column" || type == "bar" || type == "stackingbar" || type == "stackingcolumn" || type == "waterfall" || type == "rangecolumn" ? chartPos.X : (requireInvertedAxes) ? series.yAxis.x : series.xAxis.x)
                        :location.X + ((!series.isIndicator && !series.isTrendLine) ? ((BoldBIDashboard.util.isNullOrUndefined(series._trackMarker)) ? markerWidth : (series._trackMarker.size.width)) : 0) + (type == "column" || type == "bar" || type == "stackingbar" || type == "stackingcolumn" || type == "waterfall" || type == "rangecolumn" ? chartPos.X : (requireInvertedAxes) ? series.yAxis.x : series.xAxis.x);
                    //condition checked for multipleaxis line tooltip position changed
                    y = (location.Y) + (type.indexOf("column") != -1 || type.indexOf("waterfall") != -1 || type.indexOf("bar") != -1 || type.indexOf("rangearea") != -1 || type == "scatter" || type == "bubble" ? chartPos.Y : (requireInvertedAxes) ? series.xAxis.y : series.yAxis.y);
                    seriesColor = this.getSeriesColor(point, seriesIndex, series);
                    break;

                case "polaraxes":
                    x = isRTL ? location.X - padding + ((BoldBIDashboard.util.isNullOrUndefined(series._trackMarker)) ? markerWidth : (series._trackMarker.size.width))
                        :location.X + padding + ((BoldBIDashboard.util.isNullOrUndefined(series._trackMarker)) ? markerWidth : (series._trackMarker.size.width));
                    y = location.Y; 
                    seriesColor = this.getSeriesColor(point, seriesIndex, series);
                    break;

                case "none":
                    x = isRTL ? location.X - markerWidth + padding : location.X + markerWidth + padding;
                    y = (location.Y);
                    seriesColor = this.model.pointColors[pointIndex];
                    break;
            }
            trackTooltipText = this.getTooltipFormat(point, series, seriesIndex, pointIndex, format);
            textOffset = BoldBIDashboard.EjSvgRender.utils._measureText(trackTooltipText.text);
            var toolTipOptions = this.getTooltipOptions(seriesColor, series);
            var rectBorderColor = toolTipOptions.rectBColor;
            var rectFillColor = toolTipOptions.rectFColor;
            var textColor = toolTipOptions.rectTextColor;
            var rX = toolTipOptions.rectX;
            var rY = toolTipOptions.rectY;
            var rectOptions = series.tooltip;
            //draw tooltip rectangle
            var tooltipdivRect;
            var padding = 5;

            if (document.getElementById(this.svgObject.id + "_TrackToolTip") == null)
                tooltipdivRect = bbdesigner$("<div id=" + this.svgObject.id + "_TrackToolTip class = " + 'BoldBIDashboardTooltip' + "></div>");
            else
                tooltipdivRect = bbdesigner$("#" + this.svgObject.id + "_TrackToolTip");
			var isIE11 = !!navigator.userAgent.match(/Trident\/7\./);
            if (BoldBIDashboard.isTouchDevice() && !isIE11 && !this.vmlRendering) {
                if (window.navigator.msPointerEnabled)
                    this._on(tooltipdivRect, 'MSPointerMove', this.chartTooltipHover);
                else
                    this._on(tooltipdivRect, 'touchmove', this.chartTooltipHover);
            }
            else {
                this._on(tooltipdivRect, 'mousemove', this.chartTooltipHover);
            }
            bbdesigner$("#" + this.svgObject.id + "_TrackToolTip").show();
			if (!parentZindex)
                parentZindex = bbdesigner$('#' + this._id)[0].offsetParent.style.zIndex;
			x = !isCanvas ? location.X : x;
			y = !isCanvas ? location.Y : y;
            var rectOptions = {
                'top': y + bbdesigner$(document).scrollTop(),
                'left': x + bbdesigner$(document).scrollLeft(),
                "background-color": (rectOptions.fill) ? rectOptions.fill : rectFillColor,
                "border-style": "solid",
                "position": "absolute",
                "border-color": (rectOptions.border.color) ? rectOptions.border.color : rectBorderColor,
                "border-width": (rectOptions.border.width || rectOptions.border.width==0) ? rectOptions.border.width : 1,
                "opacity": rectOptions.opacity,
				 'z-index': parentZindex + 10000,
                'border-radius': ((rectOptions.rx) ? rectOptions.rx : rX).toString() + "px " + ((rectOptions.ry) ? rectOptions.ry : rY).toString() + "px",               
                "padding-left": '5px',
				 "padding-right": '5px',
                "padding-top": '2px',
                "padding-bottom": '2px'
            };
            bbdesigner$(tooltipdivRect).css(rectOptions);

            //event for tooltip text
            var commonTrackTextArgs = bbdesigner$.extend({}, BoldBIDashboard.EjSvgRender.commonChartEventArgs);
            commonTrackTextArgs.data = { seriesIndex: seriesIndex, pointIndex: pointIndex, currentText: trackTooltipText.text, isTrendLine: series.isTrendLine, trendlineIndex: series.trendlineIndex };
            this._trigger("toolTipInitialize", commonTrackTextArgs);
 	        if (!commonTrackTextArgs.cancel) {
            //draw tooltip text
            var fontSize = 0;
            var tooltip = series.tooltip;
            var font = (tooltip.font) ? bbdesigner$.extend(false, series.font, {}, tooltip.font) : series.font;
            
            // draw tooltip text styles
            var textOptions = {
                'top': y + bbdesigner$(document).scrollTop(),
                'left': x + bbdesigner$(document).scrollLeft(),
                "color": (tooltip.font && tooltip.font.color) ? font.color : textColor,
                'font-size': font.size,
                'font-family': font.fontFamily,
                'font-style': font.fontStyle,
                'font-weight': font.fontWeight,
                "align-self": "baseline"
            };
            bbdesigner$(tooltipdivRect).css(textOptions);

            // append the tooltip Div (condition for performance without remove div)
            if (document.getElementById(this.svgObject.id + "_TrackToolTip") == null)
                bbdesigner$(document.body).append(tooltipdivRect[0]);

            // Add string in text array for tooltip format
            var text = measureText = commonTrackTextArgs.data.currentText;
            bbdesigner$("#" + this.svgObject.id + "_TrackToolTip").html(text);

            // div size calculation perform here
            var textHeight = 0;
            var textWidth = 0;
             text = text.replace(/<br >/g, "<br/>")
                        .replace(/<br \/>/g, "<br/>")
                        .replace(/<br>/g, "<br/>");
             text = text.split("<br/>");
             for (var i = 0; i < text.length; i++) {
                        var text1 = text[i];
                        text1 = text1.split('</tr>');
                        for (var j = 0; j < text1.length; j++) {
                            var text2 = text1[j];
                            text2 = this.RemoveTableAttr(text2);
                            text2 = text2.replace(/&nbsp;/g, " ");
                            textHeight += BoldBIDashboard.EjSvgRender.utils._measureText(text2, null, font).height;
                            var width = BoldBIDashboard.EjSvgRender.utils._measureText(text2, null, font).width;
                            if (textWidth < width)
                                textWidth = width;
                        }
                    }

            fontSize = (this.model.AreaType == "cartesianaxes"|| this.model.AreaType == "none") ? BoldBIDashboard.EjSvgRender.utils._measureText(measureText, series.xAxis.width, font).height : BoldBIDashboard.EjSvgRender.utils._measureText(text, null, font).height;
            var maxWidth = (this.model.AreaType == "cartesianaxes"|| this.model.AreaType == "none") ? (this.model.requireInvertedAxes) ? series.yAxis.width : series.xAxis.width : bbdesigner$(this.svgObject).width() - (this.model.legend.position.toLowerCase() == "right" ? (this.model.LegendViewerBounds.Width + 2 * this.model.elementSpacing) : 0);
            var maxHeight = (this.model.AreaType == "cartesianaxes"|| this.model.AreaType == "none") ? (this.model.requireInvertedAxes) ? series.xAxis.height : series.yAxis.height : bbdesigner$(this.svgObject).height() - (this.model.legend.position.toLowerCase() == "bottom" ? (this.model.LegendViewerBounds.Height + this.model.elementSpacing) : 0);
          if (!isCanvas) {
                maxWidth = chartArea.width;
                maxHeight = chartArea.height;
            }
            //Adjust x-position to display tooltip within chart area 
            var box = bbdesigner$("#" + this.svgObject.id + "_TrackToolTip")[0].getBoundingClientRect();

            bbdesigner$("#" + this.svgObject.id + "_TrackToolTip").css("top", (bbdesigner$(document).scrollTop() + box.top - ((textHeight + 4) / 2)));
			bbdesigner$("#" + this.svgObject.id + "_TrackToolTip").css("left",(bbdesigner$(document).scrollLeft() + box.left + padding )); 
		
			if ((x + (box.width + padding)) >= maxWidth + xAxisX) {
                var areaPos = document.getElementById(this.svgObject.id).getClientRects()[0];
                var diff = x - ((box.width + padding) + ((!series.isIndicator && !series.isTrendLine) ? ((BoldBIDashboard.util.isNullOrUndefined(series._trackMarker)) ? ((series.marker.visible) ? markerWidth : 0) : series._trackMarker.size.width) : 0) + (2 * padding));
                bbdesigner$("#" + this.svgObject.id + "_TrackToolTip").css("left", diff + padding + bbdesigner$(document).scrollLeft());
            }
            box = bbdesigner$("#" + this.svgObject.id + "_TrackToolTip")[0].getBoundingClientRect();
            if (box.bottom >= (yAxisY + maxHeight + position.top) || box.bottom >= (xAxisY + maxHeight + position.top)) {
				var diffY = y - (((box.height) + ((!series.isIndicator && !series.isTrendLine) ? ((BoldBIDashboard.util.isNullOrUndefined(series._trackMarker)) ? ((series.marker.visible) ? series.marker.size.height : 0) : series._trackMarker.size.height) : 0))) + padding + (position.top < 0 ? 0 : position.top);
				bbdesigner$("#" + this.svgObject.id + "_TrackToolTip").css("top", diffY + bbdesigner$(document).scrollTop() );
             }
			//var rect = bbdesigner$("#" + this.svgObject.id + "_SvgRect")[0].getBoundingClientRect();
            //if (box.left < rect.left) {
            //    bbdesigner$("#" + this.svgObject.id + "_TrackToolTip").css("left", x + padding);
            //    bbdesigner$("#" + this.svgObject.id + "_TrackToolTip").css("top", y - ((box.height)));
            //    box = bbdesigner$("#" + this.svgObject.id + "_TrackToolTip")[0].getBoundingClientRect();
            //    if (box.right > rect.right) {
            //        bbdesigner$("#" + this.svgObject.id + "_TrackToolTip").css("left", rect.x - padding * 2);
            //        bbdesigner$("#" + this.svgObject.id + "_TrackToolTip").css("top", y - ((box.height + padding)));
            //    }
            //}

            //adjust rectangle size based on text length  
            box = bbdesigner$("#" + this.svgObject.id + "_TrackToolTip")[0].getBoundingClientRect();
			if (box.left < 0) {
			// checked condition for whether left position display outsude of the chart area
                bbdesigner$("#" + this.svgObject.id + "_TrackToolTip").css("left", chartArea.x - padding * 2);
				bbdesigner$("#" + this.svgObject.id + "_TrackToolTip").css("top", y - ((box.bottom - box.top)));

            }
            if (box.top < position.top || box.top < 0)
                bbdesigner$("#" + this.svgObject.id + "_TrackToolTip").css("top", (position.top < 0 ? bbdesigner$(document).scrollTop() : position.top) + 'px');
            if (isRTL)
            {
                bbdesigner$("#" + this.svgObject.id + "_TrackToolTip").css("left", x - (box.width + padding));
                if(x - (box.width + padding) < series.xAxis.x) // to display tooltip within chartarea when it is outside
                    bbdesigner$("#" + this.svgObject.id + "_TrackToolTip").css("left", x + (box.width - xAxisX - (padding * 2)));
            }
            bbdesigner$("#" + this.svgObject.id + "_TrackToolTip").show();
        }
        }
    },
	RemoveTableAttr: function (text) {
			if (text.indexOf('<table>') != -1 || text.indexOf('</table>') != -1 || text.indexOf('<td>') != -1 || text.indexOf('</td>') != -1 || 	text.indexOf('<tr>') != -1)
                     text = text.replace(/\//g, "").replace(/<table>/g, "").replace(/<th>/g, "").replace(/<tr>/g, "").replace(/<td>/g, "");
            while(text.search(/<td/i) > -1){
								if(text.search(/<tr/) > -1) text = text.slice(text.search(/<td/i))
								else {
									if(text.search(/<td/) > -1 && (text.indexOf('>') > text.search(/<td/)) ) {
										text = text.slice(text.indexOf(">") + 1);
										var splitText = text.split('<td');
										for (var i =0; i < splitText.length; i++){
											var currentText = splitText[i];
											splitText[i] = currentText.indexOf(">") > -1 ? currentText.slice(currentText.indexOf(">") + 1) : currentText;
										}
										text = splitText.join("");
									}
								}
							}
			return text;
		},
	chartTooltipHover: function (evt) {
        var box = bbdesigner$("#" + evt.target.id)[0].getBoundingClientRect();
		var diff = evt.clientX - box.left;
		var padding = 5;
		bbdesigner$("#" + evt.target.id).css("left", box.left + diff + padding);
		box = bbdesigner$("#" + evt.target.id)[0].getBoundingClientRect();
		var areaPos = document.getElementById(this.svgObject.id).getClientRects()[0];
		if (box.right > areaPos.right + padding)
				bbdesigner$("#" + evt.target.id).css("left", evt.clientX - (box.right - box.left) - padding);
	},
	_generateGradientCollection: function (colorMapping) {
	    var gradientCollection = [],
			startRangeColor = colorMapping.colors[0],
			endRangeColor = colorMapping.colors[colorMapping.colors.length - 1];
	    startRangeColor = this.colorNameToHex(startRangeColor);
	    endRangeColor = this.colorNameToHex(endRangeColor);
	    var startR = this._hexToR(startRangeColor),
			startG = this._hexToG(startRangeColor),
			startB = this._hexToB(startRangeColor),
			endR = this._hexToR(endRangeColor),
			endG = this._hexToG(endRangeColor),
			endB = this._hexToB(endRangeColor),
			range = 10,
			rRange = this._getRangeColorValues(range, startR, endR),
			gRange = this._getRangeColorValues(range, startG, endG),
			bRange = this._getRangeColorValues(range, startB, endB);
	    for (var i = 0; i < range; i++) {
	        gradientCollection.push(this._rgbToHex(rRange[i], gRange[i], bRange[i]));
	    }
	    return gradientCollection;
	},
	_hexToR: function (h) {
	    return parseInt((this._cropHex(h)).substring(0, 2), 16);
	},

	_hexToG: function (h) {
	    return parseInt((this._cropHex(h)).substring(2, 4), 16);
	},

	_hexToB: function (h) {
	    return parseInt((this._cropHex(h)).substring(4, 6), 16);
	},

	_cropHex: function (h) {
	    return (h.charAt(0) == "#") ? h.substring(1, 7) : h;
	},

	_rgbToHex: function (R, G, B) {
	    return "#" + this._toHex(R) + this._toHex(G) + this._toHex(B);
	},
	_toHex: function (n) {
	    var charstr = "0123456789ABCDEF";
	    n = parseInt(n, 10);
	    if (isNaN(n)) return "00";
	    n = Math.max(0, Math.min(n, 255));
	    return charstr.charAt((n - n % 16) / 16)
            + charstr.charAt(n % 16);
	},
	_getRangeColorValues: function (range, start, end) {
	    var rangeColorValues = [];
	    rangeColorValues.push(start);
	    if (start > end) {
	        var rangeValue = (start - end) / (range - 1);
	        for (var i = range; i > 2; i--) {
	            start = start - rangeValue;
	            rangeColorValues.push(start);
	        }
	    }
	    else {
	        var rangeValue = (end - start) / (range - 1);
	        for (var i = 2; i < range; i++) {
	            start = start + rangeValue;
	            rangeColorValues.push(start + rangeValue);
	        }
	    }
	    rangeColorValues.push(end);
	    return rangeColorValues;
	},
	_applyFillColor: function(chart, point){
	    var colormapping = chart.model.rangeColorMapping;
	    for (var index = 0; index < colormapping.length; index++) {
	       var gradientCollection = null;
	       var mapping = colormapping[index];
		   var checkNull = BoldBIDashboard.util.isNullOrUndefined;
		    if(!checkNull(mapping.start) && !checkNull(mapping.end)){
	        if (!BoldBIDashboard.util.isNullOrUndefined(mapping.colors)) {
	            gradientCollection = chart._generateGradientCollection(mapping);
	        }
	        var value = !BoldBIDashboard.util.isNullOrUndefined(point.mappedColumn) ? point.mappedColumn:point.y;
	        if (value >= mapping.start && value <= mapping.end) {
	            var minValue = index;
	            if (index != 0)
	                minValue = index * 10;
	            var minRange = mapping.start;
				var diffValue = Math.ceil((mapping.end - mapping.start) / 10);
	            var maxRange = mapping.start + diffValue;
	            for (var i = minValue; i < minValue + 10; i++) {
	                if (value >= minRange && value <= maxRange) {
	                    if (!BoldBIDashboard.util.isNullOrUndefined(mapping.colors)) {
	                        if (index != 0) {
	                            point.rangeFill = gradientCollection[i - index * 10];
	                        } else {
	                            point.rangeFill = gradientCollection[i];
	                        }
	                    } else
	                        point.rangeFill = mapping.color;
	                }
	                minRange = maxRange;
	                maxRange = maxRange + diffValue;
	            }
	        }
		  }
	    }
	},
    _initializeSeriesColors: function () {
        var chartObj = this;
        var modelColor = (chartObj.model.palette) ? chartObj.model.palette : chartObj.model.colors;
        var count = modelColor.length;
        var legendMode = chartObj.model.legend.mode.toLowerCase(), defaultColors;
        var areaType = chartObj.model.AreaType;
		var rangeVal = true;
        chartObj.model.seriesColors = [];
        chartObj.model.seriesBorderColors = [];
        chartObj.model.pointColors = [];
        chartObj.model.pointBorderColors = [];
        var elementCollection, color, borderColor, element, tlines,visibleSeriesLength =chartObj.model._visibleSeries.length,visibleSeries = chartObj.model._visibleSeries
        if (areaType != "none" && (legendMode == "series" || visibleSeriesLength > 1)) {
            elementCollection = chartObj.model._visibleSeries;
            color = chartObj.model.seriesColors;
            borderColor = chartObj.model.seriesBorderColors;
        }
        else {
            var lgth = 0;
            var longest;
            for (var i = 0; i < visibleSeriesLength; i++) {
                if (chartObj.model._visibleSeries[i].points.length > lgth) {
                    var lgth = chartObj.model._visibleSeries[i].points.length;
                    longest = chartObj.model._visibleSeries[i].points;
                }
                else if (chartObj.model._visibleSeries[i].points.length == lgth)
                    longest = chartObj.model._visibleSeries[i].points;
				}
           elementCollection = longest;
            color = chartObj.model.pointColors;
            borderColor = chartObj.model.pointBorderColors;
        }
        if (areaType == "none" && visibleSeriesLength > 1 && legendMode == "series")
        {
            for (var k = 0; k < visibleSeriesLength; k++)
            {
                chartObj.model.seriesColors[k] = modelColor[k % count];
            }
        }
   
        if (legendMode != "series" && this.model.rangeColorMapping.length > 0) {
                  if (visibleSeriesLength > 1) {
                      elementCollection.map(function (series, index, elementCollection) {
                          points = elementCollection[index].points ? elementCollection[index].points : elementCollection;
                          points.map(function (point, index, points) {
                              chartObj._applyFillColor(chartObj, point);
                          });
                      });
                      if (legendMode == "point" && elementCollection > 0)
                        modelColor[index] = range.colors[0];
                  }
                  else {
                      elementCollection.map(function (point, ptIndex, elementCollection) {
                          chartObj._applyFillColor(chartObj, point);                         
                      });
                  }
          }
        for (var i = 0; i < elementCollection.length; i++) {
            element = elementCollection[i];
            tlines = element.trendlines;
			defaultColors = chartObj.model.seriesBorderDefaultColors;
                element.isFill = (element.isFill == undefined || !element.isFill) ? ((element.fill && element.fill != "" && element.fill != element.rangeFill) ? true : false) : element.isFill;
                if (element.isFill) {
                    color[i] = element.fill;
                } else {
                    if (legendMode !="series" && visibleSeriesLength == 1 && rangeVal)
                        color[i] = element.rangeFill ? element.rangeFill: chartObj.model._visibleSeries[0].fill ? chartObj.model._visibleSeries[0].fill : modelColor[0];
                    else
                    color[i] = modelColor[i % count];
                    if (!element._hiloTypes)
                        element.fill = color[i];
                }
                if (areaType != "none" && tlines && tlines.length > 0)
                    this._initializeTrendlinesColors(tlines, color[i]);
                if (!BoldBIDashboard.util.isNullOrUndefined(element.border) && !BoldBIDashboard.util.isNullOrUndefined(element.border.color) && element.border.color != "") {
                    borderColor[i] = element.border.color;
                } else {
                    borderColor[i] = chartObj.model.seriesBorderDefaultColors[i % 10];
                    if (areaType != "none" && visibleSeriesLength > 1)
                        element.border.color = borderColor[i];
                }
                element.dataPoint = element.points;
					
            } 
    },
    _initializeTrendlinesColors: function(tlines, color) {
        for (var k in tlines) {
            if (BoldBIDashboard.util.isNullOrUndefined(tlines[k].fill) || tlines[k].fill == "")
                tlines[k].fill = color;
        }
    },

    _createAxisLabelAndRange: function () {
	     var count = 0;
        var seriesLength = this.model.series.length;
		 var series;
        for (var i = 0; i < seriesLength; i++) {
            series = this.model.series[i];
            if (series._isTransposed)
                count++;
        }
        if (seriesLength) {
            if (count == seriesLength)
                this.model.requireInvertedAxes = true;
            else {
                series = this.model.series[0];
                if (series._isTransposed)
                    this.model.requireInvertedAxes = true;
            }
        }        
        if (this.model.requireInvertedAxes) {
            this.model.primaryYAxis.orientation = "horizontal";
            this.model.primaryXAxis.orientation = "vertical";
            this.model.primaryYAxis.labelPlacement = (!(this.model.primaryYAxis.labelPlacement)) ? BoldBIDashboard.datavisualization.Chart.LabelPlacement.OnTicks : this.model.primaryYAxis.labelPlacement;
        }
        else {
            this.model.primaryYAxis.orientation = "vertical";
            this.model.primaryXAxis.orientation = "horizontal";
        }
		 
        this.model.primaryYAxis.name = BoldBIDashboard.util.isNullOrUndefined(this.model.primaryYAxis.name) ? "SecondaryAxis" : this.model.primaryYAxis.name;
        this.model.primaryXAxis.name = BoldBIDashboard.util.isNullOrUndefined(this.model.primaryXAxis.name) ? "PrimaryAxis" : this.model.primaryXAxis.name;

        this.model._axes = [];
        this.model._axes[0] = this.model.primaryXAxis;
        this.model._axes[1] = this.model.primaryYAxis;
       
        var len = this.model.axes.length;
		 var series = this.model.series;
		 var indicatorSeries = this.model.indicators;
        for (var i = 0; i < len; i++) {
            var axis = this.model.axes[i];
			if (axis.name) {
			//Sets orientation for axes collections
            for (var j = 0; j < series.length; j++) {
                var type = series[j].type.toLowerCase();
                    if (series[j].xAxisName == axis.name) {
                        axis.orientation = (type.indexOf("bar") != -1) ? series[j].isTransposed ? "horizontal" : "vertical" : series[j].isTransposed ? "vertical" : "horizontal";
                        break;
                    }
                    else if (series[j].yAxisName == axis.name) {
                        axis.orientation = (type.indexOf("bar") != -1) ? series[j].isTransposed ? "vertical" : "horizontal" : series[j].isTransposed ? "horizontal" : "vertical";
                            break;
                        }
                 }
				  for (var k = 0; k < indicatorSeries.length; k++) {
                    if (indicatorSeries[k].xAxisName == axis.name) {
                        axis.orientation ="horizontal";
                        break;
                    }
                    else if (indicatorSeries[k].yAxisName == axis.name) {
                        axis.orientation ="vertical";
                        break;
                    }
                 }
		     if (!axis.orientation) continue;
            if (axis.orientation.toLowerCase() == "horizontal")
                this.model.axes[i] = bbdesigner$.extend(true, {}, this.model.secondaryX, axis);
            else
                this.model.axes[i] = bbdesigner$.extend(true, {}, this.model.secondaryY, axis);
            this.model._axes[i + 2] = this.model.axes[i];
		  }
        }
        for (var k = 0; k < this.model._axes.length; k++) {
            var axis = this.model._axes[k],
                orientation = axis.orientation.toLowerCase();
            axis.visibleLabels = [];
            axis.range = (axis.range.min == null && axis.range.max == null && axis.range.interval == null) ? null : axis.range;            
            axis.setRange = (!(axis.range)) ? false : (BoldBIDashboard.util.isNullOrUndefined(axis.setRange)) ? true : axis.setRange;
            axis.setRange = ((axis.actual_Range) || (axis.setRange != false)) ? true : false;
            axis.actualRange = (!(axis.actualRange)) ? (axis.range == null) ? {} : bbdesigner$.extend(true, {}, axis.range) : axis.actualRange;
            axis.visibleRange = (!(axis.visibleRange)) ? (axis.range == null) ? {} : axis.range : axis.visibleRange;
            axis.name = !(axis.name) ? k.toString() : axis.name;
            axis._scrollBar = (axis.enableScrollbar && (orientation == 'horizontal' || (orientation == 'vertical' && this.model.requireInvertedAxes)));
        }
    },






    _drawTitle: function () {
        var titleText = this.model.title.text;
        var isRTL = this.model.title.isReversed;
        var measureTitle = BoldBIDashboard.EjSvgRender.utils._measureText(titleText, bbdesigner$(this.svgObject).width() - this.model.margin.left - this.model.margin.right, this.model.title.font);
        var modelTitleHeight = (titleText == "") ? 0 : (measureTitle.height + this.model.elementSpacing);
        var svgWidth = bbdesigner$(this.svgObject).width();
        var margin = this.model.margin;
        var areaBounds = this.model.m_AreaBounds;
        this.model.chartTitleRegion = "";
        var areaType = this.model.AreaType.toLowerCase();
		var legendSpace = (this.model.legend.position.toLowerCase() == "left") ? this.model.LegendViewerBounds.Width / 2 : ((this.model.legend.position.toLowerCase() == "right" ? (-this.model.LegendViewerBounds.Width / 2) : 0));
		var elementSpacing = this.model.elementSpacing;

        // Drawing the chart title
        var leftSpace = margin.left + elementSpacing + this.model.border.width;
        var rightSpace = margin.right + elementSpacing + this.model.border.width;

        var titleLocation, textBorderConstant = 1.2,
            titleFontSize = parseInt(this.model.title.font.size),
            titleTextHeight = parseInt(this.model.title.font.size) * textBorderConstant;

        if (this.model.title.text != "" && this.model.title.text != null) {
            if ((this.model.title.border.color == 'transparent') && (this.model.title.background == 'transparent')) {
                titleLocation = this.model.margin.top + (modelTitleHeight / 2) + (this.model.elementSpacing);
                } else {
                titleLocation = this.model.margin.top + (titleTextHeight / 2) + (elementSpacing) + (titleFontSize / 4);
            }
           
            var locX = ((areaType != "cartesianaxes") ? (svgWidth - margin.left - margin.right) / 2 + (margin.left + legendSpace) : (leftSpace + (svgWidth - rightSpace) / 2)) - measureTitle.width / 2;

            if (this.model.title.textAlignment.toLowerCase() == "near") {
                locX = isRTL ? (svgWidth - rightSpace - measureTitle.width) : leftSpace;
            }
            else if (this.model.title.textAlignment.toLowerCase() == "far") {
                locX = isRTL ? leftSpace : (svgWidth - rightSpace - measureTitle.width);
            }

            if (this.model.adaptiveRendering) {
			    if (locX < 0) locX = 0;
                maxTitleWidth = this.svgWidth - locX;
                while (measureTitle.width > maxTitleWidth) {
                    titleText = BoldBIDashboard.EjAxisRenderer.prototype.trimText(titleText, titleText.length, "...");
                    measureTitle = BoldBIDashboard.EjSvgRender.utils._measureText(titleText, bbdesigner$(this.svgObject).width() - this.model.margin.left - this.model.margin.right, this.model.title.font);
                    if (titleText == "...") {
                        titleText = "";
                        break;
                    }
                }
                var bounds = { X: locX, Y: titleLocation, Width: measureTitle.width, Height: measureTitle.height };
                var chartTitleRegion = { Bounds: bounds, trimText: titleText, labelText: this.model.title.text };
                this.model.chartTitleRegion = chartTitleRegion;
            }

            var commonEventArgs = bbdesigner$.extend({}, BoldBIDashboard.EjSvgRender.commonChartEventArgs);
            this.model.title.displayText = titleText;
            commonEventArgs.data = { title: titleText, location: { x: locX, y: titleLocation }, size: measureTitle };
            this._trigger("titleRendering", commonEventArgs);
            this.model._titleLocation = { X: commonEventArgs.data.location.x, Y: commonEventArgs.data.location.y, size: measureTitle };
            var options = {
                'id': this.svgObject.id + '_ChartTitle',
                'x': commonEventArgs.data.location.x,
                'y': commonEventArgs.data.location.y,
                'fill': this.model.title.font.color,
                'font-size': this.model.title.font.size,
                'font-family': this.model.title.font.fontFamily,
                'font-style': this.model.title.font.fontStyle,
                'font-weight': this.model.title.font.fontWeight,
				'opacity': this.model.title.font.opacity,
				'text-anchor': 'start'
            };

            var borderOptions = {
                'id': this.svgObject.id + '_ChartTitleBorder',
                'x': commonEventArgs.data.location.x - elementSpacing,
                'y': commonEventArgs.data.location.y - titleTextHeight + (titleTextHeight / 4),
                'rx': this.model.title.border.cornerRadius,
                'ry': this.model.title.border.cornerRadius,
                'width': measureTitle.width + (2 * elementSpacing),
                'height': titleTextHeight,
                'fill': this.model.title.background,
                'stroke-width': this.model.title.border.width,
                'stroke': this.model.title.border.color,
                'opacity': this.model.title.border.opacity,

            };
            this.svgRenderer.drawRect(borderOptions, this.svgObject);

            this.svgRenderer.drawText(options, commonEventArgs.data.title, this.gTitleEle);

            this.svgRenderer.append(this.gTitleEle, this.svgObject);
            if (this.model.title.subTitle.text != "" && this.model.title.subTitle.visible && this.model.title.subTitle.responsiveVisibility)
                this._drawSubTitle();
        } else {
            this.model.chartTitleRegion = null;
            this.model.chartSubTitleRegion = null;
        }
    },



    _getLegendSize: function (series) {

        var legend = this.model.legend,
            symbolSize = legend.itemStyle,
            width = symbolSize.width,
            height = symbolSize.height;
		if (legend.mode.toLowerCase() == "range" && !legend.enableMultiRange) {
            var position = legend.position.toLowerCase();
            if (position == "left" || position == "right") {
                var consWidth = 15, consHeight = 200;
                width = consWidth;
                height = consHeight;
            }
            else if (position == "top" || position == "bottom") {
                var consWidth = 200, consHeight = 15;
                width = consWidth;
                height = consHeight;
            }
        }
        var textSize = BoldBIDashboard.EjSvgRender.utils._measureText(series.Text, null, series.Font),
            padding = 10,
            width = width + padding + textSize.width,
            height = Math.max(height, textSize.height);

        return { Width: width, Height: height };

    },

    _getYValues: function (points) {
        var values = [],
			length = points.length;
        for (var i = 0; i < length; i++)
            values.push(points[i].y);
        return values;
    },
    _getXValues: function (points) {
         var values = [],
			length = points.length;
        for (var i = 0; i < length; i++)
            values.push(points[i].xValue);
        return values;
    },




    _drawSubTitle: function () {
        this.model.chartSubTitleRegion = "";
        var titleText = this.model.title.subTitle.trimmedText == "" ? "" : this.model.title.subTitle.text;
        var measureTitle = BoldBIDashboard.EjSvgRender.utils._measureText(this.model.title.displayText, bbdesigner$(this.svgObject).width() - this.model.margin.left - this.model.margin.right, this.model.title.font);
        var measuresubTitle = BoldBIDashboard.EjSvgRender.utils._measureText(titleText, bbdesigner$(this.svgObject).width() - this.model.margin.left - this.model.margin.right, this.model.title.subTitle.font);

        var textanchor = "middle";

        var subTitleLocation, startX, textBorderConstant = 1.2, titleBorderSpacing = 10, subTitleBorderSpacing = 10, elementSpacing = this.model.elementSpacing,
           subTitleFontSize = parseInt(this.model.title.subTitle.font.size),
           titleTextHeight = parseInt(this.model.title.font.size) * textBorderConstant;
        subTitleTextHeight = parseInt(this.model.title.subTitle.font.size) * textBorderConstant; //subTitle Text height Measurement for border
        var modelsubTitleHeight = (this.model.title.subTitle.text == "") ? 0 : (measuresubTitle.height + elementSpacing);

        // Drawing the chart subtitle

        if (titleText != "" && titleText != null && this.model.title.subTitle.visible) {
            if (((this.model.title.border.color == 'transparent') && (this.model.title.background == 'transparent')) || ((this.model.title.subTitle.border.color == 'transparent') && (this.model.title.subTitle.background == 'transparent'))) {
               subTitleLocation = (modelsubTitleHeight) / 2 + elementSpacing + this.model._titleLocation.Y;
            } else {
               subTitleLocation = (subTitleTextHeight / 2) + subTitleBorderSpacing + elementSpacing + titleTextHeight + titleBorderSpacing + (subTitleFontSize / 3);
            }
            var locX = this.model._titleLocation.X + (measureTitle.width / 2);

            if (this.model.title.subTitle.textAlignment.toLowerCase() == "near") {
                locX = this.model._titleLocation.X;
                textanchor = "start";
				startX = locX;
            }
            else if (this.model.title.subTitle.textAlignment.toLowerCase() == "far") {

                locX = this.model._titleLocation.X + measureTitle.width;

                textanchor = "end";
				startX = locX - measuresubTitle.width + this.model.elementSpacing;
            }

            if (this.model.adaptiveRendering) {
                maxTitleWidth = this.svgWidth - this.model.elementSpacing;
                while (measuresubTitle.width > maxTitleWidth) {
                    titleText = BoldBIDashboard.EjAxisRenderer.prototype.trimText(titleText, titleText.length, "...");
                    measuresubTitle = BoldBIDashboard.EjSvgRender.utils._measureText(titleText, bbdesigner$(this.svgObject).width() - this.model.margin.left - this.model.margin.right, this.model.title.subTitle.font);
                    if (titleText == "...") {
                        titleText = "";
                        break;
                    }
                }
                var bounds = { X: startX, Y: subTitleLocation, Width: measuresubTitle.width, Height: measuresubTitle.height };
                var chartSubTitleRegion = { Bounds: bounds, trimText: titleText, labelText: this.model.title.subTitle.text };
                this.model.chartSubTitleRegion = chartSubTitleRegion;
                this.model.title.subTitle.trimmedText = titleText;
            }

            var commonEventArgs = bbdesigner$.extend({}, BoldBIDashboard.EjSvgRender.commonChartEventArgs);
            commonEventArgs.data = { subTitle: titleText, location: { x: locX, y: subTitleLocation }, size: measuresubTitle };
            this._trigger("subTitleRendering", commonEventArgs);
            this.model._subTitleLocation = { X: commonEventArgs.data.location.x, Y: commonEventArgs.data.location.y };
            var subTitleYposition = (((this.model.title.border.color == 'transparent') && (this.model.title.background == 'transparent')) || ((this.model.title.subTitle.border.color == 'transparent') && (this.model.title.subTitle.background == 'transparent'))) ? commonEventArgs.data.location.y : commonEventArgs.data.location.y - (elementSpacing / 2);

            var options = {
                'id': this.svgObject.id + '_ChartsubTitle',

                'x': commonEventArgs.data.location.x,
                'y': subTitleYposition,
                'fill': this.model.title.subTitle.font.color,
                'font-size': this.model.title.subTitle.font.size,
                'font-family': this.model.title.subTitle.font.fontFamily,
                'font-style': this.model.title.subTitle.font.fontStyle,
                'font-weight': this.model.title.subTitle.font.fontWeight,
				'opacity': this.model.title.subTitle.font.opacity,
                'text-anchor': textanchor
            };

            var x, y, subTitleXLocation = commonEventArgs.data.location.x;
            if (textanchor == "start") {
                x = subTitleXLocation - elementSpacing;
            }
            else if (textanchor == "end") {
                x = subTitleXLocation - elementSpacing - (measuresubTitle.width);
            }
            else {
                x = subTitleXLocation - elementSpacing - (measuresubTitle.width / 2);
            }
            y = (((this.model.title.border.color == 'transparent') && (this.model.title.background == 'transparent')) || ((this.model.title.subTitle.border.color == 'transparent') && (this.model.title.subTitle.background == 'transparent'))) ? commonEventArgs.data.location.y - subTitleTextHeight + (subTitleTextHeight / 4)  : commonEventArgs.data.location.y - subTitleTextHeight + (subTitleTextHeight / 4) - (elementSpacing / 2);
            var borderOptions = {
                'id': this.svgObject.id + '_ChartSubTitleBorder',
                'x': x,
                'y': y,
                'rx': this.model.title.subTitle.border.cornerRadius,
                'ry': this.model.title.subTitle.border.cornerRadius,
                'width': measuresubTitle.width + (2 * elementSpacing),
                'height': subTitleTextHeight,
                'fill': this.model.title.subTitle.background,
                'stroke-width': this.model.title.subTitle.border.width,
                'stroke': this.model.title.subTitle.border.color,
                'opacity': this.model.title.subTitle.border.opacity,

            };

            this.svgRenderer.drawRect(borderOptions, this.svgObject);

            this.svgRenderer.drawText(options, commonEventArgs.data.subTitle, this.gSubTitleEle);

            this.svgRenderer.append(this.gSubTitleEle, this.gTitleEle);
        }
    },


    _calculateStackingValues: function (seriesCollection, axis, params) {

        var chartModel = this.model;
        chartModel.stackedValue[axis.name] = [];
        var stackedValue = chartModel.stackedValue[axis.name];
        stackedValue.min = 0;
        stackedValue.max = 0;
        var stackAxes = (!chartModel.requireInvertedAxes) ? chartModel.hAxes : chartModel.vAxes,
            stackAxesLength = stackAxes.length,visiblePointsLength, yValues,stackingGroup,
            seriesLength = seriesCollection.length, visiblePoints,
            lastPosValue, lastNegValue, values, lastValue, currentValue,
            isNul = BoldBIDashboard.util.isNullOrUndefined;

        for (var k = 0; k < stackAxesLength; k++) {
            j = 0;
            var lastPosValue = [], lastNegValue = [], firstPositive = [], firstNegative = [],
            crossing = 0;
            for (var i = 0; i < seriesCollection.length; i++) {
                if (seriesCollection[i]._xAxisName == stackAxes[k].name) {
                    if (seriesCollection[i].type.toLowerCase().indexOf("stacking") != -1 || seriesCollection[i].isStacking) {
                        values = {};
                        values.StartValues = [];
                        values.EndValues = [];
                        stackingGroup = seriesCollection[i].stackingGroup;
                        if (stackingGroup && seriesCollection[i].type.toLowerCase() != "stackingarea") {
                            if (isNul(lastPosValue[stackingGroup])) {
                                lastPosValue[stackingGroup] = [];
                                lastNegValue[stackingGroup] = [];
                                firstPositive[stackingGroup] = [];
                                firstNegative[stackingGroup] = [];
                            }
                        }

                        else {
                            stackingGroup = "";
                            if (isNul(lastPosValue[stackingGroup])) {
                                lastPosValue[stackingGroup] = [];
                                lastNegValue[stackingGroup] = [];
                                firstPositive[stackingGroup] = [];
                                firstNegative[stackingGroup] = [];
                            }
                        }
                        series = seriesCollection[i];
						crossing = this._getXCrossValue(series, stackAxes[k], params);
						if(typeof(crossing) !== 'number')
							crossing = 0;
                        visiblePoints = BoldBIDashboard.EjSeriesRender.prototype._isVisiblePoints(series,this);
                        yValues = this._getYValues(series._visiblePoints);
                        visiblePointsLength = visiblePoints.length;
                        for (var j = 0; j < visiblePointsLength; j++) {
                            var lastValue = 0, correction=0, currentValue = yValues[j];
							if (isNul(lastPosValue[stackingGroup][series._visiblePoints[j].xValue])) {
                                lastPosValue[stackingGroup][series._visiblePoints[j].xValue] = crossing;
                            }
                            if (isNul(lastNegValue[stackingGroup][series._visiblePoints[j].xValue])) {
                                lastNegValue[stackingGroup][series._visiblePoints[j].xValue] = crossing;
                            }
                            if (values.StartValues.length <= j) {
                                values.StartValues.push(0);
                                values.EndValues.push(0);
                            }
                            if (currentValue >= 0) {
                                firstPositive[stackingGroup][j] = firstPositive[stackingGroup][j] == null;
                                currentValue -= firstPositive[stackingGroup][j] && crossing;
                                if (series.type.toLowerCase().indexOf("stacking") != -1 || currentValue > 0)
                                    lastValue = lastPosValue[stackingGroup][series._visiblePoints[j].xValue];
                                else
                                    lastValue = 0;
                                lastPosValue[stackingGroup][series._visiblePoints[j].xValue] += currentValue;
                                correction = lastValue < crossing ? crossing - lastValue : 0;
                                values.StartValues[j] = lastValue + correction;
                                values.EndValues[j] = currentValue + lastValue;
                            }
                            else {
                                firstNegative[stackingGroup][j] = firstNegative[stackingGroup][j] == null;
                                currentValue -= firstNegative[stackingGroup][j] && crossing;
                                lastValue = lastNegValue[stackingGroup][series._visiblePoints[j].xValue];
                                lastNegValue[stackingGroup][series._visiblePoints[j].xValue] += currentValue;
                                values.StartValues[j] = lastValue;
                                values.EndValues[j] = currentValue + lastValue;
                                if (crossing < values.EndValues[j]) {
                                    lastNegValue[stackingGroup][series._visiblePoints[j].xValue] = values.StartValues[j];
                                    lastPosValue[stackingGroup][series._visiblePoints[j].xValue] = values.EndValues[j];
                                    firstPositive[stackingGroup][j] = firstPositive[stackingGroup][j] == null;
                                }
                            }
                            
                            visiblePointIndex = visiblePoints[j].actualIndex;
                            series.points[visiblePointIndex].YValues = [values.EndValues[j]];
                        }
                        values.stackedSeries = false;
                        stackedValue.push(values);
                        if (stackedValue.min > Math.min.apply(0, values.StartValues))
                            stackedValue.min = Math.min.apply(0, values.StartValues);
                        if (stackedValue.max < Math.max.apply(0, values.EndValues))
                            stackedValue.max = Math.max.apply(0, values.EndValues);
                        series.stackedValue = values;
                    }
                }
            }
        }
    },
    _calculateStackingCumulativeValues: function (seriesCollection, axis, params) {
        this.model.stackedValue[axis.name] = [];
        this.model.stackedValue[axis.name].min = 0;
        this.model.stackedValue[axis.name].max = 0;
        var stackAxes = (!this.model.requireInvertedAxes) ? this.model.hAxes : this.model.vAxes;
        var seriesLength = seriesCollection.length;
        var axesLength = stackAxes.length;
        var percent;
        for (var k = 0; k < axesLength ; k++) {
            var posValues = [], negValues = [], frequencies = [], stackingName = " ", firstPositive = [], firstNegative = [], crossing = 0;

            //calculate the cumulative frequencies from the collection of series  
            for (var i = 0; i < seriesLength; i++) {
                var visiblePoints = BoldBIDashboard.EjSeriesRender.prototype._isVisiblePoints(seriesCollection[i], this);
                stackingName = seriesCollection[i].stackingGroup;
                if (seriesCollection[i].type.toLowerCase().indexOf("100") != -1) {
                    if (seriesCollection[i]._xAxisName == stackAxes[k].name) {
                        if (seriesCollection[i].stackingGroup && seriesCollection[i].type.toLowerCase() != " stackingarea100 ") {
                            if (!posValues[stackingName]) {
                                frequencies[stackingName] = [];
                                posValues[stackingName] = [];
                                negValues[stackingName] = [];
                                firstPositive[stackingName] = [];
                                firstNegative[stackingName] = [];
                            }
                        }
                        else {
                            seriesCollection[i].stackingGroup = "";
                            stackingName = seriesCollection[i].stackingGroup;
                            if (!posValues[stackingName]) {
                                frequencies[stackingName] = [];
                                posValues[stackingName] = [];
                                negValues[stackingName] = [];
                                firstPositive[stackingName] = [];
                                firstNegative[stackingName] = [];
                            }
                        }
                        var yValues = this._getYValues(seriesCollection[i]._visiblePoints);
                        var yValuesLength = yValues.length;
                        for (var j = 0; j < yValuesLength; j++) {
                            var getYValue = yValues[j];
                            if (!frequencies[stackingName][seriesCollection[i].points[j].xValue]) {
                                frequencies[stackingName][seriesCollection[i].points[j].xValue] = 0;
                            }
                            frequencies[stackingName][seriesCollection[i].points[j].xValue] += Math.abs(getYValue);
                        }
                    }
                }
              
            }

            //calculate the cumulative percentage for each series points
            for (var i = 0; i < seriesLength; i++) {
                stackingName = seriesCollection[i].stackingGroup;
                if (seriesCollection[i].type.toLowerCase().indexOf("100") != -1) {
                    if (seriesCollection[i]._xAxisName == stackAxes[k].name) {
                        var values = {};
                        values.StartValues = [];
                        values.EndValues = [];
                        series = seriesCollection[i];
                        crossing = this._getXCrossValue(series, stackAxes[k], params);
						if(typeof(crossing) !== 'number')
							crossing = 0;
                        var yValues = this._getYValues(series._visiblePoints);
                        var yValuesLength = yValues.length;
                        for (var j = 0; j < yValuesLength; j++) {
                            var lastValue, correction = 0;
                            var currentValue = yValues[j];

                            //Pecentage calculation for point 
                            percent = (currentValue / frequencies[stackingName][series.points[j].xValue]) * 100
                            currentValue = !isNaN(percent) ? percent :0;
                            series.points[j].percentage = currentValue.toFixed(2);
                            if (!posValues[stackingName][series.points[j].xValue]) {
                                posValues[stackingName][series.points[j].xValue] = crossing;
                            }
                            if (!negValues[stackingName][series.points[j].xValue]) {
                                negValues[stackingName][series.points[j].xValue] = crossing;
                            }
                            if (values.StartValues.length <= j) {
                                values.StartValues.push(0);
                                values.EndValues.push(0);
                            }
                            if (currentValue >= 0) {
                                var posValue = posValues[stackingName][series.points[j].xValue];
                                firstPositive[stackingName][j] = firstPositive[stackingName][j] == null;
                                currentValue -= firstPositive[stackingName][j] && crossing;
                                correction = posValue < crossing ? crossing - posValue : 0;
                                lastValue = posValue;
                                posValues[stackingName][series.points[j].xValue] += currentValue;
                            }
                            else {
                                var negValue = negValues[stackingName][series.points[j].xValue];
                                firstNegative[stackingName][j] = firstNegative[stackingName][j] == null;
                                currentValue -= firstNegative[stackingName][j] && crossing;
                                correction = negValue > crossing ? crossing - negValue : 0;
                                lastValue = negValue;
                                negValues[stackingName][series.points[j].xValue] += currentValue;
                            }
                            values.StartValues[j] = lastValue + correction;
                            values.EndValues[j] = lastValue + currentValue;
                            if (values.EndValues[j] > 100) values.EndValues[j] = 100;
                            series.points[j].YValues = [values.EndValues[j]];
                        }
                        values.stackedSeries = false;
                        this.model.stackedValue[axis.name].push(values);
                        if (this.model.stackedValue[axis.name].min > Math.min.apply(0, values.StartValues))
                            this.model.stackedValue[axis.name].min = Math.min.apply(0, values.StartValues);
                        if (this.model.stackedValue[axis.name].max < Math.max.apply(0, values.EndValues))
                            this.model.stackedValue[axis.name].max = Math.max.apply(0, values.EndValues);
                        if (this.model.stackedValue[axis.name].min > Math.min.apply(0, values.EndValues))
                            this.model.stackedValue[axis.name].min = -100;

                        series.stackedValue = values;
                    }
                }
            }
        }
    },
    _legendItemBounds: function (itemCount, legendItemWidth, legendItemHeight) {
         var legend = this.model.legend, legVal,
            position = legend.position.toLowerCase(),
            itemPadding = legend.itemPadding,
            legnedHeightIncr, column, legendWidth = 0, legendHeight = 0;
        if (BoldBIDashboard.util.isNullOrUndefined(legend.columnCount) && legend.rowCount) {
            legnedHeightIncr = legend.rowCount;
            column = Math.ceil(itemCount / legnedHeightIncr);
            legendWidth = legendItemWidth * column;
            legendHeight = legendItemHeight * legnedHeightIncr;
        }
        else if (BoldBIDashboard.util.isNullOrUndefined(legend.rowCount) && legend.columnCount) {
            legnedHeightIncr = Math.ceil(itemCount / legend.columnCount);
            legVal = legend.columnCount;
            legendWidth = legendItemWidth * legVal;
            legendHeight = legendItemHeight * legnedHeightIncr;
        }
        else if ((legend.rowCount) && (legend.columnCount)) {
            if (legend.columnCount < legend.rowCount) {
                legnedHeightIncr = legend.rowCount;
                column = Math.ceil(itemCount / legnedHeightIncr);
                legendWidth = legendItemWidth * column;
                legendHeight = legendItemHeight * legnedHeightIncr;
            }
			else if(legend.columnCount > legend.rowCount){
                  if (position === 'top' || position === 'bottom' || position === 'custom') {
                    legnedHeightIncr = Math.ceil(itemCount / legend.columnCount);
                    legVal = legend.columnCount;
                    legendWidth = legendItemWidth * legVal;
                    legendHeight = legendItemHeight * legnedHeightIncr;
                } else {
                    legnedHeightIncr = Math.ceil(itemCount / legend.columnCount);
                    column = Math.ceil(itemCount / legnedHeightIncr);
                    legVal = legend.columnCount;
                    legendWidth = legendItemWidth * legVal;
                    legendHeight = legendItemHeight * legnedHeightIncr;
                }
			 }
            else {
                if (position === 'top' || position === 'bottom' || position === 'custom') {
                    legnedHeightIncr = Math.ceil(itemCount / legend.columnCount);
                    legVal = Math.ceil(itemCount / legend.rowCount); 
                    legendWidth = legendItemWidth * legend.columnCount;
                    legendHeight = legendItemHeight *legVal;
                } else {
                    legnedHeightIncr = legend.rowCount;
                    column = Math.ceil(itemCount / legnedHeightIncr);
                    legendWidth = legendItemWidth * column;
                    legendHeight = legendItemHeight * legnedHeightIncr;
                }
                
            }
			
        }
        legendHeight += this.model.elementSpacing;
        return { LegendWidth: legendWidth, LegendHeight: legendHeight };
    },
	
	_isEjScroller: function () {
        var chart = this,
           chartModel = chart.model,
            legendContainer = bbdesigner$(chart.legendContainer),
            legend = chartModel.legend;
        if (BoldBIDashboard.util.isNullOrUndefined(bbdesigner$('#' + legendContainer[0].id).BoldBIDashboardScroller)) 
            legend._BoldBIDashboardScroller = false;
        else
            legend._BoldBIDashboardScroller = legend.enableScrollbar;
    },

    //legend text wrapping
    _rowsCalculation:function(data,textmaxwidth)
    {
        var chart = this,
            chartModel = chart.model,
            legend = chartModel.legend,
            word, textCollection = [], currentWidth,nextWidth,
            text = data.legendItem.Text.toString(),
            legendTextCollection = text.split(' '),
            textMaxWidth=textmaxwidth,
            font=data.legendItem.LegendStyle.Font,
            textOverflow=legend.textOverflow.toLowerCase(),
            legendTextLength = legendTextCollection.length;
      
        for (var i = 0; i < legendTextLength; i++) {
            word = legendTextCollection[i];
            currentWidth = BoldBIDashboard.EjSvgRender.utils._measureText(word, null, font).width;
            if (currentWidth <= textMaxWidth) {
                while (i < legendTextLength) {
                    currentWidth = BoldBIDashboard.EjSvgRender.utils._measureText(word, null, font).width;
                    nextWidth = (legendTextCollection[i + 1]) ? BoldBIDashboard.EjSvgRender.utils._measureText(legendTextCollection[i + 1], null, font).width : 0;
                    if ((currentWidth + nextWidth) <= textMaxWidth && nextWidth>0) {
                        word = word.concat(' ' + legendTextCollection[i + 1]);
                        i++;
                    }
                    else{
                        break;
                    }
                }
                textCollection.push(word);
            }
            else{
                if (textOverflow == "wrapandtrim") {
                    word = BoldBIDashboard.EjSvgRender.utils._trimText(word, textMaxWidth, font);
                    textCollection.push(word);
                    this.model._legendMaxWidth = textMaxWidth;
                }
                else {
                    textCollection.push(word);
                    this.model._legendMaxWidth = Math.max(this.model._legendMaxWidth, currentWidth);
                }                
            }
        }        
        this.model._legendMaxHeight = Math.max(this.model._legendMaxHeight, textCollection.length);
        return textCollection;
    },

    _triggerLegendEvent:function(name,color,index, chartObj, ptIndex)
    {
        var chart = !BoldBIDashboard.util.isNullOrUndefined(this.model) ? this : chartObj,
            chartModel = chart.model,
            legend = chartModel.legend,
            size = legend.size,
            padding = 15,
            legendMode = legend.mode,
            legendMultiRange = legend.enabeleMultiRange,
            legendPosition = legend.position,
			areaType = chartModel.AreaType,
            itemStyle = legend.itemStyle,
            border = itemStyle.border,
            elementSpacing = chartModel.elementSpacing,
            textMaxWidth = legend.textWidth,
            svgRender = BoldBIDashboard.EjSvgRender,
            chartSvgRender = chart.svgRenderer,
            seriesLength = chartModel._visibleSeries.length,
            svgObject = chart.svgObject,
            elementSpacing = chartModel.elementSpacing,
            textOverflow = legend.textOverflow.toLowerCase(),
            legendItem, legendFont,textWidth,
            style= {
                BorderColor:border.color,
                BorderWidth: border.width,
                Opacity: legend.opacity,
                Color: color,
                Font: legend.font
            };
		if (legendMode == "range" && !legendMultiRange)
            legend.shape = 'rectangle';
        commonEventArgs = bbdesigner$.extend({}, svgRender.commonChartEventArgs);
        commonEventArgs.data = {
            svgRenderer: chartSvgRender,
            svgObject: svgObject,
            symbolShape: legend.shape,
            legendItem: {
                Text: name,
                Shape: legend.shape,
                LegendStyle: style,
                SeriesIndex: ((areaType == "none" && seriesLength == 1 )  || legendMode != "series") ? 0 : index,
            },            
            style: {
                ShapeSize: itemStyle,
                ElementSpace: elementSpacing,
                Style: style,
                ID: chart.svgObject.id + '_LegendItemShape' + (ptIndex ? ptIndex : index),
                SeriesIndex: ((areaType == "none" && seriesLength == 1 )|| legendMode != "series") ? 0 : index,
                context: true
            },
            gLegendItemEle: chart.gLegendItemEle
       };
        if (legendMode == "point")
            commonEventArgs.data.legendItem.PointIndex = index;
        else if (BoldBIDashboard.util.isNullOrUndefined(commonEventArgs.data.legendItem.PointIndex))
            delete commonEventArgs.data.legendItem.PointIndex;
       chart._trigger("legendItemRendering", commonEventArgs);
       legendItem = commonEventArgs.data.legendItem.Text;
       legendFont = commonEventArgs.data.legendItem.LegendStyle.Font;
       textWidth = BoldBIDashboard.EjSvgRender.utils._measureText(legendItem, null, legendFont).width;
       if (areaType == "none" && legend.columnCount == 1) {
           itemStyleWidth = commonEventArgs.data.style.ShapeSize.width;
           var svgWidth = bbdesigner$(chart.svgObject).width();
           var svgHeight = bbdesigner$(chart.svgObject).height();
               if (size.width == "" || size.width == null) {
                   if (legendPosition == 'top' || legendPosition == 'bottom' || legendPosition == 'custom')
                       textMaxWidth = Math.abs(svgWidth);
                   else
                       textMaxWidth = Math.abs((svgWidth / 100) * parseInt('20%'));
               }
               else {
                   if (size.width.indexOf("%") != -1)
                       textMaxWidth = Math.abs((svgWidth / 100) * parseInt(size.width));
                   else
                       textMaxWidth = parseInt(size.width);
               }           
           textWidth = textWidth + itemStyleWidth + (padding * 2);
       }
       if (textOverflow == "trim") {          
           if (textWidth >= textMaxWidth) {
               if (areaType == "none" && legend.columnCount == 1)
                   textMaxWidth = textMaxWidth - itemStyleWidth - (padding * 2);
               legendItem = BoldBIDashboard.EjSvgRender.utils._trimText(legendItem, textMaxWidth, legendFont);
               chart.model._legendMaxWidth = textMaxWidth;
           }
       }
       else if (textOverflow == "wrap" || textOverflow == "wrapandtrim") {
           if (areaType == "none" && legend.columnCount == 1)
               textMaxWidth = textMaxWidth - itemStyleWidth - (padding * 2);
           legendItem = chart._rowsCalculation(commonEventArgs.data, textMaxWidth);    
       }
       return { commonEventArgs: commonEventArgs, legendItem: legendItem };  
    },
    _calculateRangeLegends: function (model, series, isMultiRange) {
        var enableMultiRange = model.legend.enableMultiRange;
        var rangeColorMapping = model.rangeColorMapping;
        var seriesPoints = series.points;
        var startEndColor = [];
        var points = [], rangeStartEnd = [], length, rangeMin, rangeMax, rangeColors = [];
		var checkNull = BoldBIDashboard.util.isNullOrUndefined;
        if (enableMultiRange) {
            for (var r = 0; r < rangeColorMapping.length; r++) {
				if(!checkNull(rangeColorMapping[r].start) && !checkNull(rangeColorMapping[r].end) && !checkNull(rangeColorMapping[r].colors)){
                var indexes = [], rangeStartEnd = [];
                var text = rangeColorMapping[r].legendName ? rangeColorMapping[r].legendName : rangeColorMapping[r].start + '-' + rangeColorMapping[r].end;
                rangeStartEnd.push(rangeColorMapping[r].start, rangeColorMapping[r].end);
                var k = 0;
                for (var q = 0; q < seriesPoints.length; q++) {
                    if (seriesPoints[q].y >= rangeStartEnd[0] && seriesPoints[q].y <= rangeStartEnd[rangeStartEnd.length - 1]) {
                        indexes[k] = q;
                        k++;
                    }
                }
                if (rangeColorMapping[r].colors.length > 0) {
                    startEndColor[0] = rangeColorMapping[r].colors[0];
                    startEndColor[1] = rangeColorMapping[r].colors[rangeColorMapping[r].colors.length - 1];
                }
                var color = rangeColorMapping[r].colors && rangeColorMapping[r].colors.length > 0 ? this._generateGradientCollection(rangeColorMapping[r], rangeColorMapping[r].colors.length, enableMultiRange) : model.seriesBorderDefaultColors[0];
                var visibility = indexes.length == 0 ? 'visible' : (seriesPoints[indexes[0]]._visibility == "visible" ? 'visible' : 'hidden');
				rangeColorMapping[r].isLegendVisible = BoldBIDashboard.util.isNullOrUndefined(rangeColorMapping[r].isLegendVisible) || rangeColorMapping[r].isLegendVisible ? true : false;
                points.push({ legendName: text, legendColor: color, pointIndexes: indexes, rangeVisibility: visibility, isLegendVisible : rangeColorMapping[r].isLegendVisible });
            }
			}
            rangeStartEnd.sort(function (a, b) { return a - b });
            length = rangeStartEnd.length;
            if(rangeColorMapping.length == 0 && model.primaryYAxis.range){
				rangeMin = model.primaryYAxis.range.min;
				rangeMax = model.primaryYAxis.range.max;
				var visibility = series.visibility;
				if (!(rangeStartEnd[0] == rangeMin && rangeStartEnd[length - 1] == rangeMax))
					points.push({ legendName: 'Others', legendColor: model.seriesBorderDefaultColors[0], rangeVisibility: visibility });
            }
            return points;
        }
        else {
            var colorMappingLength = rangeColorMapping.length;
            for (var r = 0; r < rangeColorMapping.length; r++) {
				if(!checkNull(rangeColorMapping[r].start) && !checkNull(rangeColorMapping[r].end) && !checkNull(rangeColorMapping[r].colors)){
                if (rangeColorMapping[r].colors) {
                    for (var c = 0; c < rangeColorMapping[r].colors.length;c++)
                        rangeColors.push(rangeColorMapping[r].colors[c]);
                }
                rangeStartEnd.push(rangeColorMapping[r].start, rangeColorMapping[r].end);
				}
            }
            rangeStartEnd.sort(function (a, b) { return a - b });
            if (rangeColors.length == 0) rangeColors.push(model.seriesBorderDefaultColors[0]);
            var text = [],
				startText = rangeStartEnd[0],
				endText = rangeStartEnd[rangeStartEnd.length - 1];
            text[0] = startText; text[1] = endText;
            points.push({ legendName: text, legendColor: rangeColors, isLegendVisible : true });
            return points;
        }
    },
    _addLegendItems: function (legendName, legendColor, seriesIndex, pointIndex, chart, series) {
        legendInfo = chart._triggerLegendEvent(legendName, legendColor, seriesIndex, chart, pointIndex);
        legendStyle = legendInfo.commonEventArgs.data.legendItem.LegendStyle;
        tempSeries = {
            Text: legendInfo.legendItem,
            displayText: legendInfo.commonEventArgs.data.legendItem.Text,
            Font: legendStyle.Font,
            SeriesIndex: seriesIndex,
            fill: legendStyle.Color,
            visibility: !BoldBIDashboard.util.isNullOrUndefined(pointIndex) ? (series.points[pointIndex]._visibility ? series.points[pointIndex]._visibility : "visible") : series.visibility,
            Shape: legendInfo.commonEventArgs.data.legendItem.Shape,
            LegendStyle: legendStyle,
            CommonEventArgs: { cancel: legendInfo.commonEventArgs.cancel, data: legendInfo.commonEventArgs.data }
        };
        if (chart.model.legend.mode == "point" && !BoldBIDashboard.util.isNullOrUndefined(pointIndex))
            tempSeries.PointIndex = pointIndex;
        return tempSeries;
    },
    _calculateLegendBounds: function (chartObj) {
        // intialize
        var chart = !BoldBIDashboard.util.isNullOrUndefined(this.model) ? this : chartObj;
        chart.model.legendCollection = [];
        chart.model.legendTextRegion = [];
        chart.model.legendRegion = [];
        chart.model.svgHeight = bbdesigner$(chart.svgObject).height();
        chart.model.svgWidth = bbdesigner$(chart.svgObject).width();
        chart.model._legendMaxWidth = 0;
        chart.model._legendMaxHeight = 0;

        var chartModel = chart.model,
            math = Math,
            max = math.max,
            min = math.min,
            abs = math.abs,
            legend = chartModel.legend,
            padding = 10,
            legendSizeHeight = legend.size.height,
            legendSizeWidth = legend.size.width,
            itemPadding = legend.itemPadding > 0 ? legend.itemPadding : 0,
            position = !BoldBIDashboard.util.isNullOrUndefined(legend.responsivePosition) ? legend.responsivePosition : legend.position.toLowerCase(),
            width = 0, height = 0,
            svgHeight = chartModel.svgHeight,
            svgWidth = chartModel.svgWidth,
            legendItemWidth = 0,
            legendItemHeight = 0,
            legendWidth = 0,
            legendHeight = 0,
            legnedHeightIncr = 1,
            currentLegend,
            index,
            bounds,
            legendviewerHeight = 0, legendviewerWidth = 0,
            legendHeightTemp, legendWidthTemp,
            tempSeries = {},
            legendSeries = [], trendLineLength, trendLines,
            trendLine,
			trendlineType,
            areaType = chartModel.AreaType,
            visibleSeries = chartModel._visibleSeries,
            rowCount = legend.rowCount, point,
            columnCount = legend.columnCount,
            legendMode = legend.mode,
            enableMultiRange = legend.enableMultiRange,
            elementSpacing = chartModel.elementSpacing,
            visiblePoints, series,
            length, legendColor, legendName,legendStyleColor,
            titleSize = BoldBIDashboard.EjSvgRender.utils._measureText(legend.title.text, null, legend.title.font, legend.title.text ? chart._id : null),
            legendsize, colorGradName,
            vScrollSize = 0, hScrollSize = 0,
            borderSize = chartModel.border.width,
            legendBorder = legend.border.width,type,
            isRTL = legend.isReversed,
            legendInfo, legendStyle, legendFont, shapeWidth,
            textOverflow = legend.textOverflow.toLowerCase(),
            svgObjectHeight = svgHeight - ((elementSpacing * 4) + (borderSize * 2) + (legend.border.width * 2)),
            svgObjectWidth = svgWidth - ((elementSpacing * 4) + (borderSize * 2) + (legendBorder * 2));
        if (visibleSeries && legend.visible && visibleSeries.length != 0 && legend.responsiveVisibility) {
            type = visibleSeries[0].type.toLowerCase();			
            
            if (legendMode == "range") {
                for (var v = 0 ; v < visibleSeries.length; v++) {
                    BoldBIDashboard.EjSeriesRender.prototype._calculateVisiblePoints(visibleSeries[v], chart).legendPoints;
                    visiblePoints = this._calculateRangeLegends(chartModel, visibleSeries[v], enableMultiRange);
                    length = visiblePoints.length;                    
                    for (var j = 0; j < length; j++) {
                        visibleOnLegend = !(visiblePoints[j].visibleOnLegend) ? 'visible' : visiblePoints[j].visibleOnLegend;
                        if (visibleOnLegend == "visible" && visibleSeries[v].visibleOnLegend == "visible") {
						  if (visiblePoints[j].isLegendVisible){
                            legendInfo = this._triggerLegendEvent(visiblePoints[j].legendName, visiblePoints[j].legendColor, j, chart);
                            legendStyle = legendInfo.commonEventArgs.data.legendItem.LegendStyle;
                            tempSeries = {
                                Text: legendInfo.legendItem,
                                displayText: legendInfo.commonEventArgs.data.legendItem.Text,
                                Font: legendStyle.Font,
                                SeriesIndex: 0,
                                PointIndex: j,
                                PointIndexes: visiblePoints[j].pointIndexes,
                                fill: legendStyle.Color,
                                visibility: enableMultiRange ? visiblePoints[j].rangeVisibility : visibleSeries[0].visibility,
                                Shape: legendInfo.commonEventArgs.data.legendItem.Shape,
                                LegendStyle: legendStyle,
                                CommonEventArgs: { cancel: legendInfo.commonEventArgs.cancel, data: legendInfo.commonEventArgs.data }
                            };
                            if (v == 0)
                                legendSeries.push(tempSeries);
						  }	
                        }
                    }
                }
            }
            else if ((areaType == "none" || legendMode == "point") && visibleSeries.length == 1 || type == 'pyramid' || type == 'funnel') {
                series = visibleSeries[0];
                visiblePoints = legendMode == "point" && areaType == "cartesianaxes" ? BoldBIDashboard.EjSeriesRender.prototype._calculateVisiblePoints(series, chart).legendPoints :BoldBIDashboard.EjSeriesRender.prototype._calculateVisiblePoints(series).legendPoints;
                length = visiblePoints.length;
                for (isRTL && (position == "top" || position == "bottom") ? j = length - 1 : j = 0; isRTL && (position == "top" || position == "bottom") ? j >= 0 : j < length; isRTL && (position == "top" || position == "bottom")? j-- : j++) {
                    legendColor = legend.fill ? (!(legend.fill._gradientStop) ? legend.fill : legend.fill._gradientStop) : chartModel.pointColors[visiblePoints[j].actualIndex];
                    point = visiblePoints[j];
                    legendName = !BoldBIDashboard.util.isNullOrUndefined(point.x) ? point.x : 'series' + j;
                    visibleOnLegend = !(point.visibleOnLegend) ? 'visible' : point.visibleOnLegend;
                    if (!point.isEmpty && visibleOnLegend.toLowerCase() == 'visible' && series.visibleOnLegend.toLowerCase() == "visible") {
                        legendInfo=this._triggerLegendEvent(legendName, legendColor, j, chart);
                        legendStyle = legendInfo.commonEventArgs.data.legendItem.LegendStyle;
                        tempSeries = {
                            Text: legendInfo.legendItem,
                            displayText: legendInfo.commonEventArgs.data.legendItem.Text,
                            Font: legendStyle.Font,
                            SeriesIndex: 0,
                            PointIndex: j,
                            fill: legendStyle.Color,
                            visibility: point.visible ? 'visible' : 'hidden',
                            Shape: legendInfo.commonEventArgs.data.legendItem.Shape,
                            LegendStyle: legendStyle,
                            CommonEventArgs: { cancel: legendInfo.commonEventArgs.cancel, data: legendInfo.commonEventArgs.data }
                        };
                        legendSeries.push(tempSeries);
                    }
                }            
            }
            else {
                length = visibleSeries.length;
                var j, colorColl = [], fillColor;
                for (isRTL && (position == "top" || position == "bottom") ? j = length - 1 : j = 0; isRTL && (position == "top" || position == "bottom") ? j >= 0 : j < length; isRTL && (position == "top" || position == "bottom")? j-- : j++) {
                    legendColor = legend.fill ? (!(legend.fill._gradientStop) ? legend.fill : legend.fill._gradientStop) : BoldBIDashboard.util.isNullOrUndefined(chartModel.seriesColors[j]) ? chartModel.pointColors[j] : chartModel.seriesColors[j];
                    series = visibleSeries[j];
                    if (series.visibleOnLegend.toLowerCase() == "visible") {
                        if (legendMode == "series") {
                            legendName = series.name ? series.name : 'series' + j;
                            tempSeries = this._addLegendItems(legendName, legendColor, j, null, chart, series);
                            legendSeries.push(tempSeries);
                        }
                        else if (legendMode == "point") {
                            visiblePoints = BoldBIDashboard.EjSeriesRender.prototype._calculateVisiblePoints(series).legendPoints;
                            var pointsLength = visiblePoints.length;
                            for (var k = 0; k < pointsLength; k++) {
								var point = visiblePoints[k];
								visibleOnLegend = BoldBIDashboard.util.isNullOrUndefined(point.visibleOnLegend) ? 'visible' : point.visibleOnLegend;
								if(visibleOnLegend.toLowerCase() == 'visible'){
                                legendName = point.x;
                                legendColor = (areaType == "none") ? chartModel.pointColors[k] : point.fill ? point.fill : series.fill;
                                tempSeries = this._addLegendItems(legendName, legendColor, j , k, chart, series);
                                if (tempSeries)
									legendSeries.push(tempSeries);
								}
                            }
                        }
                    }
                    trendLines = series.trendlines;
                    trendLineLength = trendLines.length;
                    for (var i = 0; i < trendLineLength; i++) {
                        trendLine = trendLines[i];
                        legendColor = legend.fill ? (!(legend.fill._gradientStop) ? legend.fill : legend.fill._gradientStop) : trendLine.fill;
                        legendName = trendLine.name ? trendLine.name : 'series' + j;                                        
                        if (trendLine.visibility != '' && trendLine.visibleOnLegend.toLowerCase() == "visible") {
                            legendInfo = this._triggerLegendEvent(legendName, legendColor, j, chart);
                            legendStyle = legendInfo.commonEventArgs.data.legendItem.LegendStyle;
                            tempSeries = {
                                Text: legendInfo.legendItem,
                                displayText: legendInfo.commonEventArgs.data.legendItem.Text,
                                Font: legendStyle.Font,
                                SeriesIndex: j,
                                trendLineIndex: i,
                                fill: legendStyle.Color,
                                isTrendLine: true,
                                visibility: series.visibility.toLowerCase() == "visible" ? trendLine.visibility : "hidden",
                                Shape: legendInfo.commonEventArgs.data.legendItem.Shape,
                                LegendStyle: legendStyle,
                                CommonEventArgs: { cancel: legendInfo.commonEventArgs.cancel, data: legendInfo.commonEventArgs.data }
                            };
                            legendSeries.push(tempSeries);
                        }
                    }
                }
            }
            
            legendSeriesLength = legendSeries.length;
            for (var j = 0; j < legendSeriesLength; j++) {
                currentLegend = legendSeries[j];
                shapeWidth = currentLegend.CommonEventArgs.data.style.ShapeSize.width;
                legendsize = chart._getLegendSize(currentLegend);
                legendItemWidth = max(chartModel._legendMaxWidth > 0 ? (chartModel._legendMaxWidth + itemPadding + shapeWidth) : legendsize.Width, legendItemWidth);
                legendItemHeight = max((textOverflow == "wrap" || textOverflow == "wrapandtrim") ? legendsize.Height * chartModel._legendMaxHeight : legendsize.Height, legendItemHeight);
            }
            legendHeight = legendItemHeight + elementSpacing * 2;
            legendWidth = legendItemWidth;
           
            if (columnCount || rowCount) {
                legendBounds = chart._legendItemBounds(legendSeries.length, legendItemWidth + (itemPadding), legendItemHeight + (itemPadding));
                legendWidth = legendBounds.LegendWidth;
                legendHeight = legendBounds.LegendHeight;
                if (position === 'top' || position === 'bottom' || position === 'custom')
                    legendHeight = legendHeight - itemPadding + elementSpacing;
                else
                    legendWidth = legendWidth - itemPadding;
            }
            for (var k = 0; k < legendSeriesLength; k++) {
                currentLegend = legendSeries[k];
                index = currentLegend.SeriesIndex;
                series = chartModel.series[index];
                legendsize = chart._getLegendSize(currentLegend);
                if (textOverflow == "wrap"||textOverflow=="wrapandtrim") {
                    legendsize.Width = legendItemWidth;
                    legendsize.Height = legendItemHeight;
                }
                if (!(rowCount) && !(columnCount)) {
                    
                    if ((position == 'top' || position == 'bottom' || position == 'custom')) {
                        width += legendsize.Width + itemPadding;
                        if (width > svgObjectWidth && k !=0) {
                            width -= legendsize.Width + itemPadding;
                            legendWidth = max(legendWidth, width);
                            width = legendsize.Width + itemPadding;
                            legnedHeightIncr++;
                            legendHeight += legendItemHeight + itemPadding;
                        }
                        else
                            legendWidth = max(legendWidth, width);

                        height = max(height, legendItemHeight);
                    }
                    else {
                        height += legendsize.Height + itemPadding;
                        if (height > svgObjectHeight) {
                            height -= legendsize.Height + itemPadding;
                            legendHeight = max(legendHeight, height);
                            height = legendsize.Height + itemPadding;
                            legendWidth += legendItemWidth + itemPadding;
                        }
                        else
                            legendHeight = max(legendHeight, height);

                        width = max(width, legendItemWidth);
                    }
                }
                if (currentLegend.visibility.toLowerCase() == "visible"){
                    if (chartModel.enableCanvasRendering && !chartModel.legend.enableMultiRange)
                        colorGradName = chart.svgRenderer.createGradientElement('legend' + k, legendSeries[k].fill, chartModel, position);
                    else {
                        if (legendMode == "range" || legendMode == "point") {
                            if (position == "top" || position == "bottom")
                                colorGradName = chart.svgRenderer.createGradientElement('legend' + k, legendSeries[k].fill, 0, 0, 100, 0, chart.gLegendEle, chartModel);
                            else if(position == "right" || position == "left")
                                colorGradName = chart.svgRenderer.createGradientElement('legend' + k, legendSeries[k].fill, 0, 0, 0, 100, chart.gLegendEle, chartModel);
                        }
                        else
                            colorGradName = chart.svgRenderer.createGradientElement('legend' + k, legendSeries[k].fill, 0, 0, 0, svgObjectHeight, chart.gLegendEle, chartModel);
                    }
                }else
                    colorGradName = 'gray';
                currentLegend.CommonEventArgs.data.legendItem.LegendStyle.Color = colorGradName;
                bounds = (rowCount || columnCount) ? { Width: legendItemWidth, Height: legendItemHeight } : legendsize;

                if (currentLegend.isTrendLine) {
                    currentLegend.TrendLineIndex = currentLegend.trendLineIndex;
					trendlineType = series.trendlines[currentLegend.trendLineIndex].type.toLowerCase();
                    currentLegend.CommonEventArgs.data.legendItem.drawType = currentLegend.drawType= trendlineType == 'linear' || trendlineType == "movingaverage" ? 'line' : 'spline';
                }
                legendSeries[k].Bounds = bounds;
                chartModel.legendCollection.push(currentLegend);
            }

            //LegendBounds calculation Perform here..
            if (position === 'top' || position === 'bottom' || position === 'custom') {
                legendWidth = titleSize.width > legendWidth - itemPadding ? (titleSize.width + padding * 2 + itemPadding) : legendWidth + padding * 2;
                width += padding ;
                height += padding * 2;
                chartModel.LegendBounds = { Width: max(legendWidth, width) - itemPadding, Height: max(legendHeight, height), Rows: legnedHeightIncr };
            }
            else {
                legendWidth = titleSize.width > legendWidth ? (titleSize.width + padding * 2) : legendWidth + padding * 2;
                width += padding;
                height += padding;
                chartModel.LegendBounds = { Width: max(legendWidth, width), Height: max(legendHeight, height) + padding - itemPadding, Columns: legnedHeightIncr };
            }
            //Calculating legend viewer bounds or calculate user specified legend bounds
            chartModel.LegendViewerBounds = { Width: "0", Height: "0" };

            if (legendSizeHeight == "" || legendSizeHeight == null) {
                if (position == 'left' || position == 'right' || position == 'custom')
                    legendHeightTemp = abs(svgHeight);
                else
                    legendHeightTemp = abs((svgHeight / 100) * parseInt('20%'));
                chartModel.LegendViewerBounds.Height = min(legendHeightTemp, chartModel.LegendBounds.Height);
            }
            else{
				if (legendSizeHeight.indexOf("%") != -1)
                    chartModel.LegendViewerBounds.Height = abs((svgHeight / 100) * parseInt(legendSizeHeight));
                else
                    chartModel.LegendViewerBounds.Height = parseInt(legendSizeHeight);
			}                

            if (legendSizeWidth == "" || legendSizeWidth == null) {
                if (position == 'top' || position == 'bottom' || position == 'custom')
                    legendWidthTemp = abs(svgWidth);
                else
                    legendWidthTemp = abs((svgWidth / 100) * parseInt('20%'));
                chartModel.LegendViewerBounds.Width = min(legendWidthTemp, chartModel.LegendBounds.Width);
            }
            else{
				 if (legendSizeWidth.indexOf("%") != -1)
                    chartModel.LegendViewerBounds.Width = abs((svgWidth / 100) * parseInt(legendSizeWidth));
                else
                    chartModel.LegendViewerBounds.Width = parseInt(legendSizeWidth);
			}                
        }
        else {
            chartModel.LegendBounds = { Width: 0, Height: 0 };
            chartModel.LegendViewerBounds = { Width: 0, Height: 0 };
        }
        legendContainer = bbdesigner$(chart.legendContainer);
        legendSvgContainer = bbdesigner$(chart.legendSvgContainer);
        if (legend.enableScrollbar) {
            chartModel.LegendActualBounds = chartModel.LegendViewerBounds;
            legendContainer.removeAttr("style");
            legendContainer.css({ "visibility":'hidden',"width": chartModel.LegendViewerBounds.Width, "height": chartModel.LegendViewerBounds.Height });
            legendSvgContainer.css({ "height": chartModel.LegendBounds.Height, "width": chartModel.LegendBounds.Width });
			
			bbdesigner$(legendSvgContainer).empty();	// to avoid adding additionanl scrollHeight of SVG to parent element and render unwanted scrollbar
			
			if (legend._BoldBIDashboardScroller){
			//	if (legend.isReversed)
			    //    legendContainer.addClass("e-rtl");
                bbdesigner$('#' + legendContainer[0].id).BoldBIDashboardScroller({width: chartModel.LegendViewerBounds.Width, height: chartModel.LegendViewerBounds.Height })
            }
			else {
                legendContainer.css({ "overflow": "scroll" });
			//	if(legendContainer.hasClass("e-rtl"))
				//	legendContainer.removeClass("e-rtl");
			}
				
			chart.scrollerContainer.css({"width":'auto', "height":'auto'});
			chart.svgRenderer.append(legendSvgContainer, chart.scrollerContainer);
			
            if (chartModel.LegendBounds.Width > chartModel.LegendViewerBounds.Width && chartModel.LegendBounds.Height > chartModel.LegendViewerBounds.Height) {
                if (legend._BoldBIDashboardScroller) {
                    hScrollSize = bbdesigner$('.e-hscrollbar').height();
                    vScrollSize = bbdesigner$('.e-vscrollbar').width();
                } else {
                    legendContainer.css({ "overflow": "scroll" });
                    hScrollSize = legendContainer[0].offsetHeight - (legendBorder * 2) - legendContainer[0].clientHeight;
                    vScrollSize = legendContainer[0].offsetWidth - (legendBorder * 2) - legendContainer[0].clientWidth;
                }
            } else if (chartModel.LegendBounds.Width > chartModel.LegendViewerBounds.Width) {
				if (legend._BoldBIDashboardScroller) {
                    hScrollSize = bbdesigner$('.e-hscrollbar').height();
                    vScrollSize = 0;
                }
                else {
                    legendContainer[0].style.overflowX = "scroll";
                    legendContainer[0].style.overflowY = "hidden";
                    hScrollSize = legendContainer[0].offsetHeight - (legendBorder * 2) - legendContainer[0].clientHeight;
                    vScrollSize = 0;
                }
            } else if (chartModel.LegendBounds.Height > chartModel.LegendViewerBounds.Height) {
				if (legend._BoldBIDashboardScroller) {
                    hScrollSize = 0;
                    vScrollSize = bbdesigner$('.e-vscrollbar').width();
                }
                else {
                    legendContainer[0].style.overflowY = "scroll";
                    legendContainer[0].style.overflowX = "hidden";
                    hScrollSize = 0;
                    vScrollSize = legendContainer[0].offsetWidth - (legendBorder * 2) - legendContainer[0].clientWidth;
                } 
            }
            
        }
        else {
            chartModel.LegendActualBounds = chartModel.LegendBounds;
            if (legendSizeWidth != "" && legendSizeWidth != null)
                chartModel.LegendActualBounds.Width = parseInt(legendSizeWidth);
            if (legendSizeHeight != "" && legendSizeHeight != null)
                chartModel.LegendActualBounds.Height = parseInt(legendSizeHeight);
        }
		if(hScrollSize == 0 && bbdesigner$(legendContainer[0]).find('.e-hscrollbar'))
			bbdesigner$(legendContainer[0]).find('.e-hscrollbar').remove();
		if(vScrollSize == 0 && bbdesigner$(legendContainer[0]).find('.e-vscrollbar'))
			bbdesigner$(legendContainer[0]).find('.e-vscrollbar').remove();
        chartModel.LegendActualBounds.Height += Math.abs(hScrollSize);
        chartModel.LegendActualBounds.Width += Math.abs(vScrollSize);
        chartModel.LegendActualBounds.hScrollSize = hScrollSize;
        chartModel.LegendActualBounds.vScrollSize = vScrollSize;
    },

    GetPointXYOrgin: function (x, y, orginX, orginY) {

        var xvalue = ((x - orginX) / (this.model.axes.PrimaryXaxis.visibleRange.max - orginX)) * (this.model.m_AreaBounds.Width);
        var yvalue = ((y - orginY) / (this.model.axes.PrimaryYaxis.visibleRange.max - orginY)) * (this.model.m_AreaBounds.Height - this.GetPointXY(this.model.axes.PrimaryXaxis.visibleRange.min, Math.max(this.model.axes.PrimaryYaxis.visibleRange.min, 0)).Y);

        return { X: xvalue, Y: yvalue };
    },






  


    _drawChartAreaRect: function () {

        var fillColor = !(this.model.background && this.model.background._gradientStop) ? this.model.background : 'url(#' + this.svgObject.id + '_backGradient)';

        if (this.model.backGroundImageUrl)
            fillColor = 'transparent';
        
        var chartBorder = this.model.border;
        var options = {
            'id': this.svgObject.id + '_SvgRect',
            'x': chartBorder.width / 2,
            'y': chartBorder.width / 2,
            'width': bbdesigner$(this.svgObject).width() - (2 * chartBorder.width),
            'height': bbdesigner$(this.svgObject).height() - (2 * chartBorder.width),
            'fill': fillColor,
            'opacity': chartBorder.opacity,
            'stroke-width': chartBorder.width,
            'stroke': chartBorder.color
        };
        this.svgRenderer.drawRect(options, this.svgObject);
        


        if (this.model.backGroundImageUrl)
            this._drawBackImage();

        if (this.model.AreaType == 'cartesianaxes' && !this.model.enable3D) {
            var borderOptions = {
                'id': this.svgObject.id + '_ChartArea',
                'x': this.model.m_AreaBounds.X,
                'y': this.model.m_AreaBounds.Y,
                'width': this.model.m_AreaBounds.Width,
                'height': this.model.m_AreaBounds.Height,
                'fill': this.model.chartArea.background,
                'stroke-width': this.model.chartArea.border.width,
                'opacity': this.model.chartArea.border.opacity,
                'stroke': this.model.chartArea.border.color
            };
            this.svgRenderer.drawRect(borderOptions, this.svgObject);


        }

    },
    axesIndexCount: function (axis,index) {
        var vRowcount = [];
        for (var k = 0; k < axis.length; k++) {
            var currentAxis = axis[k];
            if (currentAxis.orientation.toLowerCase() == "vertical") {
                if (currentAxis.rowIndex == index)
                    vRowcount.push(currentAxis);
            }
            else {
                if (currentAxis.columnIndex == index)
                    vRowcount.push(currentAxis);
            }
        }
        return vRowcount ;
    },
    axesCount: function (axis) {
        var vRowcount = [], indexValue=[], definitionsLength=0;
        var chartModel = this.model;
        bbdesigner$.each(axis, function (index, currentAxis) {
            if (currentAxis.orientation.toLowerCase() == "vertical") {
                definitionsLength =(chartModel.rowDefinitions)?chartModel.rowDefinitions.length:0;
                if (index == 0) vRowcount.push({ axis: currentAxis, index: currentAxis.rowIndex });
                else if (currentAxis.rowIndex != vRowcount[vRowcount.length - 1].axis.rowIndex)
                    vRowcount.push({ axis: currentAxis, index: currentAxis.rowIndex});
            }
            else {
                definitionsLength =(chartModel.columnDefinitions)? chartModel.columnDefinitions.length:0;
                if (index == 0) vRowcount.push({ axis: currentAxis, index: currentAxis.columnIndex });
                else if (currentAxis.columnIndex != vRowcount[vRowcount.length - 1].axis.columnIndex)
                    vRowcount.push({ axis: currentAxis, index: currentAxis.columnIndex });
            }
        });
        var length = vRowcount.length;
        if (definitionsLength > length) {
            length = definitionsLength;
            for (var l = 0; l < definitionsLength; l++)
                indexValue.push(l);
        } else {
            for (var i = 0; i < length; i++)
                indexValue.push(vRowcount[i].index);
        }
        
        return { length: length, indexValue: indexValue };

    },
   
     //Calculate position for each vertical axis
    _calRowSize: function () {
        var start = 0;
        var yaxisOrign = [];
        var totalRealLength = 0;
        var orginY = this.model.m_AreaBounds.Y + this.model.m_AreaBounds.Height;
        //Caluculate size for rowdefinitions values
        if (this.model._rowDefinitions[0].rowDefinitions != null) {
            for (var i = 0, rowMax = this.model._rowDefinitions.length; i < rowMax; i++) {
                var rowDef = this.model._rowDefinitions[i].rowDefinitions;
                rowDef.rowHeight = Math.abs(rowDef.rowHeight);
                var realLength = 0;
                if (rowDef.unit.toLowerCase() == "percentage"){
                    var length = this._axisRowDefinitionSize(this.model.rowDefinitions);
                    realLength = Math.floor((this.model.m_AreaBounds.Height) * (rowDef.rowHeight / length));
                }  
                else
                    realLength = rowDef.rowHeight;
                if (i == 0) yaxisOrign.push(orginY);
                   
                      yaxisOrign.push( (orginY - realLength - totalRealLength ));
                    totalRealLength += realLength;
                

            }
            
        }
        //Calculate size based on chart area size
        else {
            var height = Math.floor((this.model.m_AreaBounds.Height) / this.model._rowDefinitions.length);

            for (start = (orginY) ; start >= this.model.m_AreaBounds.Y; start = start - height) {
                yaxisOrign.push(start);
            }
        }
        return yaxisOrign;
    },
    
     //Calculate position for each horizontal axis
    _calColumnSize: function () {
        var xaxisOrign = [];
        var orginX = this.model.m_AreaBounds.X;
        var areaWidth = this.model.m_AreaBounds.Width;
        var totalRealLength = 0;
        var columnDef = this.model._columnDefinitions;
        //Caluculate size for columndefinitions values
        if (columnDef[0].columnDefinitions != null) {
            for (var i = 0, max = columnDef.length; i < max; i++) {
                var rowDef = columnDef[i].columnDefinitions;
				rowDef.columnWidth = Math.abs(rowDef.columnWidth);
                var realLength;
                if (rowDef.unit.toLowerCase() == "percentage"){
				    var length = this._axisColumnDefinitionSize(this.model.columnDefinitions);
				    realLength = Math.floor((areaWidth) * (rowDef.columnWidth / length));
                } 
                else
                    realLength = rowDef.columnWidth;
                if (i == 0) xaxisOrign.push(orginX);

                xaxisOrign.push((orginX + realLength + totalRealLength));
                totalRealLength += realLength;
            }
        }
        //Caluculate size based on chart area size
        else {
            var width = Math.floor((areaWidth) / columnDef.length);
            for (var start = orginX, maxStart = orginX + areaWidth; start <= maxStart; start = start + width) {
                xaxisOrign.push(start);

            }
        }
        return xaxisOrign;
    },
    
     //Calculate position and size for each axis
    _calculateAxisSize: function (params) {

        //For Horizontal
        var isInitAxes = true, isOppInitAxes = true;
        var xaxisOrign = this._calColumnSize();
        var columnDefinition = this.model._columnDefinitions;		
        for (var i = 0, maxLength = columnDefinition.length; i < maxLength; i++) {
            var x1 = xaxisOrign[i];
            var x2 = xaxisOrign[i + 1];
            var nearIndexVal = 0;
            var farIndexVal = 0;;
            var isColFirstAxes = true, isColOppFirstAxes = true;
            var oppY = this.model.m_AreaBounds.Y;
            var norY = oppY + this.model.m_AreaBounds.Height;
            for (var j = 0, maxCol = columnDefinition[i].axis.length; j < maxCol; j++) {
                var currentColAxis = columnDefinition[i].axis[j];
                var realY = 0, axisColumnSpace = 0;
                var opposedPosition = currentColAxis._opposed;
                if (!params.axes[currentColAxis.name]._validCross) {
                    if (!opposedPosition) {
                        if (!(isColFirstAxes && (isInitAxes || nearIndexVal == 0))) {
                            axisColumnSpace = columnDefinition.nearSizes[nearIndexVal];
                            realY = norY = (norY + axisColumnSpace);
                            nearIndexVal++;
                        }
                        else {
                            realY = norY;
                            isColFirstAxes = false;
                        }

                    } else {
                        if (!(isColOppFirstAxes && (isOppInitAxes || farIndexVal == 0))) {
                            axisColumnSpace = columnDefinition.farSizes[farIndexVal];
                            realY = oppY = (oppY - axisColumnSpace);
                            farIndexVal++;
                        }
                        else {
                            realY = oppY;
                            isColOppFirstAxes = false;
                        }
                    }
                }
                if (currentColAxis.columnSpan) {
                    //Skip the axis size calculation for duplicate span axis
                    if (!(columnDefinition[i].index == currentColAxis.columnIndex))
                        continue;
                    var axisSize = (maxLength >= (i + currentColAxis.columnSpan)) ? i + currentColAxis.columnSpan : i+1;
                    x2 = xaxisOrign[axisSize];
                    if (!opposedPosition && nearIndexVal==0)isInitAxes = isColFirstAxes;
                    if (opposedPosition && farIndexVal == 0) isOppInitAxes = isColOppFirstAxes;
                } else {
                    x2 = xaxisOrign[i + 1];
                    isInitAxes = true;
                    isOppInitAxes = true;
                }
                
               currentColAxis.Location = { };
                currentColAxis.Location.X1 = x1 + currentColAxis.plotOffset;
                currentColAxis.Location.Y1 = realY;
                currentColAxis.Location.X2 = x2 - currentColAxis.plotOffset;
                currentColAxis.Location.Y2 = realY;
                currentColAxis.x = currentColAxis.Location.X1;
                currentColAxis.y = currentColAxis.Location.Y1;
                currentColAxis.width = (currentColAxis.Location.X2 - currentColAxis.Location.X1);
                currentColAxis.height = currentColAxis.Location.Y2 - currentColAxis.Location.Y1;

            }
        }
        
        //For Vertical
        isInitAxes = true, isOppInitAxes = true;
        var yaxisOrign = this._calRowSize();
        var rowDefinition = this.model._rowDefinitions;
        for (var i = 0, rowLength = rowDefinition.length; i < rowLength; i++) {
            var y1 = yaxisOrign[i];
            var y2 = yaxisOrign[i + 1];
            var nearIndex = 0;
            var farIndex = 0;
            var isFirstAxes = true, isOppFirstAxes = true;
           var x = this.model.m_AreaBounds.X;
           var norX = x, oppX = x + this.model.m_AreaBounds.Width;
           for (var j = 0, maxRow = rowDefinition[i].axis.length; j < maxRow; j++) {
                var axisSpace = 0;
                var realX = 0;
               
                var currentAxis = rowDefinition[i].axis[j];
                var opposedPosition = currentAxis._opposed;
                if (!params.axes[currentAxis.name]._validCross) {
                    if (!opposedPosition) {
                        if (!(isFirstAxes && (isInitAxes || nearIndex == 0))) {
                            axisSpace = rowDefinition.nearSizes[nearIndex];
                            realX = norX = (norX - axisSpace);
                            nearIndex++;
                        } else {
                            realX = x;
                            isFirstAxes = false;
                        }

                    } else {
                        if (!(isOppFirstAxes && (isOppInitAxes || isOppInitAxes == 0))) {
                            axisSpace = rowDefinition.farSizes[farIndex];
                            realX = oppX = (oppX + axisSpace);
                            farIndex++;
                        } else {
                            realX = oppX;
                            isOppFirstAxes = false;
                        }
                    }
                }
                if (currentAxis.rowSpan) {
                    //Skip the axis size calculation for duplicate span axis
                    if (!(rowDefinition[i].index == currentAxis.rowIndex))
                        continue;
                    var axisRowSize = (rowLength >= (i + currentAxis.rowSpan)) ? i + currentAxis.rowSpan : i + 1;
                    y2 = yaxisOrign[axisRowSize];
                    if (!opposedPosition && nearIndex==0) isInitAxes = isFirstAxes;
                    if (opposedPosition && farIndex==0) isOppInitAxes = isOppFirstAxes;
                } else {
                    y2 = yaxisOrign[i + 1];
                    isInitAxes = true;
                    isOppInitAxes = true;
                }
                currentAxis.Location = { };
                currentAxis.Location.X1 = realX;
                currentAxis.Location.Y1 = y1 - currentAxis.plotOffset;
                currentAxis.Location.X2 = realX;
                currentAxis.Location.Y2 = y2 + currentAxis.plotOffset;
                currentAxis.x = currentAxis.Location.X1;
                currentAxis.y = currentAxis.Location.Y2;
                currentAxis.height = (currentAxis.Location.Y1 - currentAxis.Location.Y2);
                currentAxis.width = currentAxis.axisLine.width;

            }
        }
    },

     //Validates whether provided crossing value is valid or not
    _validateCrossing: function (axis) {
        axis._opposedPosition = false;
        if (axis.crossesAt != null) {
            var crossAxis = this._getCrossAxis(this.model._axes, axis.orientation.toLowerCase() == 'horizontal', axis.crossesInAxis);
            axis._crossValue = this._getCrossValue(axis, crossAxis, crossAxis._valueType);
            if ((crossAxis.isInversed ? !axis.opposedPosition : axis.opposedPosition) ? axis._crossValue <= crossAxis.visibleRange.min : axis._crossValue >= crossAxis.visibleRange.max)
                axis._opposedPosition = true;
            return (crossAxis.visibleRange.min < axis._crossValue && crossAxis.visibleRange.max > axis._crossValue);
        }
        return false;
    },

     //Method to place axis at crossed location
    _axisCrossing: function (axis, locateAxis, params) {
        var hor = axis.orientation.toLowerCase() == 'horizontal';
        var crossAxis = this._getCrossAxis(this.model._axes, hor, axis.crossesInAxis);
        var crossValue = axis._crossValue;
        var delta = Math.abs((crossAxis.isInversed ? crossAxis.visibleRange.max : crossAxis.visibleRange.min) - crossValue);
        this._locateAxis(axis, crossAxis, hor, delta);
        if (!locateAxis)
            params._crossAxisOverlap = this._avoidOverlapping(axis, this.model.m_AreaBounds, hor, axis.opposedPosition, params) || params._crossAxisOverlap;
    },

    _locateAxis: function (axis, crossAxis, hor, delta) {
        var loc = (hor ? crossAxis.height : crossAxis.width) * delta / crossAxis.visibleRange.delta;
        if (hor)
            axis.y = crossAxis.y + crossAxis.height - loc;
        else
            axis.x = crossAxis.x + loc;
    },

    _avoidOverlapping: function (axis, bounds, hor, opposed, params) {
        var diff = 0;
		var axisbounds = params.axes[axis.name]._bounds;
        if (hor) {
            if (!opposed && axis.y + axisbounds > bounds.Y + bounds.Height) {
                bounds.Height -= diff = axis.y + axisbounds - bounds.Y - bounds.Height;
                this._recalculateSpace(axis, hor, opposed, diff);
                return true;
            }
            else if (opposed && axis.y - axisbounds < bounds.Y) {
                bounds.Y += diff = axisbounds - (axis.y - bounds.Y);
                bounds.Height -= diff;
                this._recalculateSpace(axis, hor, opposed, diff);
                return true;
            }
        }
        else {
            if (!opposed && axis.x - axisbounds < bounds.X) {
                bounds.X += diff = axisbounds - (axis.x - bounds.X);
                bounds.Width -= diff;
                this._recalculateSpace(axis, hor, opposed, diff);
                return true;
            }
            else if (opposed && axis.x + axisbounds > bounds.X + bounds.Width) {
                bounds.Width -= diff = axis.x + axisbounds - bounds.X - bounds.Width;
                this._recalculateSpace(axis, hor, opposed, diff);
                return true;
            }
        }
    },

    _recalculateSpace: function (axis, isHor, opposed, diff) {
        if (isHor) {
            var def = this.model._rowDefinitions;
            var index = opposed ? def.length - 1 : 0;
            for (var i = 0, len = def[index].axis.length; i < len; i++) {
                def[index].axis[i].height -= diff;
                def[index].axis[i].Location.Y2 -= diff;
                if (opposed)
                    def[index].axis[i].Location.Y1 = def[index].axis[i].y += diff;
            }
            var colIndex = axis.columnIndex;
            def = this.model._columnDefinitions
            for (var i = 0, len = def.length; i < len; i++)
                if (i !== colIndex)
                    for (var j = 0, length = def[i].axis.length; j < length; j++)
                        if (def[i].axis[j]._opposed === opposed)
                            def[i].axis[j].Location.Y1 = def[i].axis[j].Location.Y2 = def[i].axis[j].y += (opposed ? 1 : -1) * diff;
        }
        else {
            var def = this.model._columnDefinitions;
            var index = opposed ? def.length - 1 : 0;
            for (var i = 0, len = def[index].axis.length; i < len; i++) {
                def[index].axis[i].width -= diff;
                if (opposed)
                    def[index].axis[i].Location.X2 -= diff;
                else
                    def[index].axis[i].Location.X1 = def[index].axis[i].x += diff;
            }
            var rowIndex = axis.rowIndex;
            def = this.model._rowDefinitions
            for (var i = 0, len = def.length; i < len; i++)
                if (i !== rowIndex)
                    for (var j = 0, length = def[i].axis.length; j < length; j++)
                        if (def[i].axis[j]._opposed === opposed)
                            def[i].axis[j].Location.X1 = def[i].axis[j].Location.X2 = def[i].axis[j].x += (opposed ? -1 : 1) * diff;
        }
    },

    _getCrossValue: function (axis, crossAxis, type) {
        switch (type.toLowerCase()) {
            case 'category':
                return crossAxis.labels.indexOf(axis.crossesAt) != -1 ? crossAxis.labels.indexOf(axis.crossesAt) : axis.crossesAt;
            case 'datetime':
                return isNaN(Date.parse(axis.crossesAt)) ? null : Date.parse(axis.crossesAt);
            case 'logarithmic':
                return Math.log(axis.crossesAt) / Math.log(crossAxis.logBase);
        }
        return axis.crossesAt;
    },

    _getXCrossValue: function (series, axis, params) {
        var crossesInAxis = axis.crossesInAxis, yAxisName = series._yAxisName, validCross = params.axes[axis.name]._validCross || params.axes[axis.name]._validCross == null;
        //Checks whether origin should be changed for current series or not.
        return validCross && axis.crossesAt && ((!crossesInAxis && yAxisName === this.model.primaryYAxis.name) || (crossesInAxis && this._getCrossAxis(this.model._axes, true, crossesInAxis).name === yAxisName)) ? axis.crossesAt : 0;
    },

    _getAxisByName: function (axes, hor, name) {
        if (name) {
            for (var i = 0, count = axes.length; i < count; i++)
                if (axes[i].name === name && (hor ? axes[i].orientation=='vertical' : axes[i].orientation=='horizontal'))
                    return axes[i];
        }
    },

    _getCrossAxis: function (axes, hor, value) {
        return this._getAxisByName(axes, hor, value) || (this.model.requireInvertedAxes ? hor ? this.model.primaryXAxis : this.model.primaryYAxis : hor ? this.model.primaryYAxis : this.model.primaryXAxis);
    },

    _arrangeAxis: function () {
        var chartobj = this;
        var axis;
        var customRow;
        //Generate columnIndex/RowIndex value if it is not specify in sample  
        for (var i = 0; i < this.model._axes.length; i++) {
            axis = this.model._axes[i];
            if (axis.orientation.toLowerCase() == "horizontal") {
                chartobj.model.hAxes.push(axis);
                axis.columnIndex = (BoldBIDashboard.util.isNullOrUndefined(axis.columnIndex)) ? 0 : (axis.columnIndex);
                chartobj.model.hAxes[chartobj.model.hAxes.length - 1].columnIndex = axis.columnIndex;
            } else if (axis.orientation.toLowerCase() == "vertical") {

                chartobj.model.vAxes.push(axis);
                axis.rowIndex = (BoldBIDashboard.util.isNullOrUndefined(axis.rowIndex)) ? 0 : (axis.rowIndex);
                chartobj.model.vAxes[chartobj.model.vAxes.length - 1].rowIndex = axis.rowIndex;
                customRow = (!BoldBIDashboard.util.isNullOrUndefined(chartobj.model.rowDefinitions)) ? chartobj.model.rowDefinitions[axis.rowIndex] : null;
                if (customRow) {
                    axis.axisBottomLine = {};
                    axis.axisBottomLine.visible = true;
                    axis.axisBottomLine.lineWidth = customRow.lineWidth;
                    axis.axisBottomLine.color = customRow.lineColor;
                }
            }
        }

        this.model.hAxes = BoldBIDashboard.DataManager(this.model.hAxes, BoldBIDashboard.Query().sortBy("columnIndex")).executeLocal();

        this.model.vAxes = BoldBIDashboard.DataManager(this.model.vAxes, BoldBIDashboard.Query().sortBy("rowIndex")).executeLocal();
        
        //column axis information push into _rowDefinitions
        var rowCount = this.axesCount(chartobj.model.vAxes);
         chartobj.model._rowDefinitions = [];
        if (chartobj.model.vAxes.length>0) {
            for (var j = 0; j < rowCount.length; j++) {
                var rowCollection = chartobj.model.rowDefinitions;
                var rowDefinitions = ((rowCollection)) ? (rowCollection[j] ? rowCollection[j] : rowCollection[0]) : null;
                chartobj.model._rowDefinitions.push({axis: this.axesIndexCount(chartobj.model.vAxes, rowCount.indexValue[j])
                                , index: rowCount.indexValue[j], rowDefinitions: rowDefinitions });
            }
        }

        var rowDefinition = chartobj.model._rowDefinitions;
        //Using filter to get spanning row axis collection
        var spanningRow = this._axisFilter(rowDefinition, "rowSpan");
        //Arrange the entire axis for row span
        this._SpanningAxes(rowDefinition, spanningRow, true);

        //column axis information push into _columnDefinitions
        var columnCount = this.axesCount(chartobj.model.hAxes);
        chartobj.model._columnDefinitions = [];
        if (chartobj.model.hAxes.length > 0) {
            for (var k = 0; k < columnCount.length; k++) {
                var columnCollection = chartobj.model.columnDefinitions;
                var columnDefinitions = (columnCollection) ? (columnCollection[k] ? columnCollection[k] : columnCollection[0]) : null;
                chartobj.model._columnDefinitions.push({
                    axis: this.axesIndexCount(chartobj.model.hAxes, columnCount.indexValue[k])
                    , index: columnCount.indexValue[k], columnDefinitions: columnDefinitions });
            }
        }
        
        var columnDefinition = chartobj.model._columnDefinitions;
        //Using filter to get spanning column axis collection
        var spanningColumn = this._axisFilter(columnDefinition, "columnSpan");
        //Arrange the entire axis for column span
        this._SpanningAxes(columnDefinition, spanningColumn, false);
       
        this._axisSize();
        
        
    },
    
     //Arrange the entire axis for spanning
    _SpanningAxes: function (definition,spanningCollection, isRow) {
        for (var spanIndex = 0, spanMax = spanningCollection.length; spanIndex < spanMax; spanIndex++) {
            var currentAxis = spanningCollection[spanIndex];
             if (currentAxis == null) break;
             var span = isRow ? currentAxis.rowSpan : currentAxis.columnSpan;
             var index = isRow ? currentAxis.rowIndex : currentAxis.columnIndex;
            if(definition[index]!=undefined){
             var axisIndex = definition[index].axis.indexOf(currentAxis);
             for (var k = 1, m = index + 1; k < span && m < definition.length; k++, m++) {
                 if (definition[m].axis.length >= axisIndex) {
                     //Insert duplicate span row to appropriate rowdefinition
                     definition[m].axis.splice(axisIndex, 0, currentAxis);
                 }
             }
             }
         }
     },
    
     //Filter span axis from axes
    _axisFilter: function (definition, fieldName) {
        var axisResult = [];
        definition.filter(function (axes) {
             //Execute query to get spanning axis from axis array
              var axisCollection = BoldBIDashboard.DataManager(axes["axis"], BoldBIDashboard.Query().where(fieldName, ">", 1)).executeLocal();
              for (var i = 0, max = axisCollection.length; i < max; i++)
                  axisResult.push(axisCollection[i]);
        });
        return axisResult;
    },
    
    _axisSize: function () {
        //The below calcultion to get approximate length of axis
         var spaceValue = this._getLegendSpace();
         var hSpace = bbdesigner$(this.svgObject).width() - this.model.margin.left - this.model.margin.right - (this.model.elementSpacing * 2) - spaceValue.leftLegendWidth - spaceValue.rightLegendWidth;
        var hWidth = Math.floor(hSpace / this.axesCount(this.model.hAxes).length);

        var vSpace = bbdesigner$(this.svgObject).height() - this.model.margin.top - this.model.margin.bottom - (this.model.elementSpacing * 2) - spaceValue.topLegendHeight - spaceValue.bottomLegendHeight - spaceValue.modelTitleHeight-spaceValue.modelsubTitleHeight;
        var vWidth = Math.floor(vSpace / this.axesCount(this.model.vAxes).length);

       

        for (var j = 0; j < this.model._axes.length; j++) {
            axis = this.model._axes[j];
            if (axis.orientation.toLowerCase() == "horizontal") {
                if (this.model.AreaType != "polaraxes") {
                    var customColumn = (!BoldBIDashboard.util.isNullOrUndefined(this.model.columnDefinitions)) ? this.model.columnDefinitions[axis.columnIndex] : [];
                    var columnLength = hWidth;
                    if (customColumn) {
                        customColumn.unit = (customColumn.unit == undefined) ? "percentage" : customColumn.unit;
                        customColumn.columnWidth = (customColumn.columnWidth == undefined) ? 100 : customColumn.columnWidth;
                        if (customColumn.unit.toLowerCase() == "percentage") {
                            var length = this._axisColumnDefinitionSize(this.model.columnDefinitions);
                            columnLength = Math.floor((hWidth) * (customColumn.columnWidth / length));
                        }
                        else
                            columnLength = customColumn.columnWidth;

                    }
                    axis.length = axis.columnSpan ? axis.columnSpan * columnLength : columnLength;
                }
                else {
                    if (hSpace > vSpace*2)
                        axis.length = hSpace - vSpace;
                    else
                        axis.length = hSpace;
                }
            } else if (axis.orientation.toLowerCase() == "vertical") {
                if (this.model.AreaType != "polaraxes") {
                    var customRow = (!BoldBIDashboard.util.isNullOrUndefined(this.model.rowDefinitions)) ? this.model.rowDefinitions[axis.rowIndex] : [];
                    var realLength = vWidth;
                    if (customRow) {
                        customRow.unit = (customRow.unit == undefined) ? "percentage" : customRow.unit;
                        customRow.rowHeight = (customRow.rowHeight == undefined) ? 100 : customRow.rowHeight;
                        if (customRow.unit.toLowerCase() == "percentage") {
                            var length = this._axisRowDefinitionSize(this.model.rowDefinitions);
                            realLength = Math.floor((vWidth) * (customRow.rowHeight / length));
                        }
                        else
                            realLength = customRow.rowHeight;

                    }
                    axis.length = axis.rowSpan ? (axis.rowSpan * realLength) : realLength;
                }
                else {
                    axis.length = vSpace / 2;
                }
            }
        }
    },
	_axisRowDefinitionSize: function (array) {
        var length = 0;
        if (array) {
            for (var i = 0; i < array.length; i++) {
                length = length + array[i].rowHeight;
            }
        }
        length = length > 100 ? length : 100;
        return length;
    },
    _axisColumnDefinitionSize: function (array) {
        var length = 0;
        if (array) {
            for (var i = 0; i < array.length; i++) {
                length = length + array[i].columnWidth;
            }
        }
        length = length > 100 ? length : 100;
        return length;
    },
   _axisMeasure: function (axis, realWidth, orientation,j) {
        var axisTitleHeight =0; 
        var labelSize = 0;
        axis.axisLine.width = axis.axisLine.width < 0 ? 0 : axis.axisLine.width;
		axis.majorTickLines.size = axis.majorTickLines.size < 0 ? 0 : axis.majorTickLines.size;
		var axisLineWidth = !this.model.enable3D && axis.axisLine.visible && axis.axisLine.width;
		var titleText = !BoldBIDashboard.util.isNullOrUndefined(axis.title.trimmedText) && this.model.isResponsive ? axis.title.trimmedText : axis.title.text;
		var size = BoldBIDashboard.EjSvgRender.utils._measureText(titleText, realWidth, axis.title.font);
		if(orientation == "vertical")
		{
		    var majorTickLinesSize = this.svgWidth <= 100 ? 0 : axis.majorTickLines.size;
		    labelSize = this.svgWidth <= 100 || !axis.responsiveVisibility ? 0 : axis._LableMaxWidth.width;
		    axisTitleHeight = (axis.trimmedText == "" || titleText == "" || !(axis.title.visible) || !(axis.title.responsiveVisibility) ||!(axis.responsiveVisibility) || !(axis.visible))? 0 : ((document.documentMode === 8) ? size.width : size.height + (2 * this.model.elementSpacing));
		}
		else
		{

		    var majorTickLinesSize = this.svgHeight < 100 ? 0 : axis.majorTickLines.size;
		    labelSize = this.svgHeight <= 100 || !axis.responsiveVisibility ? 0 : (axis._LableMaxWidth.height);
		    axisTitleHeight = (axis.trimmedText == "" || titleText == "" || !(axis.title.visible) || !(axis.title.responsiveVisibility) || !(axis.responsiveVisibility) || !(axis.visible)) ? 0 : (size.height + (this.model.elementSpacing));
		}
		var width;		
		if ((j == 0) && (axis.tickLinesPosition == 'inside' && axis.labelPosition == 'inside'))
		    axis.AxisMaxWidth = axisTitleHeight + axisLineWidth + (this.model.elementSpacing);
		else if ((j == 0) && (axis.tickLinesPosition == 'inside' && axis.labelPosition != 'inside'))
		    axis.AxisMaxWidth = axisTitleHeight + axisLineWidth + (this.model.elementSpacing) + labelSize;
		else if ((j == 0) && (axis.tickLinesPosition != 'inside' && axis.labelPosition == 'inside'))
		    axis.AxisMaxWidth = axisTitleHeight + axisLineWidth + (this.model.elementSpacing) + majorTickLinesSize;
		else
		    axis.AxisMaxWidth = axisTitleHeight + axisLineWidth + this.model.elementSpacing + majorTickLinesSize + labelSize;
        return axis.AxisMaxWidth;
    },
     
    _arraySum: function (val) {
        var total = 0;
        for (var i = 0; i < val.length; i++) {
            total +=  parseFloat(val[i]) || 0;
        }
        return total;
    },
    _calSpace: function (realWidth, definitions,orientation, params) {
        var nearSizes = [];
        var farSizes = [];
        for (var i = 0; i < definitions.length; i++) {
            var nearIndex = 0, farIndex = 0;
            for (var j = 0; j < definitions[i].axis.length; j++) {
                var currentaxis = definitions[i].axis[j];                
                    bounds = params.axes[currentaxis.name]._bounds = this._axisMeasure(currentaxis, realWidth, orientation, j);
                    validCross = params.axes[currentaxis.name]._validCross = this._validateCrossing(currentaxis);
                    measureValue = validCross ? 0 : bounds;
                currentaxis._opposed = currentaxis.opposedPosition ? !currentaxis._opposedPosition : currentaxis._opposedPosition || currentaxis.opposedPosiiton||false;
                if (validCross)
                    continue;
                if (!currentaxis._opposed) {
                    if (nearSizes.length <= nearIndex) {
                        nearSizes.push(measureValue);
                    } else if (nearSizes[nearIndex] < (measureValue)) {
                        nearSizes[nearIndex] = measureValue;
                    }
                    nearIndex++;
                }
                else {
                    if (farSizes.length <= farIndex) {
                        farSizes.push(measureValue);
                    } else if (farSizes[farIndex] < (measureValue)) {
                        farSizes[farIndex] = measureValue;
                    }
                    farIndex++;
                }                

            }
        }        
        return { nearSizes: nearSizes, farSizes: farSizes };
    },
    
    _getLegendSpace: function (chartObj) {
        var chartObj = !BoldBIDashboard.util.isNullOrUndefined(chartObj) ? chartObj : this;
        var chart = chartObj.model,
            legend = chart.legend,
            position = !BoldBIDashboard.util.isNullOrUndefined(legend.responsivePosition) ? legend.responsivePosition : legend.position.toLowerCase(),
            bounds = chart.LegendActualBounds,
            measureText = BoldBIDashboard.EjSvgRender.utils._measureText,
            title = chart.title,
            subTitle = title.subTitle,
            elementSpacing = chart.elementSpacing,
            margin = chart.margin,
            svgWidth = chart.svgWidth,
            legendBorder = legend.border.width,
            ltheight = 0, space = 0,
            itemPadding = 10,
            leftLegendWidth = 0, rightLegendWidth = 0,
            topLegendHeight = 0, bottomLegendHeight = 0,
            modelTitleHeight = 0, modelsubTitleHeight = 0;
        if (legend.visible && legend.responsiveVisibility) {
            space = (bounds.Width + (itemPadding / 2) + elementSpacing + (2 * legendBorder));
            leftLegendWidth = position == 'left' ? space : 0;
            rightLegendWidth = position == 'right' ? space : 0;
            if (legend.title.text)
                ltheight = measureText(legend.title, null, legend.title.font).height;
            topLegendHeight = position == 'top' ? (bounds.Height + ltheight + (2 * legendBorder)) : 0;
            bottomLegendHeight = position == 'bottom' ? (bounds.Height + ltheight + (2 * legendBorder)) : 0;
        }            
        if (chartObj.model.title.visible && chartObj.model.title.responsiveVisibility) {
            var titleText = chartObj.model.title.text;
            modelTitleHeight = (titleText == "") ? 0 : (BoldBIDashboard.EjSvgRender.utils._measureText(titleText, bbdesigner$(chartObj.svgObject).width() - chartObj.model.margin.left - chartObj.model.margin.right, chartObj.model.title.font).height + chartObj.model.elementSpacing);
        }
        if (chartObj.model.title.subTitle.visible && chartObj.model.title.subTitle.responsiveVisibility) {
            var subTitleText = chartObj.model.title.subTitle.text;
            modelsubTitleHeight = (subTitleText == "") ? 0 : (BoldBIDashboard.EjSvgRender.utils._measureText(subTitleText, bbdesigner$(chartObj.svgObject).width() - chartObj.model.margin.left - chartObj.model.margin.right, chartObj.model.title.subTitle.font).height + chartObj.model.elementSpacing);
        }
        return {
            leftLegendWidth: leftLegendWidth, rightLegendWidth: rightLegendWidth, topLegendHeight: topLegendHeight, bottomLegendHeight: bottomLegendHeight, modelTitleHeight: modelTitleHeight, modelsubTitleHeight: modelsubTitleHeight
        };
    },


    _arraySome: function (axes,orientation) {
        var scroll = false,
            count = axes.length;

        for (var i = 0; i < count; i++) {
            scroll = (scroll || (((axes[i]._scrollBar && axes[i].maxPointLength < axes[i].pointsLength) || (axes[i].zoomFactor < 1 && this.model.zooming.enableScrollbar)) && axes[i].orientation.toLowerCase() == orientation));
        }

        return scroll;
    },

    _calculateAreaBounds: function (params, chartobj) {
        var chartobj = BoldBIDashboard.util.isNullOrUndefined(chartobj) ?  this : chartobj,
        realWidth = bbdesigner$(chartobj.svgObject).width() - chartobj.model.margin.left - chartobj.model.margin.right,
        // Calculate area bounds X and width
        chartBorderWidth = chartobj.model.border.width,
        adaptiveRendering = chartobj.model.adaptiveRendering,
        axis = chartobj.model._axes[0],
        zomming = chartobj.model.zooming.enableScrollbar,
        type = chartobj.model.zooming.type.toLowerCase();
        chartobj.model.scrollerSize = 18;
        chartobj.model._yScroll = chartobj._arraySome(chartobj.model._axes, 'vertical');
        chartobj.model._xScroll = chartobj._arraySome(chartobj.model._axes, 'horizontal');
        if (BoldBIDashboard.util.isNullOrUndefined(chartobj.params)) chartobj.params = params;
        //Calcultion for multiple axes(vertical)
        var sizes = chartobj._calSpace(realWidth, chartobj.model._rowDefinitions,"vertical", params);
        chartobj.model._rowDefinitions.nearSizes = sizes.nearSizes;
        chartobj.model._rowDefinitions.farSizes = sizes.farSizes;
        var vAxesWidth = chartobj._arraySum(sizes.nearSizes);
        var vAxesOppWidth = chartobj._arraySum(sizes.farSizes);

        var spaceValue=chartobj._getLegendSpace();
       
        var x = vAxesWidth + spaceValue.leftLegendWidth + chartobj.model.margin.left + chartBorderWidth + (chartobj.model._yScroll ? chartobj.model.scrollerSize : 0);
        var rightSpacing = vAxesOppWidth + spaceValue.rightLegendWidth + chartobj.model.margin.right + chartobj.model.margin.left + (2 * chartBorderWidth);
        var width = bbdesigner$(chartobj.svgObject).width();
        var boundsWidth =  width - (x + rightSpacing);
        if (boundsWidth <= 0 && chartobj.model.AreaType == "cartesianaxes" && !adaptiveRendering) {
            bbdesigner$(chartobj.svgObject).width(width - boundsWidth + 1);
            chartobj._calculateAreaBounds(params);
        }
        else {
        // Calculate area bounds Y and Height   
        
        //Calcultion for multiple axes(Horizontal)
        var columnSizes = chartobj._calSpace(realWidth, chartobj.model._columnDefinitions,"horizontal", params);
        chartobj.model._columnDefinitions.nearSizes = columnSizes.nearSizes;
            chartobj.model._columnDefinitions.farSizes = columnSizes.farSizes;
            var hAxesWidth = chartobj._arraySum(columnSizes.nearSizes);
            var hAxesOppWidth = chartobj._arraySum(columnSizes.farSizes);

            var y = hAxesOppWidth + chartobj.model.margin.top + (chartobj.model.elementSpacing) + spaceValue.modelTitleHeight + (spaceValue.modelsubTitleHeight) + spaceValue.topLegendHeight + chartBorderWidth;
            var bottomSpacing = hAxesWidth + chartobj.model.margin.bottom + spaceValue.bottomLegendHeight + (2 * chartBorderWidth) + (chartobj.model._xScroll ? chartobj.model.scrollerSize : 0);
            chartobj.model.derivedBoundsHeight = bbdesigner$(chartobj.svgObject).height() - (y + bottomSpacing);
            var boundsHeight = Math.abs(chartobj.model.derivedBoundsHeight);

            chartobj.model.m_AreaBounds = { X: x, Y: y, Width: boundsWidth, Height: boundsHeight };
            chartobj.model.m_Spacing = { Left: x, Top: y, Right: rightSpacing, Bottom: bottomSpacing };

            if (chartobj.model.enableCanvasRendering) {  // for adding bounds in canvas rendering
                chartobj.canvasX = x;
                chartobj.canvasY = y;
                chartobj.canvasWidth = boundsWidth;
                chartobj.canvasHeight = boundsHeight;
            } else 
                chartobj.canvasX = chartobj.canvasY = chartobj.canvasHeight = chartobj.canvasWidth = 0;
        }

        if (adaptiveRendering && chartobj.model.AreaType != "none") {
            chartobj.count = BoldBIDashboard.util.isNullOrUndefined(chartobj.count) ? 1 : chartobj.count + 1;
            if (chartobj.count > 0)
                chartobj._chartResponsiveLayout(params);
        }
      }
};

bbdesigner$.uaMatch = function (ua) {
    ua = ua.toLowerCase();

    var match = /(chrome)[ \/]([\w.]+)/.exec(ua) ||
        /(webkit)[ \/]([\w.]+)/.exec(ua) ||
        /(opera)(?:.*version|)[ \/]([\w.]+)/.exec(ua) ||
        /(msie) ([\w.]+)/.exec(ua) ||
        ua.indexOf("compatible") < 0 && /(mozilla)(?:.*? rv:([\w.]+)|)/.exec(ua) ||
        [];

    return {
        browser: match[1] || "",
        version: match[2] || "0"
    };
};


 
})(bbdesigner$);
;
/**
* @fileOverview Plugin to style the Html Chart elements
* @copyright Copyright SyncfusionBoldBIDashboard Inc. 2001 - 2013. All rights reserved.
*  Use of this code is subject to the terms of our license.
*  A copy of the current license can be obtained at any time by e-mailing
*  licensing@syncfusion.com. Any infringement will be prosecuted under
*  applicable laws. 
* @version 12.1 
* @author <a href="mailto:licensing@syncfusion.com">SyncfusionBoldBIDashboard Inc</a>
*/

(function (bbdesigner$, BoldBIDashboard) {

    BoldBIDashboard.widget("BoldBIDashboardChart", "BoldBIDashboard.datavisualization.Chart", {
 
        element: null,
 
        model: null,

        validTags: ["div"],
 
        defaults: {

            rangeColorMapping: [],


            chartArea:
            {

                border: {

                    color: 'Gray',

                    width: 0.5,

                    opacity: 0.3
                },

                background: 'transparent'

            },

            primaryXAxis:
            {
	            crossesAt: null,

         		crossesInAxis: null,

                isIndexed:false,
                range: {

                    min: null,

                    max: null,

                    interval: null
                },

                labelPosition: 'outside',

                tickLinesPosition: 'outside',

                alternateGridBand:
                        {

                            odd: {

                                fill: "transparent",

                                opacity: 1
                            },

                            even: {

                                fill: "transparent",

                                opacity: 1
                            }
                        },

                enableAutoIntervalOnZooming : true,
                         

                majorGridLines:
                {

                    width: 1,

                    dashArray: "",

                    visible: true,

                    opacity: 1

                },

                majorTickLines:
               {

                   width: 1,

                   size: 5,

                   visible: true
               },

                minorGridLines:
               {

                   width: 1,

                   dashArray: "",

                   visible: true

               },

                minorTickLines:
                {

                    width: 1,

                    size: 5,

                    visible: true
                },

                minorTicksPerInterval: null,

                columnIndex: null,

                columnSpan: null,

                labelRotation: null,

                valueType: null,

                name: null,

                labelFormat: null,

                desiredIntervals: null,

                intervalType: null,

                roundingPlaces: null,

                logBase: 10,

                plotOffset: 0,
                labels: [],

                stripLine: [
                       {

                           visible: false,

                           startFromAxis: false,

                           text: "",

                           width: 0,

                           textAlignment: "middlecenter",

                           font: {

                               fontFamily: 'Segoe UI',

                               fontStyle: 'Normal',

                               size: '12px',

                               fontWeight: 'Regular',

                               color: 'black',

                               opacity: 1
                           },

                           start: null,

                           end: null,

                           color: 'gray',

                           borderColor: 'black',

                           zIndex: 'over'
                       }
                ],

                title:
               {


                   text: "",

				    visible:true,

                   enableTrim: false,

                   maximumTitleWidth: null,

                   font:
                   {

                       fontFamily: 'Segoe UI',

                       fontStyle: 'Normal',

                       size: '14px',

                       opacity: 1,

                       fontWeight: 'regular'
                   }
               },
                rangePadding: 'Auto',
                additionalPadding: [1, 1],
                orientation: 'Horizontal',

                maximumLabels: 3,

                opposedPosition: false,

                axisLine:
                {

                    visible: true,

                    width: 1,

                    dashArray: "",

                    offset: 0
                },

                labelIntersectAction: "",

                maximumLabelWidth: 34,

                enableTrim: false,


                edgeLabelPlacement: "none",



                isInversed: false,



                font:
                {

                    fontFamily: 'Segoe UI',

                    fontStyle: 'Normal',

                    size: '11px',

                    fontWeight: 'regular',

                    opacity: 1
					
                },

                visible: true,

                crosshairLabel:
                {

                    visible: false
                },

                zoomFactor: 1,

                zoomPosition: 0
            },


            primaryYAxis:
              {
                  crossesAt: null,
                  crossesInAxis: null,
                  range: {

                      min: null,

                      max: null,

                      interval: null
                  },

                  labelPosition: 'outside',

                  tickLinesPosition: 'outside',

                  alternateGridBand:
                             {

                                 odd: {

                                     fill: "transparent",

                                     opacity: 1
                                 },

                                 even: {


                                     fill: "transparent",

                                     opacity: 1
                                 }
                             },

                  enableAutoIntervalOnZooming: true,                                

                  majorGridLines:
                 {

                     width: 1,

                     dashArray: "",

                     visible: true,

                     opacity: 1

                 },

                  majorTickLines:
                {

                    width: 1,

                    size: 3,

                    visible: true
                },

                  minorGridLines:
                 {

                     width: 1,

                     dashArray: "",

                     visible: true

                 },

                  minorTickLines:
                {

                    width: 1,

                    size: 3,

                    visible: true
                },

                  minorTicksPerInterval: null,

                  rowIndex: null,

                  rowSpan: null,

                  valueType: null,

                  name: null,

                  labelFormat: null,

                  desiredIntervals: null,

                  intervalType: null,

                  roundingPlaces: null,
                  labels: [],

                  title:
                  {

                      text: "",

					   visible:true,

                      enableTrim: false,

                      maximumTitleWidth: null,

                      font:
                     {

                         fontFamily: 'Segoe UI',

                         fontStyle: 'Normal',

                         opacity: 1,

                         size: '14px',

                         fontWeight: 'regular'
                     }
                  },

                  rangePadding: 'Auto',


                  stripLine: [
                       {

                           visible: false,

                           startFromAxis: false,

                           width: 0,

                           text: "",

                           textAlignment: "middlecenter",

                           font: {

                               fontFamily: 'Segoe UI',

                               fontWeight: 'Regular',

                               fontStyle: 'Normal',

                               size: '12px',

                               color: 'black',

                               opacity: 1
                           },

                           start: null,

                           end: null,

                           color: 'gray',

                           borderColor: 'black',

                           zIndex: 'over'
                       }
                  ],

                  logBase: 10,

                  plotOffset: 0,

                  orientation: 'Vertical',

                  maximumLabels: 3,

                  labelIntersectAction: "",


                  maximumLabelWidth: 34,

                  enableTrim: false,

                  edgeLabelPlacement: "none",


                  isInversed: false,


                  crosshairLabel:
                 {

                     visible: false
                 },

                  visible: true,

                  opposedPosition: false,

                  font:
               {

                   fontFamily: 'Segoe UI',

                   fontStyle: 'Normal',

                   size: '11px',

                   opacity: 1,

                   fontWeight: 'regular'
				   
               },

                  axisLine:
              {

                  visible: true,

                  width: 1,

                  dashArray: "",

                  offset: 0
              },


                  zoomFactor: 1,

                  zoomPosition: 0
              },
            axes: [],

            secondaryX:
             {
                 crossesAt: null,
                 crossesInAxis: null,
                 range: {
                     min: null,
                     max: null,
                     interval: null
                 },
                 tickLinesPosition: "outside",
                 labelPosition: "outside",

                 majorGridLines:
        {

            width: 1,

            dashArray: "",

            visible: true
        },
                 alternateGridBand:
           {
               odd: {
                   fill: "transparent",
                   opacity: 1
               },
               even: {
                   fill: "transparent",
                   opacity: 1
               }
           },

                 enableAutoIntervalOnZooming: true,                                

                 majorTickLines:
         {

             width: 1,

             size: 5,

             visible: true
         },

                 minorGridLines:
         {

             width: 1,

             dashArray: "",

             visible: true

         },

                 minorTickLines:
        {

            width: 1,

            size: 5,

            visible: true
        },

                 minorTicksPerInterval: null,

                 columnIndex: null,

                 columnSpan: null,

                 labelRotation: null,

                 valueType: null,

                 name: null,

                 labelFormat: null,

                 desiredIntervals: null,

                 intervalType: null,

                 roundingPlaces: null,

                 logBase: 10,

                 plotOffset: 0,
                 labels: [],
                 stripLine: [
              {
                  visible: false,
                  startFromAxis: false,
                  text: "",
                  textAlignment: "middlecenter",
                  font: { fontFamily: 'Segoe UI', fontStyle: 'Normal', fontWeight: 'regular', size: '12px', color: 'black', opacity: 1 },
                  start: null,
                  end: null,
                  color: 'gray',
                  borderColor: 'black',
                  zIndex: 'over'
              }
                 ],

                 title:
         {


             text: "",
             visible:true,
             enableTrim: false,
             maximumTitleWidth: null,
             font:
        {

            fontFamily: 'Segoe UI',

            fontStyle: 'Normal',

            size: '14px',

            opacity: 1,

            fontWeight: 'regular'
			
        }

         },

                 rangePadding: 'Auto',
                 additionalPadding: [1, 1],

                 orientation: 'Horizontal',

                 maximumLabels: 3,

                 opposedPosition: false,

                 axisLine:
          {

              visible: true,

              width: 1,

              dashArray: "",

              offset: 0
          },

                 labelIntersectAction: "",

                 edgeLabelPlacement: "none",

                 font:
          {

              fontFamily: 'Segoe UI',

              fontStyle: 'Normal',

              size: '11px',

              fontWeight: 'regular',

              opacity: 1
          },

                 visible: true,

                 crosshairLabel:
           {

               visible: false
           },

                 zoomFactor: 1,

                 zoomPosition: 0
             },

            secondaryY:
                {
                    crossesAt: null,
                    crossesInAxis: null,
                    range: {
                        min: null,
                        max: null,
                        interval: null
                    },
                    tickLinesPosition: "outside",
                    labelPosition: "outside",

                    majorGridLines:
       {

           width: 1,

           dashArray: "",

           visible: true

       },
                    alternateGridBand:
           {
               odd: {
                   fill: "transparent",
                   opacity: 1
               },
               even: {
                   fill: "transparent",
                   opacity: 1
               }
           },

                    enableAutoIntervalOnZooming: true,                                   

                    majorTickLines:
                        {

                            width: 1,

                            size: 3,

                            visible: true
                        },

                    minorGridLines:
                        {

                            width: 1,

                            dashArray: "",

                            visible: true

                        },

                    minorTickLines:
                        {

                            width: 1,

                            size: 3,

                            visible: true
                        },

                    minorTicksPerInterval: null,

                    rowIndex: null,

                    rowSpan: null,

                    valueType: null,

                    name: null,

                    labelFormat: null,

                    desiredIntervals: null,

                    intervalType: null,

                    roundingPlaces: null,
                    labels: [],

                    title:
                    {

                        text: "",
                        visible:true,
                        enableTrim: false,
                        maximumTitleWidth: null,
                        font:
                        {
                            fontFamily: 'Segoe UI',

                            fontStyle: 'Normal',

                            opacity: 1,

                            size: '14px',

                            fontWeight: 'regular'
                        }
                    },

                    rangePadding: 'Auto',

                    stripLine: [
                         {
                             visible: false,
                             startFromAxis: false,
                             text: "",
                             textAlignment: "middlecenter",
                             font: { fontFamily: 'Segoe UI', fontStyle: 'Normal', fontWeight: 'regular', size: '12px', color: 'black', opacity: 1 },
                             start: null,
                             end: null,
                             color: 'gray',
                             borderColor: 'black',
                             zIndex: 'over'
                         }
                    ],

                    logBase: 10,

                    plotOffset: 0,

                    orientation: 'Vertical',

                    maximumLabels: 3,

                    labelIntersectAction: "",

                    edgeLabelPlacement: "none",

                    crosshairLabel:
                    {

                        visible: false
                    },

                    visible: true,

                    opposedPosition: false,

                    font:
                    {
                        fontFamily: 'Segoe UI',

                        fontStyle: 'Normal',

                        size: '11px',

                        opacity: 1,

                        fontWeight: 'regular'
						
                    },

                    axisLine:
                        {

                            visible: true,

                            width: 1,

                            dashArray: "",

                            offset: 0
                        },


                    zoomFactor: 1,

                    zoomPosition: 0
                },
            trendlineDefaults: {
                type: "linear",
                visibility: "",
				visibleOnLegend:"visible",
                name: "Trendline",
                fill: "",
                width: 1,
                opacity: 1,
                dashArray: "",
                forwardForecast: 0,
                backwardForecast: 0,
                polynomialOrder: 2,
                period: 2,
				intercept: null,
                tooltip: {
                    visible: false, format: "#point.x# : #point.y#", fill: null, border: { width: 1, color: null }, duration: '500ms', enableAnimation: true, opacity: 0.95, font: {fontFamily: 'Segoe UI', fontStyle: 'Normal', fontWeight: 'Regular', size: '12px', opacity: 1}
                }
            },
            indicatorDefaults: {
                visible: true,
                points: [],
                tooltip: { visible: false, format: "#point.x# : #point.y#", fill: null, border: { width: 1, color: null }, duration: '500ms', enableAnimation: true, opacity: 0.95 },
                seriesName: "",
                font: { fontFamily: 'Segoe UI', fontStyle: 'Normal', fontWeight: 'Regular', size: '12px', color: '#707070', opacity: 1 },
                type: "SMA",
                period: 14,
                standardDeviations: 2,
                kPeriod: 3,
                dPeriod: 3,
                periodLine: { fill: "blue", width: 2 },
                lowerLine: { fill: "#008000", width: 2 },
                upperLine: { fill: "#ff0000", width: 2 },
                macdLine: { fill: "#ff9933", width: 2 },
                histogram: { fill: "#ccccff", opacity: 1, border: { color: "#9999ff", width: 1 } },
                fill: "#00008B",
                width: 2,
                xAxisName: "",
                yAxisName: "",
                visibility: "visible",
                macdType: "line",
                shortPeriod: 12,
                longPeriod: 26,
                trigger: 9,
                enableAnimation: false
            },
            annotationsDefault: {
                visible: false,
                content: "",
                coordinateUnit: "none",
                verticalAlignment: "middle",
                horizontalAlignment: "middle",
                region: "chart",
                x: 0,
                y: 0,
                opacity: 1,
                angle: 0,
                xAxisName: "",
                yAxisName: "",
                margin: {
                    left: 0,
                    right: 0,
                    bottom: 0,
                    top: 0
                }
            },
            stripLineDefault: {

                visible: false,

                startFromAxis: false,

                width: 0,

                text: "",

                textAlignment: 'middlecenter',

                font:
                {

                    fontFamily: 'Segoe UI',

                    fontStyle: 'Normal',

                    fontWeight: 'Regular',

                    size: '12px',

                    color: 'black',

                    opacity: 1
                },

                start: null,

                end: null,

                color: 'gray',

                borderColor: 'black',

                zIndex: 'over',

                borderWidth: 1
            },

            rowDefinitions: null,

            columnDefinitions: null,

            title:
				{
				    isReversed: false,

				    text: "",
					
					visible: true,

				    textAlignment: "center",

				    background: 'transparent',

				    border: {

				        color: 'transparent',

				        width: 1,

				        opacity: 0.8,

				        cornerRadius: 0.8

				    },

				    font: {

				        fontFamily: 'Segoe UI',

				        fontStyle: 'Normal',

				        size: '16px',

				        opacity: 1,

				        fontWeight: 'regular'
				    },


				    subTitle:
                           {

                               isReversed: false,

                               text: "",
							   
							   visible: true,

                               textAlignment: 'far',

                               background: 'transparent',

                               border: {

                                   color: 'transparent',

                                   width: 1,

                                   opacity: 0.8,

                                   cornerRadius: 0.8

                               },


                               font:
                               {

                                   fontFamily: 'Segoe UI',

                                   fontStyle: 'Normal',

                                   size: '12px',

                                   opacity: 1,

                                   fontWeight: 'regular'
                               }
                           }

				},





            lineCap: { butt: 'butt', round: 'round', square: 'square' },
            lineJoin: { round: 'round', bevel: 'bevel', miter: 'miter' },
            legendAlignment: { near: 'near', center: 'center', far: 'far' },
            legendPosition: { top: 'top', bottom: 'bottom', right: 'right', left: 'left', custom: 'custom' },

            enableAnimation: true,

            selectedDataPointIndexes :[],

            legend:
            {
				isReversed: false,

                title:
                      {
                          text: "",

                          textAlignment: 'center',

                          font:
                              {

                                  size: '12px',

                                  fontFamily: "Segoe UI",

                                  fontStyle: 'normal',

                                  fontWeight: 'regular'
                              }
                      },

                border:
                {

                    color: 'transparent',


                    width: 1
                },

                visible: true,

                textOverflow: 'none',

                textWidth:34,

                toggleSeriesVisibility: true,
				
				enableScrollbar: true,

                itemPadding: 10,

                shape: 'None',

                alignment: 'Center',

                position: 'Bottom',

                location:
                {

                    x: 0,

                    y: 0
                },

                itemStyle:
                {
                    height: 10,

                    width: 10,

                    border:
                    {

                        color: 'transparent',

                        width: 1
                    }
                },

                rowCount: null,

                columnCount: null,

                opacity: 1,

                fill: null,

                background: null,

                font:
                {

                    fontFamily: 'Segoe UI',

                    fontStyle: 'Normal',

                    fontWeight: 'Regular',

                    size: '12px'
                },

                size:
                    {

                        height: null,

                        width: null
                    },

                mode: "series",

                enableMultiRange: true
            },

            indicators: [
              {
                  points: [],

                  tooltip:
				  {

				      visible: false,

				      format: "#point.x# : #point.y#",

				      fill: null,

				      border: {

				          width: 1,

				          color: null
				      },

				      duration: '500ms',

				      enableAnimation: true,

				      opacity: 0.95
				  },

                  seriesName: "",

                  type: "SMA",

                  period: 14,

                  standardDeviations: 2,

                  kPeriod: 3,

                  dPeriod: 3,

                  periodLine: {

                      fill: "blue",

                      width: 2
                  },

                  lowerLine: {


                      fill: "#008000",

                      width: 2
                  },

                  upperLine: {

                      fill: "#ff0000",

                      width: 2
                  },

                  macdLine: {

                      fill: "#ff9933",

                      width: 2
                  },

                  histogram: {

                      fill: "#ccccff",

                      opacity: 1,

                      border: {

                          color: "#9999ff",

                          width: 1
                      }
                  },

                  fill: "#00008B",

                  visible: true,

                  font: {

                      fontFamily: 'Segoe UI',

                      fontStyle: 'Normal',

                      fontWeight: 'Regular',

                      size: '12px',

                      color: '#707070',

                      opacity: 1
                  },

                  width: 2,

                  xAxisName: "",

                  yAxisName: "",

                  macdType: "line",

                  shortPeriod: 12,

                  longPeriod: 26,

                  trigger: 9,

                  visibility: "visible",

                  enableAnimation: false
              }
            ],


            backGroundImageUrl: null,

            annotations: [{

                visible: false,

                content: "",

                coordinateUnit: "none",

                verticalAlignment: "middle",

                horizontalAlignment: "middle",

                region: "chart",

                x: 0,

                y: 0,

                opacity: 1,

                angle: 0,

                xAxisName: "",

                yAxisName: "",

                margin: {

                    left: 0,

                    right: 0,

                    bottom: 0,

                    top: 0
                }
            }],

            series: [
                {
                    clusterName :'',
                    type: 'column',
					
					visibleOnLegend:"visible",

                    enableAnimation: false,

                    isClosed: true,

					 isTransposed:false,

                    isStacking: true,

					columnSpacing: 0,

                    columnWidth: 0.7,

                    drawType: 'line',

                    doughnutCoefficient: 0.4,

                    explodeOffset: 25,

                    pyramidMode: 'linear',

                    funnelWidth: '11.6%',

                    funnelHeight: '32.7%',

                    positiveFill: null,

                    connectorLine: {

                        width: 1,

                        opacity: 1,

                        dashArray: null
                    },
					
					 errorBar: {

                        visibility: "hidden",

                        mode: "vertical",

                        type:"fixedValue",
                        
                        horizontalErrorValue: 1,

                        verticalErrorValue: 3,

                        horizontalPositiveErrorValue: 1,

                        horizontalNegativeErrorValue: 1,

                        verticalPositiveErrorValue: 5,

                        verticalNegativeErrorValue: 5,

                        direction: "both",

                        cap:{
                            
                            visible:true,
                            
                            width: 1,

                            length: 20,

                        },


                        width: 1,

                        opacity: 1,

                    },

                    highlightSettings: {

                        enable: false,

                        mode: 'series',

                        color: "",

                        opacity: 0.6,

                        border: {

                            color: "",

                            width: 2
                        },

                        pattern: 'none',

                        customPattern: ""
                    },

                    selectionSettings: {

                        type:'Single',

                        enable: false,

                        mode: 'series',

                        rangeType: 'xy',

                        color: "",

                        opacity: 0.6,

                        border: {

                            color: "",

                            width: 2
                        },

                        pattern: 'none',

                        customPattern: ""
                    },
					
					emptyPointSettings: {

                        visible: true,

                        style: {

                            color: '',

                            border: {

                                color: '',

                                width: 1

                            }
                        
                        },

                        displayMode: 'gap'
                    },
					
                    labelPosition: 'inside',

                    gapRatio: 0,

                    points: null,

                    pieCoefficient: 0.8,

                    doughnutSize: 0.8,

                    dataSource: null,

                    high: '',

                    low: '',

                    open: '',

                    close: '',

                    bullFillColor: null,

                    bearFillColor: null,

                    query: null,

                    xName: '',

                    yName: '',

                    pointColorMappingName: '',



                    visibility: "visible",
					
                    startAngle: null,

                    endAngle: null,

                    xAxisName: null,

                    yAxisName: null,

                    explodeAll: null,

                    explode: false,

                    explodeIndex: null,

                    enableSmartLabels: null,

                    tooltip: {

                        isReversed: false,

                        visible: false,

                        format: "#point.x# : #point.y#",

                        template: null,


                        fill: null,

                        border: {

                            width: 1,

                            color: null
                        },

                        enableAnimation: true,

                        duration: '500ms',

                        opacity: 0.95
                    },

                    fill: null,

                    opacity: 1,

                    lineCap: 'butt',

                    lineJoin: 'round',

                    dashArray: "",

                    border: {

                        width: 1,

                        color: 'transparent',

                        dashArray:""
                    },
                    width: 2,

                    marker: {

                        shape: 'circle',

                        imageUrl: "",

                        size: {

                            width: 6,

                            height: 6
                        },

                        visible: false,

                        opacity: 1,

                        fill: null,

                        border: {

                            color: 'white',

                            width: 3
                        },

                        dataLabel: {

                            isReversed: false,

                            visible: false,

                            angle: 0,

                            textMappingName:'',

                            verticalTextAlignment: 'center',

                            horizontalTextAlignment: 'center',

                            textPosition: 'top',
							
							textAnchor: 'middle',

                            shape: 'none',

                            opacity: 1,

                            fill: null,

                            border: {

                                color: 'white',

                                width: 0.1
                            },

                            connectorLine: {

                                width: 0.5,

                                type: 'line',

                                color: null
                            },

                            offset: {

                                x: 0,

                                y:0
                            },

                            font: {

                                fontFamily: 'Segoe UI',

                                fontStyle: 'Normal',

                                fontWeight: 'Regular',

                                size: '11px',

                                opacity: 1
                            },

                            margin: {

                                left: 5,

                                top: 5,

                                bottom: 5,

                                right: 5
                            }

                        }
                    },


                    trendlines: [{

                        visibility: "",
						
						visibleOnLegend: "visible",

                        type: "linear",

                        name: "Trendline",

                        fill: "",

                        width: 1,

                        opacity: 1,

                        dashArray: "",

                        forwardForecast: 0,

                        backwardForecast: 0,

                        polynomialOrder: 2,

                        period: 2,
						
						intercept: null,

                        tooltip:
                 {

                     visible: false,

                     format: "#point.x# : #point.y#",

                     fill: null,

                     border: {

                         width: 1,

                         color: null
                     },

                     duration: '500ms',

                     enableAnimation: true,

                     opacity: 0.95,

                     font: {

                         fontFamily: 'Segoe UI',

                         fontStyle: 'Normal',

                         fontWeight: 'Regular',

                         size: '12px',

                         opacity: 1
                     }
                 }
                    }],


                    font: {

                        fontFamily: 'Segoe UI',

                        fontStyle: 'Normal',

                        fontWeight: 'Regular',

                        size: '12px',

                        color: '#707070',

                        opacity: 1
                    },
                    _isdesigntime: true

                }
            ],

            commonSeriesOptions: {

                clusterName: '',

                type: 'column',
				
				visibleOnLegend: "visible",

                enableAnimation: false,

                isClosed: true,

				 isTransposed:false,

                isStacking: false,

				columnWidth: 0.7,

                columnSpacing: 0,

                drawType: 'line',

                doughnutCoefficient: 0.4,

                explodeOffset: 25,

                pyramidMode: 'linear',

                funnelWidth: '11.6%',

                funnelHeight: '32.7%',

                positiveFill: null,

                connectorLine: {

                    width: 1,

                    opacity: 1,

                    dashArray: null
                },

				 errorBar: {

                        visibility: "hidden",

                        mode: "vertical",

                        type:"fixedValue",
                        
                        horizontalErrorValue: 1,

                        verticalErrorValue: 3,

                        horizontalPositiveErrorValue: 1,

                        horizontalNegativeErrorValue: 1,

                        verticalPositiveErrorValue: 5,

                        verticalNegativeErrorValue: 5,

                        direction: "both",

                        cap:{
                            
                            visible:true,
                            
                            width: 1,

                            length: 20,

                        },


                        width: 1,

                        opacity: 1,

                    },
				
                highlightSettings: {

                    enable: false,

                    mode: 'series',

                    color: "",

                    opacity: 0.6,

                    border: {

                        color: "",

                        width: 2
                    },

                    pattern: 'none',

                    customPattern: ""
                },

                selectionSettings: {

                    type:'Single',

                    enable: false,

                    mode: 'series',

                    rangeType: 'xy',

                    color: "",

                    opacity: 0.6,

                    border: {

                        color: "",

                        width: 2
                    },

                    pattern: 'none',

                    customPattern: ""
                },
				
				emptyPointSettings: {

                        visible: true,

                        style: {

                            color: '',

                            border: {

                                color: '',

                                width: 1

                            }
                        
                        },

                        displayMode: 'gap'
                },

                labelPosition: 'inside',

                gapRatio: 0,

                pieCoefficient: 0.8,

                doughnutSize: 0.8,

                dataSource: null,

                xName: '',

                yName: '',

                pointColorMappingName:'',

                high: '',

                low: '',

                open: '',

                close: '',

                startAngle: null,

                endAngle: null,

                xAxisName: null,

                yAxisName: null,

                explodeAll: false,

                explode: false,

                explodeIndex: null,

                enableSmartLabels: null,

                tooltip: {

                    isReversed: false,

                    visible: false,

                    format: "#point.x# : #point.y#",

                    template: null,

                    fill: null,

                    border: {

                        color: null,

                        width: 1
                    },

                    enableAnimation: true,

                    duration: '500ms',

                    opacity: 0.95
                },

                fill: null,

                opacity: 1,

                lineCap: 'butt',

                lineJoin: 'round',

                dashArray: "",

                border: {

                    color: 'transparent',

                    width: 1,

                    dashArray: ""
                },
                width: 2,

                marker:
                {

                    shape: 'circle',

                    imageUrl: "",

                    size: {

                        width: 6,

                        height: 6
                    },

                    visible: false,

                    opacity: 1,

                    fill: null,

                    border: {

                        color: 'white',

                        width: 3
                    },

                    dataLabel:
                    {
                        isReversed: false,

                        visible: false,

                        angle: 0,

                        textMappingName:'',

                        verticalTextAlignment: 'center',

                        horizontalTextAlignment: 'center',

                        textPosition: 'top',
						
						textAnchor: 'middle',

                        shape: 'none',


                        opacity: 1,

                        fill: null,

                        border: {

                            color: 'white',

                            width: 0.1
                        },

                        offset: {

                            x: 0,

                            y: 0
                        },

                        connectorLine:
                        {

                            width: 0.5,

                            type: 'line'
                        },

                        font:
                        {

                            fontFamily: 'Segoe UI',

                            fontStyle: 'Normal',

                            fontWeight: 'Regular',

                            size: '11px',

                            opacity: 1
                        },

                        margin:
                        {

                            left: 5,

                            top: 5,

                            bottom: 5,

                            right: 5
                        }
                    }
                },

                trendlines: [{

                    visibility: "",
					
					visibleOnLegend: "visible",

                    type: "linear",

                    name: "Trendline",

                    fill: "",

                    width: 1,

                    opacity: 1,

                    dashArray: "",

                    forwardForecast: 0,

                    backwardForecast: 0,

                    polynomialOrder: 2,

                    period: 2,
					
					intercept: null,

                    tooltip:
                 {

                     visible: false,

                     format: "#point.x# : #point.y#",

                     fill: null,

                     border: {

                         width: 1,

                         color: null
                     },

                     duration: '500ms',

                     enableAnimation: true,

                     opacity: 0.95,

                     font: {

                         fontFamily: 'Segoe UI',

                         fontStyle: 'Normal',

                         fontWeight: 'Regular',

                         size: '12px',

                         opacity: 1
                     }
                 }
                }],

                font: {

                    fontFamily: 'Segoe UI',

                    fontStyle: 'Normal',

                    fontWeight: 'Regular',

                    size: '12px',

                    color: '#707070',

                    opacity: 1
                }
            },

            crosshair:
            {

                marker:
                {

                    visible: true,

                    size:
                    {

                        width: 10,

                        height: 10
                    },

                    opacity: 1,

                    border:
                    {

                        width: 3
                    }
                },

                visible: false,

                isReversed:false,

                type: "crosshair"
            },


            pointStyle:
            {
                lineCap: 'butt', lineJoin: 'round', opacity: 1, interior: null, borderColor: null, borderWidth: 1
            },
            textStyle:
            {
                marker: { textAlignment: 'center', textPosition: 'top' },
                font: { fontFamily: 'Segoe UI', fontStyle: 'Normal', fontWeight: 'Regular', size: '12px', color: '#707070', opacity: 1 }
            },
            symbolShape: {
                None: 0,
                LeftArrow: 1,
                RightArrow: 2,
                Circle: 3,
                Cross: 4,
                HorizLine: 5,
                VertLine: 6,
                Diamond: 7,
                Rectangle: 8,
                Triangle: 9,
                InvertedTriangle: 10,
                Hexagon: 11,
                Pentagon: 12,
                Star: 13,
                Ellipse: 14,
                Wedge: 15,
                Trapezoid: 16,
                UpArrow: 17,
                DownArrow: 18,
                Image: 19,
                SeriesType: 20

            },
            initSeriesRender: true,

            enableRightClick: false,

            theme: "flatlight",

            canResize: false,

            isResponsive: false,

			adaptiveRendering: false,

            enable3D: false,

            enableRotation: false,

            sideBySideSeriesPlacement: null,

            perspectiveAngle: 90,

            rotation: 0,

            tilt: 0,

            wallSize: 2,

            depth: 100,

            enableCanvasRendering: false,

			exportSettings: {

                type: "png",

                fileName: "Chart",

                orientation: "portrait",

                angle: 0,

                mode: "client",

                action: "",
				
				multipleExport: false
            },
			
            zooming:
            {
                isReversed: false,

                enable: false,

                enableScrollbar : false,

                type: 'x,y',

                enableMouseWheel: false,

                enableDeferredZoom: false,

                toolbarItems: ["zoomIn", "zoomOut", "zoom", "pan", "reset"]
            },
            type: 'x,y',

            locale: "en-US",

            xZoomFactor: 1,

            yZoomFactor: 1,

            xZoomPosition: 0,

            yZoomPosition: 0,

            load: "",

            axesLabelRendering: "",

            axesRangeCalculate: "",

            axesTitleRendering: "",

            chartAreaBoundsCalculate: "",

            legendItemRendering: "",

            legendBoundsCalculate: "",

            preRender: "",

            seriesRendering: "",


            trendlineRendering: "",

            symbolRendering: "",

            titleRendering: "",
            subtitleRendering: "",

            axesLabelsInitialize: "",

            pointRegionClick: "",

            seriesRegionClick: "",

            annotationClick:"",
 
			 axisLabelClick:"",

			 chartClick: "",

			 chartRightClick: "",

			 scrollStart: "",

			 scrollEnd: "",

            scrollChanged: "",

            chartDoubleClick:"",

            pointRegionMouseMove: "",

            legendItemClick: "",

            axisLabelMouseMove: "",

            chartMouseMove: "",

            legendItemMouseMove: "",

            chartMouseLeave: "",

            displayTextRendering: "",

            toolTipInitialize: "",

            trackAxisToolTip: "",

            trackToolTip: "",

            animationComplete: "",

            zoomed:"",

            destroy: "",

            create: "",

            beforeResize: "",

            afterResize: "",

            rangeSelected: "",

            margin: { left: 10, right: 10, top: 10, bottom: 10 },
            size: { width: null, height: null },
            elementSpacing: 10,

            dateStart: 25568.791666666668

        },

        dataTypes: {
            commonSeriesOptions: { dataSource: "data" },
            axes: "array",
            series: "array",
            annotations: "array",
            indicators: "array",
            seriesColors: "array",
            palette: "array",
            rowDefinitions: "array",
            columnDefinitions: "array",
            seriesBorderColors: "array",
            pointColors: "array",
            pointBorderColors: "array",
            initSeriesRender: "boolean",
            enableRightClick: "boolean",
            theme: "enum",
            canResize: "boolean",
            isResponsive:"boolean",
            adaptiveRendering:"boolean",
            elementSpacing: "number",
            primaryXAxis: {
                labels: "array",
                stripLine: "array",
                orientation: "enum",
                rangePadding: "enum",
                tickLinesPosition: "enum",
                labelPosition: "enum",
                opposedPosition: "boolean",
                zoomFactor: "number",
                zoomPosition: "number"                 
            },
            primaryYAxis: {
                labels: "array",
                stripLine: "array",
                orientation: "enum",
                rangePadding: "enum",
                opposedPosition: "boolean",
                zoomFactor: "number",
                zoomPosition: "number"               
            },
            legend: {
                textOverflow:"enum",
                shape: "enum",
                alignment: "enum",
                position: "enum",
                itemPadding: "number"
            },
			exportSettings: {
                type: "string",
                fileName: "string",
                orientation: "enum",
                angle: "number",
                mode: "enum",
                action: "string",
				multipleExport: "boolean"
            },
            zooming: {
                enable: "boolean",
                type: "string",
                enableMouseWheel: "boolean",
                toolbarItems: "array",
                enableScrollbar: "boolean"
            },
            size: {
                width: "string",
                height: "string"
            }

        },

        observables: ["xZoomFactor", "yZoomFactor", "xZoomPosition", "yZoomPosition"],

        _tags: [{
            tag: "series",
            attr: ["xAxisName", "yAxisName", "endAngle", "startAngle", "explodeIndex", "labelPosition", "xName", "yName","pointColorMappingName", "pyramidMode", 
                   "pieCoefficient", "explodeAll", "explodeOffset", "funnelWidth", "funnelHeight", "gapRatio", "isClosed","isTransposed", 
                   "isStacking", "bearFillColor", "bullFillColor", "dataSource", "enableAnimation", "doughnutCoefficient", "doughnutSize", 
                   "enableSmartLabels", "drawType",
				   [
				     {
				         tag: "trendlines", attr: ["dashArray", "forewardForecast", "backwardForecast", "polynomialOrder"], singular:"trendline"
				     }
			       ],
			       [
				     {
				         tag: "points", attr: ["x", "y", "text", "textMappingName", "isEmpty", "fill", "visible"]
				     }
			       ]
				    
            ],
            singular: "series"
        }, {
            tag: "axes",
            attr: ["columnIndex", "rowIndex", "desiredIntervals", "edgeLabelPlacement", "intervalType", "labelFormat", "labelPosition", "labelRotation", "logBase", "labelIntersectAction", "opposedPosition", "plotOffset", "rangePadding", "roundingPlaces", "valueType", "zoomFactor", "zoomPosition", "orientation",
              [
                {
                    tag: "stripLine", attr: ["borderColor", "startFromAxis", "zIndex", "textAlignment"],
                    singular: "stripLine"
                }
              ],
            ],
            singular: "axis"
        },
              {
                  tag: "primaryXAxis.stripLine",
                  attr: ["borderColor", "startFromAxis", "zIndex", "textAlignment"],
                  singular: "primaryXAxis.stripLine"
              },
            {
                tag: "primaryYAxis.stripLine",
                attr: ["borderColor", "startFromAxis", "zIndex", "textAlignment"],
                singular: "primaryYAxis.stripLine"
            },
           {
               tag: "indicators",
               attr: ["seriesName", "type", "xName", "period", "xAxisName", "visibility", "macdType", "shortPeriod", "longPeriod", "trigger", "enableAnimation", "yAxisName", "standardDeviations", "kPeriod", "dPeriod", "periodLine", "lowerLine", "upperLine", "macdLine", "histogram",
                  [
                    {
                        tag: "points", attr: []
                    }
                  ]
               ],
               singular: "indicator"
           },
          {
              tag: "annotations",
              attr: ["visible", "content", "coordinateUnit", "opacity", "verticalAlignment", "horizontalAlignment", "region", "x", "y", "angle", "xAxisName", "yAxisName", "margin"],
              singular: "annotation"
          }
        ],
        _xZoomFactor: BoldBIDashboard.util.valueFunction("xZoomFactor"),
        _yZoomFactor: BoldBIDashboard.util.valueFunction("yZoomFactor"),
        _xZoomPosition: BoldBIDashboard.util.valueFunction("xZoomPosition"),
        _yZoomPosition: BoldBIDashboard.util.valueFunction("yZoomPosition"),


        _init: function () {

            this._renderSfChart();

        },
        _destroy: function () {
            bbdesigner$('#template_group_' + this._id).remove();
            bbdesigner$("#annotation_group_" + this._id).remove();
            bbdesigner$(this.element).removeClass("e-chart e-js").find("#" + this.svgObject.id).remove();
            bbdesigner$(this.element).removeClass("e-chart e-js").find("#legend_" + this.svgObject.id).remove();
        },

        _series: function (index, property, value, old) {
            this.redraw();
            this._trigger("refresh");
        },
        _series_points: function (index, property, value, old) {
            this.redraw();
            this._trigger("refresh");
        },
        _primaryXAxis_stripLine: function (index, property, value, old) {
            this.redraw();
            this._trigger("refresh");
        },
        _primaryYAxis_stripLine: function (index, property, value, old) {
            this.redraw();
            this._trigger("refresh");
        },
        _axes: function (index, property, value, old) {
            this.redraw();
            this._trigger("refresh");
        },
        _axes_stripLine: function (index, property, value, old) {
            this.redraw();
            this._trigger("refresh");
        },

        _ignoreOnExport: ["dataSource"],


        _removeZoomkit: function () {
            if (this.model.zooming.enable) {
                bbdesigner$('#' + this.svgObject.id + '_ResetZoom').remove();
                bbdesigner$('#' + this.svgObject.id + '_PanBtn').remove();
                bbdesigner$('#' + this.svgObject.id + '_ZoomBtn').remove();
                bbdesigner$('#' + this.svgObject.id + '_ZoomInBtn').remove();
                bbdesigner$('#' + this.svgObject.id + '_ZoomOutBtn').remove();
            }
        },


        redraw: function (excludeDataUpdate) {
			if(this.model.enableAnimation){
				var series = this.model.series;
                for (var i = 0; i < series.length; i++) {
                    series[i]._animatedSeries = false;
                    series[i]._animatedTrendline = false;
                    series[i].AnimationComplete = false; //pie doughnut animation with datalabel
                }
                var indicators = this.model.indicators;
                for (var j = 0; j < indicators.length; j++) {
                    indicators[j]._animatedSeries = false;
                    indicators[j]._animatedTrendline = false;
                }
			}
            if (this.model.enableCanvasRendering) {
                if (this.model.zooming.enable && this.svgRenderer.ctx)
                    this.svgRenderer.ctx.clearRect(0, 0, BoldBIDashboard.util.isNullOrUndefined(this.model.size.width) ? bbdesigner$("#" + this._id).width() : this.model.size.width, BoldBIDashboard.util.isNullOrUndefined(this.model.size.height) ? "450" : this.model.size.height);
                else {
                    bbdesigner$(this.svgObject).remove();
                    var width = this.svgWidth;
                    bbdesigner$("#canvas_trackSymbol").remove();
                    this.svgRenderer = new BoldBIDashboard.EjCanvasRender(this.element); // to create canvas container
                    this.svgRenderer.svgObj.height = BoldBIDashboard.util.isNullOrUndefined(this.model.size.height) ? "450" : this.model.size.height;
                    this.svgRenderer.svgObj.width = BoldBIDashboard.util.isNullOrUndefined(this.model.size.width) ? width : this.model.size.width;
                    this.svgObject = this.svgRenderer.svgObj;
                    var ctx = this.svgRenderer.svgObj.getContext("2d");

					bbdesigner$(this.scrollerContainer).remove();
                    bbdesigner$(this.legendSvgContainer).remove();
                    bbdesigner$(this.legendContainer).remove();
                    this.legendContainer = bbdesigner$("<div></div>").attr('id', "legend_" + this._id).css("height", "0px");
					this.scrollerContainer = bbdesigner$("<div></div>").attr('id', "legend_Scroller" + this._id).css("height", "0px");
                    this.legendSvgContainer = this.svgRenderer.createLegendCanvas(this.element); //creating new CANVAS element for legend
                    this.svgRenderer.append(this.legendSvgContainer, this.scrollerContainer);
					bbdesigner$(this.scrollerContainer).appendTo(this.legendContainer);
                    bbdesigner$(this.legendContainer).appendTo(this.chartContainer);
                }
            }
            else if ((this.svgObject.id).indexOf("_canvas") != -1) {
                this._removeZoomkit();
                bbdesigner$(this.svgObject).remove();
                this.svgRenderer = new BoldBIDashboard.EjSvgRender(this.element);  // to create svg container
                this.svgObject = this.svgRenderer.svgObj;
                this.canvasX = this.canvasY = 0;

                bbdesigner$(this.scrollerContainer).remove();
                bbdesigner$(this.legendSvgContainer).remove();
                bbdesigner$(this.legendContainer).remove();
                this.legendContainer = bbdesigner$("<div></div>").attr('id', "legend_" + this._id).css("height", "0px");
                this.scrollerContainer = bbdesigner$("<div></div>").attr('id', "legend_Scroller" + this._id).css("height", "0px");
                this.legendSvgContainer = this.svgRenderer.createLegendSvg(this.element); //creating new SVG element for legend
                this.svgRenderer.append(this.legendSvgContainer, this.scrollerContainer);
                bbdesigner$(this.scrollerContainer).appendTo(this.legendContainer);
                bbdesigner$(this.legendContainer).appendTo(this.chartContainer);
            } else {
                bbdesigner$(this.svgObject).empty();              // using existing svg container			   
                bbdesigner$(this.legendSvgContainer).empty();
            }
            bbdesigner$("#annotation_group_" + this._id).remove();   // to remove annotation on redraw
            if (!excludeDataUpdate) {

                if (this.model.canResize || this.model.isResponsive)
                    this.bindResizeEvents();
                else
                    this.removeResizeEvents();
            }
            this.bindTo(excludeDataUpdate);
        },

          "export": function (type, action, multipleExport) {       // method to export chart
            var data,
            exporting = this.model.exportSettings,
            type = BoldBIDashboard.util.isNullOrUndefined(type) ? exporting.type : type.toLowerCase(),
            action = BoldBIDashboard.util.isNullOrUndefined(action) ? exporting.action : action.toLowerCase();

            if (type == "xlsx")
                this.excelExport(type, action, multipleExport);
            else if (type == "svg")
                data = this.svgExport();
            else
                data = this.imageExport();

            return data;
        },

         excelExport: function (type, action, multipleExport) {           // to export chart as excel
            var modelClone = bbdesigner$.extend(true, {}, this.model),
            exporting = this.model.exportSettings,
            multipleExport = BoldBIDashboard.util.isNullOrUndefined(type) ? exporting.multipleExport : multipleExport,
            attr = { action: action, method: 'post' },
            form = BoldBIDashboard.buildTag('form', "", null, attr),
            series, chartobj = this;
            
            if (this._ignoreOnExport) {
                series = modelClone.series;
                for (var j = 0; j < series.length; j++) {
                    delete series[j].dataSource;
                    delete series[j].query;
                    series[j].fill = bbdesigner$.type(series[j].fill) == "array" ? series[j].fill[0].color : series[j].fill;
                }
            }
            if (BoldBIDashboard.raiseWebFormsServerEvents){
                this.raiseWebServerEvents(JSON.stringify(modelClone), "excelExporting");
                this.raiseWebServerEvents(JSON.stringify(modelClone));
             }
            else {
                if (multipleExport) {
                    var chartObjectArray = {};
                    bbdesigner$('body').find('.e-datavisualization-chart').each(function (index, object) {
                        var chartObject = bbdesigner$(object).data('BoldBIDashboardChart');
                        if (!BoldBIDashboard.isNullOrUndefined(chartObject)) {
                            var modelClone = JSON.parse(JSON.stringify(chartObject.model));
                            if (chartobj._ignoreOnExport) {
                                series = modelClone.series;
                                for (var j = 0; j < series.length; j++) {
                                    delete series[j].dataSource;
                                    delete series[j].query;
                                    series[j].fill = bbdesigner$.type(series[j].fill) == "array" ? series[j].fill[0].color : series[j].fill;
                                }
                                chartObjectArray[index] = JSON.stringify(modelClone);
                                var inputAttr = { name: 'ChartModel', type: 'hidden', value: JSON.stringify(modelClone) }
                                var input = BoldBIDashboard.buildTag('input', "", null, inputAttr);
                                form.append(input);
                            }
                        }
                    });
                }
                else {
                    var inputAttr = { name: 'ChartModel', type: 'hidden', value: JSON.stringify(modelClone) }
                    var input = BoldBIDashboard.buildTag('input', "", null, inputAttr);
                    form.append(input);
                    form.append(this);
                }
                bbdesigner$('body').append(form);
                form.submit();
            }
            return true;
        },

        imageExport: function () {       // to export chart as image
            var modelClone = bbdesigner$.extend(true, {}, this.model);
            var Id = this._id,
                chart = bbdesigner$("#" + Id + '_canvas')[0],
                legend = bbdesigner$('#legend_' + Id + '_canvas')[0],
                selectionChart = bbdesigner$('[id*=' + Id + '_Selection_' + ']'),
                exportChart = document.createElement('canvas'),
                exprtCtx = exportChart.getContext("2d"),
                exporting = this.model.exportSettings,
                angle = exporting.angle,
                legendPos = this.model.LegendBounds, containerStyle, i, dataURL;
            exportChart.setAttribute('id', 'Export_' + Id);
            chartWidth = bbdesigner$("#" +Id + "_canvas").width();
            chartHeight = bbdesigner$("#" +Id + "_canvas").height();
            if (angle==0){
                exportChart.setAttribute('width', chartWidth);
                exportChart.setAttribute('height', chartHeight);
                exprtCtx.drawImage(chart, 0, 0);
                legendPos = this.model.LegendBounds;
                if (legendPos.X)
                   exprtCtx.drawImage(legend, legendPos.X, legendPos.Y);
            } else if (angle == 90 || angle == -90) {
                 exportChart.setAttribute('width', chartHeight);
            exportChart.setAttribute('height', chartWidth);
            exprtCtx.save();
            exprtCtx.translate(chartHeight/2, chartWidth/2);
            exprtCtx.rotate(angle*Math.PI/180);
            exprtCtx.drawImage(chart,-chartWidth/2,- chartHeight/2);
            exprtCtx.restore();
            if (legendPos.X){
              exprtCtx.save();
              if (angle==90)
                exprtCtx.translate(chartHeight - legendPos.Y - legendPos.Height/2, chartWidth- legendPos.X - legendPos.Width/2); 
              else
                exprtCtx.translate(legendPos.Y + legendPos.Height/2, legendPos.X + legendPos.Width/2);
              exprtCtx.rotate(angle*Math.PI/180);
              exprtCtx.drawImage(legend, -legendPos.Width/2 , -legendPos.Height/2);
              exprtCtx.restore();
             }
            } else {
                exportChart.setAttribute('width', chartWidth);
                exportChart.setAttribute('height', chartHeight);
                exprtCtx.save();
                exprtCtx.translate(chartWidth, chartHeight);
                exprtCtx.rotate(180*Math.PI/180);
                exprtCtx.drawImage(chart,0,0);
                exprtCtx.restore();
                if (legendPos.X){
                  exprtCtx.save();
                  exprtCtx.translate(legendPos.X + legendPos.Width/2, chartHeight -legendPos.Y - legendPos.Height/2);
                  exprtCtx.rotate(angle*Math.PI/180);
                  exprtCtx.drawImage(legend, -legendPos.Width/2 , -legendPos.Height/2);
                  exprtCtx.restore();
                }
              }

             for (i = 0; i < selectionChart.length; i++) {       // export for selection
                containerStyle = document.getElementById(selectionChart[i].id).getBoundingClientRect();
                exprtCtx.drawImage(selectionChart[i], 0, 0);
            }
            dataURL = exporting.type == "jpg" ? exportChart.toDataURL("image/jpeg") : exportChart.toDataURL();
			if (exporting.mode == "client")                    // for client side
			    return exportChart;
            else if (BoldBIDashboard.raiseWebFormsServerEvents)                            // for web forms
                this.raiseWebServerEvents(dataURL);
            else if (exporting.mode == "server") {                       // server side
                var attr, form, chartModel, input1, data, input2;
                attr = { action: exporting.action, method: 'post' };
                form = BoldBIDashboard.buildTag('form', "", null, attr);
                chartModel = { name: 'ChartModel', type: 'hidden', value: JSON.stringify(modelClone) };
                input1 = BoldBIDashboard.buildTag('input', "", null, chartModel);
				data = { name: 'Data', type: 'hidden', value: dataURL};
				input2 = BoldBIDashboard.buildTag('input', "", null, data);
                form.append(input1).append(input2).append(this);
                bbdesigner$('body').append(form);
                form.submit();
            }
        },

        svgExport: function () {                   // to export chart as SVG
            var svgObj = this.svgObject.id,
            modelClone = bbdesigner$.extend(true, {}, this.model);
            svg =  bbdesigner$('<div>').append(bbdesigner$('#' + svgObj).clone()).html(),
            position = bbdesigner$("#legend_" + this._id).position(),
            element = bbdesigner$("#" + svgObj + "_Legend").attr('transform', "translate(" + position.left + "," + position.top + ")"),
            legend =  bbdesigner$('<div>').append(bbdesigner$('#legend_' + svgObj).clone()).html(),
            exporting = this.model.exportSettings, angle = exporting.angle, 
            content= '<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">', chartWidth = bbdesigner$("#" +this._id).width(),
            chartHeight = bbdesigner$("#" +this._id).height();
            if (angle ==0)
                content = content + svg.toString() + legend.toString() + "</svg>";
            else if (angle == 90)
                content = content + '<g transform="translate('+ chartHeight + ',0) rotate(90 0 0)">' + svg.toString() + legend.toString() + "</g></svg>";
            else if (angle == -90)
                content = content + '<g transform="translate(0,'+ chartWidth + ') rotate(-90 0 0)">' + svg.toString() + legend.toString() + "</g></svg>";
            else
                content = content + '<g transform="translate('+ chartWidth + ',' + chartHeight + ') rotate(180 0 0)">' + svg.toString() + legend.toString() + "</g></svg>";
            content = encodeURIComponent(content);
            bbdesigner$("#" + svgObj + "_Legend").removeAttr("transform");
			if (exporting.mode == "client")            // for client side
			    return content;
            else if (BoldBIDashboard.raiseWebFormsServerEvents)                               // for web forms
                this.raiseWebServerEvents(content);
            else if (exporting.mode == "server") {                         // server side
                var attr, form, inputAttr, input;
                attr = { action: exporting.action, method: 'post' };
                form = BoldBIDashboard.buildTag('form', "", null, attr);
                chartModel = { name: 'ChartModel', type: 'hidden', value: JSON.stringify(modelClone) };
                input1 = BoldBIDashboard.buildTag('input', "", null, chartModel);
                inputAttr = { name: 'Data', type: 'hidden', value: content };
                input = BoldBIDashboard.buildTag('input', "", null, inputAttr);
                form.append(input).append(input1).append(this);
                bbdesigner$('body').append(form);
                form.submit();
            }
        },
        
		 raiseWebServerEvents: function (content, event) {             // to trigger server events in web forms
            var modelClone = bbdesigner$.extend(true, {}, this.model),
            exporting = this.model.exportSettings,
            event = BoldBIDashboard.util.isNullOrUndefined(event) ? "exporting" : event;
            args = { model: modelClone, originalEventType: event },
            clientArgs = { Data: content, Format: exporting.type, Orientation: exporting.orientation, FileName: exporting.fileName };
            BoldBIDashboard.raiseWebFormsServerEvents(event, args, clientArgs);
        },
		
        animate: function (options) {
            if (!options) { // Animate the entire series and indicators "previous behavior"
                var series = this.model.series;
                for (var i = 0; i < series.length; i++) {
                    series[i]._animatedSeries = false;
                    series[i]._animatedTrendline = false;
                    series[i].AnimationComplete = false; //pie doughnut animation with datalabel
                }
                var indicators = this.model.indicators;
                for (var j = 0; j < indicators.length; j++) {
                    indicators[j]._animatedSeries = false;
                    indicators[j]._animatedTrendline = false;
                }
            } else if (options.constructor === Array) { // Animate array of series
                for (var i = 0; i < options.length; i++) {
                    options[i]._animatedSeries = false;
                    options[i]._animatedTrendline = false;
                    options[i].AnimationComplete = false; //pie doughnut animation with datalabel
                }
            } else {   // Animate the specific series
                options._animatedSeries = false;
                options._animatedTrendline = false;
                options.AnimationComplete = false;  //pie doughnut animation with datalabel
            }
            this.redraw();
        },


        _setModel: function (options) {
            var series, axes;
            for (var prop in options) {
                this.disableAnimation();
                switch (prop) {
                    case "theme":
                        this.model._themeChanged = true;
                        this.model.theme = options[prop];
                        this.setTheme(BoldBIDashboard.EjSvgRender.themes, this.model.theme);
                        bbdesigner$.extend(true, this.model.primaryXAxis, BoldBIDashboard.EjSvgRender.themes[this.model.theme].primaryXAxis);
                        bbdesigner$.extend(true, this.model.primaryYAxis, BoldBIDashboard.EjSvgRender.themes[this.model.theme].primaryYAxis);
                        for (var k = 0; k < this.model.axes.length; k++) {
                            if (this.model.axes[k].orientation && this.model.axes[k].orientation.toLowerCase() == "horizontal")
                                bbdesigner$.extend(true, this.model.axes[k], BoldBIDashboard.EjSvgRender.themes[this.model.theme].secondaryX);
                            else
                                bbdesigner$.extend(true, this.model.axes[k], BoldBIDashboard.EjSvgRender.themes[this.model.theme].secondaryY);
                        }
                        for (var l = 0; l < this.model.series.length; l++) {
                            bbdesigner$.extend(true, this.model.series[l], BoldBIDashboard.EjSvgRender.themes[this.model.theme].commonSeriesOptions);
                        }
                        break;
                    case "commonSeriesOptions":
                        for (var i = 0; i < this.model.series.length; i++)
                            bbdesigner$.extend(true, this.model.series[i], {}, options[prop]);
                        break;
                    case "series":
                        series = this.model.series;
                        bbdesigner$.extend(true, series, {}, options[prop]);
                        for (var i = 0, len = series.length; i < len; i++) {
                            if (series[i].enableAnimation)
                                series[i]._animatedSeries = false;
                        }
                        break;
                    case "legend":
                        bbdesigner$.extend(true, this.model.legend, {}, options[prop]);
                        break;
                    case "axes":
                        bbdesigner$.extend(true, this.model.axes, {}, options[prop]);
                        break;
                    case "primaryXAxis":
                        this.model.primaryXAxis.setRange = (options[prop].range) ? true : false;
                        this.model.primaryXAxis.setAxisInterval = (options[prop].range && options[prop].range.interval) ? true : this.model.primaryXAxis.setAxisInterval;
                        this.model.primaryXAxis.actual_Range = (this.model._axes[0].setRange) ? null : this.model._axes[0].actual_Range;
                        bbdesigner$.extend(true, this.model.primaryXAxis, {}, options[prop]);
                        break;
                    case "primaryYAxis":
                        this.model.primaryYAxis.setRange = (options[prop].range) ? true : false;
                        this.model.primaryYAxis.log_Range = options[prop].range ? options[prop].range : this.model.primaryYAxis.log_Range;
                        this.model.primaryYAxis.actual_Range = (this.model._axes[1].setRange) ? null : this.model._axes[1].actual_Range;
                        bbdesigner$.extend(true, this.model.primaryYAxis, {}, options[prop]);
                        break;
                    case "xZoomFactor":
                        this.model.primaryXAxis.zoomFactor = this._xZoomFactor();
                        axes = this.model.axes;
                        for (var i = 0; i < axes.length; i++) {
                            if(axes[i].orientation.toLowerCase() == "horizontal")
                            axes[i].zoomFactor = this._xZoomFactor();
                        }
                        break;
                    case "yZoomFactor":
                        this.model.primaryYAxis.zoomFactor = this._yZoomFactor();
                        axes = this.model.axes;
                        for (var i = 0; i < axes.length; i++) {
                            if (axes[i].orientation.toLowerCase() == "vertical")
                                axes[i].zoomFactor = this._yZoomFactor();
                        }
                        break;
                    case "xZoomPosition":
                        this.model.primaryXAxis.zoomPosition = this._xZoomPosition();
                        axes = this.model.axes;
                        for (var i = 0; i < axes.length; i++) {
                            if (axes[i].orientation.toLowerCase() == "horizontal")
                                axes[i].zoomPosition = this._xZoomPosition();
                        }
                        break;
                    case "yZoomPosition":
                        this.model.primaryYAxis.zoomPosition = this._yZoomPosition();
                        axes = this.model.axes;
                        for (var i = 0; i < axes.length; i++) {
                            if (axes[i].orientation.toLowerCase() == "vertical")
                                axes[i].zoomPosition = this._yZoomPosition();
                        }
                        break;
                    case "drilldown":
                        this.model.series = [];
                        this.model.explodeValue = null;
                        bbdesigner$.extend(true, this.model, {}, options[prop]);
                        break;
                    case "datasource":
                        for (var i = 0; i < this.model.series.length; i++) {
                            this.model.series[i].dataSource = null;
                            this.model.series[i].points = null;
                        }
                        bbdesigner$.extend(true, this.model, {}, options[prop]);
                        break;
                    case "chartArea":
                        bbdesigner$.extend(true, this.model.chartArea, {}, options[prop]);
                        break;

                    default:
                        bbdesigner$.extend(true, this.model, {}, options[prop]);
                        series = this.model.series;
                        for (var i = 0, len = series.length; i < len; i++) {
                            if (series[i].enableAnimation)
                                series[i]._animatedSeries = false;
                        }
                }
            }
            if (this.model.canResize ||this.model.isResponsive)
                this.bindResizeEvents();
            else
                this.removeResizeEvents();
            bbdesigner$("#annotation_group_" + this._id).remove(); // to remove annotation on set model
            if (this.model.enableCanvasRendering) {
                bbdesigner$(this.svgObject).remove();
                bbdesigner$("#canvas_trackSymbol").remove();
                this.svgRenderer = new BoldBIDashboard.EjCanvasRender(this.element); // to create canvas container
                this.svgRenderer.svgObj.height = BoldBIDashboard.util.isNullOrUndefined(this.model.size.height) ? "450" : this.model.size.height;
                this.svgRenderer.svgObj.width = BoldBIDashboard.util.isNullOrUndefined(this.model.size.width) ? bbdesigner$("#" + this._id).width() : this.model.size.width;
                this.svgObject = this.svgRenderer.svgObj;

                bbdesigner$(this.legendSvgContainer).remove();
                this.legendSvgContainer = this.svgRenderer.createLegendCanvas(this.element); //creating new CANVAS element for legend
                this.svgRenderer.append(this.legendSvgContainer, this.legendContainer);
            }
            else if ((this.svgObject.id).indexOf("_canvas") != -1) {
                this._removeZoomkit();
                bbdesigner$(this.svgObject).remove();
                this.svgRenderer = new BoldBIDashboard.EjSvgRender(this.element);  // to create svg container
                this.svgObject = this.svgRenderer.svgObj;
                this.canvasX = this.canvasY = 0;

                bbdesigner$(this.legendSvgContainer).remove();
                this.legendSvgContainer = this.svgRenderer.createLegendSvg(this.element); //creating new SVG element for legend
                this.svgRenderer.append(this.legendSvgContainer, this.legendContainer);
            }
            else {
                bbdesigner$(this.svgObject).empty();              // using existing svg container
                bbdesigner$(this.legendSvgContainer).empty();
            }

            this.bindTo();
        }
    });

    BoldBIDashboard.datavisualization.Chart.CrosshairType = {

        Crosshair: 'crosshair',

        TrackBall: 'trackBall'
    };
	
	BoldBIDashboard.datavisualization.Chart.VisibleOnLegend={
		
		Visible:'visible',
		
		Hidden:'hidden'
	};
	
    BoldBIDashboard.datavisualization.Chart.ExportingType = {

        PNG: 'png',

        JPG: 'jpg',

        PDF: 'pdf',

        SVG: 'svg',

        DOCX: 'docx',

        XLSX: 'xlsx'
    };

    BoldBIDashboard.datavisualization.Chart.ExportingMode = {
       
        Client: 'client',

        Server: 'server'
    };

     BoldBIDashboard.datavisualization.Chart.ExportingOrientation = {
       
        Portrait: 'portrait',

        Landscape: 'landscape'
    };

    BoldBIDashboard.datavisualization.Chart.ValueType = {

        Double: 'double',

        DateTime: 'datetime',

        Category: 'category',

        Logarithmic: 'logarithmic',
		
		DateTimeCategory:'datetimecategory'
    };

    BoldBIDashboard.datavisualization.Chart.TextOverflow = {

        None: 'none',

        Wrap: 'wrap',

        Trim: 'trim',

        WrapAndTrim:'wrapandtrim'
    };

    BoldBIDashboard.datavisualization.Chart.Type = {

        Line: 'line',

        Spline: 'spline',

        Column: 'column',

        Doughnut: 'doughnut',

        Area: 'area',

        SplineArea: 'splinearea',

        StepLine: 'stepline',

        StepArea: 'steparea',

        Pie: 'pie',

        Hilo: 'hilo',

        HiloOpenClose: 'hiloopenclose',

        Candle: 'candle',

        Bubble: 'bubble',

        Scatter: 'scatter',

        Bar: 'bar',

        StackingArea: 'stackingarea',

        StackingArea100: 'stackingarea100',

        RangeColumn: 'rangecolumn',

        StackingColumn: 'stackingcolumn',

        StackingColumn100: 'stackingcolumn100',

        StackingBar: 'stackingbar',

        StackingBar100: 'stackingbar100',

        Pyramid: 'pyramid',

        Funnel: 'funnel',

        Polar: 'polar',

        Radar: 'radar',

        RangeArea: 'rangearea',
		
		SplineRangeArea: 'splinerangearea',

        Waterfall: 'waterfall'

    };

    BoldBIDashboard.datavisualization.Chart.LabelPlacement = {

        BetweenTicks: "betweenTicks",

        OnTicks: "onTicks"
    };

    BoldBIDashboard.datavisualization.Chart.TrendlinesType = {

        Linear: "linear",

        Exponential: "exponential",

        Logarithmic: "logarithmic",

        Power: "power",

        Polynomial: "polynomial"
    };

    BoldBIDashboard.datavisualization.Chart.ErrorBarType = {

        FixedValue: "fixedValue",

        Percentage: "percentage",

        StandardDeviation: "standardDeviation",

        StandardError: "standardError",

        Custom: "custom"
    };

    BoldBIDashboard.datavisualization.Chart.ErrorBarMode = {

        Both: "both",

        Vertical: "vertical",

        Horizontal: "horizontal"
    };
    
    BoldBIDashboard.datavisualization.Chart.ErrorBarDirection = {

        Both: "both",

        Plus: "plus",

        Minus:"minus"
    };

    BoldBIDashboard.datavisualization.Chart.LabelIntersectAction = {

        None: "none",

        Rotate90: "rotate90",

        Rotate45: "rotate45",

        Wrap: "wrap",

        WrapByword : "wrapByWord",

        Trim: "trim",

        Hide: "hide",

        MultipleRows: "multipleRows"
    };

    BoldBIDashboard.datavisualization.Chart.EdgeLabelPlacement = {

        None: "none",

        Shift: "shift",

        Hide: "hide"
    };

    BoldBIDashboard.datavisualization.Chart.Theme = {

        Azure: 'azure',

        FlatLight: 'flatlight',

        Azuredark: 'azuredark',

        Lime: 'lime',

        LimeDark: 'limedark',

        Saffron: 'saffron',

        SaffronDark: 'saffrondark',

        GradientLight: 'gradientlight',

        GradientDark: 'gradientdark'
    };

    BoldBIDashboard.datavisualization.Chart.FontStyle = {

        Normal: 'normal',

        Italic: 'italic'
    };

    BoldBIDashboard.datavisualization.Chart.FontWeight = {

        Regular: 'regular',

        Bold: 'bold',

        Lighter: 'lighter'
    };

    BoldBIDashboard.datavisualization.Chart.IntervalType = {
	
	    Auto : 'auto',

        Days: 'days',

        Hours: 'hours',

        Seconds: 'seconds',

        Milliseconds: 'milliseconds',

        Minutes: 'minutes',

        Months: 'months',

        Years: 'years'
    };

    BoldBIDashboard.datavisualization.Chart.RangePadding = {

        Additional: 'additional',

        Normal: 'normal',

        None: 'none',

        Round: 'round',

        Auto: 'auto'
    };

    BoldBIDashboard.datavisualization.Chart.TextAlignment = {

        MiddleTop: 'middletop',

        MiddleCenter: 'middlecenter',

        MiddleBottom: 'middlebottom'
    };

    BoldBIDashboard.datavisualization.Chart.LabelPosition = {

        Inside: 'inside',

        Outside: 'outside'
    };

    BoldBIDashboard.datavisualization.Chart.ZIndex = {

        Over: 'over',

        Behind: 'behind'
    };

    BoldBIDashboard.datavisualization.Chart.Unit = {

        percentage: 'percentage',

        pixel: 'pixel'
    };

    BoldBIDashboard.datavisualization.Chart.PyramidMode = {

        Linear: 'linear',

        Surface: 'Surface'
    };

    BoldBIDashboard.datavisualization.Chart.DrawType = {

        Line: 'line',

        Column: 'column',

        Area: 'area'
    };
	
	BoldBIDashboard.datavisualization.Chart.EmptyPointMode = {

        Gap: 'gap',

        Zero: 'zero',

        Average: 'average',

        Previous: 'previous'

    };

    BoldBIDashboard.datavisualization.Chart.Pattern = {

        None: 'none',

        Chessboard: 'chessboard',

        Crosshatch: 'crosshatch',

        Dots: 'dots',

        Pacman: 'pacman',

        DiagonalBackward: 'diagonalBackward',

        DiagonalForward: 'diagonalForward',

        Grid: 'grid',

        Turquoise: 'turquoise',

        Star: 'star',

        Triangle: 'triangle',

        Circle: 'circle',

        Tile: 'tile',

        HorizontalDash: 'horizontalDash',

        VerticalDash: 'verticalDash',

        Rectangle: 'rectangle',

        Box: 'box',

        VerticalStripe: 'verticalStripe',

        HorizontalStripe: 'horizontalStripe',

        Bubble: 'bubble',

        Custom: 'custom'
    };

    BoldBIDashboard.datavisualization.Chart.Mode = {

        Series: 'series',

        Point: 'point',
		
        Cluster: 'cluster',

        Range: 'range',
		
		Single: 'single'
    };

    BoldBIDashboard.datavisualization.Chart.SelectionType = {

        Single: 'single',

        Multiple:'multiple'
    };
    BoldBIDashboard.datavisualization.Chart.Shape = {

        None: 'none',

        LeftArrow: 'leftarrow',

        RightArrow: 'rightarrow',

        Circle: 'circle',

        Cross: 'cross',

        HorizLine: 'horizline',

        VertLine: 'vertLine',

        Diamond: 'diamond',

        Rectangle: 'rectangle',

        Triangle: 'triangle',

        InvertedTriangle: 'invertedtriangle',

        Hexagon: 'hexagon',

        Pentagon: 'pentagon',

        Star: 'star',

        Ellipse: 'ellipse',

        Wedge: 'wedge',

        Trapezoid: 'trapezoid',

        UpArrow: 'uparrow',

        DownArrow: 'downarrow',

        Image: 'image'
    };

    BoldBIDashboard.datavisualization.Chart.DrawMode = {

        Both: 'both',

        Open: 'open',

        Close: 'close'
    };

    BoldBIDashboard.datavisualization.Chart.LineCap = {

        Butt: 'butt',

        Round: 'round',

        Square: 'square'
    };

    BoldBIDashboard.datavisualization.Chart.LineJoin = {

        Round: 'round',

        Bevel: 'bevel',

        Miter: 'miter'
    };

    BoldBIDashboard.datavisualization.Chart.Position = {

        Top: 'top',

        Middle: 'middle',

        Bottom: 'bottom'
    };

    BoldBIDashboard.datavisualization.Chart.LegendMode = {

        Series: 'series',

        Point: 'point',

        Range:'range'

    };

    BoldBIDashboard.datavisualization.Chart.Alignment = {

        Center: 'center',

        Near: 'near',

        Far: 'far'
    };
	
	BoldBIDashboard.datavisualization.Chart.TickLinesPosition = {

        Inside: 'inside',

        Outside: 'outside'
    };
	
	BoldBIDashboard.datavisualization.Chart.CoordinateUnit = {

        None: 'none',

        Pixels: 'pixels',
		
		Points: 'points'
    };
	
	BoldBIDashboard.datavisualization.Chart.HorizontalAlignment = {

        Left: 'left',

        Right: 'right',
		
		Middle: 'middle'
    };
	
	BoldBIDashboard.datavisualization.Chart.VerticalAlignment = {

        Top: 'top',

        Bottom: 'bottom',
		
		Middle: 'middle'
    };
	
	BoldBIDashboard.datavisualization.Chart.TextAnchor = {

        Start: 'start',

        Middle: 'middle',
		
		End: 'end'  
	};
	
	BoldBIDashboard.datavisualization.Chart.Region = {

        Chart: 'chart',

        Series: 'series'
    };
	
	BoldBIDashboard.datavisualization.Chart.ConnectorLineType = {

        Line: 'line',

        Bezier: 'bezier'
    };
	
	BoldBIDashboard.datavisualization.Chart.HorizontalTextAlignment = {

        Near: 'near',

        Far: 'far',
		
		Center: 'center'
    };
	
	BoldBIDashboard.datavisualization.Chart.VerticalTextAlignment = {

        Near: 'near',

        Far: 'far',
		
		Center: 'center'
    };
	
	BoldBIDashboard.datavisualization.Chart.MACDType = {

        Line: 'line',

        Histogram: 'histogram',
		
		Both: 'both'
    };
	
	BoldBIDashboard.datavisualization.Chart.IndicatorsType = {

        RSI: 'rsi',

        Momentum: 'momentum',
		
		Bollingerband: 'bollingerband',
		
		Accumulationdistribution : 'accumulationdistribution',
		
		EMA: 'ema',
		
		SMA: 'sma',
		
		Stochastic: 'stochastic',
		
		ATR: 'atr',
		
		MACD: 'macd',
		
		TMA: 'tma'
    };
	
    bbdesigner$.extend(BoldBIDashboard.datavisualization.Chart.prototype, BoldBIDashboard.BoldBIDashboardChart);
})(bbdesigner$, SyncfusionBoldBIDashboard);
;